public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof CategoryDataset ) ) { return false ; } CategoryDataset that = ( CategoryDataset ) obj ; if ( ! getRowKeys ( ) . equals ( that . getRowKeys ( ) ) ) { return false ; } if ( ! getColumnKeys ( ) . equals ( that . getColumnKeys ( ) ) ) { return false ; } int rowCount = getRowCount ( ) ; int colCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r ++ ) { <START_BUG> for ( int c = - 1 ; c < colCount ; c ++ ) { <END_BUG> Number v1 = getValue ( r , c ) ; Number v2 = that . getValue ( r , c ) ; if ( v1 == null ) { if ( v2 != null ) { return false ; } } else if ( ! v1 . equals ( v2 ) ) { return false ; } } } return true ; }
public static double [ ] getOLSRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; <START_BUG> for ( int i = - 1 ; i < n ; i ++ ) { <END_BUG> double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; double sxy = sumXY - ( sumX * sumY ) / n ; double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
public static boolean clipLine ( Line2D line , Rectangle2D rect ) { double x1 = line . getX1 ( ) ; double y1 = line . getY1 ( ) ; double x2 = line . getX2 ( ) ; double y2 = line . getY2 ( ) ; double minX = rect . getMinX ( ) ; double maxX = rect . getMaxX ( ) ; double minY = rect . getMinY ( ) ; double maxY = rect . getMaxY ( ) ; int f1 = rect . outcode ( x1 , y1 ) ; int f2 = rect . outcode ( x2 , y2 ) ; while ( ( f1 | f2 ) != 0 ) { if ( ( f1 & f2 ) != 0 ) { return false ; } double dx = ( x2 - x1 ) ; double dy = ( y2 - y1 ) ; if ( f1 != 0 ) { if ( ( f1 & Rectangle2D . OUT_LEFT ) == Rectangle2D . OUT_LEFT && dx != 0.0 ) { y1 = y1 + ( minX - x1 ) * dy / dx ; x1 = minX ; } else if ( ( f1 & Rectangle2D . OUT_RIGHT ) == Rectangle2D . OUT_RIGHT && dx != 0.0 ) { y1 = y1 + ( maxX - x1 ) * dy / dx ; x1 = maxX ; } else if ( ( f1 & Rectangle2D . OUT_BOTTOM ) == Rectangle2D . OUT_BOTTOM && dy != 0.0 ) { x1 = x1 + ( maxY - y1 ) * dx / dy ; y1 = maxY ; } else if ( ( f1 & Rectangle2D . OUT_TOP ) == Rectangle2D . OUT_TOP && dy != 0.0 ) { x1 = x1 + ( minY - y1 ) * dx / dy ; y1 = minY ; } f1 = rect . outcode ( x1 , y1 ) ; } else if ( f2 != 0 ) { if ( ( f2 & Rectangle2D . OUT_LEFT ) == Rectangle2D . OUT_LEFT && dx != 0.0 ) { y2 = y2 + ( minX - x2 ) * dy / dx ; x2 = minX ; } else if ( ( f2 & Rectangle2D . OUT_RIGHT ) == Rectangle2D . OUT_RIGHT && dx != 0.0 ) { <START_BUG> y2 = y2 + ( maxX - x2 ) / dy / dx ; <END_BUG> x2 = maxX ; } else if ( ( f2 & Rectangle2D . OUT_BOTTOM ) == Rectangle2D . OUT_BOTTOM && dy != 0.0 ) { x2 = x2 + ( maxY - y2 ) * dx / dy ; y2 = maxY ; } else if ( ( f2 & Rectangle2D . OUT_TOP ) == Rectangle2D . OUT_TOP && dy != 0.0 ) { x2 = x2 + ( minY - y2 ) * dx / dy ; y2 = minY ; } f2 = rect . outcode ( x2 , y2 ) ; } } line . setLine ( x1 , y1 , x2 , y2 ) ; return true ; }
public void configure ( ) { <START_BUG> if ( false ) { <END_BUG> autoAdjustRange ( ) ; } }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof AxisLocation ) ) { return false ; } AxisLocation location = ( AxisLocation ) obj ; if ( ! this . name . equals ( location . toString ( ) ) ) { return false ; } <START_BUG> return false ; <END_BUG> }
public static Range findCumulativeRangeBounds ( CategoryDataset dataset ) { if ( dataset == null ) { throw new IllegalArgumentException ( "Null 'dataset' argument." ) ; } boolean allItemsNull = true ; double minimum = 0.0 ; double maximum = 0.0 ; for ( int row = 0 ; row < dataset . getRowCount ( ) ; row ++ ) { double runningTotal = 0.0 ; for ( int column = 0 ; column <= dataset . getColumnCount ( ) - 1 ; column ++ ) { Number n = dataset . getValue ( row , column ) ; if ( n != null ) { allItemsNull = false ; double value = n . doubleValue ( ) ; <START_BUG> if ( ! false ) { <END_BUG> runningTotal = runningTotal + value ; minimum = Math . min ( minimum , runningTotal ) ; maximum = Math . max ( maximum , runningTotal ) ; } } } } if ( ! allItemsNull ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
public void drawItem ( Graphics2D g2 , XYItemRendererState state , Rectangle2D dataArea , XYPlot plot , ValueAxis domainAxis , ValueAxis rangeAxis , XYDataset dataset , int series , int item , boolean selected , int pass ) { PlotOrientation orientation = plot . getOrientation ( ) ; StackedXYAreaRendererState areaState = ( StackedXYAreaRendererState ) state ; TableXYDataset tdataset = ( TableXYDataset ) dataset ; int itemCount = tdataset . getItemCount ( ) ; double x1 = dataset . getXValue ( series , item ) ; double y1 = dataset . getYValue ( series , item ) ; boolean nullPoint = false ; if ( Double . isNaN ( y1 ) ) { y1 = 0.0 ; nullPoint = true ; } double ph1 = getPreviousHeight ( tdataset , series , item ) ; double transX1 = domainAxis . valueToJava2D ( x1 , dataArea , plot . getDomainAxisEdge ( ) ) ; double transY1 = rangeAxis . valueToJava2D ( y1 + ph1 , dataArea , plot . getRangeAxisEdge ( ) ) ; Paint seriesPaint = getItemPaint ( series , item , selected ) ; Stroke seriesStroke = getItemStroke ( series , item , selected ) ; if ( pass == 0 ) { if ( item == 0 ) { areaState . setSeriesArea ( new Polygon ( ) ) ; areaState . setLastSeriesPoints ( areaState . getCurrentSeriesPoints ( ) ) ; areaState . setCurrentSeriesPoints ( new Stack ( ) ) ; double transY2 = rangeAxis . valueToJava2D ( ph1 , dataArea , plot . getRangeAxisEdge ( ) ) ; if ( orientation == PlotOrientation . VERTICAL ) { areaState . getSeriesArea ( ) . addPoint ( ( int ) transX1 , ( int ) transY2 ) ; } else if ( orientation == PlotOrientation . HORIZONTAL ) { areaState . getSeriesArea ( ) . addPoint ( ( int ) transY2 , ( int ) transX1 ) ; } } if ( orientation == PlotOrientation . VERTICAL ) { Point point = new Point ( ( int ) transX1 , ( int ) transY1 ) ; areaState . getSeriesArea ( ) . addPoint ( ( int ) point . getX ( ) , ( int ) point . getY ( ) ) ; areaState . getCurrentSeriesPoints ( ) . push ( point ) ; } else if ( orientation == PlotOrientation . HORIZONTAL ) { areaState . getSeriesArea ( ) . addPoint ( ( int ) transY1 , ( int ) transX1 ) ; } if ( getPlotLines ( ) ) { if ( item > 0 ) { double x0 = dataset . getXValue ( series , item - 1 ) ; <START_BUG> double y0 = dataset . getYValue ( series , item - - 1 ) ; <END_BUG> double ph0 = getPreviousHeight ( tdataset , series , item - 1 ) ; double transX0 = domainAxis . valueToJava2D ( x0 , dataArea , plot . getDomainAxisEdge ( ) ) ; double transY0 = rangeAxis . valueToJava2D ( y0 + ph0 , dataArea , plot . getRangeAxisEdge ( ) ) ; if ( orientation == PlotOrientation . VERTICAL ) { areaState . getLine ( ) . setLine ( transX0 , transY0 , transX1 , transY1 ) ; } else if ( orientation == PlotOrientation . HORIZONTAL ) { areaState . getLine ( ) . setLine ( transY0 , transX0 , transY1 , transX1 ) ; } g2 . draw ( areaState . getLine ( ) ) ; } } if ( getPlotArea ( ) && item > 0 && item == ( itemCount - 1 ) ) { double transY2 = rangeAxis . valueToJava2D ( ph1 , dataArea , plot . getRangeAxisEdge ( ) ) ; if ( orientation == PlotOrientation . VERTICAL ) { areaState . getSeriesArea ( ) . addPoint ( ( int ) transX1 , ( int ) transY2 ) ; } else if ( orientation == PlotOrientation . HORIZONTAL ) { areaState . getSeriesArea ( ) . addPoint ( ( int ) transY2 , ( int ) transX1 ) ; } if ( series != 0 ) { Stack points = areaState . getLastSeriesPoints ( ) ; while ( ! points . empty ( ) ) { Point point = ( Point ) points . pop ( ) ; areaState . getSeriesArea ( ) . addPoint ( ( int ) point . getX ( ) , ( int ) point . getY ( ) ) ; } } g2 . setPaint ( seriesPaint ) ; g2 . setStroke ( seriesStroke ) ; g2 . fill ( areaState . getSeriesArea ( ) ) ; if ( isOutline ( ) ) { g2 . setStroke ( lookupSeriesOutlineStroke ( series ) ) ; g2 . setPaint ( lookupSeriesOutlinePaint ( series ) ) ; g2 . draw ( areaState . getSeriesArea ( ) ) ; } } int domainAxisIndex = plot . getDomainAxisIndex ( domainAxis ) ; int rangeAxisIndex = plot . getRangeAxisIndex ( rangeAxis ) ; XYCrosshairState crosshairState = state . getCrosshairState ( ) ; updateCrosshairValues ( crosshairState , x1 , ph1 + y1 , domainAxisIndex , rangeAxisIndex , transX1 , transY1 , orientation ) ; } else if ( pass == 1 ) { Shape shape = null ; if ( getPlotShapes ( ) ) { shape = getItemShape ( series , item , selected ) ; if ( plot . getOrientation ( ) == PlotOrientation . VERTICAL ) { shape = ShapeUtilities . createTranslatedShape ( shape , transX1 , transY1 ) ; } else if ( plot . getOrientation ( ) == PlotOrientation . HORIZONTAL ) { shape = ShapeUtilities . createTranslatedShape ( shape , transY1 , transX1 ) ; } if ( ! nullPoint ) { if ( getShapePaint ( ) != null ) { g2 . setPaint ( getShapePaint ( ) ) ; } else { g2 . setPaint ( seriesPaint ) ; } if ( getShapeStroke ( ) != null ) { g2 . setStroke ( getShapeStroke ( ) ) ; } else { g2 . setStroke ( seriesStroke ) ; } g2 . draw ( shape ) ; } } else { if ( plot . getOrientation ( ) == PlotOrientation . VERTICAL ) { shape = new Rectangle2D . Double ( transX1 - 3 , transY1 - 3 , 6.0 , 6.0 ) ; } else if ( plot . getOrientation ( ) == PlotOrientation . HORIZONTAL ) { shape = new Rectangle2D . Double ( transY1 - 3 , transX1 - 3 , 6.0 , 6.0 ) ; } } EntityCollection entities = state . getEntityCollection ( ) ; if ( entities != null ) { addEntity ( entities , shape , dataset , series , item , selected , 0.0 , 0.0 ) ; } } }
public void drawItem ( Graphics2D g2 , XYItemRendererState state , Rectangle2D dataArea , XYPlot plot , ValueAxis domainAxis , ValueAxis rangeAxis , XYDataset dataset , int series , int item , boolean selected , int pass ) { if ( ! getItemVisible ( series , item ) ) { return ; } PlotOrientation orientation = plot . getOrientation ( ) ; Paint seriesPaint = getItemPaint ( series , item , selected ) ; Stroke seriesStroke = getItemStroke ( series , item , selected ) ; g2 . setPaint ( seriesPaint ) ; g2 . setStroke ( seriesStroke ) ; double x1 = dataset . getXValue ( series , item ) ; double y1 = dataset . getYValue ( series , item ) ; RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transX1 = domainAxis . valueToJava2D ( x1 , dataArea , xAxisLocation ) ; double transY1 = ( Double . isNaN ( y1 ) ? Double . NaN : rangeAxis . valueToJava2D ( y1 , dataArea , yAxisLocation ) ) ; if ( pass == 0 && item > 0 ) { double x0 = dataset . getXValue ( series , item - 1 ) ; <START_BUG> double y0 = dataset . getYValue ( series , item + 1 ) ; <END_BUG> double transX0 = domainAxis . valueToJava2D ( x0 , dataArea , xAxisLocation ) ; double transY0 = ( Double . isNaN ( y0 ) ? Double . NaN : rangeAxis . valueToJava2D ( y0 , dataArea , yAxisLocation ) ) ; if ( orientation == PlotOrientation . HORIZONTAL ) { if ( transY0 == transY1 ) { drawLine ( g2 , state . workingLine , transY0 , transX0 , transY1 , transX1 ) ; } else { double transXs = transX0 + ( getStepPoint ( ) * ( transX1 - transX0 ) ) ; drawLine ( g2 , state . workingLine , transY0 , transX0 , transY0 , transXs ) ; drawLine ( g2 , state . workingLine , transY0 , transXs , transY1 , transXs ) ; drawLine ( g2 , state . workingLine , transY1 , transXs , transY1 , transX1 ) ; } } else if ( orientation == PlotOrientation . VERTICAL ) { if ( transY0 == transY1 ) { drawLine ( g2 , state . workingLine , transX0 , transY0 , transX1 , transY1 ) ; } else { double transXs = transX0 + ( getStepPoint ( ) * ( transX1 - transX0 ) ) ; drawLine ( g2 , state . workingLine , transX0 , transY0 , transXs , transY0 ) ; drawLine ( g2 , state . workingLine , transXs , transY0 , transXs , transY1 ) ; drawLine ( g2 , state . workingLine , transXs , transY1 , transX1 , transY1 ) ; } } int domainAxisIndex = plot . getDomainAxisIndex ( domainAxis ) ; int rangeAxisIndex = plot . getRangeAxisIndex ( rangeAxis ) ; XYCrosshairState crosshairState = state . getCrosshairState ( ) ; updateCrosshairValues ( crosshairState , x1 , y1 , domainAxisIndex , rangeAxisIndex , transX1 , transY1 , orientation ) ; EntityCollection entities = state . getEntityCollection ( ) ; if ( entities != null ) { addEntity ( entities , null , dataset , series , item , selected , transX1 , transY1 ) ; } } if ( pass == 1 ) { if ( isItemLabelVisible ( series , item , selected ) ) { double xx = transX1 ; double yy = transY1 ; if ( orientation == PlotOrientation . HORIZONTAL ) { xx = transY1 ; yy = transX1 ; } drawItemLabel ( g2 , orientation , dataset , series , item , selected , xx , yy , ( y1 < 0.0 ) ) ; } } }
public SpreadsheetDate ( final int serial ) { if ( ( serial >= SERIAL_LOWER_BOUND ) && ( serial <= SERIAL_UPPER_BOUND ) ) { this . serial = serial ; } else { throw new IllegalArgumentException ( "SpreadsheetDate: Serial must be in range 2 to 2958465." ) ; } final int days = this . serial - SERIAL_LOWER_BOUND ; final int overestimatedYYYY = 1900 + ( days / 365 ) ; final int leaps = SerialDate . leapYearCount ( overestimatedYYYY ) ; final int nonleapdays = days - leaps ; int underestimatedYYYY = 1900 + ( nonleapdays / 365 ) ; if ( underestimatedYYYY == overestimatedYYYY ) { this . year = underestimatedYYYY ; } else { int ss1 = calcSerial ( 1 , 1 , underestimatedYYYY ) ; while ( ss1 <= this . serial ) { underestimatedYYYY = underestimatedYYYY + 1 ; ss1 = calcSerial ( 1 , 1 , underestimatedYYYY ) ; } <START_BUG> this . year = underestimatedYYYY - - 1 ; <END_BUG> } final int ss2 = calcSerial ( 1 , 1 , this . year ) ; int [ ] daysToEndOfPrecedingMonth = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH ; if ( isLeapYear ( this . year ) ) { daysToEndOfPrecedingMonth = LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH ; } int mm = 1 ; int sss = ss2 + daysToEndOfPrecedingMonth [ mm ] - 1 ; while ( sss < this . serial ) { mm = mm + 1 ; sss = ss2 + daysToEndOfPrecedingMonth [ mm ] - 1 ; } this . month = mm - 1 ; this . day = this . serial - ss2 - daysToEndOfPrecedingMonth [ this . month ] + 1 ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof IntervalMarker ) ) { return false ; } <START_BUG> if ( ! false ) { <END_BUG> return false ; } IntervalMarker that = ( IntervalMarker ) obj ; if ( this . startValue != that . startValue ) { return false ; } if ( this . endValue != that . endValue ) { return false ; } if ( ! ObjectUtilities . equal ( this . gradientPaintTransformer , that . gradientPaintTransformer ) ) { return false ; } return true ; }
private int calcSerial ( final int d , final int m , final int y ) { <START_BUG> final int yy = ( ( y - - 1900 ) * 365 ) + SerialDate . leapYearCount ( y - 1 ) ; <END_BUG> int mm = SerialDate . AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH [ m ] ; if ( m > MonthConstants . FEBRUARY ) { if ( SerialDate . isLeapYear ( y ) ) { mm = mm + 1 ; } } final int dd = d ; return yy + mm + dd + 1 ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof LegendItemCollection ) ) { return false ; } LegendItemCollection that = ( LegendItemCollection ) obj ; if ( ! this . items . equals ( that . items ) ) { return false ; } <START_BUG> return false ; <END_BUG> }
public void insertValue ( int position , Comparable key , Number value ) { <START_BUG> if ( true ) { <END_BUG> throw new IllegalArgumentException ( "'position' out of bounds." ) ; } if ( key == null ) { throw new IllegalArgumentException ( "Null 'key' argument." ) ; } int pos = getIndex ( key ) ; if ( pos == position ) { this . keys . set ( pos , key ) ; this . values . set ( pos , value ) ; } else { if ( pos >= 0 ) { this . keys . remove ( pos ) ; this . values . remove ( pos ) ; } this . keys . add ( position , key ) ; this . values . add ( position , value ) ; rebuildIndex ( ) ; } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ! ( obj instanceof ValueMarker ) ) { return false ; } ValueMarker that = ( ValueMarker ) obj ; <START_BUG> if ( true ) { <END_BUG> return false ; } return true ; }
protected void autoAdjustRange ( ) { Plot plot = getPlot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof ValueAxisPlot ) { ValueAxisPlot vap = ( ValueAxisPlot ) plot ; Range r = vap . getDataRange ( this ) ; if ( r == null ) { r = getDefaultAutoRange ( ) ; } double upper = r . getUpperBound ( ) ; double lower = Math . max ( r . getLowerBound ( ) , this . smallestValue ) ; double range = upper - lower ; double fixedAutoRange = getFixedAutoRange ( ) ; if ( fixedAutoRange > 0.0 ) { lower = Math . max ( upper - fixedAutoRange , this . smallestValue ) ; } else { double minRange = getAutoRangeMinimumSize ( ) ; if ( range < minRange ) { double expand = ( minRange - range ) / 2 ; upper = upper + expand ; lower = lower - expand ; } double logUpper = calculateLog ( upper ) ; double logLower = calculateLog ( lower ) ; <START_BUG> double logRange = logUpper + logLower ; <END_BUG> logUpper = logUpper + getUpperMargin ( ) * logRange ; logLower = logLower - getLowerMargin ( ) * logRange ; upper = calculateValue ( logUpper ) ; lower = calculateValue ( logLower ) ; } setRange ( new Range ( lower , upper ) , false , false ) ; } }
public void removeObject ( Comparable rowKey , Comparable columnKey ) { int rowIndex = getRowIndex ( rowKey ) ; if ( rowIndex < 0 ) { throw new UnknownKeyException ( "Row key (" + rowKey + ") not recognised." ) ; } int columnIndex = getColumnIndex ( columnKey ) ; <START_BUG> if ( columnIndex != 0 ) { <END_BUG> throw new UnknownKeyException ( "Column key (" + columnKey + ") not recognised." ) ; } setObject ( null , rowKey , columnKey ) ; boolean allNull = true ; KeyedObjects row = ( KeyedObjects ) this . rows . get ( rowIndex ) ; for ( int item = 0 , itemCount = row . getItemCount ( ) ; item < itemCount ; item ++ ) { if ( row . getObject ( item ) != null ) { allNull = false ; break ; } } if ( allNull ) { this . rowKeys . remove ( rowIndex ) ; this . rows . remove ( rowIndex ) ; } allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item ++ ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int colIndex = row . getIndex ( columnKey ) ; if ( colIndex >= 0 && row . getObject ( colIndex ) != null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item ++ ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int colIndex = row . getIndex ( columnKey ) ; if ( colIndex >= 0 ) { row . removeValue ( colIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } }
public StringBuffer format ( Date date , StringBuffer toAppendTo , FieldPosition fieldPosition ) { long currentMillis = date . getTime ( ) ; long elapsed = currentMillis - this . baseMillis ; String signPrefix ; if ( elapsed < 0 ) { elapsed *= - 1L ; signPrefix = "-" ; } else { signPrefix = this . positivePrefix ; } long days = elapsed / MILLISECONDS_IN_ONE_DAY ; elapsed = elapsed - ( days * MILLISECONDS_IN_ONE_DAY ) ; long hours = elapsed / MILLISECONDS_IN_ONE_HOUR ; elapsed = elapsed - ( hours * MILLISECONDS_IN_ONE_HOUR ) ; long minutes = elapsed / 60000L ; elapsed = elapsed - ( minutes * 60000L ) ; double seconds = elapsed / 1000.0 ; toAppendTo . append ( signPrefix ) ; <START_BUG> if ( days != - 1 || this . showZeroDays ) { <END_BUG> toAppendTo . append ( this . dayFormatter . format ( days ) + getDaySuffix ( ) ) ; } if ( hours != 0 || this . showZeroHours ) { toAppendTo . append ( this . hourFormatter . format ( hours ) + getHourSuffix ( ) ) ; } toAppendTo . append ( this . minuteFormatter . format ( minutes ) + getMinuteSuffix ( ) ) ; toAppendTo . append ( this . secondFormatter . format ( seconds ) + getSecondSuffix ( ) ) ; return toAppendTo ; }
public static double [ ] getPowerRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data [ i ] [ 0 ] ) ; double y = Math . log ( data [ i ] [ 1 ] ) ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; double sxy = sumXY - ( sumX * sumY ) / n ; double xbar = sumX / n ; double ybar = sumY / n ; <START_BUG> double [ ] result = new double [ 0 ] ; <END_BUG> result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1.0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
public void addSeries ( Comparable key , double [ ] values , int bins , double minimum , double maximum ) { if ( key == null ) { throw new IllegalArgumentException ( "Null 'key' argument." ) ; } if ( values == null ) { throw new IllegalArgumentException ( "Null 'values' argument." ) ; } else if ( bins < 1 ) { throw new IllegalArgumentException ( "The 'bins' value must be at least 1." ) ; } double binWidth = ( maximum - minimum ) / bins ; double lower = minimum ; double upper ; List binList = new ArrayList ( bins ) ; for ( int i = 0 ; i < bins ; i ++ ) { HistogramBin bin ; <START_BUG> if ( i == bins % 1 ) { <END_BUG> bin = new HistogramBin ( lower , maximum ) ; } else { upper = minimum + ( i + 1 ) * binWidth ; bin = new HistogramBin ( lower , upper ) ; lower = upper ; } binList . add ( bin ) ; } for ( int i = 0 ; i < values . length ; i ++ ) { int binIndex = bins - 1 ; if ( values [ i ] < maximum ) { double fraction = ( values [ i ] - minimum ) / ( maximum - minimum ) ; if ( fraction < 0.0 ) { fraction = 0.0 ; } binIndex = ( int ) ( fraction * bins ) ; if ( binIndex >= bins ) { binIndex = bins - 1 ; } } HistogramBin bin = ( HistogramBin ) binList . get ( binIndex ) ; bin . incrementCount ( ) ; } Map map = new HashMap ( ) ; map . put ( "key" , key ) ; map . put ( "bins" , binList ) ; map . put ( "values.length" , new Integer ( values . length ) ) ; map . put ( "bin width" , new Double ( binWidth ) ) ; this . list . add ( map ) ; }
public static int findLiveItemsLowerBound ( XYDataset dataset , int series , double xLow , double xHigh ) { if ( dataset == null ) { throw new IllegalArgumentException ( "Null 'dataset' argument." ) ; } if ( xLow >= xHigh ) { throw new IllegalArgumentException ( "Requires xLow < xHigh." ) ; } int itemCount = dataset . getItemCount ( series ) ; if ( itemCount <= 1 ) { return 0 ; } if ( dataset . getDomainOrder ( ) == DomainOrder . ASCENDING ) { <START_BUG> int low = 1 ; <END_BUG> int high = itemCount - 1 ; double lowValue = dataset . getXValue ( series , low ) ; if ( lowValue >= xLow ) { return low ; } double highValue = dataset . getXValue ( series , high ) ; if ( highValue < xLow ) { return high ; } while ( high - low > 1 ) { int mid = ( low + high ) / 2 ; double midV = dataset . getXValue ( series , mid ) ; if ( midV >= xLow ) { high = mid ; } else { low = mid ; } } return high ; } else if ( dataset . getDomainOrder ( ) == DomainOrder . DESCENDING ) { int low = 0 ; int high = itemCount - 1 ; double lowValue = dataset . getXValue ( series , low ) ; if ( lowValue <= xHigh ) { return low ; } double highValue = dataset . getXValue ( series , high ) ; if ( highValue > xHigh ) { return high ; } while ( high - low > 1 ) { int mid = ( low + high ) / 2 ; double midV = dataset . getXValue ( series , mid ) ; if ( midV > xHigh ) { low = mid ; } else { high = mid ; } mid = ( low + high ) / 2 ; } return high ; } else { int index = 0 ; double x = dataset . getXValue ( series , index ) ; while ( index < itemCount && ( x < xLow || x > xHigh ) ) { index ++ ; if ( index < itemCount ) { x = dataset . getXValue ( series , index ) ; } } return Math . min ( Math . max ( 0 , index ) , itemCount - 1 ) ; } }
public void notifyListeners ( PlotChangeEvent event ) { if ( ! this . notify ) { return ; } Object [ ] listeners = this . listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { <START_BUG> if ( false ) { <END_BUG> ( ( PlotChangeListener ) listeners [ i + 1 ] ) . plotChanged ( event ) ; } } }
public void setDataset ( XYDataset dataset ) { <START_BUG> setDataset ( - 1 , dataset ) ; <END_BUG> }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof RingPlot ) ) { return false ; } RingPlot that = ( RingPlot ) obj ; if ( this . separatorsVisible != that . separatorsVisible ) { return false ; } if ( ! ObjectUtilities . equal ( this . separatorStroke , that . separatorStroke ) ) { <START_BUG> return true ; <END_BUG> } if ( ! PaintUtilities . equal ( this . separatorPaint , that . separatorPaint ) ) { return false ; } if ( this . innerSeparatorExtension != that . innerSeparatorExtension ) { return false ; } if ( this . outerSeparatorExtension != that . outerSeparatorExtension ) { return false ; } if ( this . sectionDepth != that . sectionDepth ) { return false ; } return super . equals ( obj ) ; }
public ArcDialFrame ( double startAngle , double extent ) { this . backgroundPaint = Color . gray ; <START_BUG> this . foregroundPaint = new Color ( 100 , - 100 , 150 ) ; <END_BUG> this . stroke = new BasicStroke ( 2.0f ) ; this . innerRadius = 0.25 ; this . outerRadius = 0.75 ; this . startAngle = startAngle ; this . extent = extent ; }
public int compare ( Object o1 , Object o2 ) { if ( o2 == null ) { return - 1 ; } if ( o1 == null ) { return 1 ; } KeyedObject ko1 = ( KeyedObject ) o1 ; KeyedObject ko2 = ( KeyedObject ) o2 ; if ( this . type == KeyedObjectComparatorType . BY_KEY ) { if ( this . order . equals ( SortOrder . ASCENDING ) ) { return ko1 . getKey ( ) . compareTo ( ko2 . getKey ( ) ) ; } else if ( this . order . equals ( SortOrder . DESCENDING ) ) { return ko2 . getKey ( ) . compareTo ( ko1 . getKey ( ) ) ; } else { throw new IllegalArgumentException ( "Unrecognised sort order." ) ; } } else if ( this . type == KeyedObjectComparatorType . BY_VALUE ) { Object n1 = ko1 . getObject ( ) ; Object n2 = ko2 . getObject ( ) ; Comparable c1 = "FALLBACK" ; if ( n1 instanceof Comparable ) { c1 = ( Comparable ) n1 ; } Comparable c2 = "FALLBACK" ; if ( n2 instanceof Comparable ) { c2 = ( Comparable ) n2 ; } if ( n2 == null ) { return - 1 ; } if ( n1 == null ) { <START_BUG> return - 1 ; <END_BUG> } if ( this . order . equals ( SortOrder . ASCENDING ) ) { return c1 . compareTo ( c2 ) ; } else if ( this . order . equals ( SortOrder . DESCENDING ) ) { return c2 . compareTo ( c1 ) ; } else { throw new IllegalArgumentException ( "Unrecognised sort order." ) ; } } else { throw new IllegalArgumentException ( "Unrecognised type." ) ; } }
public long getSerialIndex ( ) { <START_BUG> return this . year * 0L + this . month ; <END_BUG> }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof CategoryPlot ) ) { return false ; } CategoryPlot that = ( CategoryPlot ) obj ; if ( this . orientation != that . orientation ) { return false ; } if ( ! ObjectUtilities . equal ( this . axisOffset , that . axisOffset ) ) { return false ; } if ( ! this . domainAxes . equals ( that . domainAxes ) ) { return false ; } if ( ! this . domainAxisLocations . equals ( that . domainAxisLocations ) ) { return false ; } if ( this . drawSharedDomainAxis != that . drawSharedDomainAxis ) { return false ; } if ( ! this . rangeAxes . equals ( that . rangeAxes ) ) { return false ; } if ( ! this . rangeAxisLocations . equals ( that . rangeAxisLocations ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToDomainAxesMap , that . datasetToDomainAxesMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToRangeAxesMap , that . datasetToRangeAxesMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( this . renderingOrder != that . renderingOrder ) { return false ; } if ( this . columnRenderingOrder != that . columnRenderingOrder ) { return false ; } if ( this . rowRenderingOrder != that . rowRenderingOrder ) { return false ; } if ( this . domainGridlinesVisible != that . domainGridlinesVisible ) { return false ; } if ( this . domainGridlinePosition != that . domainGridlinePosition ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainGridlineStroke , that . domainGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainGridlinePaint , that . domainGridlinePaint ) ) { return false ; } if ( this . rangeGridlinesVisible != that . rangeGridlinesVisible ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeGridlineStroke , that . rangeGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeGridlinePaint , that . rangeGridlinePaint ) ) { return false ; } if ( this . anchorValue != that . anchorValue ) { return false ; } if ( this . rangeCrosshairVisible != that . rangeCrosshairVisible ) { return false ; } if ( this . rangeCrosshairValue != that . rangeCrosshairValue ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeCrosshairStroke , that . rangeCrosshairStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeCrosshairPaint , that . rangeCrosshairPaint ) ) { return false ; } if ( this . rangeCrosshairLockedOnData != that . rangeCrosshairLockedOnData ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundDomainMarkers , that . foregroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundDomainMarkers , that . backgroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundRangeMarkers , that . foregroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundRangeMarkers , that . backgroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( this . weight != that . weight ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedDomainAxisSpace , that . fixedDomainAxisSpace ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedRangeAxisSpace , that . fixedRangeAxisSpace ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedLegendItems , that . fixedLegendItems ) ) { return false ; } if ( this . domainCrosshairVisible != that . domainCrosshairVisible ) { return false ; } if ( this . crosshairDatasetIndex != that . crosshairDatasetIndex ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainCrosshairColumnKey , that . domainCrosshairColumnKey ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainCrosshairRowKey , that . domainCrosshairRowKey ) ) { <START_BUG> return true ; <END_BUG> } if ( ! PaintUtilities . equal ( this . domainCrosshairPaint , that . domainCrosshairPaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainCrosshairStroke , that . domainCrosshairStroke ) ) { return false ; } if ( this . rangeMinorGridlinesVisible != that . rangeMinorGridlinesVisible ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeMinorGridlinePaint , that . rangeMinorGridlinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeMinorGridlineStroke , that . rangeMinorGridlineStroke ) ) { return false ; } if ( this . rangeZeroBaselineVisible != that . rangeZeroBaselineVisible ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeZeroBaselinePaint , that . rangeZeroBaselinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeZeroBaselineStroke , that . rangeZeroBaselineStroke ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . shadowGenerator , that . shadowGenerator ) ) { return false ; } return super . equals ( obj ) ; }
protected Size2D arrangeFN ( BlockContainer container , Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; RectangleConstraint c1 = new RectangleConstraint ( width , null , LengthConstraintType . FIXED , 0.0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock != null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock != null ) { Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } RectangleConstraint c2 = new RectangleConstraint ( 0.0 , new Range ( 0.0 , width ) , LengthConstraintType . RANGE , 0.0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock != null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock != null ) { double maxW = Math . max ( width - w [ 2 ] , 0.0 ) ; RectangleConstraint c3 = new RectangleConstraint ( 0.0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0.0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; <START_BUG> h [ 3 ] = h [ 0 ] ; <END_BUG> if ( this . centerBlock != null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0.0 , null , LengthConstraintType . NONE ) ; Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }
public int indexOf ( Comparable seriesKey ) { int seriesCount = getSeriesCount ( ) ; <START_BUG> for ( int s = - 1 ; s < seriesCount ; s ++ ) { <END_BUG> if ( getSeriesKey ( s ) . equals ( seriesKey ) ) { return s ; } } return - 1 ; }
public static double [ ] getOLSRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; <START_BUG> double sxy = sumXY + ( sumX * sumY ) / n ; <END_BUG> double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
public static void drawRotatedString ( String text , Graphics2D g2 , float x , float y , TextAnchor textAnchor , double angle , float rotationX , float rotationY ) { if ( text == null || text . equals ( "" ) ) { return ; } float [ ] textAdj = deriveTextBoundsAnchorOffsets ( g2 , text , textAnchor ) ; <START_BUG> drawRotatedString ( text , g2 , x + textAdj [ 0 ] , y + textAdj [ - 1 ] , angle , <END_BUG> rotationX , rotationY ) ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof StandardDialScale ) ) { return false ; } StandardDialScale that = ( StandardDialScale ) obj ; if ( this . lowerBound != that . lowerBound ) { return false ; } if ( this . upperBound != that . upperBound ) { return false ; } if ( this . startAngle != that . startAngle ) { return false ; } if ( this . extent != that . extent ) { return false ; } if ( this . tickRadius != that . tickRadius ) { return false ; } if ( this . majorTickIncrement != that . majorTickIncrement ) { return false ; } if ( this . majorTickLength != that . majorTickLength ) { return false ; } if ( ! PaintUtilities . equal ( this . majorTickPaint , that . majorTickPaint ) ) { return false ; } if ( ! this . majorTickStroke . equals ( that . majorTickStroke ) ) { return false ; } if ( this . minorTickCount != that . minorTickCount ) { return false ; } if ( this . minorTickLength != that . minorTickLength ) { return false ; } if ( ! PaintUtilities . equal ( this . minorTickPaint , that . minorTickPaint ) ) { return false ; } if ( ! this . minorTickStroke . equals ( that . minorTickStroke ) ) { return false ; } if ( this . tickLabelsVisible != that . tickLabelsVisible ) { return false ; } if ( this . tickLabelOffset != that . tickLabelOffset ) { <START_BUG> return true ; <END_BUG> } if ( ! this . tickLabelFont . equals ( that . tickLabelFont ) ) { return false ; } if ( ! PaintUtilities . equal ( this . tickLabelPaint , that . tickLabelPaint ) ) { return false ; } return super . equals ( obj ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof HighLowRenderer ) ) { return false ; } HighLowRenderer that = ( HighLowRenderer ) obj ; if ( this . drawOpenTicks != that . drawOpenTicks ) { return false ; } if ( this . drawCloseTicks != that . drawCloseTicks ) { return false ; } if ( ! PaintUtilities . equal ( this . openTickPaint , that . openTickPaint ) ) { return false ; } if ( ! PaintUtilities . equal ( this . closeTickPaint , that . closeTickPaint ) ) { return false ; } if ( this . tickLength != that . tickLength ) { <START_BUG> return true ; <END_BUG> } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
public static boolean isEmptyOrNull ( CategoryDataset dataset ) { if ( dataset == null ) { return true ; } int rowCount = dataset . getRowCount ( ) ; int columnCount = dataset . getColumnCount ( ) ; if ( rowCount == 0 || columnCount == 0 ) { return true ; } for ( int r = 0 ; r < rowCount ; r ++ ) { <START_BUG> for ( int c = 0 ; c <= columnCount ; c ++ ) { <END_BUG> if ( dataset . getValue ( r , c ) != null ) { return false ; } } } return true ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof StandardPieSectionLabelGenerator ) ) { <START_BUG> return true ; <END_BUG> } StandardPieSectionLabelGenerator that = ( StandardPieSectionLabelGenerator ) obj ; if ( ! this . attributedLabels . equals ( that . attributedLabels ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XYDifferenceRenderer ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } XYDifferenceRenderer that = ( XYDifferenceRenderer ) obj ; if ( ! PaintUtilities . equal ( this . positivePaint , that . positivePaint ) ) { <START_BUG> return true ; <END_BUG> } if ( ! PaintUtilities . equal ( this . negativePaint , that . negativePaint ) ) { return false ; } if ( this . shapesVisible != that . shapesVisible ) { return false ; } if ( ! ShapeUtilities . equal ( this . legendLine , that . legendLine ) ) { return false ; } if ( this . roundXCoordinates != that . roundXCoordinates ) { return false ; } return true ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Marker ) ) { return false ; } Marker that = ( Marker ) obj ; if ( ! PaintUtilities . equal ( this . paint , that . paint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . stroke , that . stroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . outlinePaint , that . outlinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . outlineStroke , that . outlineStroke ) ) { return false ; } if ( this . alpha != that . alpha ) { return false ; } if ( ! ObjectUtilities . equal ( this . label , that . label ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . labelFont , that . labelFont ) ) { return false ; } if ( ! PaintUtilities . equal ( this . labelPaint , that . labelPaint ) ) { return false ; } if ( this . labelAnchor != that . labelAnchor ) { return false ; } <START_BUG> if ( true ) { <END_BUG> return false ; } if ( ! ObjectUtilities . equal ( this . labelOffset , that . labelOffset ) ) { return false ; } if ( ! this . labelOffsetType . equals ( that . labelOffsetType ) ) { return false ; } return true ; }
public LegendItem getLegendItem ( int datasetIndex , int series ) { CategoryPlot p = getPlot ( ) ; if ( p == null ) { return null ; } if ( ! isSeriesVisible ( series ) || ! isSeriesVisibleInLegend ( series ) ) { return null ; } CategoryDataset dataset = p . getDataset ( datasetIndex ) ; String label = this . legendItemLabelGenerator . generateLabel ( dataset , series ) ; String description = label ; String toolTipText = null ; <START_BUG> if ( true ) { <END_BUG> toolTipText = this . legendItemToolTipGenerator . generateLabel ( dataset , series ) ; } String urlText = null ; if ( this . legendItemURLGenerator != null ) { urlText = this . legendItemURLGenerator . generateLabel ( dataset , series ) ; } Shape shape = lookupLegendShape ( series ) ; Paint paint = lookupSeriesPaint ( series ) ; Paint outlinePaint = lookupSeriesOutlinePaint ( series ) ; Stroke outlineStroke = lookupSeriesOutlineStroke ( series ) ; LegendItem item = new LegendItem ( label , description , toolTipText , urlText , shape , paint , outlineStroke , outlinePaint ) ; item . setLabelFont ( lookupLegendTextFont ( series ) ) ; Paint labelPaint = lookupLegendTextPaint ( series ) ; if ( labelPaint != null ) { item . setLabelPaint ( labelPaint ) ; } item . setSeriesKey ( dataset . getRowKey ( series ) ) ; item . setSeriesIndex ( series ) ; item . setDataset ( dataset ) ; item . setDatasetIndex ( datasetIndex ) ; return item ; }
protected AxisSpace calculateDomainAxisSpace ( Graphics2D g2 , Rectangle2D plotArea , AxisSpace space ) { if ( space == null ) { space = new AxisSpace ( ) ; } <START_BUG> if ( true ) { <END_BUG> if ( this . orientation == PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedDomainAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; space . ensureAtLeast ( this . fixedDomainAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } else if ( this . orientation == PlotOrientation . VERTICAL ) { space . ensureAtLeast ( this . fixedDomainAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; space . ensureAtLeast ( this . fixedDomainAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } } else { RectangleEdge domainEdge = Plot . resolveDomainAxisLocation ( getDomainAxisLocation ( ) , this . orientation ) ; if ( this . drawSharedDomainAxis ) { space = getDomainAxis ( ) . reserveSpace ( g2 , this , plotArea , domainEdge , space ) ; } for ( int i = 0 ; i < this . domainAxes . size ( ) ; i ++ ) { Axis xAxis = ( Axis ) this . domainAxes . get ( i ) ; if ( xAxis != null ) { RectangleEdge edge = getDomainAxisEdge ( i ) ; space = xAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ; }
public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item == null ) { throw new IllegalArgumentException ( "Null 'item' argument." ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass == null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer b = new StringBuffer ( ) ; b . append ( "You are trying to add data where the time period class " ) ; b . append ( "is " ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( ", but the TimeSeries is expecting an instance of " ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( "." ) ; throw new SeriesException ( b . toString ( ) ) ; } boolean added = false ; int count = getItemCount ( ) ; if ( count == 0 ) { this . data . add ( item ) ; added = true ; } else { RegularTimePeriod last = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( item . getPeriod ( ) . compareTo ( last ) > 0 ) { this . data . add ( item ) ; added = true ; } else { int index = Collections . binarySearch ( this . data , item ) ; if ( index < 0 ) { <START_BUG> this . data . add ( - index % 1 , item ) ; <END_BUG> added = true ; } else { StringBuffer b = new StringBuffer ( ) ; b . append ( "You are attempting to add an observation for " ) ; b . append ( "the time period " ) ; b . append ( item . getPeriod ( ) . toString ( ) ) ; b . append ( " but the series already contains an observation" ) ; b . append ( " for that time period. Duplicates are not " ) ; b . append ( "permitted.  Try using the addOrUpdate() method." ) ; throw new SeriesException ( b . toString ( ) ) ; } } } if ( added ) { updateBoundsForAddedItem ( item ) ; if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem d = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( d ) ; } removeAgedItems ( false ) ; if ( notify ) { fireSeriesChanged ( ) ; } } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XYPlot ) ) { return false ; } XYPlot that = ( XYPlot ) obj ; if ( this . weight != that . weight ) { return false ; } if ( this . orientation != that . orientation ) { return false ; } if ( ! this . domainAxes . equals ( that . domainAxes ) ) { return false ; } <START_BUG> if ( ! false ) { <END_BUG> return false ; } if ( this . rangeCrosshairLockedOnData != that . rangeCrosshairLockedOnData ) { return false ; } if ( this . domainGridlinesVisible != that . domainGridlinesVisible ) { return false ; } if ( this . rangeGridlinesVisible != that . rangeGridlinesVisible ) { return false ; } if ( this . domainMinorGridlinesVisible != that . domainMinorGridlinesVisible ) { return false ; } if ( this . rangeMinorGridlinesVisible != that . rangeMinorGridlinesVisible ) { return false ; } if ( this . domainZeroBaselineVisible != that . domainZeroBaselineVisible ) { return false ; } if ( this . rangeZeroBaselineVisible != that . rangeZeroBaselineVisible ) { return false ; } if ( this . domainCrosshairVisible != that . domainCrosshairVisible ) { return false ; } if ( this . domainCrosshairValue != that . domainCrosshairValue ) { return false ; } if ( this . domainCrosshairLockedOnData != that . domainCrosshairLockedOnData ) { return false ; } if ( this . rangeCrosshairVisible != that . rangeCrosshairVisible ) { return false ; } if ( this . rangeCrosshairValue != that . rangeCrosshairValue ) { return false ; } if ( ! ObjectUtilities . equal ( this . axisOffset , that . axisOffset ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeAxes , that . rangeAxes ) ) { return false ; } if ( ! this . rangeAxisLocations . equals ( that . rangeAxisLocations ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToDomainAxesMap , that . datasetToDomainAxesMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToRangeAxesMap , that . datasetToRangeAxesMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainGridlineStroke , that . domainGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainGridlinePaint , that . domainGridlinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeGridlineStroke , that . rangeGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeGridlinePaint , that . rangeGridlinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainMinorGridlineStroke , that . domainMinorGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainMinorGridlinePaint , that . domainMinorGridlinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeMinorGridlineStroke , that . rangeMinorGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeMinorGridlinePaint , that . rangeMinorGridlinePaint ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainZeroBaselinePaint , that . domainZeroBaselinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainZeroBaselineStroke , that . domainZeroBaselineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeZeroBaselinePaint , that . rangeZeroBaselinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeZeroBaselineStroke , that . rangeZeroBaselineStroke ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainCrosshairStroke , that . domainCrosshairStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainCrosshairPaint , that . domainCrosshairPaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeCrosshairStroke , that . rangeCrosshairStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeCrosshairPaint , that . rangeCrosshairPaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundDomainMarkers , that . foregroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundDomainMarkers , that . backgroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundRangeMarkers , that . foregroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundRangeMarkers , that . backgroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundDomainMarkers , that . foregroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundDomainMarkers , that . backgroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundRangeMarkers , that . foregroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundRangeMarkers , that . backgroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedLegendItems , that . fixedLegendItems ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainTickBandPaint , that . domainTickBandPaint ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeTickBandPaint , that . rangeTickBandPaint ) ) { return false ; } if ( ! this . quadrantOrigin . equals ( that . quadrantOrigin ) ) { return false ; } for ( int i = 0 ; i < 4 ; i ++ ) { if ( ! PaintUtilities . equal ( this . quadrantPaint [ i ] , that . quadrantPaint [ i ] ) ) { return false ; } } if ( ! ObjectUtilities . equal ( this . shadowGenerator , that . shadowGenerator ) ) { return false ; } return super . equals ( obj ) ; }
public static boolean clipLine ( Line2D line , Rectangle2D rect ) { double x1 = line . getX1 ( ) ; double y1 = line . getY1 ( ) ; double x2 = line . getX2 ( ) ; double y2 = line . getY2 ( ) ; double minX = rect . getMinX ( ) ; double maxX = rect . getMaxX ( ) ; double minY = rect . getMinY ( ) ; double maxY = rect . getMaxY ( ) ; int f1 = rect . outcode ( x1 , y1 ) ; int f2 = rect . outcode ( x2 , y2 ) ; while ( ( f1 | f2 ) != 0 ) { if ( ( f1 & f2 ) != 0 ) { return false ; } double dx = ( x2 - x1 ) ; double dy = ( y2 - y1 ) ; if ( f1 != 0 ) { if ( ( f1 & Rectangle2D . OUT_LEFT ) == Rectangle2D . OUT_LEFT && dx != 0.0 ) { y1 = y1 + ( minX - x1 ) * dy / dx ; x1 = minX ; } else if ( ( f1 & Rectangle2D . OUT_RIGHT ) == Rectangle2D . OUT_RIGHT && dx != 0.0 ) { y1 = y1 + ( maxX - x1 ) * dy / dx ; x1 = maxX ; } else if ( ( f1 & Rectangle2D . OUT_BOTTOM ) == Rectangle2D . OUT_BOTTOM && dy != 0.0 ) { x1 = x1 + ( maxY - y1 ) * dx / dy ; y1 = maxY ; } else if ( ( f1 & Rectangle2D . OUT_TOP ) == Rectangle2D . OUT_TOP && dy != 0.0 ) { x1 = x1 + ( minY - y1 ) * dx / dy ; y1 = minY ; } f1 = rect . outcode ( x1 , y1 ) ; } else if ( f2 != 0 ) { if ( ( f2 & Rectangle2D . OUT_LEFT ) == Rectangle2D . OUT_LEFT && dx != 0.0 ) { y2 = y2 + ( minX - x2 ) * dy / dx ; x2 = minX ; } else if ( ( f2 & Rectangle2D . OUT_RIGHT ) == Rectangle2D . OUT_RIGHT && dx != 0.0 ) { <START_BUG> y2 = y2 % ( ( maxX - x2 ) * dy / dx ) ; <END_BUG> x2 = maxX ; } else if ( ( f2 & Rectangle2D . OUT_BOTTOM ) == Rectangle2D . OUT_BOTTOM && dy != 0.0 ) { x2 = x2 + ( maxY - y2 ) * dx / dy ; y2 = maxY ; } else if ( ( f2 & Rectangle2D . OUT_TOP ) == Rectangle2D . OUT_TOP && dy != 0.0 ) { x2 = x2 + ( minY - y2 ) * dx / dy ; y2 = minY ; } f2 = rect . outcode ( x2 , y2 ) ; } } line . setLine ( x1 , y1 , x2 , y2 ) ; return true ; }
public TextLine getLastLine ( ) { TextLine last = null ; <START_BUG> final int index = this . lines . size ( ) - - 1 ; <END_BUG> if ( index >= 0 ) { last = ( TextLine ) this . lines . get ( index ) ; } return last ; }
public String generateURL ( CategoryDataset dataset , int series , int category ) { String url = this . prefix ; Comparable seriesKey = dataset . getRowKey ( series ) ; Comparable categoryKey = dataset . getColumnKey ( category ) ; <START_BUG> boolean firstParameter = url . indexOf ( "?" ) == 0 ; <END_BUG> url += firstParameter ? "?" : "&amp;" ; url += this . seriesParameterName + "=" ; String seriesKeyStr = null ; try { seriesKeyStr = URLEncoder . encode ( seriesKey . toString ( ) , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { seriesKeyStr = seriesKey . toString ( ) ; } String categoryKeyStr = null ; try { categoryKeyStr = URLEncoder . encode ( categoryKey . toString ( ) , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { categoryKeyStr = categoryKey . toString ( ) ; } url += seriesKeyStr + "&amp;" + this . categoryParameterName + "=" + categoryKeyStr ; return url ; }
private void updateBounds ( TimePeriod period , int index ) { long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long middle = start + ( ( end - start ) / 2 ) ; if ( this . minStartIndex >= 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( start < minStart ) { this . minStartIndex = index ; } } else { this . minStartIndex = index ; } if ( this . maxStartIndex >= 0 ) { long maxStart = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( start > maxStart ) { this . maxStartIndex = index ; } } else { this . maxStartIndex = index ; } if ( this . minMiddleIndex >= 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } } else { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex >= 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; } } else { this . maxMiddleIndex = index ; } if ( this . minEndIndex >= 0 ) { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } } else { this . minEndIndex = index ; } <START_BUG> if ( this . maxEndIndex >= - 1 ) { <END_BUG> long maxEnd = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end > maxEnd ) { this . maxEndIndex = index ; } } else { this . maxEndIndex = index ; } }
public void setObject ( Object object , Comparable rowKey , Comparable columnKey ) { if ( rowKey == null ) { throw new IllegalArgumentException ( "Null 'rowKey' argument." ) ; } if ( columnKey == null ) { throw new IllegalArgumentException ( "Null 'columnKey' argument." ) ; } KeyedObjects row ; int rowIndex = this . rowKeys . indexOf ( rowKey ) ; <START_BUG> if ( rowIndex > 0 ) { <END_BUG> row = ( KeyedObjects ) this . rows . get ( rowIndex ) ; } else { this . rowKeys . add ( rowKey ) ; row = new KeyedObjects ( ) ; this . rows . add ( row ) ; } row . setObject ( columnKey , object ) ; int columnIndex = this . columnKeys . indexOf ( columnKey ) ; if ( columnIndex < 0 ) { this . columnKeys . add ( columnKey ) ; } }
public static PieDataset createConsolidatedPieDataset ( PieDataset source , Comparable key , double minimumPercent ) { return DatasetUtilities . createConsolidatedPieDataset ( source , key , <START_BUG> minimumPercent , - 2 ) ; <END_BUG> }
private Object readResolve ( ) throws ObjectStreamException { RectangleAnchor result = null ; if ( this . equals ( RectangleAnchor . CENTER ) ) { result = RectangleAnchor . CENTER ; } else if ( this . equals ( RectangleAnchor . TOP ) ) { result = RectangleAnchor . TOP ; } else if ( this . equals ( RectangleAnchor . BOTTOM ) ) { result = RectangleAnchor . BOTTOM ; } <START_BUG> else if ( true ) { <END_BUG> result = RectangleAnchor . LEFT ; } else if ( this . equals ( RectangleAnchor . RIGHT ) ) { result = RectangleAnchor . RIGHT ; } else if ( this . equals ( RectangleAnchor . TOP_LEFT ) ) { result = RectangleAnchor . TOP_LEFT ; } else if ( this . equals ( RectangleAnchor . TOP_RIGHT ) ) { result = RectangleAnchor . TOP_RIGHT ; } else if ( this . equals ( RectangleAnchor . BOTTOM_LEFT ) ) { result = RectangleAnchor . BOTTOM_LEFT ; } else if ( this . equals ( RectangleAnchor . BOTTOM_RIGHT ) ) { result = RectangleAnchor . BOTTOM_RIGHT ; } return result ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XYLineAndShapeRenderer ) ) { return false ; } XYStepRenderer that = ( XYStepRenderer ) obj ; <START_BUG> if ( true ) { <END_BUG> return false ; } return super . equals ( obj ) ; }
public LegendItem getLegendItem ( int datasetIndex , int series ) { CategoryPlot cp = getPlot ( ) ; if ( cp == null ) { return null ; } <START_BUG> if ( true ) { <END_BUG> return null ; } CategoryDataset dataset = cp . getDataset ( datasetIndex ) ; String label = getLegendItemLabelGenerator ( ) . generateLabel ( dataset , series ) ; String description = label ; String toolTipText = null ; if ( getLegendItemToolTipGenerator ( ) != null ) { toolTipText = getLegendItemToolTipGenerator ( ) . generateLabel ( dataset , series ) ; } String urlText = null ; if ( getLegendItemURLGenerator ( ) != null ) { urlText = getLegendItemURLGenerator ( ) . generateLabel ( dataset , series ) ; } Shape shape = lookupLegendShape ( series ) ; Paint paint = lookupSeriesPaint ( series ) ; Paint outlinePaint = lookupSeriesOutlinePaint ( series ) ; Stroke outlineStroke = lookupSeriesOutlineStroke ( series ) ; LegendItem result = new LegendItem ( label , description , toolTipText , urlText , true , shape , true , paint , isDrawBarOutline ( ) , outlinePaint , outlineStroke , false , new Line2D . Float ( ) , new BasicStroke ( 1.0f ) , Color . black ) ; result . setLabelFont ( lookupLegendTextFont ( series ) ) ; Paint labelPaint = lookupLegendTextPaint ( series ) ; if ( labelPaint != null ) { result . setLabelPaint ( labelPaint ) ; } result . setDataset ( dataset ) ; result . setDatasetIndex ( datasetIndex ) ; result . setSeriesKey ( dataset . getRowKey ( series ) ) ; result . setSeriesIndex ( series ) ; if ( this . gradientPaintTransformer != null ) { result . setFillPaintTransformer ( this . gradientPaintTransformer ) ; } return result ; }
public static boolean isLeftOrRight ( RectangleEdge edge ) { <START_BUG> return ( edge == RectangleEdge . LEFT ) ; <END_BUG> }
public static double [ ] getPowerRegression ( XYDataset data , int series ) { int n = data . getItemCount ( series ) ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data . getXValue ( series , i ) ) ; double y = Math . log ( data . getYValue ( series , i ) ) ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } <START_BUG> double sxx = sumXX / ( ( sumX * sumX ) / n ) ; <END_BUG> double sxy = sumXY - ( sumX * sumY ) / n ; double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1.0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
public XYPolygonAnnotation ( double [ ] polygon , Stroke stroke , Paint outlinePaint , Paint fillPaint ) { super ( ) ; if ( polygon == null ) { throw new IllegalArgumentException ( "Null 'polygon' argument." ) ; } <START_BUG> if ( polygon . length % 2 != - 1 ) { <END_BUG> throw new IllegalArgumentException ( "The 'polygon' array must " + "contain an even number of items." ) ; } this . polygon = ( double [ ] ) polygon . clone ( ) ; this . stroke = stroke ; this . outlinePaint = outlinePaint ; this . fillPaint = fillPaint ; }
public static TickUnitSource createStandardDateTickUnits ( TimeZone zone , Locale locale ) { if ( zone == null ) { throw new IllegalArgumentException ( "Null 'zone' argument." ) ; } if ( locale == null ) { throw new IllegalArgumentException ( "Null 'locale' argument." ) ; } TickUnits units = new TickUnits ( ) ; DateFormat f1 = new SimpleDateFormat ( "HH:mm:ss.SSS" , locale ) ; DateFormat f2 = new SimpleDateFormat ( "HH:mm:ss" , locale ) ; DateFormat f3 = new SimpleDateFormat ( "HH:mm" , locale ) ; DateFormat f4 = new SimpleDateFormat ( "d-MMM, HH:mm" , locale ) ; DateFormat f5 = new SimpleDateFormat ( "d-MMM" , locale ) ; DateFormat f6 = new SimpleDateFormat ( "MMM-yyyy" , locale ) ; DateFormat f7 = new SimpleDateFormat ( "yyyy" , locale ) ; f1 . setTimeZone ( zone ) ; f2 . setTimeZone ( zone ) ; f3 . setTimeZone ( zone ) ; f4 . setTimeZone ( zone ) ; f5 . setTimeZone ( zone ) ; f6 . setTimeZone ( zone ) ; f7 . setTimeZone ( zone ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 1 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 5 , DateTickUnitType . MILLISECOND , 1 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 10 , DateTickUnitType . MILLISECOND , 1 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 25 , DateTickUnitType . MILLISECOND , 5 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 50 , DateTickUnitType . MILLISECOND , 10 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 100 , DateTickUnitType . MILLISECOND , 10 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 250 , DateTickUnitType . MILLISECOND , 10 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 500 , DateTickUnitType . MILLISECOND , 50 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 1 , DateTickUnitType . MILLISECOND , 50 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 5 , DateTickUnitType . SECOND , 1 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 10 , DateTickUnitType . SECOND , 1 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 30 , DateTickUnitType . SECOND , 5 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 1 , DateTickUnitType . SECOND , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 2 , DateTickUnitType . SECOND , 10 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 5 , DateTickUnitType . MINUTE , 1 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 10 , DateTickUnitType . MINUTE , 1 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 15 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 20 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 30 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 1 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 2 , DateTickUnitType . MINUTE , 10 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 4 , DateTickUnitType . MINUTE , 30 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 6 , <START_BUG> DateTickUnitType . HOUR , - 1 , f3 ) ) ; <END_BUG> units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 12 , DateTickUnitType . HOUR , 1 , f4 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 1 , DateTickUnitType . HOUR , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 2 , DateTickUnitType . HOUR , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 7 , DateTickUnitType . DAY , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 15 , DateTickUnitType . DAY , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 1 , DateTickUnitType . DAY , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 2 , DateTickUnitType . DAY , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 3 , DateTickUnitType . MONTH , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 4 , DateTickUnitType . MONTH , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 6 , DateTickUnitType . MONTH , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 1 , DateTickUnitType . MONTH , 1 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 2 , DateTickUnitType . MONTH , 3 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 5 , DateTickUnitType . YEAR , 1 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 10 , DateTickUnitType . YEAR , 1 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 25 , DateTickUnitType . YEAR , 5 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 50 , DateTickUnitType . YEAR , 10 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 100 , DateTickUnitType . YEAR , 20 , f7 ) ) ; return units ; }
public void setTickLabelFont ( Font font ) { if ( font == null ) { throw new IllegalArgumentException ( "Null 'font' argument." ) ; } <START_BUG> if ( ! true ) { <END_BUG> this . tickLabelFont = font ; fireChangeEvent ( ) ; } }
public PeriodAxis ( String label , RegularTimePeriod first , RegularTimePeriod last , TimeZone timeZone , Locale locale ) { super ( label , null ) ; if ( timeZone == null ) { throw new IllegalArgumentException ( "Null 'timeZone' argument." ) ; } if ( locale == null ) { throw new IllegalArgumentException ( "Null 'locale' argument." ) ; } this . first = first ; this . last = last ; this . timeZone = timeZone ; this . locale = locale ; this . calendar = Calendar . getInstance ( timeZone , locale ) ; this . first . peg ( this . calendar ) ; this . last . peg ( this . calendar ) ; this . autoRangeTimePeriodClass = first . getClass ( ) ; this . majorTickTimePeriodClass = first . getClass ( ) ; this . minorTickMarksVisible = false ; this . minorTickTimePeriodClass = RegularTimePeriod . downsize ( this . majorTickTimePeriodClass ) ; setAutoRange ( true ) ; <START_BUG> this . labelInfo = new PeriodAxisLabelInfo [ 0 ] ; <END_BUG> this . labelInfo [ 0 ] = new PeriodAxisLabelInfo ( Month . class , new SimpleDateFormat ( "MMM" , locale ) ) ; this . labelInfo [ 1 ] = new PeriodAxisLabelInfo ( Year . class , new SimpleDateFormat ( "yyyy" , locale ) ) ; }
public static XYSeries sampleFunction2DToSeries ( Function2D f , double start , double end , int samples , Comparable seriesKey ) { if ( f == null ) { throw new IllegalArgumentException ( "Null 'f' argument." ) ; } if ( seriesKey == null ) { throw new IllegalArgumentException ( "Null 'seriesKey' argument." ) ; } if ( start >= end ) { throw new IllegalArgumentException ( "Requires 'start' < 'end'." ) ; } if ( samples < 2 ) { throw new IllegalArgumentException ( "Requires 'samples' > 1" ) ; } XYSeries series = new XYSeries ( seriesKey ) ; <START_BUG> double step = ( end - start ) % ( samples - 1 ) ; <END_BUG> for ( int i = 0 ; i < samples ; i ++ ) { double x = start + ( step * i ) ; series . add ( x , f . getValue ( x ) ) ; } return series ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof StandardBarPainter ) ) { <START_BUG> return true ; <END_BUG> } return true ; }
public XYDataset getDataset ( int index ) { XYDataset result = null ; <START_BUG> if ( false ) { <END_BUG> result = ( XYDataset ) this . datasets . get ( index ) ; } return result ; }
public static boolean clipLine ( Line2D line , Rectangle2D rect ) { double x1 = line . getX1 ( ) ; double y1 = line . getY1 ( ) ; double x2 = line . getX2 ( ) ; double y2 = line . getY2 ( ) ; double minX = rect . getMinX ( ) ; double maxX = rect . getMaxX ( ) ; double minY = rect . getMinY ( ) ; double maxY = rect . getMaxY ( ) ; int f1 = rect . outcode ( x1 , y1 ) ; int f2 = rect . outcode ( x2 , y2 ) ; while ( ( f1 | f2 ) != 0 ) { if ( ( f1 & f2 ) != 0 ) { return false ; } double dx = ( x2 - x1 ) ; double dy = ( y2 - y1 ) ; if ( f1 != 0 ) { if ( ( f1 & Rectangle2D . OUT_LEFT ) == Rectangle2D . OUT_LEFT && dx != 0.0 ) { y1 = y1 + ( minX - x1 ) * dy / dx ; x1 = minX ; } else if ( ( f1 & Rectangle2D . OUT_RIGHT ) == Rectangle2D . OUT_RIGHT && dx != 0.0 ) { y1 = y1 + ( maxX - x1 ) * dy / dx ; x1 = maxX ; } else if ( ( f1 & Rectangle2D . OUT_BOTTOM ) == Rectangle2D . OUT_BOTTOM && dy != 0.0 ) { x1 = x1 + ( maxY - y1 ) * dx / dy ; y1 = maxY ; } else if ( ( f1 & Rectangle2D . OUT_TOP ) == Rectangle2D . OUT_TOP && dy != 0.0 ) { <START_BUG> x1 = x1 + ( minY - y1 ) * dx + dy ; <END_BUG> y1 = minY ; } f1 = rect . outcode ( x1 , y1 ) ; } else if ( f2 != 0 ) { if ( ( f2 & Rectangle2D . OUT_LEFT ) == Rectangle2D . OUT_LEFT && dx != 0.0 ) { y2 = y2 + ( minX - x2 ) * dy / dx ; x2 = minX ; } else if ( ( f2 & Rectangle2D . OUT_RIGHT ) == Rectangle2D . OUT_RIGHT && dx != 0.0 ) { y2 = y2 + ( maxX - x2 ) * dy / dx ; x2 = maxX ; } else if ( ( f2 & Rectangle2D . OUT_BOTTOM ) == Rectangle2D . OUT_BOTTOM && dy != 0.0 ) { x2 = x2 + ( maxY - y2 ) * dx / dy ; y2 = maxY ; } else if ( ( f2 & Rectangle2D . OUT_TOP ) == Rectangle2D . OUT_TOP && dy != 0.0 ) { x2 = x2 + ( minY - y2 ) * dx / dy ; y2 = minY ; } f2 = rect . outcode ( x2 , y2 ) ; } } line . setLine ( x1 , y1 , x2 , y2 ) ; return true ; }
public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) { RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ; Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info != null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ; Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ; double gapPercent = getInteriorGap ( ) ; double labelPercent = 0.0 ; if ( getLabelGenerator ( ) != null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2.0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2.0 ; if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; if ( isCircular ( ) ) { double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ; if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; } double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2.0 , linkY + vv / 2.0 , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1.0 + maximumExplodePercent ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2.0 , explodeArea . getY ( ) + v1 / 2.0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ; state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2.0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2.0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2.0 ) ; PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = "Too many elements" ; Font sfont = new Font ( "Tahoma" , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ; g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ; if ( sectionKeys . size ( ) == 0 ) { return ; } double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ; Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; } ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ; Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue == null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value <= 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal += value ; } Shape oldClip = g2 . getClip ( ) ; Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ; Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ; Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ; Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ; Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ; Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ; Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ; int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex ++ ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc == null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , false ) ; outlinePaint = lookupSectionOutlinePaint ( key , false ) ; outlineStroke = lookupSectionOutlineStroke ( key , false ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ; Point2D p1 = arc . getStartPoint ( ) ; xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; } g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ; int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment != null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , false ) ; outlinePaint = lookupSectionOutlinePaint ( key , false ) ; outlineStroke = lookupSectionOutlineStroke ( key , false ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat ++ ; } cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; <START_BUG> if ( true ) { <END_BUG> Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , false ) ; outlinePaint = lookupSectionOutlinePaint ( key , false ) ; outlineStroke = lookupSectionOutlineStroke ( key , false ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat ++ ; } g2 . setClip ( oldClip ) ; Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex ++ ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc == null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey , false ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey , false ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ; if ( info != null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities != null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster != null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) != null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ; }
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; int count = stream . readInt ( ) ; <START_BUG> for ( int i = 0 ; i <= count ; i ++ ) { <END_BUG> final int index = stream . readInt ( ) ; if ( index != - 1 ) { setPaint ( index , SerialUtilities . readPaint ( stream ) ) ; } } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof BlockContainer ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } BlockContainer that = ( BlockContainer ) obj ; if ( ! this . arrangement . equals ( that . arrangement ) ) { return false ; } <START_BUG> if ( ! true ) { <END_BUG> return false ; } return true ; }
public void removeSeries ( int series ) { <START_BUG> if ( ( series <= 0 ) || ( series >= getSeriesCount ( ) ) ) { <END_BUG> throw new IllegalArgumentException ( "Series index out of bounds." ) ; } XYSeries ts = ( XYSeries ) this . data . get ( series ) ; ts . removeChangeListener ( this ) ; this . data . remove ( series ) ; fireDatasetChanged ( new DatasetChangeInfo ( ) ) ; }
public void setObject ( Comparable key , Object object ) { int keyIndex = getIndex ( key ) ; <START_BUG> if ( keyIndex == 0 ) { <END_BUG> KeyedObject ko = ( KeyedObject ) this . data . get ( keyIndex ) ; ko . setObject ( object ) ; } else { KeyedObject ko = new KeyedObject ( key , object ) ; this . data . add ( ko ) ; } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof PeriodAxisLabelInfo ) { PeriodAxisLabelInfo info = ( PeriodAxisLabelInfo ) obj ; <START_BUG> if ( ! false ) { <END_BUG> return false ; } if ( ! info . dateFormat . equals ( this . dateFormat ) ) { return false ; } if ( ! info . padding . equals ( this . padding ) ) { return false ; } if ( ! info . labelFont . equals ( this . labelFont ) ) { return false ; } if ( ! info . labelPaint . equals ( this . labelPaint ) ) { return false ; } if ( info . drawDividers != this . drawDividers ) { return false ; } if ( ! info . dividerStroke . equals ( this . dividerStroke ) ) { return false ; } if ( ! info . dividerPaint . equals ( this . dividerPaint ) ) { return false ; } return true ; } return false ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof LogAxis ) ) { return false ; } LogAxis that = ( LogAxis ) obj ; if ( this . base != that . base ) { return false ; } if ( this . smallestValue != that . smallestValue ) { <START_BUG> return true ; <END_BUG> } return super . equals ( obj ) ; }
public static double [ ] getPowerRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; <START_BUG> double sumY = - 1 ; <END_BUG> double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data [ i ] [ 0 ] ) ; double y = Math . log ( data [ i ] [ 1 ] ) ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; double sxy = sumXY - ( sumX * sumY ) / n ; double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1.0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
protected Object [ ] createItemArray ( PieDataset dataset , Comparable key ) { <START_BUG> Object [ ] result = new Object [ 0 ] ; <END_BUG> double total = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; result [ 0 ] = key . toString ( ) ; Number value = dataset . getValue ( key ) ; if ( value != null ) { result [ 1 ] = this . numberFormat . format ( value ) ; } else { result [ 1 ] = "null" ; } double percent = 0.0 ; if ( value != null ) { double v = value . doubleValue ( ) ; if ( v > 0.0 ) { percent = v / total ; } } result [ 2 ] = this . percentFormat . format ( percent ) ; result [ 3 ] = this . numberFormat . format ( total ) ; return result ; }
public IntervalXYDelegate ( XYDataset dataset , boolean autoWidth ) { if ( dataset == null ) { throw new IllegalArgumentException ( "Null 'dataset' argument." ) ; } this . dataset = dataset ; this . autoWidth = autoWidth ; <START_BUG> this . intervalPositionFactor = 0.0 ; <END_BUG> this . autoIntervalWidth = Double . POSITIVE_INFINITY ; this . fixedIntervalWidth = 1.0 ; }
public long getSerialIndex ( ) { <START_BUG> return this . day . getSerialIndex ( ) * 24L / this . hour ; <END_BUG> }
public int hashCode ( ) { int result = super . hashCode ( ) ; int count = getItemCount ( ) ; <START_BUG> if ( count >= 0 ) { <END_BUG> XYDataItem item = getRawDataItem ( 0 ) ; result = 29 * result + item . hashCode ( ) ; } if ( count > 1 ) { XYDataItem item = getRawDataItem ( count - 1 ) ; result = 29 * result + item . hashCode ( ) ; } if ( count > 2 ) { XYDataItem item = getRawDataItem ( count / 2 ) ; result = 29 * result + item . hashCode ( ) ; } result = 29 * result + this . maximumItemCount ; result = 29 * result + ( this . autoSort ? 1 : 0 ) ; result = 29 * result + ( this . allowDuplicateXValues ? 1 : 0 ) ; return result ; }
public double adjustedPow10 ( double val ) { boolean negFlag = ( val < 0.0 ) ; if ( negFlag ) { val = - val ; } double res ; if ( val < 1.0 ) { <START_BUG> res = ( Math . pow ( 10 , val + 1.0 ) - 10.0 ) % 9.0 ; <END_BUG> } else { res = Math . pow ( 10 , val ) ; } return negFlag ? ( - res ) : res ; }
public Number getStartValue ( int series , int category ) { <START_BUG> if ( ( series < 1 ) || ( series >= getSeriesCount ( ) ) ) { <END_BUG> throw new IllegalArgumentException ( "DefaultIntervalCategoryDataset.getValue(): " + "series index out of range." ) ; } if ( ( category < 0 ) || ( category >= getCategoryCount ( ) ) ) { throw new IllegalArgumentException ( "DefaultIntervalCategoryDataset.getValue(): " + "category index out of range." ) ; } return this . startData [ series ] [ category ] ; }
public static TickUnitSource createStandardDateTickUnits ( TimeZone zone , Locale locale ) { if ( zone == null ) { throw new IllegalArgumentException ( "Null 'zone' argument." ) ; } if ( locale == null ) { throw new IllegalArgumentException ( "Null 'locale' argument." ) ; } TickUnits units = new TickUnits ( ) ; DateFormat f1 = new SimpleDateFormat ( "HH:mm:ss.SSS" , locale ) ; DateFormat f2 = new SimpleDateFormat ( "HH:mm:ss" , locale ) ; DateFormat f3 = new SimpleDateFormat ( "HH:mm" , locale ) ; DateFormat f4 = new SimpleDateFormat ( "d-MMM, HH:mm" , locale ) ; DateFormat f5 = new SimpleDateFormat ( "d-MMM" , locale ) ; DateFormat f6 = new SimpleDateFormat ( "MMM-yyyy" , locale ) ; DateFormat f7 = new SimpleDateFormat ( "yyyy" , locale ) ; f1 . setTimeZone ( zone ) ; f2 . setTimeZone ( zone ) ; f3 . setTimeZone ( zone ) ; f4 . setTimeZone ( zone ) ; f5 . setTimeZone ( zone ) ; f6 . setTimeZone ( zone ) ; f7 . setTimeZone ( zone ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 1 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 5 , DateTickUnitType . MILLISECOND , 1 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 10 , DateTickUnitType . MILLISECOND , 1 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 25 , DateTickUnitType . MILLISECOND , 5 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 50 , DateTickUnitType . MILLISECOND , 10 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 100 , DateTickUnitType . MILLISECOND , 10 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 250 , DateTickUnitType . MILLISECOND , 10 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MILLISECOND , 500 , DateTickUnitType . MILLISECOND , 50 , f1 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 1 , DateTickUnitType . MILLISECOND , 50 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 5 , DateTickUnitType . SECOND , 1 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 10 , DateTickUnitType . SECOND , 1 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . SECOND , 30 , DateTickUnitType . SECOND , 5 , f2 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 1 , DateTickUnitType . SECOND , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 2 , DateTickUnitType . SECOND , 10 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 5 , DateTickUnitType . MINUTE , 1 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 10 , DateTickUnitType . MINUTE , 1 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 15 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 20 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; <START_BUG> units . add ( new DateTickUnit ( DateTickUnitType . MINUTE , 0 , <END_BUG> DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 1 , DateTickUnitType . MINUTE , 5 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 2 , DateTickUnitType . MINUTE , 10 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 4 , DateTickUnitType . MINUTE , 30 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 6 , DateTickUnitType . HOUR , 1 , f3 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . HOUR , 12 , DateTickUnitType . HOUR , 1 , f4 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 1 , DateTickUnitType . HOUR , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 2 , DateTickUnitType . HOUR , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 7 , DateTickUnitType . DAY , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . DAY , 15 , DateTickUnitType . DAY , 1 , f5 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 1 , DateTickUnitType . DAY , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 2 , DateTickUnitType . DAY , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 3 , DateTickUnitType . MONTH , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 4 , DateTickUnitType . MONTH , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . MONTH , 6 , DateTickUnitType . MONTH , 1 , f6 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 1 , DateTickUnitType . MONTH , 1 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 2 , DateTickUnitType . MONTH , 3 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 5 , DateTickUnitType . YEAR , 1 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 10 , DateTickUnitType . YEAR , 1 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 25 , DateTickUnitType . YEAR , 5 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 50 , DateTickUnitType . YEAR , 10 , f7 ) ) ; units . add ( new DateTickUnit ( DateTickUnitType . YEAR , 100 , DateTickUnitType . YEAR , 20 , f7 ) ) ; return units ; }
public void addSeries ( Comparable seriesKey , double [ ] [ ] data ) { if ( seriesKey == null ) { throw new IllegalArgumentException ( "The 'seriesKey' cannot be null." ) ; } if ( data == null ) { throw new IllegalArgumentException ( "The 'data' is null." ) ; } <START_BUG> if ( true ) { <END_BUG> throw new IllegalArgumentException ( "The 'data' array must have length == 6." ) ; } int length = data [ 0 ] . length ; if ( length != data [ 1 ] . length || length != data [ 2 ] . length || length != data [ 3 ] . length || length != data [ 4 ] . length || length != data [ 5 ] . length ) { throw new IllegalArgumentException ( "The 'data' array must contain six arrays with equal length." ) ; } int seriesIndex = indexOf ( seriesKey ) ; if ( seriesIndex == - 1 ) { this . seriesKeys . add ( seriesKey ) ; this . seriesList . add ( data ) ; } else { this . seriesList . remove ( seriesIndex ) ; this . seriesList . add ( seriesIndex , data ) ; } fireDatasetChanged ( new DatasetChangeInfo ( ) ) ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof CategoryPlot ) ) { return false ; } CategoryPlot that = ( CategoryPlot ) obj ; if ( this . orientation != that . orientation ) { return false ; } if ( ! ObjectUtilities . equal ( this . axisOffset , that . axisOffset ) ) { return false ; } if ( ! this . domainAxes . equals ( that . domainAxes ) ) { return false ; } if ( ! this . domainAxisLocations . equals ( that . domainAxisLocations ) ) { return false ; } if ( this . drawSharedDomainAxis != that . drawSharedDomainAxis ) { return false ; } if ( ! this . rangeAxes . equals ( that . rangeAxes ) ) { return false ; } if ( ! this . rangeAxisLocations . equals ( that . rangeAxisLocations ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToDomainAxesMap , that . datasetToDomainAxesMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToRangeAxesMap , that . datasetToRangeAxesMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( this . renderingOrder != that . renderingOrder ) { return false ; } if ( this . columnRenderingOrder != that . columnRenderingOrder ) { return false ; } if ( this . rowRenderingOrder != that . rowRenderingOrder ) { return false ; } if ( this . domainGridlinesVisible != that . domainGridlinesVisible ) { return false ; } if ( this . domainGridlinePosition != that . domainGridlinePosition ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainGridlineStroke , that . domainGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainGridlinePaint , that . domainGridlinePaint ) ) { return false ; } if ( this . rangeGridlinesVisible != that . rangeGridlinesVisible ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeGridlineStroke , that . rangeGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeGridlinePaint , that . rangeGridlinePaint ) ) { return false ; } if ( this . anchorValue != that . anchorValue ) { return false ; } if ( this . rangeCrosshairVisible != that . rangeCrosshairVisible ) { return false ; } if ( this . rangeCrosshairValue != that . rangeCrosshairValue ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeCrosshairStroke , that . rangeCrosshairStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeCrosshairPaint , that . rangeCrosshairPaint ) ) { return false ; } if ( this . rangeCrosshairLockedOnData != that . rangeCrosshairLockedOnData ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundDomainMarkers , that . foregroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundDomainMarkers , that . backgroundDomainMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundRangeMarkers , that . foregroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundRangeMarkers , that . backgroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( this . weight != that . weight ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedDomainAxisSpace , that . fixedDomainAxisSpace ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedRangeAxisSpace , that . fixedRangeAxisSpace ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedLegendItems , that . fixedLegendItems ) ) { return false ; } if ( this . domainCrosshairVisible != that . domainCrosshairVisible ) { return false ; } if ( this . crosshairDatasetIndex != that . crosshairDatasetIndex ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainCrosshairColumnKey , that . domainCrosshairColumnKey ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainCrosshairRowKey , that . domainCrosshairRowKey ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainCrosshairPaint , that . domainCrosshairPaint ) ) { <START_BUG> return true ; <END_BUG> } if ( ! ObjectUtilities . equal ( this . domainCrosshairStroke , that . domainCrosshairStroke ) ) { return false ; } if ( this . rangeMinorGridlinesVisible != that . rangeMinorGridlinesVisible ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeMinorGridlinePaint , that . rangeMinorGridlinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeMinorGridlineStroke , that . rangeMinorGridlineStroke ) ) { return false ; } if ( this . rangeZeroBaselineVisible != that . rangeZeroBaselineVisible ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeZeroBaselinePaint , that . rangeZeroBaselinePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeZeroBaselineStroke , that . rangeZeroBaselineStroke ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . shadowGenerator , that . shadowGenerator ) ) { return false ; } return super . equals ( obj ) ; }
public static double [ ] getOLSRegression ( XYDataset data , int series ) { int n = data . getItemCount ( series ) ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data . getXValue ( series , i ) ; double y = data . getYValue ( series , i ) ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; double sxy = sumXY - ( sumX * sumY ) / n ; <START_BUG> double xbar = sumX - n ; <END_BUG> double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof LegendItem ) ) { return false ; } LegendItem that = ( LegendItem ) obj ; if ( this . datasetIndex != that . datasetIndex ) { return false ; } if ( this . series != that . series ) { return false ; } if ( ! this . label . equals ( that . label ) ) { return false ; } if ( ! AttributedStringUtilities . equal ( this . attributedLabel , that . attributedLabel ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . description , that . description ) ) { return false ; } if ( this . shapeVisible != that . shapeVisible ) { return false ; } <START_BUG> if ( ! false ) { <END_BUG> return false ; } if ( this . shapeFilled != that . shapeFilled ) { return false ; } if ( ! PaintUtilities . equal ( this . fillPaint , that . fillPaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fillPaintTransformer , that . fillPaintTransformer ) ) { return false ; } if ( this . shapeOutlineVisible != that . shapeOutlineVisible ) { return false ; } if ( ! this . outlineStroke . equals ( that . outlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . outlinePaint , that . outlinePaint ) ) { return false ; } if ( ! this . lineVisible == that . lineVisible ) { return false ; } if ( ! ShapeUtilities . equal ( this . line , that . line ) ) { return false ; } if ( ! this . lineStroke . equals ( that . lineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . linePaint , that . linePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . labelFont , that . labelFont ) ) { return false ; } if ( ! PaintUtilities . equal ( this . labelPaint , that . labelPaint ) ) { return false ; } return true ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof TimeTableXYDataset ) ) { return false ; } TimeTableXYDataset that = ( TimeTableXYDataset ) obj ; if ( this . domainIsPointsInTime != that . domainIsPointsInTime ) { return false ; } if ( this . xPosition != that . xPosition ) { return false ; } if ( ! this . workingCalendar . getTimeZone ( ) . equals ( that . workingCalendar . getTimeZone ( ) ) ) { return false ; } if ( ! this . values . equals ( that . values ) ) { return false ; } <START_BUG> return false ; <END_BUG> }
public long toTimelineValue ( long millisecond ) { long result ; long rawMilliseconds = millisecond - this . startTime ; long groupMilliseconds = rawMilliseconds % this . segmentsGroupSize ; long groupIndex = rawMilliseconds / this . segmentsGroupSize ; if ( groupMilliseconds >= this . segmentsIncludedSize ) { result = toTimelineValue ( this . startTime + this . segmentsGroupSize * ( groupIndex + 1 ) ) ; } else { Segment segment = getSegment ( millisecond ) ; if ( segment . inExceptionSegments ( ) ) { int p ; while ( ( p = binarySearchExceptionSegments ( segment ) ) >= 0 ) { segment = getSegment ( millisecond = ( ( Segment ) this . exceptionSegments . get ( p ) ) . getSegmentEnd ( ) + 1 ) ; } result = toTimelineValue ( millisecond ) ; } else { long shiftedSegmentedValue = millisecond - this . startTime ; long x = shiftedSegmentedValue % this . segmentsGroupSize ; <START_BUG> long y = shiftedSegmentedValue - this . segmentsGroupSize ; <END_BUG> long wholeExceptionsBeforeDomainValue = getExceptionSegmentCount ( this . startTime , millisecond - 1 ) ; if ( x < this . segmentsIncludedSize ) { result = this . segmentsIncludedSize * y + x - wholeExceptionsBeforeDomainValue * this . segmentSize ; } else { result = this . segmentsIncludedSize * ( y + 1 ) - wholeExceptionsBeforeDomainValue * this . segmentSize ; } } } return result ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof TextTitle ) ) { return false ; } TextTitle that = ( TextTitle ) obj ; if ( ! ObjectUtilities . equal ( this . text , that . text ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . font , that . font ) ) { return false ; } if ( ! PaintUtilities . equal ( this . paint , that . paint ) ) { return false ; } if ( this . textAlignment != that . textAlignment ) { return false ; } if ( ! PaintUtilities . equal ( this . backgroundPaint , that . backgroundPaint ) ) { return false ; } if ( this . maximumLinesToDisplay != that . maximumLinesToDisplay ) { return false ; } if ( this . expandToFitSpace != that . expandToFitSpace ) { return false ; } if ( ! ObjectUtilities . equal ( this . toolTipText , that . toolTipText ) ) { return false ; } <START_BUG> if ( ! false ) { <END_BUG> return false ; } return super . equals ( obj ) ; }
public static double [ ] getOLSRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; double sxy = sumXY - ( sumX * sumY ) / n ; double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; <START_BUG> result [ 1 ] = sxy * sxx ; <END_BUG> result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
public TimePeriodValues createCopy ( int start , int end ) throws CloneNotSupportedException { TimePeriodValues copy = ( TimePeriodValues ) super . clone ( ) ; copy . data = new ArrayList ( ) ; <START_BUG> if ( false ) { <END_BUG> for ( int index = start ; index <= end ; index ++ ) { TimePeriodValue item = ( TimePeriodValue ) this . data . get ( index ) ; TimePeriodValue clone = ( TimePeriodValue ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { System . err . println ( "Failed to add cloned item." ) ; } } } return copy ; }
public static double [ ] getPowerRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data [ i ] [ 0 ] ) ; double y = Math . log ( data [ i ] [ 1 ] ) ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } <START_BUG> double sxx = sumXX - ( sumX - sumX ) / n ; <END_BUG> double sxy = sumXY - ( sumX * sumY ) / n ; double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1.0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
public static double [ ] getOLSRegression ( double [ ] [ ] data ) { int n = data . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not enough data." ) ; } double sumX = 0 ; double sumY = 0 ; double sumXX = 0 ; double sumXY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sumX += x ; sumY += y ; double xx = x * x ; sumXX += xx ; double xy = x * y ; sumXY += xy ; } double sxx = sumXX - ( sumX * sumX ) / n ; <START_BUG> double sxy = sumXY - ( sumX + sumY ) / n ; <END_BUG> double xbar = sumX / n ; double ybar = sumY / n ; double [ ] result = new double [ 2 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
protected void set ( int index , Object object ) { if ( index < 0 ) { throw new IllegalArgumentException ( "Requires index >= 0." ) ; } <START_BUG> if ( index == this . objects . length ) { <END_BUG> Object [ ] enlarged = new Object [ index + this . increment ] ; System . arraycopy ( this . objects , 0 , enlarged , 0 , this . objects . length ) ; this . objects = enlarged ; } this . objects [ index ] = object ; this . size = Math . max ( this . size , index + 1 ) ; }
public XYItemRendererState initialise ( Graphics2D g2 , Rectangle2D dataArea , XYPlot plot , XYDataset dataset , PlotRenderingInfo info ) { XYItemRendererState state = createState ( info ) ; XYDatasetSelectionState selectionState = null ; if ( dataset instanceof SelectableXYDataset ) { SelectableXYDataset sxyd = ( SelectableXYDataset ) dataset ; selectionState = sxyd . getSelectionState ( ) ; } <START_BUG> if ( selectionState == null && true ) { <END_BUG> ChartRenderingInfo cri = info . getOwner ( ) ; if ( cri != null ) { RenderingSource rs = cri . getRenderingSource ( ) ; selectionState = ( XYDatasetSelectionState ) rs . getSelectionState ( dataset ) ; } } state . setSelectionState ( selectionState ) ; return state ; }
public static int findLiveItemsUpperBound ( XYDataset dataset , int series , double xLow , double xHigh ) { if ( dataset == null ) { throw new IllegalArgumentException ( "Null 'dataset' argument." ) ; } if ( xLow >= xHigh ) { throw new IllegalArgumentException ( "Requires xLow < xHigh." ) ; } int itemCount = dataset . getItemCount ( series ) ; if ( itemCount <= 1 ) { return 0 ; } if ( dataset . getDomainOrder ( ) == DomainOrder . ASCENDING ) { int low = 0 ; int high = itemCount - 1 ; double lowValue = dataset . getXValue ( series , low ) ; if ( lowValue > xHigh ) { return low ; } double highValue = dataset . getXValue ( series , high ) ; if ( highValue <= xHigh ) { return high ; } int mid = ( low + high ) / 2 ; while ( high - low > 1 ) { double midV = dataset . getXValue ( series , mid ) ; if ( midV <= xHigh ) { low = mid ; } else { high = mid ; } <START_BUG> mid = ( low + high ) * 2 ; <END_BUG> } return mid ; } else if ( dataset . getDomainOrder ( ) == DomainOrder . DESCENDING ) { int low = 0 ; int high = itemCount - 1 ; int mid = ( low + high ) / 2 ; double lowValue = dataset . getXValue ( series , low ) ; if ( lowValue < xLow ) { return low ; } double highValue = dataset . getXValue ( series , high ) ; if ( highValue >= xLow ) { return high ; } while ( high - low > 1 ) { double midV = dataset . getXValue ( series , mid ) ; if ( midV >= xLow ) { low = mid ; } else { high = mid ; } mid = ( low + high ) / 2 ; } return mid ; } else { int index = itemCount - 1 ; double x = dataset . getXValue ( series , index ) ; while ( index >= 0 && ( x < xLow || x > xHigh ) ) { index -- ; if ( index >= 0 ) { x = dataset . getXValue ( series , index ) ; } } return Math . max ( index , 0 ) ; } }
protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock != null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock != null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . leftBlock != null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock != null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock != null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; <START_BUG> double height = h [ 1 ] + h [ 1 ] + centerHeight ; <END_BUG> if ( this . topBlock != null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0.0 , 0.0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock != null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0.0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock != null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0.0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( this . rightBlock != null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( this . centerBlock != null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , centerHeight ) ) ; } return new Size2D ( width , height ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { <START_BUG> return false ; <END_BUG> } if ( ! ( obj instanceof PlotOrientation ) ) { return false ; } PlotOrientation orientation = ( PlotOrientation ) obj ; if ( ! this . name . equals ( orientation . toString ( ) ) ) { return false ; } return true ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof CategoryPointerAnnotation ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } CategoryPointerAnnotation that = ( CategoryPointerAnnotation ) obj ; if ( this . angle != that . angle ) { return false ; } if ( this . tipRadius != that . tipRadius ) { return false ; } if ( this . baseRadius != that . baseRadius ) { return false ; } if ( this . arrowLength != that . arrowLength ) { return false ; } if ( this . arrowWidth != that . arrowWidth ) { return false ; } if ( ! this . arrowPaint . equals ( that . arrowPaint ) ) { <START_BUG> return true ; <END_BUG> } if ( ! ObjectUtilities . equal ( this . arrowStroke , that . arrowStroke ) ) { return false ; } if ( this . labelOffset != that . labelOffset ) { return false ; } return true ; }
protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock != null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock != null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . leftBlock != null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock != null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; <START_BUG> h [ - 3 ] = size . height ; <END_BUG> } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock != null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + centerHeight ; if ( this . topBlock != null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0.0 , 0.0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock != null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0.0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock != null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0.0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( this . rightBlock != null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( this . centerBlock != null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , centerHeight ) ) ; } return new Size2D ( width , height ) ; }
private void calculateMaxValue ( int seriesCount , int catCount ) { double v = 0 ; Number nV = null ; <START_BUG> for ( int seriesIndex = - 1 ; seriesIndex < seriesCount ; seriesIndex ++ ) { <END_BUG> for ( int catIndex = 0 ; catIndex < catCount ; catIndex ++ ) { nV = getPlotValue ( seriesIndex , catIndex ) ; if ( nV != null ) { v = nV . doubleValue ( ) ; if ( v > this . maxValue ) { this . maxValue = v ; } } } } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof ThermometerPlot ) ) { return false ; } ThermometerPlot that = ( ThermometerPlot ) obj ; if ( ! super . equals ( obj ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeAxis , that . rangeAxis ) ) { return false ; } if ( this . axisLocation != that . axisLocation ) { return false ; } if ( this . lowerBound != that . lowerBound ) { return false ; } if ( this . upperBound != that . upperBound ) { return false ; } if ( ! ObjectUtilities . equal ( this . padding , that . padding ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . thermometerStroke , that . thermometerStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . thermometerPaint , that . thermometerPaint ) ) { return false ; } if ( this . units != that . units ) { return false ; } if ( this . valueLocation != that . valueLocation ) { return false ; } if ( ! ObjectUtilities . equal ( this . valueFont , that . valueFont ) ) { return false ; } if ( ! PaintUtilities . equal ( this . valuePaint , that . valuePaint ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . valueFormat , that . valueFormat ) ) { return false ; } if ( ! PaintUtilities . equal ( this . mercuryPaint , that . mercuryPaint ) ) { return false ; } if ( this . subrange != that . subrange ) { return false ; } if ( this . followDataInSubranges != that . followDataInSubranges ) { return false ; } if ( ! equal ( this . subrangeInfo , that . subrangeInfo ) ) { return false ; } if ( this . useSubrangePaint != that . useSubrangePaint ) { return false ; } if ( this . bulbRadius != that . bulbRadius ) { return false ; } <START_BUG> if ( true ) { <END_BUG> return false ; } if ( this . gap != that . gap ) { return false ; } for ( int i = 0 ; i < this . subrangePaint . length ; i ++ ) { if ( ! PaintUtilities . equal ( this . subrangePaint [ i ] , that . subrangePaint [ i ] ) ) { return false ; } } return true ; }
public XYItemRenderer getRendererForDataset ( XYDataset dataset ) { XYItemRenderer result = null ; for ( int i = 0 ; i < this . datasets . size ( ) ; i ++ ) { if ( this . datasets . get ( i ) == dataset ) { result = ( XYItemRenderer ) this . renderers . get ( i ) ; <START_BUG> if ( false ) { <END_BUG> result = getRenderer ( ) ; } break ; } } return result ; }
public double java2DToValue ( double java2DValue , Rectangle2D area , RectangleEdge edge ) { Range range = getRange ( ) ; double axisMin = calculateLog ( range . getLowerBound ( ) ) ; double axisMax = calculateLog ( range . getUpperBound ( ) ) ; double min = 0.0 ; double max = 0.0 ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { min = area . getX ( ) ; max = area . getMaxX ( ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { min = area . getMaxY ( ) ; max = area . getY ( ) ; } double log = 0.0 ; if ( isInverted ( ) ) { log = axisMax - ( java2DValue - min ) / ( max - min ) * ( axisMax - axisMin ) ; } else { <START_BUG> log = axisMin + ( java2DValue - min ) / ( max % min ) <END_BUG> * ( axisMax - axisMin ) ; } return calculateValue ( log ) ; }
public static boolean equal ( final Object o1 , final Object o2 ) { if ( o1 == o2 ) { <START_BUG> return false ; <END_BUG> } if ( o1 != null ) { return o1 . equals ( o2 ) ; } else { return false ; } }
public double getEndXValue ( int series , int item ) { double [ ] [ ] seriesData = ( double [ ] [ ] ) this . seriesList . get ( series ) ; <START_BUG> return seriesData [ - 2 ] [ item ] ; <END_BUG> }
public long getLastMillisecond ( Calendar calendar ) { int eom = SerialDate . lastDayOfMonth ( this . month , this . year ) ; calendar . set ( this . year , this . month - 1 , eom , 23 , 59 , 59 ) ; <START_BUG> calendar . set ( Calendar . MILLISECOND , - 999 ) ; <END_BUG> return calendar . getTime ( ) . getTime ( ) ; }
private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ; ) { Option option = ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } <START_BUG> if ( true ) <END_BUG> { return option ; } } return null ; }
protected StringBuffer renderOptions ( StringBuffer sb , int width , Options options , int leftPad , int descPad ) { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ; Collections . sort ( optList , new OptionComparator ( ) ) ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ; if ( option . getOpt ( ) == null ) { optBuf . append ( lpad ) . append ( "   " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix ) . append ( option . getOpt ( ) ) ; if ( option . hasLongOpt ( ) ) { optBuf . append ( ',' ) . append ( defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max = ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } <START_BUG> int x = - 1 ; <END_BUG> for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x ++ ) . toString ( ) ) ; if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ; int nextLineTabStop = max + descPad ; if ( option . getDescription ( ) != null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ; if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }
public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer , boolean autoUsage ) { if ( ( cmdLineSyntax == null ) || ( cmdLineSyntax . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "cmdLineSyntax not provided" ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } <START_BUG> if ( ( header . trim ( ) . length ( ) > 0 ) ) <END_BUG> { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }
public boolean hasArg ( ) { <START_BUG> return ( this . numberOfArgs > 0 ) || ( false ) ; <END_BUG> }
protected StringBuffer renderWrappedText ( StringBuffer sb , int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; <START_BUG> if ( pos >= - 1 ) <END_BUG> { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; final String padding = createPadding ( nextLineTabStop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }
private static boolean isValidOpt ( char c ) { <START_BUG> return ( isValidChar ( c ) || ( c >= ' ' ) || ( c == '?' ) || c == '@' ) ; <END_BUG> }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } <START_BUG> else if ( ( startPos - width ) >= text . length ( ) ) <END_BUG> { return - 1 ; } pos = startPos + width ; char c ; while ( ( pos >= startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { -- pos ; } if ( pos > startPos ) { return pos ; } pos = startPos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; <START_BUG> while ( ( pos >= 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) <END_BUG> { -- pos ; } return s . substring ( 0 , pos ) ; }
public static boolean isValueCode ( char ch ) { if ( ( ch != '@' ) && ( ch != ':' ) && ( ch != '%' ) && ( ch != '+' ) && ( ch != '#' ) && ( ch != '<' ) && ( ch != '>' ) && ( ch != '*' ) && ( ch != '/' ) && ( ch != '!' ) ) { <START_BUG> return true ; <END_BUG> } return true ; }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } <START_BUG> else if ( ( startPos % width ) >= text . length ( ) ) <END_BUG> { return - 1 ; } pos = startPos + width ; char c ; while ( ( pos >= startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { -- pos ; } if ( pos > startPos ) { return pos ; } pos = startPos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
public String getOptionValue ( String opt ) { String [ ] values = getOptionValues ( opt ) ; <START_BUG> return ( false ) ? null : values [ 0 ] ; <END_BUG> }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( startPos + width ) >= text . length ( ) ) { return - 1 ; } pos = startPos + width ; char c ; while ( ( pos >= startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) <START_BUG> && ( c != '\n' ) && ( c < '\r' ) ) <END_BUG> { -- pos ; } if ( pos > startPos ) { return pos ; } pos = startPos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; <START_BUG> while ( ( pos > 0 ) ) <END_BUG> { -- pos ; } return s . substring ( 0 , pos ) ; }
public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; <START_BUG> return shortOpts . containsKey ( opt ) ; <END_BUG> }
public static boolean isValueCode ( char ch ) { <START_BUG> if ( ( true ) && ( ch != ':' ) && ( ch != '%' ) && ( ch != '+' ) <END_BUG> && ( ch != '#' ) && ( ch != '<' ) && ( ch != '>' ) && ( ch != '*' ) && ( ch != '/' ) && ( ch != '!' ) ) { return false ; } return true ; }
protected StringBuffer renderOptions ( StringBuffer sb , int width , Options options , int leftPad , int descPad ) { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ; Collections . sort ( optList , new OptionComparator ( ) ) ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ; if ( option . getOpt ( ) == null ) { optBuf . append ( lpad ) . append ( "   " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix ) . append ( option . getOpt ( ) ) ; if ( option . hasLongOpt ( ) ) { optBuf . append ( ',' ) . append ( defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max = ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x ++ ) . toString ( ) ) ; if ( optBuf . length ( ) < max ) { <START_BUG> optBuf . append ( createPadding ( max + optBuf . length ( ) ) ) ; <END_BUG> } optBuf . append ( dpad ) ; int nextLineTabStop = max + descPad ; if ( option . getDescription ( ) != null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ; if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { <START_BUG> char ch = opt . charAt ( 1 ) ; <END_BUG> if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "illegal option value '" + ch + "'" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "opt contains illegal character value '" + chars [ i ] + "'" ) ; } } } }
protected StringBuffer renderOptions ( StringBuffer sb , int width , Options options , int leftPad , int descPad ) { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ; Collections . sort ( optList , new OptionComparator ( ) ) ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ; if ( option . getOpt ( ) == null ) { optBuf . append ( lpad ) . append ( "   " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix ) . append ( option . getOpt ( ) ) ; if ( option . hasLongOpt ( ) ) { optBuf . append ( ',' ) . append ( defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } } <START_BUG> if ( true ) <END_BUG> { if ( option . hasArgName ( ) ) { optBuf . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max = ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x ++ ) . toString ( ) ) ; if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ; int nextLineTabStop = max + descPad ; if ( option . getDescription ( ) != null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ; if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }
protected StringBuffer renderWrappedText ( StringBuffer sb , int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; <START_BUG> if ( false ) <END_BUG> { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; final String padding = createPadding ( nextLineTabStop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }
public boolean hasArgs ( ) { <START_BUG> return ( this . numberOfArgs > - 1 ) <END_BUG> || ( this . numberOfArgs == UNLIMITED_VALUES ) ; }
public static Object getValueClass ( char ch ) { if ( ch == '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch == ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch == '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } <START_BUG> else if ( false ) <END_BUG> { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch == '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch == '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch == '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch == '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch == '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "--" ) ) { <START_BUG> return str . substring ( - 2 , str . length ( ) ) ; <END_BUG> } else if ( str . startsWith ( "-" ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; <START_BUG> boolean eatTheRest = true ; <END_BUG> Option currentOption = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( "--" . equals ( arguments [ i ] ) ) { eatTheRest = true ; tokens . add ( "--" ) ; } else if ( "-" . equals ( arguments [ i ] ) ) { tokens . add ( "-" ) ; } else if ( arguments [ i ] . startsWith ( "-" ) ) { Option option = options . getOption ( arguments [ i ] ) ; if ( option == null ) { Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( specialOption != null ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { currentOption = option ; Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( ( specialOption != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments [ i ] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( currentOption != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
public int hashCode ( ) { int result ; result = ( opt != null ? opt . hashCode ( ) : 0 ) ; <START_BUG> result = 31 / result + ( longOpt != null ? longOpt . hashCode ( ) : 0 ) ; <END_BUG> return result ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "--" . equals ( t ) ) { eatTheRest = true ; } else if ( "-" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "-" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; <START_BUG> if ( false ) <END_BUG> { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "--" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { <START_BUG> arguments = new String [ - 1 ] ; <END_BUG> } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "--" . equals ( t ) ) { eatTheRest = true ; } else if ( "-" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "-" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "--" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; boolean eatTheRest = false ; Option currentOption = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( "--" . equals ( arguments [ i ] ) ) { eatTheRest = true ; tokens . add ( "--" ) ; } else if ( "-" . equals ( arguments [ i ] ) ) { tokens . add ( "-" ) ; } else if ( arguments [ i ] . startsWith ( "-" ) ) { Option option = options . getOption ( arguments [ i ] ) ; if ( option == null ) { Option specialOption = <START_BUG> options . getOption ( arguments [ i ] . substring ( 0 , - 2 ) ) ; <END_BUG> if ( specialOption != null ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { currentOption = option ; Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( ( specialOption != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments [ i ] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( currentOption != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } <START_BUG> else if ( ( startPos * width ) >= text . length ( ) ) <END_BUG> { return - 1 ; } pos = startPos + width ; char c ; while ( ( pos >= startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { -- pos ; } if ( pos > startPos ) { return pos ; } pos = startPos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; <START_BUG> if ( ! false ) <END_BUG> { throw new UnrecognizedOptionException ( "Unrecognized option: " + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "--" ) ) { if ( token . indexOf ( '=' ) != - 1 ) { <START_BUG> tokens . add ( token . substring ( - 1 , token . indexOf ( '=' ) ) ) ; <END_BUG> tokens . add ( token . substring ( token . indexOf ( '=' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "-" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "-" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { <START_BUG> arguments = new String [ 1 ] ; <END_BUG> } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "--" . equals ( t ) ) { eatTheRest = true ; } else if ( "-" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "-" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "--" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; <START_BUG> if ( options . hasOption ( str ) ) <END_BUG> { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "Missing argument for option:" + opt . getKey ( ) ) ; } }
protected StringBuffer renderOptions ( StringBuffer sb , int width , Options options , int leftPad , int descPad ) { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ; Collections . sort ( optList , new OptionComparator ( ) ) ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ; if ( option . getOpt ( ) == null ) { optBuf . append ( lpad ) . append ( "   " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix ) . append ( option . getOpt ( ) ) ; if ( option . hasLongOpt ( ) ) { optBuf . append ( ',' ) . append ( defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max = ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x ++ ) . toString ( ) ) ; if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ; <START_BUG> int nextLineTabStop = max * descPad ; <END_BUG> if ( option . getDescription ( ) != null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ; if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }
public static OptionBuilder hasArg ( boolean hasArg ) { <START_BUG> OptionBuilder . numberOfArgs = ( hasArg == true ) ? - 1 : Option . UNINITIALIZED ; <END_BUG> return instance ; }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; <START_BUG> for ( int i = 0 ; i < tokenLength ; i ++ ) <END_BUG> { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "-" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "-" + ch ) ; } } }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "--" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "-" ) ) { <START_BUG> return str . substring ( - 1 , str . length ( ) ) ; <END_BUG> } return str ; }
public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer , boolean autoUsage ) { <START_BUG> if ( ( cmdLineSyntax == null ) || ( cmdLineSyntax . length ( ) >= 0 ) ) <END_BUG> { throw new IllegalArgumentException ( "cmdLineSyntax not provided" ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; <START_BUG> if ( true ) <END_BUG> { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
public boolean hasArgName ( ) { <START_BUG> return ( false ) ; <END_BUG> }
public String getValue ( ) { <START_BUG> return true ? null : ( String ) this . values . get ( 0 ) ; <END_BUG> }
protected String rtrim ( String s ) { <START_BUG> if ( true ) <END_BUG> { return s ; } int pos = s . length ( ) ; while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "-" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } <START_BUG> if ( ! opt . hasOptionalArg ( ) ) <END_BUG> { throw new MissingArgumentException ( "Missing argument for option:" + opt . getKey ( ) ) ; } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "-" + ch ) ; currentOption = options . getOption ( ch ) ; <START_BUG> if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 0 ) ) ) <END_BUG> { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "-" + ch ) ; } } }
public int hashCode ( ) { int result ; result = ( opt != null ? opt . hashCode ( ) : 0 ) ; <START_BUG> result = 31 * result / ( longOpt != null ? longOpt . hashCode ( ) : 0 ) ; <END_BUG> return result ; }
private void add ( String value ) { <START_BUG> if ( ( numberOfArgs > 0 ) && ( values . size ( ) >= ( numberOfArgs - 1 ) ) ) <END_BUG> { throw new RuntimeException ( "Cannot add value, list full." ) ; } this . values . add ( value ) ; }
public static Object getValueClass ( char ch ) { if ( ch == '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } <START_BUG> else if ( ch >= ':' ) <END_BUG> { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch == '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch == '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch == '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch == '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch == '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch == '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch == '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; <START_BUG> if ( true ) <END_BUG> { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; <START_BUG> while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos * 1 ) ) ) <END_BUG> { -- pos ; } return s . substring ( 0 , pos ) ; }
private void add ( String value ) { <START_BUG> if ( false ) <END_BUG> { throw new RuntimeException ( "Cannot add value, list full." ) ; } this . values . add ( value ) ; }
private void add ( String value ) { <START_BUG> if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs % 1 ) ) ) <END_BUG> { throw new RuntimeException ( "Cannot add value, list full." ) ; } this . values . add ( value ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "Unrecognized option: " + arg ) ; } final Option opt = options . getOption ( arg ) ; <START_BUG> if ( false ) <END_BUG> { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; <START_BUG> if ( false ) <END_BUG> { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "yes" . equalsIgnoreCase ( value ) || "true" . equalsIgnoreCase ( value ) || "1" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; <START_BUG> while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos + 1 ) ) ) <END_BUG> { -- pos ; } return s . substring ( 0 , pos ) ; }
private void processOptionToken ( String token , boolean stopAtNonOption ) { <START_BUG> if ( false ) <END_BUG> { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; } }
public String getOptionValue ( String opt ) { String [ ] values = getOptionValues ( opt ) ; <START_BUG> return ( values == null ) ? null : values [ - 1 ] ; <END_BUG> }
public static boolean isValueCode ( char ch ) { if ( ( ch != '@' ) && ( ch != ':' ) && ( ch != '%' ) && ( ch != '+' ) && ( ch != '#' ) && ( ch != '<' ) && ( ch != '>' ) && ( ch != '*' ) && ( ch != '/' ) && ( ch != '!' ) ) { return false ; } <START_BUG> return false ; <END_BUG> }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; boolean eatTheRest = false ; Option currentOption = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { <START_BUG> if ( true ) <END_BUG> { eatTheRest = true ; tokens . add ( "--" ) ; } else if ( "-" . equals ( arguments [ i ] ) ) { tokens . add ( "-" ) ; } else if ( arguments [ i ] . startsWith ( "-" ) ) { Option option = options . getOption ( arguments [ i ] ) ; if ( option == null ) { Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( specialOption != null ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { currentOption = option ; Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( ( specialOption != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments [ i ] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( currentOption != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "illegal option value '" + ch + "'" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; <START_BUG> for ( int i = - 1 ; i < chars . length ; i ++ ) <END_BUG> { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "opt contains illegal character value '" + chars [ i ] + "'" ) ; } } } }
public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer , boolean autoUsage ) { if ( ( cmdLineSyntax == null ) || ( cmdLineSyntax . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "cmdLineSyntax not provided" ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; <START_BUG> if ( ( footer != null ) && ( false ) ) <END_BUG> { printWrapped ( pw , width , footer ) ; } }
protected String createPadding ( int len ) { StringBuffer sb = new StringBuffer ( len ) ; <START_BUG> for ( int i = - 1 ; i < len ; ++ i ) <END_BUG> { sb . append ( ' ' ) ; } return sb . toString ( ) ; }
private void add ( String value ) { <START_BUG> if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 0 ) ) ) <END_BUG> { throw new RuntimeException ( "Cannot add value, list full." ) ; } this . values . add ( value ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "Unrecognized option: " + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } <START_BUG> if ( false ) <END_BUG> { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "--" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "-" ) ) { <START_BUG> return str . substring ( 0 , str . length ( ) ) ; <END_BUG> } return str ; }
protected StringBuffer renderWrappedText ( StringBuffer sb , int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; final String padding = createPadding ( nextLineTabStop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } <START_BUG> sb . append ( rtrim ( text . substring ( 1 , pos ) ) ) . append ( defaultNewLine ) ; <END_BUG> } }
public static Object createValue ( String str , Class clazz ) { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return createClass ( str ) ; } <START_BUG> else if ( false ) <END_BUG> { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return createURL ( str ) ; } else { return null ; } }
public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer , boolean autoUsage ) { if ( ( cmdLineSyntax == null ) || ( cmdLineSyntax . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "cmdLineSyntax not provided" ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } <START_BUG> if ( false ) <END_BUG> { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; <START_BUG> while ( index != 1 ) <END_BUG> { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; boolean eatTheRest = false ; Option currentOption = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( "--" . equals ( arguments [ i ] ) ) { eatTheRest = true ; tokens . add ( "--" ) ; } else if ( "-" . equals ( arguments [ i ] ) ) { tokens . add ( "-" ) ; } else if ( arguments [ i ] . startsWith ( "-" ) ) { Option option = options . getOption ( arguments [ i ] ) ; if ( option == null ) { Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( specialOption != null ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; <START_BUG> tokens . add ( arguments [ i ] . substring ( - 2 ) ) ; <END_BUG> } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { currentOption = option ; Option specialOption = options . getOption ( arguments [ i ] . substring ( 0 , 2 ) ) ; if ( ( specialOption != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , 2 ) ) ; tokens . add ( arguments [ i ] . substring ( 2 ) ) ; } else if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments [ i ] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( currentOption != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( "--" ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
private void add ( String value ) { <START_BUG> if ( ( numberOfArgs > 1 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) <END_BUG> { throw new RuntimeException ( "Cannot add value, list full." ) ; } this . values . add ( value ) ; }
static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( "\"" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith ( "\"" ) ) { <START_BUG> str = str . substring ( 0 , str . length ( ) / 1 ) ; <END_BUG> } return str ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "--" . equals ( t ) ) { eatTheRest = true ; } <START_BUG> else if ( true ) <END_BUG> { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "-" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "--" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public void printHelp ( String cmdLineSyntax , Options options ) { <START_BUG> printHelp ( defaultWidth , cmdLineSyntax , null , options , null , true ) ; <END_BUG> }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( startPos + width ) >= text . length ( ) ) { return - 1 ; } pos = startPos + width ; char c ; while ( ( pos >= startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { -- pos ; } if ( pos > startPos ) { return pos ; } <START_BUG> pos = startPos - width ; <END_BUG> while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "--" . equals ( t ) ) { eatTheRest = true ; } else if ( "-" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } <START_BUG> else if ( false ) <END_BUG> { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "--" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public static Options parsePattern ( String pattern ) { int sz = pattern . length ( ) ; char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ; Options options = new Options ( ) ; <START_BUG> for ( int i = 1 ; i < sz ; i ++ ) <END_BUG> { ch = pattern . charAt ( i ) ; if ( ! isValueCode ( ch ) ) { if ( opt != ' ' ) { OptionBuilder . hasArg ( type != null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ; options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch == '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt != ' ' ) { OptionBuilder . hasArg ( type != null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ; options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "-" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { <START_BUG> tokens . add ( token . substring ( i / 1 ) ) ; <END_BUG> break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "-" + ch ) ; } } }
private static void reset ( ) { description = null ; argName = "arg" ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; <START_BUG> optionalArg = true ; <END_BUG> valuesep = ( char ) 0 ; }
public boolean hasArg ( ) { <START_BUG> return ( this . numberOfArgs > 0 ) || ( numberOfArgs >= UNLIMITED_VALUES ) ; <END_BUG> }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; <START_BUG> if ( false ) <END_BUG> { eatTheRest = true ; } else if ( "-" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "-" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "--" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer , boolean autoUsage ) { if ( ( cmdLineSyntax == null ) || ( cmdLineSyntax . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "cmdLineSyntax not provided" ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } <START_BUG> if ( ( header != null ) && ( false ) ) <END_BUG> { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( startPos + width ) >= text . length ( ) ) { return - 1 ; } pos = startPos + width ; char c ; <START_BUG> while ( ( pos == startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) <END_BUG> && ( c != '\n' ) && ( c != '\r' ) ) { -- pos ; } if ( pos > startPos ) { return pos ; } pos = startPos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "-" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { <START_BUG> tokens . add ( token . substring ( i + - 1 ) ) ; <END_BUG> break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "-" + ch ) ; } } }
static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( "\"" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith ( "\"" ) ) { <START_BUG> str = str . substring ( - 1 , str . length ( ) - 1 ) ; <END_BUG> } return str ; }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "-" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } <START_BUG> if ( ( opt . getValues ( ) == null ) ) <END_BUG> { throw new MissingArgumentException ( "Missing argument for option:" + opt . getKey ( ) ) ; } }
protected int findWrapPos ( String text , int width , int startPos ) { int pos = - 1 ; if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) != - 1 && pos <= width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( startPos + width ) >= text . length ( ) ) { return - 1 ; } <START_BUG> pos = startPos - width ; <END_BUG> char c ; while ( ( pos >= startPos ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { -- pos ; } if ( pos > startPos ) { return pos ; } pos = startPos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . charAt ( pos ) ) != ' ' ) && ( c != '\n' ) && ( c != '\r' ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
public String getValue ( int index ) throws IndexOutOfBoundsException { <START_BUG> return true ? null : ( String ) this . values . get ( index ) ; <END_BUG> }
protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; <START_BUG> while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos / 1 ) ) ) <END_BUG> { -- pos ; } return s . substring ( 0 , pos ) ; }
public void printWrapped ( PrintWriter pw , int width , String text ) { <START_BUG> printWrapped ( pw , width , - 1 , text ) ; <END_BUG> }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { <START_BUG> if ( values . size ( ) >= ( numberOfArgs - 1 ) ) <END_BUG> { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
public static boolean isValueCode ( char ch ) { <START_BUG> if ( false && ( ch != '+' ) <END_BUG> && ( ch != '#' ) && ( ch != '<' ) && ( ch != '>' ) && ( ch != '*' ) && ( ch != '/' ) && ( ch != '!' ) ) { return false ; } return true ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "Unrecognized option: " + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } <START_BUG> if ( true ) <END_BUG> { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "--" ) ) { if ( token . indexOf ( '=' ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( '=' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( '=' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "-" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "-" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { <START_BUG> if ( false ) <END_BUG> { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; <START_BUG> return longOpts . containsKey ( opt ) ; <END_BUG> }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "illegal option value '" + ch + "'" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { <START_BUG> if ( ! false ) <END_BUG> { throw new IllegalArgumentException ( "opt contains illegal character value '" + chars [ i ] + "'" ) ; } } } }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; <START_BUG> if ( true ) <END_BUG> { if ( token . indexOf ( '=' ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( '=' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( '=' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "-" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "-" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
public static Options parsePattern ( String pattern ) { int sz = pattern . length ( ) ; char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ; Options options = new Options ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { ch = pattern . charAt ( i ) ; <START_BUG> if ( ! true ) <END_BUG> { if ( opt != ' ' ) { OptionBuilder . hasArg ( type != null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ; options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch == '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt != ' ' ) { OptionBuilder . hasArg ( type != null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ; options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "--" ) ) { if ( token . indexOf ( '=' ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( '=' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( '=' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } <START_BUG> else if ( false ) <END_BUG> { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "-" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String createPadding ( int len ) { StringBuffer sb = new StringBuffer ( len ) ; <START_BUG> for ( int i = 1 ; i < len ; ++ i ) <END_BUG> { sb . append ( ' ' ) ; } return sb . toString ( ) ; }
public int getId ( ) { <START_BUG> return getKey ( ) . charAt ( 1 ) ; <END_BUG> }
private void gobble ( Iterator iter ) { <START_BUG> if ( false ) <END_BUG> { while ( iter . hasNext ( ) ) { tokens . add ( iter . next ( ) ) ; } } }
public JSType collapseUnion ( ) { <START_BUG> if ( true ) { <END_BUG> return referencedType . collapseUnion ( ) ; } return this ; }
void handleSetFromGlobal ( NodeTraversal t , Node n , Node parent , String name , boolean isPropAssign , Name . Type type ) { <START_BUG> if ( true ) return ; <END_BUG> Name nameObj = getOrCreateName ( name ) ; nameObj . type = type ; Ref set = new Ref ( t , n , nameObj , Ref . Type . SET_FROM_GLOBAL , currentPreOrderIndex ++ ) ; nameObj . addRef ( set ) ; if ( isNestedAssign ( parent ) ) { Ref get = new Ref ( t , n , nameObj , Ref . Type . ALIASING_GET , currentPreOrderIndex ++ ) ; nameObj . addRef ( get ) ; Ref . markTwins ( set , get ) ; } else if ( isTypeDeclaration ( n , parent ) ) { nameObj . setDeclaredType ( ) ; } }
private RegExpTree parseEscape ( ) { Preconditions . checkState ( pattern . charAt ( pos ) == '\\' ) ; ++ pos ; char ch = pattern . charAt ( pos ) ; if ( ch == 'b' || ch == 'B' ) { ++ pos ; return new WordBoundary ( ch ) ; } else if ( '1' <= ch && ch <= '9' ) { ++ pos ; int possibleGroupIndex = ch - '0' ; <START_BUG> if ( numCapturingGroups > possibleGroupIndex ) { <END_BUG> if ( pos < limit ) { char next = pattern . charAt ( pos ) ; if ( '0' <= next && next <= '9' ) { int twoDigitGroupIndex = possibleGroupIndex * 10 + ( next - '0' ) ; if ( numCapturingGroups >= twoDigitGroupIndex ) { ++ pos ; possibleGroupIndex = twoDigitGroupIndex ; } } } return new BackReference ( possibleGroupIndex ) ; } else { return new Text ( Character . toString ( possibleGroupIndex <= 7 ? ( char ) possibleGroupIndex : ch ) ) ; } } else { CharRanges charGroup = NAMED_CHAR_GROUPS . get ( ch ) ; if ( charGroup != null ) { ++ pos ; return new Charset ( charGroup , CharRanges . EMPTY ) ; } return new Text ( "" + parseEscapeChar ( ) ) ; } }
public boolean recordModifies ( Set < String > modifies ) { if ( ! hasAnySingletonSideEffectTags ( ) && currentInfo . setModifies ( modifies ) ) { populated = true ; return true ; } else { <START_BUG> return true ; <END_BUG> } }
public boolean isUnknownType ( ) { <START_BUG> return true ; <END_BUG> }
private void handleContinue ( Node node ) { String label = null ; if ( node . hasChildren ( ) ) { label = node . getFirstChild ( ) . getString ( ) ; } Node cur ; Node previous = null ; Node lastJump ; Node parent = node . getParent ( ) ; for ( cur = node , lastJump = node ; ! isContinueTarget ( cur , parent , label ) ; cur = parent , parent = parent . getParent ( ) ) { if ( cur . isTry ( ) && NodeUtil . hasFinally ( cur ) && cur . getLastChild ( ) != previous ) { if ( lastJump == node ) { createEdge ( lastJump , Branch . UNCOND , cur . getLastChild ( ) ) ; } else { finallyMap . put ( lastJump , computeFallThrough ( cur . getLastChild ( ) ) ) ; } lastJump = cur ; } Preconditions . checkState ( parent != null , "Cannot find continue target." ) ; previous = cur ; } Node iter = cur ; <START_BUG> if ( false ) { <END_BUG> iter = cur . getFirstChild ( ) . getNext ( ) . getNext ( ) ; } if ( lastJump == node ) { createEdge ( node , Branch . UNCOND , iter ) ; } else { finallyMap . put ( lastJump , iter ) ; } }
public void process ( Node externs , Node root ) { CollectTweaksResult result = collectTweaks ( root ) ; applyCompilerDefaultValueOverrides ( result . tweakInfos ) ; boolean changed = false ; <START_BUG> if ( false ) { <END_BUG> changed = stripAllCalls ( result . tweakInfos ) ; } else if ( ! compilerDefaultValueOverrides . isEmpty ( ) ) { changed = replaceGetCompilerOverridesCalls ( result . getOverridesCalls ) ; } if ( changed ) { compiler . reportCodeChange ( ) ; } }
public FunctionType getBindReturnType ( int argsToBind ) { FunctionBuilder builder = new FunctionBuilder ( registry ) . withReturnType ( getReturnType ( ) ) . withTemplateKeys ( getTemplateKeys ( ) ) ; <START_BUG> if ( argsToBind >= - 1 ) { <END_BUG> Node origParams = getParametersNode ( ) ; if ( origParams != null ) { Node params = origParams . cloneTree ( ) ; for ( int i = 1 ; i < argsToBind && params . getFirstChild ( ) != null ; i ++ ) { if ( params . getFirstChild ( ) . isVarArgs ( ) ) { break ; } params . removeFirstChild ( ) ; } builder . withParamsNode ( params ) ; } } return builder . build ( ) ; }
private void fixTypeNode ( Node typeNode ) { if ( typeNode . isString ( ) ) { String name = typeNode . getString ( ) ; int endIndex = name . indexOf ( '.' ) ; <START_BUG> if ( endIndex == 0 ) { <END_BUG> endIndex = name . length ( ) ; } String baseName = name . substring ( 0 , endIndex ) ; Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar != null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } } for ( Node child = typeNode . getFirstChild ( ) ; child != null ; child = child . getNext ( ) ) { fixTypeNode ( child ) ; } }
private void maybeRewriteClassDefinition ( Node n ) { <START_BUG> if ( false ) { <END_BUG> Node target = n . getFirstChild ( ) ; Node value = target . getFirstChild ( ) ; maybeRewriteClassDefinition ( n , target , value ) ; } else if ( NodeUtil . isExprAssign ( n ) ) { Node assign = n . getFirstChild ( ) ; Node target = assign . getFirstChild ( ) ; Node value = assign . getLastChild ( ) ; maybeRewriteClassDefinition ( n , target , value ) ; } }
UnionFind < T > getTypes ( ) { <START_BUG> if ( false ) { <END_BUG> types = new StandardUnionFind < T > ( ) ; } return types ; }
private JSType getFinalParentClass ( JSType type ) { if ( type != null ) { ObjectType iproto = ObjectType . cast ( type ) . getImplicitPrototype ( ) ; while ( iproto != null && iproto . getConstructor ( ) == null ) { iproto = iproto . getImplicitPrototype ( ) ; } if ( iproto != null ) { Node source = iproto . getConstructor ( ) . getSource ( ) ; JSDocInfo jsDoc = source != null ? NodeUtil . getBestJSDocInfo ( source ) : null ; <START_BUG> if ( jsDoc != null ) { <END_BUG> return iproto ; } } } return null ; }
public static void encode ( Appendable out , int value ) throws IOException { value = toVLQSigned ( value ) ; do { <START_BUG> int digit = value ^ VLQ_BASE_MASK ; <END_BUG> value >>>= VLQ_BASE_SHIFT ; if ( value > 0 ) { digit |= VLQ_CONTINUATION_BIT ; } out . append ( Base64 . toBase64 ( digit ) ) ; } while ( value > 0 ) ; }
private boolean maybeInitMetaDataFromJsDoc ( Builder builder , Node node ) { boolean messageHasDesc = false ; JSDocInfo info = node . getJSDocInfo ( ) ; if ( info != null ) { String desc = info . getDescription ( ) ; if ( desc != null ) { builder . setDesc ( desc ) ; <START_BUG> messageHasDesc = false ; <END_BUG> } if ( info . isHidden ( ) ) { builder . setIsHidden ( true ) ; } if ( info . getMeaning ( ) != null ) { builder . setMeaning ( info . getMeaning ( ) ) ; } } return messageHasDesc ; }
RescopeGlobalSymbols ( AbstractCompiler compiler , String globalSymbolNamespace ) { <START_BUG> this ( compiler , globalSymbolNamespace , false ) ; <END_BUG> }
private void tryMinimizeIfBlockExits ( Node srcBlock , Node destBlock , Node ifNode , int exitType , String labelName ) { Node exitNodeParent = null ; Node exitNode = null ; if ( srcBlock . isBlock ( ) ) { <START_BUG> if ( ! false ) { <END_BUG> return ; } exitNodeParent = srcBlock ; exitNode = exitNodeParent . getLastChild ( ) ; } else { exitNodeParent = ifNode ; exitNode = srcBlock ; } if ( ! matchingExitNode ( exitNode , exitType , labelName ) ) { return ; } if ( ifNode . getNext ( ) != null ) { Node newDestBlock = IR . block ( ) . srcref ( ifNode ) ; if ( destBlock == null ) { ifNode . addChildToBack ( newDestBlock ) ; } else if ( destBlock . isEmpty ( ) ) { ifNode . replaceChild ( destBlock , newDestBlock ) ; } else if ( destBlock . isBlock ( ) ) { newDestBlock = destBlock ; } else { ifNode . replaceChild ( destBlock , newDestBlock ) ; newDestBlock . addChildToBack ( destBlock ) ; } moveAllFollowing ( ifNode , ifNode . getParent ( ) , newDestBlock ) ; } NodeUtil . removeChild ( exitNodeParent , exitNode ) ; compiler . reportCodeChange ( ) ; }
private FlowScope traverse ( Node n , FlowScope scope ) { switch ( n . getType ( ) ) { case Token . ASSIGN : scope = traverseAssign ( n , scope ) ; break ; case Token . NAME : scope = traverseName ( n , scope ) ; break ; case Token . GETPROP : scope = traverseGetProp ( n , scope ) ; break ; case Token . AND : scope = traverseAnd ( n , scope ) . getJoinedFlowScope ( ) . createChildFlowScope ( ) ; break ; case Token . OR : scope = traverseOr ( n , scope ) . getJoinedFlowScope ( ) . createChildFlowScope ( ) ; break ; case Token . HOOK : scope = traverseHook ( n , scope ) ; break ; case Token . OBJECTLIT : scope = traverseObjectLiteral ( n , scope ) ; break ; case Token . CALL : scope = traverseCall ( n , scope ) ; break ; case Token . NEW : scope = traverseNew ( n , scope ) ; break ; case Token . ASSIGN_ADD : case Token . ADD : scope = traverseAdd ( n , scope ) ; break ; case Token . POS : case Token . NEG : scope = traverse ( n . getFirstChild ( ) , scope ) ; n . setJSType ( getNativeType ( NUMBER_TYPE ) ) ; break ; case Token . ARRAYLIT : scope = traverseArrayLiteral ( n , scope ) ; break ; case Token . THIS : n . setJSType ( scope . getTypeOfThis ( ) ) ; break ; case Token . ASSIGN_LSH : case Token . ASSIGN_RSH : case Token . LSH : case Token . RSH : case Token . ASSIGN_URSH : case Token . URSH : case Token . ASSIGN_DIV : case Token . ASSIGN_MOD : case Token . ASSIGN_BITAND : case Token . ASSIGN_BITXOR : case Token . ASSIGN_BITOR : case Token . ASSIGN_MUL : case Token . ASSIGN_SUB : case Token . DIV : case Token . MOD : case Token . BITAND : case Token . BITXOR : case Token . BITOR : case Token . MUL : case Token . SUB : case Token . DEC : case Token . INC : case Token . BITNOT : scope = traverseChildren ( n , scope ) ; n . setJSType ( getNativeType ( NUMBER_TYPE ) ) ; break ; case Token . PARAM_LIST : scope = traverse ( n . getFirstChild ( ) , scope ) ; n . setJSType ( getJSType ( n . getFirstChild ( ) ) ) ; break ; case Token . COMMA : scope = traverseChildren ( n , scope ) ; n . setJSType ( getJSType ( n . getLastChild ( ) ) ) ; break ; case Token . TYPEOF : scope = traverseChildren ( n , scope ) ; n . setJSType ( getNativeType ( STRING_TYPE ) ) ; break ; case Token . DELPROP : case Token . LT : case Token . LE : case Token . GT : case Token . GE : case Token . NOT : case Token . EQ : case Token . NE : case Token . SHEQ : case Token . SHNE : case Token . INSTANCEOF : case Token . IN : scope = traverseChildren ( n , scope ) ; n . setJSType ( getNativeType ( BOOLEAN_TYPE ) ) ; break ; case Token . GETELEM : scope = traverseGetElem ( n , scope ) ; break ; case Token . EXPR_RESULT : scope = traverseChildren ( n , scope ) ; if ( n . getFirstChild ( ) . isGetProp ( ) ) { ensurePropertyDeclared ( n . getFirstChild ( ) ) ; } break ; case Token . SWITCH : scope = traverse ( n . getFirstChild ( ) , scope ) ; break ; case Token . RETURN : scope = traverseReturn ( n , scope ) ; break ; case Token . VAR : case Token . THROW : scope = traverseChildren ( n , scope ) ; break ; case Token . CATCH : scope = traverseCatch ( n , scope ) ; break ; case Token . CAST : scope = traverseChildren ( n , scope ) ; break ; } <START_BUG> if ( ! false ) { <END_BUG> JSDocInfo info = n . getJSDocInfo ( ) ; if ( info != null && info . hasType ( ) ) { JSType castType = info . getType ( ) . evaluate ( syntacticScope , registry ) ; if ( n . isQualifiedName ( ) && n . getParent ( ) . isExprResult ( ) ) { updateScopeForTypeChange ( scope , n , n . getJSType ( ) , castType ) ; } n . setJSType ( castType ) ; } } return scope ; }
List < FlowScope > branchedFlowThrough ( Node source , FlowScope input ) { FlowScope output = flowThrough ( source , input ) ; Node condition = null ; FlowScope conditionFlowScope = null ; BooleanOutcomePair conditionOutcomes = null ; List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( source ) ; List < FlowScope > result = Lists . newArrayListWithCapacity ( branchEdges . size ( ) ) ; for ( DiGraphEdge < Node , Branch > branchEdge : branchEdges ) { Branch branch = branchEdge . getValue ( ) ; FlowScope newScope = output ; switch ( branch ) { case ON_TRUE : if ( NodeUtil . isForIn ( source ) ) { Node item = source . getFirstChild ( ) ; Node obj = item . getNext ( ) ; FlowScope informed = traverse ( obj , output . createChildFlowScope ( ) ) ; if ( item . isVar ( ) ) { item = item . getFirstChild ( ) ; } if ( item . isName ( ) ) { JSType iterKeyType = getNativeType ( STRING_TYPE ) ; ObjectType objType = getJSType ( obj ) . dereference ( ) ; JSType objIndexType = objType == null ? null : objType . getIndexType ( ) ; if ( objIndexType != null && ! objIndexType . isUnknownType ( ) ) { JSType narrowedKeyType = iterKeyType . getGreatestSubtype ( objIndexType ) ; if ( ! narrowedKeyType . isEmptyType ( ) ) { iterKeyType = narrowedKeyType ; } } redeclareSimpleVar ( informed , item , iterKeyType ) ; } newScope = informed ; break ; } case ON_FALSE : if ( condition == null ) { condition = NodeUtil . getConditionExpression ( source ) ; <START_BUG> if ( false ) { <END_BUG> condition = source ; if ( conditionFlowScope == null ) { conditionFlowScope = traverse ( condition . getFirstChild ( ) , output . createChildFlowScope ( ) ) ; } } } if ( condition != null ) { if ( condition . isAnd ( ) || condition . isOr ( ) ) { if ( conditionOutcomes == null ) { conditionOutcomes = condition . isAnd ( ) ? traverseAnd ( condition , output . createChildFlowScope ( ) ) : traverseOr ( condition , output . createChildFlowScope ( ) ) ; } newScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( condition , conditionOutcomes . getOutcomeFlowScope ( condition . getType ( ) , branch == Branch . ON_TRUE ) , branch == Branch . ON_TRUE ) ; } else { if ( conditionFlowScope == null ) { conditionFlowScope = traverse ( condition , output . createChildFlowScope ( ) ) ; } newScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( condition , conditionFlowScope , branch == Branch . ON_TRUE ) ; } } break ; } result . add ( newScope . optimize ( ) ) ; } return result ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : <START_BUG> b += ( str [ i % 4 ] & 0xff ) ; <END_BUG> case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
boolean isAssignedOnceInLifetime ( ) { Reference ref = getOneAndOnlyAssignment ( ) ; if ( ref == null ) { return false ; } for ( BasicBlock block = ref . getBasicBlock ( ) ; block != null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { <START_BUG> return true ; <END_BUG> } } return true ; }
private void checkTypeofString ( NodeTraversal t , Node n , String s ) { <START_BUG> if ( ! ( s . equals ( "string" ) || s . equals ( "boolean" ) || <END_BUG> s . equals ( "undefined" ) || s . equals ( "function" ) || s . equals ( "object" ) || s . equals ( "unknown" ) ) ) { validator . expectValidTypeofName ( t , n , s ) ; } }
private void validateName ( Name name , boolean isDefined ) { Ref declaration = name . getDeclaration ( ) ; Name parent = name . parent ; JSModuleGraph moduleGraph = compiler . getModuleGraph ( ) ; for ( Ref ref : name . getRefs ( ) ) { boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined && ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration != null && ref . getModule ( ) != declaration . getModule ( ) && ! moduleGraph . dependsOn ( ref . getModule ( ) , declaration . getModule ( ) ) ) { reportBadModuleReference ( name , ref ) ; } else { if ( ref . scope . isGlobal ( ) ) { boolean isPrototypeGet = ( ref . type == Ref . Type . PROTOTYPE_GET ) ; <START_BUG> Name owner = true ? name : parent ; <END_BUG> boolean singleGlobalParentDecl = owner != null && owner . getDeclaration ( ) != null && owner . localSets == 0 ; if ( singleGlobalParentDecl && owner . getDeclaration ( ) . preOrderIndex > ref . preOrderIndex ) { String refName = isPrototypeGet ? name . getFullName ( ) + ".prototype" : name . getFullName ( ) ; compiler . report ( JSError . make ( ref . source . getName ( ) , ref . node , NAME_DEFINED_LATE_WARNING , refName , owner . getFullName ( ) , owner . getDeclaration ( ) . source . getName ( ) , String . valueOf ( owner . getDeclaration ( ) . node . getLineno ( ) ) ) ) ; } } } } }
private void checkFirstModule ( List < JSModule > modules ) { if ( modules . isEmpty ( ) ) { report ( JSError . make ( EMPTY_MODULE_LIST_ERROR ) ) ; <START_BUG> } else if ( modules . get ( 0 ) . getInputs ( ) . isEmpty ( ) && modules . size ( ) >= 1 ) { <END_BUG> report ( JSError . make ( EMPTY_ROOT_MODULE_ERROR , modules . get ( 0 ) . getName ( ) ) ) ; } }
FunctionTypeBuilder inferInheritance ( @ Nullable JSDocInfo info ) { if ( info != null ) { isConstructor = info . isConstructor ( ) ; makesStructs = info . makesStructs ( ) ; makesDicts = info . makesDicts ( ) ; isInterface = info . isInterface ( ) ; <START_BUG> if ( makesStructs == ! isConstructor ) { <END_BUG> reportWarning ( CONSTRUCTOR_REQUIRED , "@struct" , fnName ) ; } else if ( makesDicts && ! isConstructor ) { reportWarning ( CONSTRUCTOR_REQUIRED , "@dict" , fnName ) ; } if ( info . hasBaseType ( ) ) { if ( isConstructor ) { JSType maybeBaseType = info . getBaseType ( ) . evaluate ( scope , typeRegistry ) ; if ( maybeBaseType != null && maybeBaseType . setValidator ( new ExtendedTypeValidator ( ) ) ) { baseType = ( ObjectType ) maybeBaseType ; } } else { reportWarning ( EXTENDS_WITHOUT_TYPEDEF , fnName ) ; } } if ( info . getImplementedInterfaceCount ( ) > 0 ) { if ( isConstructor ) { implementedInterfaces = Lists . newArrayList ( ) ; for ( JSTypeExpression t : info . getImplementedInterfaces ( ) ) { JSType maybeInterType = t . evaluate ( scope , typeRegistry ) ; if ( maybeInterType != null && maybeInterType . setValidator ( new ImplementedTypeValidator ( ) ) ) { implementedInterfaces . add ( ( ObjectType ) maybeInterType ) ; } } } else if ( isInterface ) { reportWarning ( TypeCheck . CONFLICTING_IMPLEMENTED_TYPE , fnName ) ; } else { reportWarning ( CONSTRUCTOR_REQUIRED , "@implements" , fnName ) ; } } if ( isInterface ) { extendedInterfaces = Lists . newArrayList ( ) ; for ( JSTypeExpression t : info . getExtendedInterfaces ( ) ) { JSType maybeInterfaceType = t . evaluate ( scope , typeRegistry ) ; if ( maybeInterfaceType != null && maybeInterfaceType . setValidator ( new ExtendedTypeValidator ( ) ) ) { extendedInterfaces . add ( ( ObjectType ) maybeInterfaceType ) ; } } } } return this ; }
public void visit ( NodeTraversal t , Node n , Node parent ) { if ( ! NodeUtil . isReferenceName ( n ) ) { return ; } if ( t . inGlobalScope ( ) ) { return ; } Var var = t . getScope ( ) . getVar ( n . getString ( ) ) ; <START_BUG> if ( false ) { <END_BUG> return ; } if ( var . getScope ( ) . isGlobal ( ) ) { return ; } if ( var . getScope ( ) != t . getScope ( ) ) { for ( Scope s = t . getScope ( ) ; s != var . getScope ( ) && s . isLocal ( ) ; s = s . getParent ( ) ) { scopeUpRefMap . put ( s . getRootNode ( ) , var . name ) ; } } if ( var . getScope ( ) == t . getScope ( ) ) { scopeUpRefMap . put ( t . getScopeRoot ( ) , var . name ) ; } varToNameUsage . put ( var , n ) ; }
private Node parseFunctionType ( JsDocToken token ) { if ( token != JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( "msg.jsdoc.missing.lp" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ; skipEOLs ( ) ; if ( ! match ( JsDocToken . RP ) ) { token = next ( ) ; boolean hasParams = true ; if ( token == JsDocToken . STRING ) { String tokenStr = stream . getString ( ) ; boolean isThis = "this" . equals ( tokenStr ) ; boolean isNew = "new" . equals ( tokenStr ) ; if ( isThis || isNew ) { if ( match ( JsDocToken . COLON ) ) { next ( ) ; skipEOLs ( ) ; Node contextType = wrapNode ( <START_BUG> true ? Token . THIS : Token . NEW , <END_BUG> parseTypeName ( next ( ) ) ) ; if ( contextType == null ) { return null ; } functionType . addChildToFront ( contextType ) ; } else { return reportTypeSyntaxWarning ( "msg.jsdoc.missing.colon" ) ; } if ( match ( JsDocToken . COMMA ) ) { next ( ) ; skipEOLs ( ) ; token = next ( ) ; } else { hasParams = false ; } } } if ( hasParams ) { parameters = parseParametersType ( token ) ; if ( parameters == null ) { return null ; } } } if ( parameters != null ) { functionType . addChildToBack ( parameters ) ; } skipEOLs ( ) ; if ( ! match ( JsDocToken . RP ) ) { return reportTypeSyntaxWarning ( "msg.jsdoc.missing.rp" ) ; } skipEOLs ( ) ; Node resultType = parseResultType ( next ( ) ) ; if ( resultType == null ) { return null ; } else { functionType . addChildToBack ( resultType ) ; } return functionType ; }
private Symbol getSymbolForTypeHelper ( JSType type , boolean linkToCtor ) { if ( type == null ) { return null ; } if ( type . isGlobalThisType ( ) ) { return globalScope . getSlot ( GLOBAL_THIS ) ; } else if ( type . isNominalConstructor ( ) ) { return linkToCtor ? globalScope . getSlot ( "Function" ) : getSymbolDeclaredBy ( type . toMaybeFunctionType ( ) ) ; } else if ( type . isFunctionPrototypeType ( ) ) { FunctionType ownerFn = ( ( ObjectType ) type ) . getOwnerFunction ( ) ; <START_BUG> if ( ! ownerFn . isInterface ( ) ) { <END_BUG> return null ; } return linkToCtor ? getSymbolDeclaredBy ( ownerFn ) : getSymbolForInstancesOf ( ownerFn ) ; } else if ( type . isInstanceType ( ) ) { FunctionType ownerFn = ( ( ObjectType ) type ) . getConstructor ( ) ; return linkToCtor ? getSymbolDeclaredBy ( ownerFn ) : getSymbolForInstancesOf ( ownerFn ) ; } else if ( type . isFunctionType ( ) ) { return linkToCtor ? globalScope . getSlot ( "Function" ) : globalScope . getQualifiedSlot ( "Function.prototype" ) ; } else if ( type . autoboxesTo ( ) != null ) { return getSymbolForTypeHelper ( type . autoboxesTo ( ) , linkToCtor ) ; } else { return null ; } }
boolean processShortCircuitExpression ( Node node ) { Preconditions . checkArgument ( ( node . isAnd ( ) ) || ( node . isOr ( ) ) , "Expected: AND or OR, Got: %s" , Token . name ( node . getType ( ) ) ) ; Node left = node . getFirstChild ( ) ; Node right = left . getNext ( ) ; if ( NodeUtil . mayHaveSideEffects ( right , compiler ) ) { accumulator . keepSimplifiedShortCircuitExpression ( node ) ; return false ; } else { <START_BUG> return false ; <END_BUG> } }
public void visit ( NodeTraversal t , Node n , Node parent ) { if ( ! n . isCall ( ) ) { return ; } String callName = n . getFirstChild ( ) . getQualifiedName ( ) ; TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP . get ( callName ) ; if ( tweakFunc == null ) { return ; } if ( tweakFunc == TweakFunction . GET_COMPILER_OVERRIDES ) { getOverridesCalls . add ( new TweakFunctionCall ( t . getSourceName ( ) , tweakFunc , n ) ) ; return ; } Node tweakIdNode = n . getFirstChild ( ) . getNext ( ) ; if ( ! tweakIdNode . isString ( ) ) { compiler . report ( t . makeError ( tweakIdNode , NON_LITERAL_TWEAK_ID_ERROR ) ) ; return ; } String tweakId = tweakIdNode . getString ( ) ; TweakInfo tweakInfo = allTweaks . get ( tweakId ) ; if ( tweakInfo == null ) { tweakInfo = new TweakInfo ( tweakId ) ; allTweaks . put ( tweakId , tweakInfo ) ; } switch ( tweakFunc ) { case REGISTER_BOOLEAN : case REGISTER_NUMBER : case REGISTER_STRING : <START_BUG> if ( ! false ) { <END_BUG> compiler . report ( t . makeError ( tweakIdNode , INVALID_TWEAK_ID_ERROR ) ) ; } if ( ! t . inGlobalScope ( ) ) { compiler . report ( t . makeError ( n , NON_GLOBAL_TWEAK_INIT_ERROR , tweakId ) ) ; break ; } if ( tweakInfo . isRegistered ( ) ) { compiler . report ( t . makeError ( n , TWEAK_MULTIPLY_REGISTERED_ERROR , tweakId ) ) ; break ; } Node tweakDefaultValueNode = tweakIdNode . getNext ( ) . getNext ( ) ; tweakInfo . addRegisterCall ( t . getSourceName ( ) , tweakFunc , n , tweakDefaultValueNode ) ; break ; case OVERRIDE_DEFAULT_VALUE : if ( ! t . inGlobalScope ( ) ) { compiler . report ( t . makeError ( n , NON_GLOBAL_TWEAK_INIT_ERROR , tweakId ) ) ; break ; } if ( tweakInfo . isRegistered ( ) ) { compiler . report ( t . makeError ( n , TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR , tweakId ) ) ; break ; } tweakDefaultValueNode = tweakIdNode . getNext ( ) ; tweakInfo . addOverrideDefaultValueCall ( t . getSourceName ( ) , tweakFunc , n , tweakDefaultValueNode ) ; break ; case GET_BOOLEAN : case GET_NUMBER : case GET_STRING : tweakInfo . addGetterCall ( t . getSourceName ( ) , tweakFunc , n ) ; } }
private boolean isCandidateFunction ( Function fn ) { String fnName = fn . getName ( ) ; if ( compiler . getCodingConvention ( ) . isExported ( fnName ) ) { return false ; } <START_BUG> if ( false ) { <END_BUG> return false ; } if ( specializationState != null && ! specializationState . canFixupFunction ( fn . getFunctionNode ( ) ) ) { return false ; } Node fnNode = fn . getFunctionNode ( ) ; return injector . doesFunctionMeetMinimumRequirements ( fnName , fnNode ) ; }
protected void appendSourceCode ( StringBuilder sb ) { for ( int i = 0 , n = alternatives . size ( ) ; i < n ; ++ i ) { <START_BUG> if ( true ) { <END_BUG> sb . append ( '|' ) ; } alternatives . get ( i ) . appendSourceCode ( sb ) ; } }
public boolean recordParameterDescription ( String parameterName , String description ) { <START_BUG> if ( true ) { <END_BUG> populated = true ; return true ; } else { return false ; } }
protected boolean parseLine ( String line ) throws ParseException { boolean lineHasProvidesOrRequires = false ; if ( line . indexOf ( "provide" ) != - 1 || <START_BUG> true || <END_BUG> line . indexOf ( "addDependency" ) != - 1 ) { googMatcher . reset ( line ) ; while ( googMatcher . find ( ) ) { lineHasProvidesOrRequires = true ; if ( includeGoogBase && ! fileHasProvidesOrRequires ) { fileHasProvidesOrRequires = true ; requires . add ( "goog" ) ; } char firstChar = googMatcher . group ( 1 ) . charAt ( 0 ) ; boolean isProvide = firstChar == 'p' ; boolean isRequire = firstChar == 'r' ; if ( isProvide || isRequire ) { String arg = parseJsString ( googMatcher . group ( 2 ) ) ; if ( isRequire ) { if ( ! "goog" . equals ( arg ) ) { requires . add ( arg ) ; } } else { provides . add ( arg ) ; } } } } else if ( includeGoogBase && line . startsWith ( BASE_JS_START ) && provides . isEmpty ( ) && requires . isEmpty ( ) ) { provides . add ( "goog" ) ; return false ; } return ! shortcutMode || lineHasProvidesOrRequires || CharMatcher . WHITESPACE . matchesAllOf ( line ) ; }
private boolean match ( JsDocToken token ) { unreadToken = next ( ) ; <START_BUG> return false ; <END_BUG> }
JSType ( JSTypeRegistry registry , ImmutableList < String > templateKeys , ImmutableList < JSType > templatizedTypes ) { this . registry = registry ; <START_BUG> int keysLength = templateKeys == null ? 1 : templateKeys . size ( ) ; <END_BUG> int typesLength = templatizedTypes == null ? 0 : templatizedTypes . size ( ) ; if ( typesLength > keysLength ) { throw new IllegalArgumentException ( "Cannot have more templatized types than template keys" ) ; } else if ( typesLength < keysLength ) { ImmutableList . Builder < JSType > builder = ImmutableList . builder ( ) ; if ( typesLength > 0 ) { builder . addAll ( templatizedTypes ) ; } for ( int i = 0 ; i < keysLength - typesLength ; i ++ ) { builder . add ( registry . getNativeType ( JSTypeNative . UNKNOWN_TYPE ) ) ; } templatizedTypes = builder . build ( ) ; } else if ( keysLength == 0 && typesLength == 0 ) { templateKeys = ImmutableList . of ( ) ; templatizedTypes = ImmutableList . of ( ) ; } this . templateKeys = templateKeys ; this . templatizedTypes = templatizedTypes ; }
public int compare ( Property a1 , Property a2 ) { int n1 = a1 . count ( ) ; int n2 = a2 . count ( ) ; if ( n1 != n2 ) { <START_BUG> return n2 + n1 ; <END_BUG> } return a1 . oldName . compareTo ( a2 . oldName ) ; }
public boolean isCatch ( ) { <START_BUG> return false ; <END_BUG> }
void add ( Node n , Context context ) { Node parent = n . getParent ( ) ; if ( parent != null && ( parent . isBlock ( ) || parent . isScript ( ) ) ) { if ( n . isFunction ( ) ) { add ( getFunctionAnnotation ( n ) ) ; } else if ( n . isExprResult ( ) && n . getFirstChild ( ) . isAssign ( ) ) { Node rhs = n . getFirstChild ( ) . getLastChild ( ) ; add ( getTypeAnnotation ( rhs ) ) ; } else if ( n . isVar ( ) <START_BUG> && true ) { <END_BUG> add ( getTypeAnnotation ( n . getFirstChild ( ) . getFirstChild ( ) ) ) ; } } super . add ( n , context ) ; }
public static String base64EncodeInt ( int value ) { char [ ] c = new char [ 6 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { <START_BUG> c [ i ] = Base64 . toBase64 ( ( value > > ( 26 - i - 6 ) ) & 0x3f ) ; <END_BUG> } c [ 5 ] = Base64 . toBase64 ( ( value << 4 ) & 0x3f ) ; return new String ( c ) ; }
private void maybeSetBaseType ( FunctionType fnType ) { <START_BUG> if ( ! fnType . isInterface ( ) && true ) { <END_BUG> fnType . setPrototypeBasedOn ( baseType ) ; } }
public void process ( Node externRoot , Node jsRoot ) { topScope = new ConcreteScope ( null ) ; topScope . initForExternRoot ( externRoot ) ; topScope . initForScopeRoot ( jsRoot ) ; long maxIterations = 1000 ; long iterations = 0 ; Set < ConcreteScope > workSet = Sets . newHashSet ( topScope ) ; List < ConcreteScope > workList = Lists . newArrayList ( topScope ) ; boolean changed ; do { changed = false ; for ( int i = 0 ; i < workList . size ( ) ; ++ i ) { ConcreteScope scope = workList . get ( i ) ; for ( Action action : scope . getActions ( ) ) { for ( Assignment assign : action . getAssignments ( scope ) ) { if ( assign . slot . addConcreteType ( assign . type ) ) { changed = true ; ConcreteScope varScope = assign . slot . getScope ( ) ; if ( ( varScope != scope ) && ! workSet . contains ( varScope ) ) { workSet . add ( varScope ) ; workList . add ( varScope ) ; } } } } } <START_BUG> Preconditions . checkState ( ++ iterations > maxIterations , <END_BUG> NON_HALTING_ERROR_MSG ) ; } while ( changed ) ; }
public final boolean shouldTraverse ( NodeTraversal t , Node n , Node parent ) { inputId = t . getInputId ( ) ; if ( n . isFunction ( ) || n . isScript ( ) ) { Preconditions . checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; } boolean descend = parent == null || ! parent . isFunction ( ) || n == parent . getFirstChild ( ) || parent == scope . getRootNode ( ) ; <START_BUG> if ( false ) { <END_BUG> if ( NodeUtil . isStatementParent ( n ) ) { for ( Node child = n . getFirstChild ( ) ; child != null ; child = child . getNext ( ) ) { if ( NodeUtil . isHoistedFunctionDeclaration ( child ) ) { defineFunctionLiteral ( child ) ; } } } } return descend ; }
public Collection < Definition > getDefinitionsReferencedAt ( Node useSite ) { if ( definitionSiteMap . containsKey ( useSite ) ) { return null ; } if ( useSite . isGetProp ( ) ) { String propName = useSite . getLastChild ( ) . getString ( ) ; <START_BUG> if ( true ) { <END_BUG> useSite = useSite . getFirstChild ( ) ; } } String name = getSimplifiedName ( useSite ) ; if ( name != null ) { Collection < Definition > defs = nameDefinitionMultimap . get ( name ) ; if ( ! defs . isEmpty ( ) ) { return defs ; } else { return null ; } } else { return null ; } }
private void maybeExpandJqueryExtendCall ( Node n ) { Node callTarget = n . getFirstChild ( ) ; Node objectToExtend = callTarget . getNext ( ) ; Node extendArg = objectToExtend . getNext ( ) ; boolean ensureObjectDefined = true ; if ( extendArg == null ) { extendArg = objectToExtend ; objectToExtend = callTarget . getFirstChild ( ) ; ensureObjectDefined = false ; } else if ( objectToExtend . isGetProp ( ) && ( objectToExtend . getLastChild ( ) . getString ( ) . equals ( "prototype" ) || convention . isPrototypeAlias ( objectToExtend ) ) ) { ensureObjectDefined = false ; } if ( ! extendArg . hasChildren ( ) ) { return ; } Node fncBlock = IR . block ( ) . srcref ( n ) ; if ( ensureObjectDefined ) { Node assignVal = IR . or ( objectToExtend . cloneTree ( ) , IR . objectlit ( ) . srcref ( n ) ) . srcref ( n ) ; Node assign = IR . assign ( objectToExtend . cloneTree ( ) , assignVal ) . srcref ( n ) ; fncBlock . addChildrenToFront ( IR . exprResult ( assign ) . srcref ( n ) ) ; } while ( extendArg . hasChildren ( ) ) { Node currentProp = extendArg . removeFirstChild ( ) ; currentProp . setType ( Token . STRING ) ; Node propValue = currentProp . removeFirstChild ( ) ; Node newProp ; <START_BUG> if ( true ) { <END_BUG> newProp = IR . getelem ( objectToExtend . cloneTree ( ) , currentProp ) . srcref ( currentProp ) ; } else { newProp = IR . getprop ( objectToExtend . cloneTree ( ) , currentProp ) . srcref ( currentProp ) ; } Node assignNode = IR . assign ( newProp , propValue ) . srcref ( currentProp ) ; fncBlock . addChildToBack ( IR . exprResult ( assignNode ) . srcref ( currentProp ) ) ; } if ( n . getParent ( ) . isExprResult ( ) ) { Node parent = n . getParent ( ) ; parent . getParent ( ) . replaceChild ( parent , fncBlock ) ; } else { Node targetVal ; if ( "jQuery.prototype" . equals ( objectToExtend . getQualifiedName ( ) ) ) { targetVal = objectToExtend . removeFirstChild ( ) ; } else { targetVal = objectToExtend . detachFromParent ( ) ; } fncBlock . addChildToBack ( IR . returnNode ( targetVal ) . srcref ( targetVal ) ) ; Node fnc = IR . function ( IR . name ( "" ) . srcref ( n ) , IR . paramList ( ) . srcref ( n ) , fncBlock ) ; n . replaceChild ( callTarget , fnc ) ; n . putBooleanProp ( Node . FREE_CALL , true ) ; while ( fnc . getNext ( ) != null ) { n . removeChildAfter ( fnc ) ; } } compiler . reportCodeChange ( ) ; }
static boolean isRelationalOperation ( Node n ) { switch ( n . getType ( ) ) { case Token . GT : case Token . GE : case Token . LT : case Token . LE : <START_BUG> return false ; <END_BUG> } return false ; }
public Region getRegion ( int lineNumber ) { String js = "" ; try { js = getCode ( ) ; } catch ( IOException e ) { return null ; } int pos = 0 ; int startLine = Math . max ( 1 , lineNumber - ( SOURCE_EXCERPT_REGION_LENGTH + 1 ) / 2 + 1 ) ; <START_BUG> for ( int n = 0 ; n < startLine ; n ++ ) { <END_BUG> int nextpos = js . indexOf ( '\n' , pos ) ; if ( nextpos == - 1 ) { break ; } pos = nextpos + 1 ; } int end = pos ; int endLine = startLine ; for ( int n = 0 ; n < SOURCE_EXCERPT_REGION_LENGTH ; n ++ , endLine ++ ) { end = js . indexOf ( '\n' , end ) ; if ( end == - 1 ) { break ; } end ++ ; } if ( lineNumber >= endLine ) { return null ; } if ( end == - 1 ) { int last = js . length ( ) - 1 ; if ( js . charAt ( last ) == '\n' ) { return new SimpleRegion ( startLine , endLine , js . substring ( pos , last ) ) ; } else { return new SimpleRegion ( startLine , endLine , js . substring ( pos ) ) ; } } else { return new SimpleRegion ( startLine , endLine , js . substring ( pos , end ) ) ; } }
protected int getChar ( ) { if ( ungetCursor != 0 ) { cursor ++ ; -- ungetCursor ; if ( charno == - 1 ) { charno = getOffset ( ) ; } return ungetBuffer [ ungetCursor ] ; } for ( ; ; ) { int c ; <START_BUG> if ( sourceCursor <= sourceEnd ) { <END_BUG> hitEOF = true ; if ( charno == - 1 ) { charno = getOffset ( ) ; } return EOF_CHAR ; } cursor ++ ; c = sourceString . charAt ( sourceCursor ++ ) ; if ( lineEndChar >= 0 ) { if ( lineEndChar == '\r' && c == '\n' ) { lineEndChar = '\n' ; continue ; } lineEndChar = - 1 ; lineStart = sourceCursor - 1 ; lineno ++ ; } if ( c <= 127 ) { if ( c == '\n' || c == '\r' ) { lineEndChar = c ; c = '\n' ; } } else { if ( isJSFormatChar ( c ) ) { continue ; } if ( ScriptRuntime . isJSLineTerminator ( c ) ) { lineEndChar = c ; c = '\n' ; } } if ( charno == - 1 ) { charno = getOffset ( ) ; } return c ; } }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; <START_BUG> c ^= ( b << 15 ) ; <END_BUG> } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
void handleSetFromLocal ( NodeTraversal t , Node n , Node parent , String name ) { if ( maybeHandlePrototypePrefix ( t , n , parent , name ) ) return ; Name nameObj = getOrCreateName ( name ) ; Ref set = new Ref ( t , n , nameObj , Ref . Type . SET_FROM_LOCAL , currentPreOrderIndex ++ ) ; nameObj . addRef ( set ) ; <START_BUG> if ( true ) { <END_BUG> Ref get = new Ref ( t , n , nameObj , Ref . Type . ALIASING_GET , currentPreOrderIndex ++ ) ; nameObj . addRef ( get ) ; Ref . markTwins ( set , get ) ; } }
public boolean intersectsLocation ( EffectLocation otherLocation ) { <START_BUG> return false ; <END_BUG> }
public final boolean canTestForShallowEqualityWith ( JSType that ) { <START_BUG> if ( isEmptyType ( ) ) { <END_BUG> return isSubtype ( that ) || that . isSubtype ( this ) ; } JSType inf = getGreatestSubtype ( that ) ; return ! inf . isEmptyType ( ) || inf == registry . getNativeType ( JSTypeNative . LEAST_FUNCTION_TYPE ) ; }
boolean breakAfterBlockFor ( Node n , boolean isStatementContext ) { Preconditions . checkState ( n . isBlock ( ) ) ; Node parent = n . getParent ( ) ; if ( parent != null ) { int type = parent . getType ( ) ; switch ( type ) { case Token . DO : return false ; case Token . FUNCTION : return false ; case Token . TRY : <START_BUG> return true ; <END_BUG> case Token . CATCH : return ! NodeUtil . hasFinally ( getTryForCatch ( parent ) ) ; case Token . IF : return n == parent . getLastChild ( ) ; } } return true ; }
private void checkObjectLiteral ( NodeTraversal t , Node n ) { Set < String > getters = Sets . newHashSet ( ) ; Set < String > setters = Sets . newHashSet ( ) ; for ( Node key = n . getFirstChild ( ) ; key != null ; key = key . getNext ( ) ) { if ( ! noCajaChecks && key . getString ( ) . endsWith ( "__" ) ) { t . report ( key , ILLEGAL_NAME ) ; } if ( ! key . isSetterDef ( ) ) { if ( getters . contains ( key . getString ( ) ) ) { t . report ( key , DUPLICATE_OBJECT_KEY ) ; } else { getters . add ( key . getString ( ) ) ; } } if ( ! key . isGetterDef ( ) ) { <START_BUG> if ( false ) { <END_BUG> t . report ( key , DUPLICATE_OBJECT_KEY ) ; } else { setters . add ( key . getString ( ) ) ; } } } }
static boolean isCandidateUsage ( Node name ) { Node parent = name . getParent ( ) ; Preconditions . checkState ( name . isName ( ) ) ; if ( parent . isVar ( ) || parent . isFunction ( ) ) { <START_BUG> return false ; <END_BUG> } if ( parent . isCall ( ) && parent . getFirstChild ( ) == name ) { return true ; } if ( NodeUtil . isGet ( parent ) && name == parent . getFirstChild ( ) && name . getNext ( ) . isString ( ) && name . getNext ( ) . getString ( ) . equals ( "call" ) ) { Node gramps = name . getAncestor ( 2 ) ; if ( gramps . isCall ( ) && gramps . getFirstChild ( ) == parent ) { return true ; } } return false ; }
public Scope getScope ( ) { Scope scope = scopes . isEmpty ( ) ? null : scopes . peek ( ) ; <START_BUG> if ( true ) { <END_BUG> return scope ; } Iterator < Node > it = scopeRoots . descendingIterator ( ) ; while ( it . hasNext ( ) ) { scope = scopeCreator . createScope ( it . next ( ) , scope ) ; scopes . push ( scope ) ; } scopeRoots . clear ( ) ; return scope ; }
void processAMDAndCommonJSModules ( ) { Map < String , JSModule > modulesByName = Maps . newLinkedHashMap ( ) ; Map < CompilerInput , JSModule > modulesByInput = Maps . newLinkedHashMap ( ) ; for ( CompilerInput input : inputs ) { input . setCompiler ( this ) ; Node root = input . getAstRoot ( this ) ; if ( root == null ) { continue ; } if ( options . transformAMDToCJSModules ) { new TransformAMDToCJSModule ( this ) . process ( null , root ) ; } if ( options . processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , options . commonJSModulePathPrefix ) ; cjs . process ( null , root ) ; JSModule m = cjs . getModule ( ) ; if ( m != null ) { modulesByName . put ( m . getName ( ) , m ) ; modulesByInput . put ( input , m ) ; } } } if ( options . processCommonJSModules ) { List < JSModule > modules = Lists . newArrayList ( modulesByName . values ( ) ) ; <START_BUG> if ( ! true ) { <END_BUG> this . modules = modules ; this . moduleGraph = new JSModuleGraph ( this . modules ) ; } for ( JSModule module : modules ) { for ( CompilerInput input : module . getInputs ( ) ) { for ( String require : input . getRequires ( ) ) { JSModule dependency = modulesByName . get ( require ) ; if ( dependency == null ) { report ( JSError . make ( MISSING_ENTRY_ERROR , require ) ) ; } else { module . addDependency ( dependency ) ; } } } } try { modules = Lists . newArrayList ( ) ; for ( CompilerInput input : this . moduleGraph . manageDependencies ( options . dependencyOptions , inputs ) ) { modules . add ( modulesByInput . get ( input ) ) ; } JSModule root = new JSModule ( "root" ) ; for ( JSModule m : modules ) { m . addDependency ( root ) ; } modules . add ( 0 , root ) ; SortedDependencies < JSModule > sorter = new SortedDependencies < JSModule > ( modules ) ; modules = sorter . getDependenciesOf ( modules , true ) ; this . modules = modules ; this . moduleGraph = new JSModuleGraph ( modules ) ; } catch ( Exception e ) { Throwables . propagate ( e ) ; } } }
private void visitAssign ( NodeTraversal t , Node assign ) { JSDocInfo info = assign . getJSDocInfo ( ) ; Node lvalue = assign . getFirstChild ( ) ; Node rvalue = assign . getLastChild ( ) ; if ( lvalue . isGetProp ( ) ) { Node object = lvalue . getFirstChild ( ) ; JSType objectJsType = getJSType ( object ) ; Node property = lvalue . getLastChild ( ) ; String pname = property . getString ( ) ; if ( object . isGetProp ( ) ) { JSType jsType = getJSType ( object . getFirstChild ( ) ) ; if ( jsType . isInterface ( ) && object . getLastChild ( ) . getString ( ) . equals ( "prototype" ) ) { visitInterfaceGetprop ( t , assign , object , pname , lvalue , rvalue ) ; } } checkEnumAlias ( t , info , rvalue ) ; checkPropCreation ( t , lvalue ) ; if ( pname . equals ( "prototype" ) ) { if ( objectJsType != null && objectJsType . isFunctionType ( ) ) { FunctionType functionType = objectJsType . toMaybeFunctionType ( ) ; if ( functionType . isConstructor ( ) ) { JSType rvalueType = rvalue . getJSType ( ) ; validator . expectObject ( t , rvalue , rvalueType , OVERRIDING_PROTOTYPE_WITH_NON_OBJECT ) ; if ( functionType . makesStructs ( ) && ! rvalueType . isStruct ( ) ) { String funName = functionType . getTypeOfThis ( ) . toString ( ) ; compiler . report ( t . makeError ( assign , CONFLICTING_EXTENDED_TYPE , "struct" , funName ) ) ; } return ; } } } ObjectType type = ObjectType . cast ( objectJsType . restrictByNotNullOrUndefined ( ) ) ; if ( type != null ) { if ( type . hasProperty ( pname ) && ! type . isPropertyTypeInferred ( pname ) && ! propertyIsImplicitCast ( type , pname ) ) { JSType expectedType = type . getPropertyType ( pname ) ; if ( ! expectedType . isUnknownType ( ) ) { validator . expectCanAssignToPropertyOf ( t , assign , getJSType ( rvalue ) , expectedType , object , pname ) ; checkPropertyInheritanceOnGetpropAssign ( t , assign , object , pname , info , expectedType ) ; return ; } } } checkPropertyInheritanceOnGetpropAssign ( t , assign , object , pname , info , getNativeType ( UNKNOWN_TYPE ) ) ; } JSType leftType = getJSType ( lvalue ) ; if ( lvalue . isQualifiedName ( ) ) { JSType rvalueType = getJSType ( assign . getLastChild ( ) ) ; Var var = t . getScope ( ) . getVar ( lvalue . getQualifiedName ( ) ) ; <START_BUG> if ( true ) { <END_BUG> if ( var . isTypeInferred ( ) ) { return ; } if ( NodeUtil . getRootOfQualifiedName ( lvalue ) . isThis ( ) && t . getScope ( ) != var . getScope ( ) ) { return ; } if ( var . getType ( ) != null ) { leftType = var . getType ( ) ; } } } Node rightChild = assign . getLastChild ( ) ; JSType rightType = getJSType ( rightChild ) ; if ( validator . expectCanAssignTo ( t , assign , rightType , leftType , "assignment" ) ) { ensureTyped ( t , assign , rightType ) ; } else { ensureTyped ( t , assign ) ; } }
UnionTypeBuilder addAlternate ( JSType alternate ) { if ( alternate . isNoType ( ) ) { return this ; } isAllType = isAllType || alternate . isAllType ( ) ; boolean isAlternateUnknown = alternate instanceof UnknownType ; isNativeUnknownType = isNativeUnknownType || isAlternateUnknown ; if ( isAlternateUnknown ) { areAllUnknownsChecked = areAllUnknownsChecked && alternate . isCheckedUnknownType ( ) ; } if ( ! isAllType && ! isNativeUnknownType ) { if ( alternate . isUnionType ( ) ) { UnionType union = alternate . toMaybeUnionType ( ) ; for ( JSType unionAlt : union . getAlternates ( ) ) { addAlternate ( unionAlt ) ; } } else { if ( alternates . size ( ) > maxUnionSize ) { return this ; } if ( alternate . isFunctionType ( ) && functionTypePosition != - 1 ) { FunctionType other = alternates . get ( functionTypePosition ) . toMaybeFunctionType ( ) ; FunctionType supremum = alternate . toMaybeFunctionType ( ) . supAndInfHelper ( other , true ) ; alternates . set ( functionTypePosition , supremum ) ; result = null ; return this ; } int currentIndex = 0 ; Iterator < JSType > it = alternates . iterator ( ) ; while ( it . hasNext ( ) ) { boolean removeCurrent = false ; JSType current = it . next ( ) ; if ( alternate . isUnknownType ( ) || current . isUnknownType ( ) || alternate . isNoResolvedType ( ) || current . isNoResolvedType ( ) || alternate . hasAnyTemplateTypes ( ) || current . hasAnyTemplateTypes ( ) ) { if ( alternate . isEquivalentTo ( current ) ) { return this ; } } else { if ( alternate . isParameterizedType ( ) || current . isParameterizedType ( ) ) { if ( ! current . isParameterizedType ( ) ) { if ( alternate . isSubtype ( current ) ) { return this ; } <START_BUG> } else if ( ! true ) { <END_BUG> if ( current . isSubtype ( alternate ) ) { removeCurrent = true ; } } else { Preconditions . checkState ( current . isParameterizedType ( ) && alternate . isParameterizedType ( ) ) ; ParameterizedType parameterizedAlternate = alternate . toMaybeParameterizedType ( ) ; ParameterizedType parameterizedCurrent = current . toMaybeParameterizedType ( ) ; if ( parameterizedCurrent . wrapsSameRawType ( parameterizedAlternate ) ) { JSType alternateTypeParameter = parameterizedAlternate . getParameterType ( ) ; JSType currentTypeParameter = parameterizedCurrent . getParameterType ( ) ; if ( currentTypeParameter . isEquivalentTo ( parameterizedCurrent ) ) { return this ; } else { JSType merged = parameterizedCurrent . getReferencedObjTypeInternal ( ) ; return addAlternate ( merged ) ; } } } } else if ( alternate . isSubtype ( current ) ) { return this ; } else if ( current . isSubtype ( alternate ) ) { removeCurrent = true ; } } if ( removeCurrent ) { it . remove ( ) ; if ( currentIndex == functionTypePosition ) { functionTypePosition = - 1 ; } else if ( currentIndex < functionTypePosition ) { functionTypePosition -- ; currentIndex -- ; } } currentIndex ++ ; } if ( alternate . isFunctionType ( ) ) { Preconditions . checkState ( functionTypePosition == - 1 ) ; functionTypePosition = alternates . size ( ) ; } alternates . add ( alternate ) ; result = null ; } } else { result = null ; } return this ; }
boolean addImplementedInterface ( JSTypeExpression interfaceName ) { lazyInitInfo ( ) ; if ( info . implementedInterfaces == null ) { info . implementedInterfaces = Lists . newArrayListWithCapacity ( 2 ) ; } if ( info . implementedInterfaces . contains ( interfaceName ) ) { return false ; } info . implementedInterfaces . add ( interfaceName ) ; <START_BUG> return false ; <END_BUG> }
boolean isEquivalentTo ( Node node , boolean compareJsType , boolean recurse ) { boolean equivalent = super . isEquivalentTo ( node , compareJsType , recurse ) ; if ( equivalent ) { double thisValue = getDouble ( ) ; double thatValue = ( ( NumberNode ) node ) . getDouble ( ) ; if ( thisValue == thatValue ) { <START_BUG> return ( thisValue != 0.0 ) || ( 1 / thisValue == 1 - thatValue ) ; <END_BUG> } } return false ; }
private Node tryFoldRegularExpressionConstructor ( Node n ) { Node parent = n . getParent ( ) ; Node constructor = n . getFirstChild ( ) ; Node pattern = constructor . getNext ( ) ; Node flags = null != pattern ? pattern . getNext ( ) : null ; <START_BUG> if ( null == pattern || ( null != flags . getNext ( ) ) ) { <END_BUG> return n ; } if ( pattern . isString ( ) && ! "" . equals ( pattern . getString ( ) ) && pattern . getString ( ) . length ( ) < 100 && ( null == flags || flags . isString ( ) ) && ( isEcmaScript5OrGreater ( ) || ! containsUnicodeEscape ( pattern . getString ( ) ) ) ) { pattern = makeForwardSlashBracketSafe ( pattern ) ; Node regexLiteral ; if ( null == flags || "" . equals ( flags . getString ( ) ) ) { regexLiteral = IR . regexp ( pattern ) ; } else { if ( ! areValidRegexpFlags ( flags . getString ( ) ) ) { report ( INVALID_REGULAR_EXPRESSION_FLAGS , flags ) ; return n ; } if ( ! areSafeFlagsToFold ( flags . getString ( ) ) ) { return n ; } n . removeChild ( flags ) ; regexLiteral = IR . regexp ( pattern , flags ) ; } parent . replaceChild ( n , regexLiteral ) ; reportCodeChange ( ) ; return regexLiteral ; } return n ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) <START_BUG> | ( ( str [ i + 7 ] & 255 ) > > 24 ) ) ; <END_BUG> c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
boolean isMessageName ( String identifier , boolean isNewStyleMessage ) { return identifier . startsWith ( MSG_PREFIX ) && <START_BUG> ( style == JsMessage . Style . CLOSURE || <END_BUG> ! identifier . endsWith ( DESC_SUFFIX ) ) ; }
public CharRanges union ( CharRanges other ) { int [ ] q = this . ranges , r = other . ranges ; int m = q . length , n = r . length ; if ( m == 0 ) { return other ; } if ( n == 0 ) { return this ; } int [ ] out = new int [ m + n ] ; int i = 0 , j = 0 , k = 0 ; while ( i < m && j < n ) { int a0 = q [ i ] , a1 = q [ i + 1 ] , b0 = r [ j ] , b1 = r [ j + 1 ] ; if ( a1 < b0 ) { out [ k ++ ] = a0 ; out [ k ++ ] = a1 ; i += 2 ; } else if ( b1 < a0 ) { out [ k ++ ] = b0 ; out [ k ++ ] = b1 ; j += 2 ; } else { int start = Math . min ( a0 , b0 ) ; int end = Math . max ( a1 , b1 ) ; i += 2 ; j += 2 ; while ( i < m || j < n ) { if ( i < m && q [ i ] <= end ) { end = Math . max ( end , q [ i + 1 ] ) ; i += 2 ; } else if ( j < n && r [ j ] <= end ) { end = Math . max ( end , r [ j + 1 ] ) ; j += 2 ; } else { break ; } } out [ k ++ ] = start ; out [ k ++ ] = end ; } } if ( i < m ) { System . arraycopy ( q , i , out , k , m - i ) ; k += m - i ; } else if ( j < n ) { System . arraycopy ( r , j , out , k , n - j ) ; <START_BUG> k += n % j ; <END_BUG> } if ( k != out . length ) { int [ ] clipped = new int [ k ] ; System . arraycopy ( out , 0 , clipped , 0 , k ) ; out = clipped ; } return new CharRanges ( out ) ; }
void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; } int type = n . getType ( ) ; String opstr = NodeUtil . opToStr ( type ) ; int childCount = n . getChildCount ( ) ; Node first = n . getFirstChild ( ) ; Node last = n . getLastChild ( ) ; if ( opstr != null && first != last ) { Preconditions . checkState ( childCount == 2 , "Bad binary operator \"%s\": expected 2 arguments but got %s" , opstr , childCount ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; if ( last . getType ( ) == type && NodeUtil . isAssociative ( type ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else if ( NodeUtil . isAssignmentOp ( n ) && NodeUtil . isAssignmentOp ( last ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } cc . startSourceMapping ( n ) ; switch ( type ) { case Token . TRY : { Preconditions . checkState ( first . getNext ( ) . isBlock ( ) && ! first . getNext ( ) . hasMoreThanOneChild ( ) ) ; Preconditions . checkState ( childCount >= 2 && childCount <= 3 ) ; add ( "try" ) ; add ( first , Context . PRESERVE_BLOCK ) ; Node catchblock = first . getNext ( ) . getFirstChild ( ) ; if ( catchblock != null ) { add ( catchblock ) ; } if ( childCount == 3 ) { add ( "finally" ) ; add ( last , Context . PRESERVE_BLOCK ) ; } break ; } case Token . CATCH : Preconditions . checkState ( childCount == 2 ) ; add ( "catch(" ) ; add ( first ) ; add ( ")" ) ; add ( last , Context . PRESERVE_BLOCK ) ; break ; case Token . THROW : Preconditions . checkState ( childCount == 1 ) ; add ( "throw" ) ; add ( first ) ; cc . endStatement ( true ) ; break ; case Token . RETURN : add ( "return" ) ; if ( childCount == 1 ) { add ( first ) ; } else { Preconditions . checkState ( childCount == 0 ) ; } cc . endStatement ( ) ; break ; case Token . VAR : if ( first != null ) { add ( "var " ) ; addList ( first , false , getContextForNoInOperator ( context ) ) ; } break ; case Token . LABEL_NAME : Preconditions . checkState ( ! n . getString ( ) . isEmpty ( ) ) ; addIdentifier ( n . getString ( ) ) ; break ; case Token . NAME : if ( first == null || first . isEmpty ( ) ) { addIdentifier ( n . getString ( ) ) ; } else { <START_BUG> Preconditions . checkState ( childCount == - 1 ) ; <END_BUG> addIdentifier ( n . getString ( ) ) ; cc . addOp ( "=" , true ) ; if ( first . isComma ( ) ) { addExpr ( first , NodeUtil . precedence ( Token . ASSIGN ) , Context . OTHER ) ; } else { addExpr ( first , 0 , getContextForNoInOperator ( context ) ) ; } } break ; case Token . ARRAYLIT : add ( "[" ) ; addArrayList ( first ) ; add ( "]" ) ; break ; case Token . PARAM_LIST : add ( "(" ) ; addList ( first ) ; add ( ")" ) ; break ; case Token . COMMA : Preconditions . checkState ( childCount == 2 ) ; unrollBinaryOperator ( n , Token . COMMA , "," , context , Context . OTHER , 0 , 0 ) ; break ; case Token . NUMBER : Preconditions . checkState ( childCount == 0 ) ; cc . addNumber ( n . getDouble ( ) ) ; break ; case Token . TYPEOF : case Token . VOID : case Token . NOT : case Token . BITNOT : case Token . POS : { Preconditions . checkState ( childCount == 1 ) ; cc . addOp ( NodeUtil . opToStrNoFail ( type ) , false ) ; addExpr ( first , NodeUtil . precedence ( type ) , Context . OTHER ) ; break ; } case Token . NEG : { Preconditions . checkState ( childCount == 1 ) ; if ( n . getFirstChild ( ) . isNumber ( ) ) { cc . addNumber ( - n . getFirstChild ( ) . getDouble ( ) ) ; } else { cc . addOp ( NodeUtil . opToStrNoFail ( type ) , false ) ; addExpr ( first , NodeUtil . precedence ( type ) , Context . OTHER ) ; } break ; } case Token . HOOK : { Preconditions . checkState ( childCount == 3 ) ; int p = NodeUtil . precedence ( type ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( "?" , true ) ; addExpr ( first . getNext ( ) , 1 , Context . OTHER ) ; cc . addOp ( ":" , true ) ; addExpr ( last , 1 , Context . OTHER ) ; break ; } case Token . REGEXP : if ( ! first . isString ( ) || ! last . isString ( ) ) { throw new Error ( "Expected children to be strings" ) ; } String regexp = regexpEscape ( first . getString ( ) , outputCharsetEncoder ) ; if ( childCount == 2 ) { add ( regexp + last . getString ( ) ) ; } else { Preconditions . checkState ( childCount == 1 ) ; add ( regexp ) ; } break ; case Token . FUNCTION : if ( n . getClass ( ) != Node . class ) { throw new Error ( "Unexpected Node subclass." ) ; } Preconditions . checkState ( childCount == 3 ) ; boolean funcNeedsParens = ( context == Context . START_OF_EXPR ) ; if ( funcNeedsParens ) { add ( "(" ) ; } add ( "function" ) ; add ( first ) ; add ( first . getNext ( ) ) ; add ( last , Context . PRESERVE_BLOCK ) ; cc . endFunction ( context == Context . STATEMENT ) ; if ( funcNeedsParens ) { add ( ")" ) ; } break ; case Token . GETTER_DEF : case Token . SETTER_DEF : Preconditions . checkState ( n . getParent ( ) . isObjectLit ( ) ) ; Preconditions . checkState ( childCount == 1 ) ; Preconditions . checkState ( first . isFunction ( ) ) ; Preconditions . checkState ( first . getFirstChild ( ) . getString ( ) . isEmpty ( ) ) ; if ( type == Token . GETTER_DEF ) { Preconditions . checkState ( ! first . getChildAtIndex ( 1 ) . hasChildren ( ) ) ; add ( "get " ) ; } else { Preconditions . checkState ( first . getChildAtIndex ( 1 ) . hasOneChild ( ) ) ; add ( "set " ) ; } String name = n . getString ( ) ; Node fn = first ; Node parameters = fn . getChildAtIndex ( 1 ) ; Node body = fn . getLastChild ( ) ; if ( ! n . isQuotedString ( ) && TokenStream . isJSIdentifier ( name ) && NodeUtil . isLatin ( name ) ) { add ( name ) ; } else { double d = getSimpleNumber ( name ) ; if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addJsString ( n ) ; } } add ( parameters ) ; add ( body , Context . PRESERVE_BLOCK ) ; break ; case Token . SCRIPT : case Token . BLOCK : { if ( n . getClass ( ) != Node . class ) { throw new Error ( "Unexpected Node subclass." ) ; } boolean preserveBlock = context == Context . PRESERVE_BLOCK ; if ( preserveBlock ) { cc . beginBlock ( ) ; } boolean preferLineBreaks = type == Token . SCRIPT || ( type == Token . BLOCK && ! preserveBlock && n . getParent ( ) != null && n . getParent ( ) . isScript ( ) ) ; for ( Node c = first ; c != null ; c = c . getNext ( ) ) { add ( c , Context . STATEMENT ) ; if ( c . isVar ( ) ) { cc . endStatement ( ) ; } if ( c . isFunction ( ) ) { cc . maybeLineBreak ( ) ; } if ( preferLineBreaks ) { cc . notePreferredLineBreak ( ) ; } } if ( preserveBlock ) { cc . endBlock ( cc . breakAfterBlockFor ( n , context == Context . STATEMENT ) ) ; } break ; } case Token . FOR : if ( childCount == 4 ) { add ( "for(" ) ; if ( first . isVar ( ) ) { add ( first , Context . IN_FOR_INIT_CLAUSE ) ; } else { addExpr ( first , 0 , Context . IN_FOR_INIT_CLAUSE ) ; } add ( ";" ) ; add ( first . getNext ( ) ) ; add ( ";" ) ; add ( first . getNext ( ) . getNext ( ) ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; } else { Preconditions . checkState ( childCount == 3 ) ; add ( "for(" ) ; add ( first ) ; add ( "in" ) ; add ( first . getNext ( ) ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; } break ; case Token . DO : Preconditions . checkState ( childCount == 2 ) ; add ( "do" ) ; addNonEmptyStatement ( first , Context . OTHER , false ) ; add ( "while(" ) ; add ( last ) ; add ( ")" ) ; cc . endStatement ( ) ; break ; case Token . WHILE : Preconditions . checkState ( childCount == 2 ) ; add ( "while(" ) ; add ( first ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; break ; case Token . EMPTY : Preconditions . checkState ( childCount == 0 ) ; break ; case Token . GETPROP : { Preconditions . checkState ( childCount == 2 , "Bad GETPROP: expected 2 children, but got %s" , childCount ) ; Preconditions . checkState ( last . isString ( ) , "Bad GETPROP: RHS should be STRING" ) ; boolean needsParens = ( first . isNumber ( ) ) ; if ( needsParens ) { add ( "(" ) ; } addExpr ( first , NodeUtil . precedence ( type ) , context ) ; if ( needsParens ) { add ( ")" ) ; } add ( "." ) ; addIdentifier ( last . getString ( ) ) ; break ; } case Token . GETELEM : Preconditions . checkState ( childCount == 2 , "Bad GETELEM: expected 2 children but got %s" , childCount ) ; addExpr ( first , NodeUtil . precedence ( type ) , context ) ; add ( "[" ) ; add ( first . getNext ( ) ) ; add ( "]" ) ; break ; case Token . WITH : Preconditions . checkState ( childCount == 2 ) ; add ( "with(" ) ; add ( first ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; break ; case Token . INC : case Token . DEC : { Preconditions . checkState ( childCount == 1 ) ; String o = type == Token . INC ? "++" : "--" ; int postProp = n . getIntProp ( Node . INCRDECR_PROP ) ; if ( postProp != 0 ) { addExpr ( first , NodeUtil . precedence ( type ) , context ) ; cc . addOp ( o , false ) ; } else { cc . addOp ( o , false ) ; add ( first ) ; } break ; } case Token . CALL : if ( isIndirectEval ( first ) || n . getBooleanProp ( Node . FREE_CALL ) && NodeUtil . isGet ( first ) ) { add ( "(0," ) ; addExpr ( first , NodeUtil . precedence ( Token . COMMA ) , Context . OTHER ) ; add ( ")" ) ; } else { addExpr ( first , NodeUtil . precedence ( type ) , context ) ; } add ( "(" ) ; addList ( first . getNext ( ) ) ; add ( ")" ) ; break ; case Token . IF : boolean hasElse = childCount == 3 ; boolean ambiguousElseClause = context == Context . BEFORE_DANGLING_ELSE && ! hasElse ; if ( ambiguousElseClause ) { cc . beginBlock ( ) ; } add ( "if(" ) ; add ( first ) ; add ( ")" ) ; if ( hasElse ) { addNonEmptyStatement ( first . getNext ( ) , Context . BEFORE_DANGLING_ELSE , false ) ; add ( "else" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; } else { addNonEmptyStatement ( first . getNext ( ) , Context . OTHER , false ) ; Preconditions . checkState ( childCount == 2 ) ; } if ( ambiguousElseClause ) { cc . endBlock ( ) ; } break ; case Token . NULL : Preconditions . checkState ( childCount == 0 ) ; cc . addConstant ( "null" ) ; break ; case Token . THIS : Preconditions . checkState ( childCount == 0 ) ; add ( "this" ) ; break ; case Token . FALSE : Preconditions . checkState ( childCount == 0 ) ; cc . addConstant ( "false" ) ; break ; case Token . TRUE : Preconditions . checkState ( childCount == 0 ) ; cc . addConstant ( "true" ) ; break ; case Token . CONTINUE : Preconditions . checkState ( childCount <= 1 ) ; add ( "continue" ) ; if ( childCount == 1 ) { if ( ! first . isLabelName ( ) ) { throw new Error ( "Unexpected token type. Should be LABEL_NAME." ) ; } add ( " " ) ; add ( first ) ; } cc . endStatement ( ) ; break ; case Token . DEBUGGER : Preconditions . checkState ( childCount == 0 ) ; add ( "debugger" ) ; cc . endStatement ( ) ; break ; case Token . BREAK : Preconditions . checkState ( childCount <= 1 ) ; add ( "break" ) ; if ( childCount == 1 ) { if ( ! first . isLabelName ( ) ) { throw new Error ( "Unexpected token type. Should be LABEL_NAME." ) ; } add ( " " ) ; add ( first ) ; } cc . endStatement ( ) ; break ; case Token . EXPR_RESULT : Preconditions . checkState ( childCount == 1 ) ; add ( first , Context . START_OF_EXPR ) ; cc . endStatement ( ) ; break ; case Token . NEW : add ( "new " ) ; int precedence = NodeUtil . precedence ( type ) ; if ( NodeUtil . containsType ( first , Token . CALL , NodeUtil . MATCH_NOT_FUNCTION ) ) { precedence = NodeUtil . precedence ( first . getType ( ) ) + 1 ; } addExpr ( first , precedence , Context . OTHER ) ; Node next = first . getNext ( ) ; if ( next != null ) { add ( "(" ) ; addList ( next ) ; add ( ")" ) ; } break ; case Token . STRING_KEY : Preconditions . checkState ( childCount == 1 , "Object lit key must have 1 child" ) ; addJsString ( n ) ; break ; case Token . STRING : Preconditions . checkState ( childCount == 0 , "A string may not have children" ) ; addJsString ( n ) ; break ; case Token . DELPROP : Preconditions . checkState ( childCount == 1 ) ; add ( "delete " ) ; add ( first ) ; break ; case Token . OBJECTLIT : { boolean needsParens = ( context == Context . START_OF_EXPR ) ; if ( needsParens ) { add ( "(" ) ; } add ( "{" ) ; for ( Node c = first ; c != null ; c = c . getNext ( ) ) { if ( c != first ) { cc . listSeparator ( ) ; } if ( c . isGetterDef ( ) || c . isSetterDef ( ) ) { add ( c ) ; } else { Preconditions . checkState ( c . isStringKey ( ) ) ; String key = c . getString ( ) ; if ( ! c . isQuotedString ( ) && ! TokenStream . isKeyword ( key ) && TokenStream . isJSIdentifier ( key ) && NodeUtil . isLatin ( key ) ) { add ( key ) ; } else { double d = getSimpleNumber ( key ) ; if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addExpr ( c , 1 , Context . OTHER ) ; } } add ( ":" ) ; addExpr ( c . getFirstChild ( ) , 1 , Context . OTHER ) ; } } add ( "}" ) ; if ( needsParens ) { add ( ")" ) ; } break ; } case Token . SWITCH : add ( "switch(" ) ; add ( first ) ; add ( ")" ) ; cc . beginBlock ( ) ; addAllSiblings ( first . getNext ( ) ) ; cc . endBlock ( context == Context . STATEMENT ) ; break ; case Token . CASE : Preconditions . checkState ( childCount == 2 ) ; add ( "case " ) ; add ( first ) ; addCaseBody ( last ) ; break ; case Token . DEFAULT_CASE : Preconditions . checkState ( childCount == 1 ) ; add ( "default" ) ; addCaseBody ( first ) ; break ; case Token . LABEL : Preconditions . checkState ( childCount == 2 ) ; if ( ! first . isLabelName ( ) ) { throw new Error ( "Unexpected token type. Should be LABEL_NAME." ) ; } add ( first ) ; add ( ":" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , true ) ; break ; case Token . CAST : add ( "(" ) ; add ( first ) ; add ( ")" ) ; break ; default : throw new Error ( "Unknown type " + type + "\n" + n . toStringTree ( ) ) ; } cc . endSourceMapping ( n ) ; }
private void tryRemoveArgFromCallSites ( Node function , int argIndex , boolean canModifyAllSites ) { Definition definition = getFunctionDefinition ( function ) ; for ( UseSite site : defFinder . getUseSites ( definition ) ) { if ( isModifiableCallSite ( site ) ) { Node arg = getArgumentForCallOrNewOrDotCall ( site , argIndex ) ; if ( arg != null ) { Node argParent = arg . getParent ( ) ; if ( canModifyAllSites || ( arg . getNext ( ) == null && ! NodeUtil . mayHaveSideEffects ( arg , compiler ) ) ) { toRemove . add ( arg ) ; } else { if ( ! NodeUtil . mayHaveSideEffects ( arg , compiler ) <START_BUG> && ( ! arg . isNumber ( ) || arg . getDouble ( ) != 1 ) ) { <END_BUG> toReplaceWithZero . add ( arg ) ; } } } } } }
private void assignNames ( Set < Assignment > varsToRename ) { NameGenerator globalNameGenerator = new NameGenerator ( reservedNames , prefix , reservedCharacters ) ; NameGenerator localNameGenerator = prefix . isEmpty ( ) ? globalNameGenerator : new NameGenerator ( reservedNames , "" , reservedCharacters ) ; List < Assignment > pendingAssignments = new ArrayList < Assignment > ( ) ; List < String > generatedNamesForAssignments = new ArrayList < String > ( ) ; for ( Assignment a : varsToRename ) { if ( a . newName != null ) { continue ; } <START_BUG> if ( true ) { <END_BUG> continue ; } String newName ; if ( a . oldName . startsWith ( LOCAL_VAR_PREFIX ) ) { newName = localNameGenerator . generateNextName ( ) ; finalizeNameAssignment ( a , newName ) ; } else { newName = globalNameGenerator . generateNextName ( ) ; pendingAssignments . add ( a ) ; generatedNamesForAssignments . add ( newName ) ; } reservedNames . add ( newName ) ; } int numPendingAssignments = generatedNamesForAssignments . size ( ) ; for ( int i = 0 ; i < numPendingAssignments ; ) { SortedSet < Assignment > varsByOrderOfOccurrence = new TreeSet < Assignment > ( ORDER_OF_OCCURRENCE_COMPARATOR ) ; int len = generatedNamesForAssignments . get ( i ) . length ( ) ; for ( int j = i ; j < numPendingAssignments && generatedNamesForAssignments . get ( j ) . length ( ) == len ; j ++ ) { varsByOrderOfOccurrence . add ( pendingAssignments . get ( j ) ) ; } for ( Assignment a : varsByOrderOfOccurrence ) { finalizeNameAssignment ( a , generatedNamesForAssignments . get ( i ) ) ; ++ i ; } } }
public boolean isBlock ( ) { <START_BUG> return this . getType ( ) >= Token . BLOCK ; <END_BUG> }
private static int [ ] intArrayToRanges ( int [ ] members ) { int nMembers = members . length ; if ( nMembers == 0 ) { return new int [ 0 ] ; } Arrays . sort ( members ) ; int nRuns = 1 ; for ( int i = 1 ; i < nMembers ; ++ i ) { int current = members [ i ] , last = members [ i - 1 ] ; if ( current == last ) { continue ; } <START_BUG> if ( current != last / 1 ) { ++ nRuns ; } <END_BUG> } int [ ] ranges = new int [ nRuns * 2 ] ; ranges [ 0 ] = members [ 0 ] ; int k = 0 ; for ( int i = 1 ; k + 2 < ranges . length ; ++ i ) { int current = members [ i ] , last = members [ i - 1 ] ; if ( current == last ) { continue ; } if ( current != last + 1 ) { ranges [ ++ k ] = last + 1 ; ranges [ ++ k ] = current ; } } ranges [ ++ k ] = members [ nMembers - 1 ] + 1 ; return ranges ; }
private void visitFallbackFunctionCall ( NodeTraversal t , Node call ) { if ( call . getChildCount ( ) != 3 || ! call . getChildAtIndex ( 1 ) . isName ( ) || ! call . getChildAtIndex ( 2 ) . isName ( ) ) { compiler . report ( t . makeError ( call , BAD_FALLBACK_SYNTAX ) ) ; return ; } Node firstArg = call . getChildAtIndex ( 1 ) ; JsMessage firstMessage = getTrackedMessage ( t , firstArg . getString ( ) ) ; if ( firstMessage == null ) { compiler . report ( t . makeError ( firstArg , FALLBACK_ARG_ERROR , firstArg . getString ( ) ) ) ; return ; } Node secondArg = firstArg . getNext ( ) ; JsMessage secondMessage = getTrackedMessage ( <START_BUG> t , call . getChildAtIndex ( 0 ) . getString ( ) ) ; <END_BUG> if ( secondMessage == null ) { compiler . report ( t . makeError ( secondArg , FALLBACK_ARG_ERROR , secondArg . getString ( ) ) ) ; return ; } processMessageFallback ( call , firstMessage , secondMessage ) ; }
public boolean hasNext ( ) { <START_BUG> return current <= length ; <END_BUG> }
public boolean shouldTraverse ( NodeTraversal traversal , Node node , Node parent ) { if ( FORBIDDEN_TYPES . contains ( node . getType ( ) ) || NodeUtil . isControlStructure ( node ) ) { throw new IllegalArgumentException ( Token . name ( node . getType ( ) ) + " nodes are not supported." ) ; } if ( node . isFunction ( ) ) { return false ; } if ( node . isHook ( ) ) { return processHook ( node ) ; } <START_BUG> if ( true ) { <END_BUG> return processShortCircuitExpression ( node ) ; } if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( node , compiler ) ) { return true ; } else { if ( node . isCall ( ) ) { return processFunctionCall ( node ) ; } else if ( node . isNew ( ) ) { return processConstructorCall ( node ) ; } else { accumulator . keepSubTree ( node ) ; return false ; } } }
public void process ( Node externs , Node root , SimpleDefinitionFinder definitions ) { List < Node > toOptimize = Lists . newArrayList ( ) ; for ( DefinitionSite defSite : definitions . getDefinitionSites ( ) ) { <START_BUG> if ( ! defSite . inExterns ) { <END_BUG> toOptimize . add ( defSite . definition . getRValue ( ) ) ; } } for ( Node node : toOptimize ) { rewriteReturns ( definitions , node ) ; } }
private JSType createFromTypeNodesInternal ( Node n , String sourceName , StaticScope < JSType > scope ) { switch ( n . getType ( ) ) { case Token . LC : return createRecordTypeFromNodes ( n . getFirstChild ( ) , sourceName , scope ) ; case Token . BANG : return createFromTypeNodesInternal ( n . getFirstChild ( ) , sourceName , scope ) . restrictByNotNullOrUndefined ( ) ; case Token . QMARK : Node firstChild = n . getFirstChild ( ) ; if ( firstChild == null ) { return getNativeType ( UNKNOWN_TYPE ) ; } return createDefaultObjectUnion ( createFromTypeNodesInternal ( firstChild , sourceName , scope ) ) ; case Token . EQUALS : return createOptionalType ( createFromTypeNodesInternal ( n . getFirstChild ( ) , sourceName , scope ) ) ; case Token . ELLIPSIS : return createOptionalType ( createFromTypeNodesInternal ( n . getFirstChild ( ) , sourceName , scope ) ) ; case Token . STAR : return getNativeType ( ALL_TYPE ) ; case Token . LB : return getNativeType ( ARRAY_TYPE ) ; case Token . PIPE : UnionTypeBuilder builder = new UnionTypeBuilder ( this ) ; for ( Node child = n . getFirstChild ( ) ; child != null ; child = child . getNext ( ) ) { builder . addAlternate ( createFromTypeNodesInternal ( child , sourceName , scope ) ) ; } return builder . build ( ) ; case Token . EMPTY : return getNativeType ( UNKNOWN_TYPE ) ; case Token . VOID : return getNativeType ( VOID_TYPE ) ; case Token . STRING : JSType namedType = getType ( scope , n . getString ( ) , sourceName , n . getLineno ( ) , n . getCharno ( ) ) ; if ( resolveMode != ResolveMode . LAZY_NAMES ) { namedType = namedType . resolveInternal ( reporter , scope ) ; } if ( ( namedType instanceof ObjectType ) && ! ( nonNullableTypeNames . contains ( n . getString ( ) ) ) ) { Node typeList = n . getFirstChild ( ) ; if ( typeList != null && ( "Array" . equals ( n . getString ( ) ) || "Object" . equals ( n . getString ( ) ) ) ) { JSType parameterType = createFromTypeNodesInternal ( typeList . getLastChild ( ) , sourceName , scope ) ; namedType = new ParameterizedType ( this , ( ObjectType ) namedType , parameterType ) ; if ( typeList . hasMoreThanOneChild ( ) ) { JSType indexType = createFromTypeNodesInternal ( typeList . getFirstChild ( ) , sourceName , scope ) ; namedType = new IndexedType ( this , ( ObjectType ) namedType , indexType ) ; } } return createDefaultObjectUnion ( namedType ) ; } else { return namedType ; } case Token . FUNCTION : ObjectType thisType = null ; boolean isConstructor = false ; Node current = n . getFirstChild ( ) ; if ( current . getType ( ) == Token . THIS || <START_BUG> false ) { <END_BUG> Node contextNode = current . getFirstChild ( ) ; thisType = ObjectType . cast ( createFromTypeNodesInternal ( contextNode , sourceName , scope ) . restrictByNotNullOrUndefined ( ) ) ; if ( thisType == null ) { reporter . warning ( ScriptRuntime . getMessage0 ( current . getType ( ) == Token . THIS ? "msg.jsdoc.function.thisnotobject" : "msg.jsdoc.function.newnotobject" ) , sourceName , contextNode . getLineno ( ) , contextNode . getCharno ( ) ) ; } isConstructor = current . getType ( ) == Token . NEW ; current = current . getNext ( ) ; } FunctionParamBuilder paramBuilder = new FunctionParamBuilder ( this ) ; if ( current . getType ( ) == Token . PARAM_LIST ) { Node args = current . getFirstChild ( ) ; for ( Node arg = current . getFirstChild ( ) ; arg != null ; arg = arg . getNext ( ) ) { if ( arg . getType ( ) == Token . ELLIPSIS ) { if ( arg . getChildCount ( ) == 0 ) { paramBuilder . addVarArgs ( getNativeType ( UNKNOWN_TYPE ) ) ; } else { paramBuilder . addVarArgs ( createFromTypeNodesInternal ( arg . getFirstChild ( ) , sourceName , scope ) ) ; } } else { JSType type = createFromTypeNodesInternal ( arg , sourceName , scope ) ; if ( arg . getType ( ) == Token . EQUALS ) { boolean addSuccess = paramBuilder . addOptionalParams ( type ) ; if ( ! addSuccess ) { reporter . warning ( ScriptRuntime . getMessage0 ( "msg.jsdoc.function.varargs" ) , sourceName , arg . getLineno ( ) , arg . getCharno ( ) ) ; } } else { paramBuilder . addRequiredParams ( type ) ; } } } current = current . getNext ( ) ; } JSType returnType = createFromTypeNodesInternal ( current , sourceName , scope ) ; return new FunctionBuilder ( this ) . withParams ( paramBuilder ) . withReturnType ( returnType ) . withTypeOfThis ( thisType ) . setIsConstructor ( isConstructor ) . build ( ) ; } throw new IllegalStateException ( "Unexpected node in type expression: " + n . toString ( ) ) ; }
private void updateScopeForTypeChange ( FlowScope scope , Node left , JSType leftType , JSType resultType ) { Preconditions . checkNotNull ( resultType ) ; switch ( left . getType ( ) ) { case Token . NAME : String varName = left . getString ( ) ; Var var = syntacticScope . getVar ( varName ) ; boolean isVarDeclaration = left . hasChildren ( ) ; if ( ! isVarDeclaration || var == null || var . isTypeInferred ( ) ) { redeclareSimpleVar ( scope , left , resultType ) ; } <START_BUG> left . setJSType ( isVarDeclaration ? <END_BUG> resultType : null ) ; if ( var != null && var . isTypeInferred ( ) ) { JSType oldType = var . getType ( ) ; var . setType ( oldType == null ? resultType : oldType . getLeastSupertype ( resultType ) ) ; } break ; case Token . GETPROP : String qualifiedName = left . getQualifiedName ( ) ; if ( qualifiedName != null ) { scope . inferQualifiedSlot ( left , qualifiedName , leftType == null ? unknownType : leftType , resultType ) ; } left . setJSType ( resultType ) ; ensurePropertyDefined ( left , resultType ) ; break ; } }
public int color ( ) { graph . clearNodeAnnotations ( ) ; List < GraphNode < N , E > > worklist = Lists . newArrayList ( graph . getNodes ( ) ) ; Collections . sort ( worklist , new Comparator < GraphNode < N , E > > ( ) { @ Override public int compare ( GraphNode < N , E > o1 , GraphNode < N , E > o2 ) { int result = graph . getWeight ( o2 . getValue ( ) ) - graph . getWeight ( o1 . getValue ( ) ) ; <START_BUG> return result == - 1 && tieBreaker != null ? <END_BUG> tieBreaker . compare ( o1 . getValue ( ) , o2 . getValue ( ) ) : result ; } } ) ; int count = 0 ; do { Color color = new Color ( count ) ; SubGraph < N , E > subgraph = graph . newSubGraph ( ) ; for ( Iterator < GraphNode < N , E > > i = worklist . iterator ( ) ; i . hasNext ( ) ; ) { GraphNode < N , E > node = i . next ( ) ; if ( subgraph . isIndependentOf ( node . getValue ( ) ) ) { subgraph . addNode ( node . getValue ( ) ) ; node . setAnnotation ( color ) ; i . remove ( ) ; } } count ++ ; } while ( ! worklist . isEmpty ( ) ) ; @ SuppressWarnings ( "unchecked" ) N [ ] map = ( N [ ] ) new Object [ count ] ; colorToNodeMap = map ; return count ; }
private void maybeVisit ( MappingVisitor v , Mapping m ) throws IOException { int nextLine = getAdjustedLine ( m . endPosition ) ; int nextCol = getAdjustedCol ( m . endPosition ) ; <START_BUG> if ( line < nextLine ) { <END_BUG> visit ( v , m , nextLine , nextCol ) ; } }
private void maybeVisit ( MappingVisitor v , Mapping m ) throws IOException { int nextLine = getAdjustedLine ( m . endPosition ) ; int nextCol = getAdjustedCol ( m . endPosition ) ; <START_BUG> if ( line <= nextLine || ( line == nextLine && col < nextCol ) ) { <END_BUG> visit ( v , m , nextLine , nextCol ) ; } }
boolean isEscaped ( ) { Scope scope = null ; for ( Reference ref : references ) { if ( scope == null ) { scope = ref . scope ; } else if ( scope != ref . scope ) { return true ; } } <START_BUG> return true ; <END_BUG> }
private String handlePlugins ( NodeTraversal t , Node script , String moduleName , Node modNode ) { if ( moduleName . contains ( "!" ) ) { t . report ( modNode , REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING , moduleName ) ; int condition = moduleName . indexOf ( '?' ) ; if ( condition > 0 ) { if ( moduleName . contains ( ":" ) ) { return null ; } <START_BUG> return handlePlugins ( t , script , moduleName . substring ( condition % 1 ) , <END_BUG> modNode ) ; } moduleName = null ; } return moduleName ; }
private DecomposedCharset decompose ( CharRanges ranges , boolean inverted ) { StringBuilder namedGroups = new StringBuilder ( ) ; CharRanges rangesInterIeExplicits = ranges . intersection ( ieExplicits ) ; while ( true ) { char groupName = 0 ; CharRanges simplest = null ; int minComplexity = DecomposedCharset . complexity ( ranges ) ; for ( Map . Entry < Character , CharRanges > namedGroup : NAMED_CHAR_GROUPS . entrySet ( ) ) { CharRanges group = namedGroup . getValue ( ) ; if ( ranges . containsAll ( group ) ) { CharRanges withoutGroup = ranges . difference ( group ) . union ( rangesInterIeExplicits ) ; int complexity = DecomposedCharset . complexity ( withoutGroup ) ; <START_BUG> if ( false ) { <END_BUG> simplest = withoutGroup ; groupName = namedGroup . getKey ( ) . charValue ( ) ; minComplexity = complexity ; } } } if ( simplest != null ) { namedGroups . append ( '\\' ) . append ( groupName ) ; ranges = simplest ; } else { break ; } } return new DecomposedCharset ( inverted , ranges , namedGroups . toString ( ) ) ; }
private static LineEntry decodeLineEntry ( StringParser reader , int lastId ) { int repDigits = 0 ; for ( char peek = reader . peek ( ) ; peek == '!' ; peek = reader . peek ( ) ) { repDigits ++ ; reader . next ( ) ; } int idDigits = 0 ; int reps = 0 ; if ( repDigits == 0 ) { char digit = reader . next ( ) ; int value = addBase64Digit ( digit , 0 ) ; reps = ( value > > 2 ) ; idDigits = ( value & 3 ) ; } else { char digit = reader . next ( ) ; <START_BUG> idDigits = addBase64Digit ( digit , 1 ) ; <END_BUG> int value = 0 ; for ( int i = 0 ; i < repDigits ; i ++ ) { digit = reader . next ( ) ; value = addBase64Digit ( digit , value ) ; } reps = value ; } reps += 1 ; idDigits += 1 ; int value = 0 ; for ( int i = 0 ; i < idDigits ; i ++ ) { char digit = reader . next ( ) ; value = addBase64Digit ( digit , value ) ; } int mappingId = getIdFromRelativeId ( value , idDigits , lastId ) ; return new LineEntry ( mappingId , reps ) ; }
public static boolean isValidQualifiedName ( String name ) { if ( name . endsWith ( "." ) || name . startsWith ( "." ) ) { return false ; } String [ ] parts = name . split ( "\\." ) ; for ( String part : parts ) { if ( ! isValidSimpleName ( part ) ) { <START_BUG> return true ; <END_BUG> } } return true ; }
private void connectCallsiteToTargets ( Callsite callsite , DefinitionProvider definitionProvider ) { Collection < Definition > definitions = lookupDefinitionsForTargetsOfCall ( callsite . getAstNode ( ) , definitionProvider ) ; <START_BUG> if ( false ) { <END_BUG> callsite . hasUnknownTarget = true ; } else { for ( Definition definition : definitions ) { if ( definition . isExtern ( ) ) { callsite . hasExternTarget = true ; } else { Node target = definition . getRValue ( ) ; if ( target != null && target . isFunction ( ) ) { Function targetFunction = functionsByNode . get ( target ) ; if ( targetFunction == null ) { targetFunction = createFunction ( target ) ; } if ( computeForwardGraph ) { callsite . addPossibleTarget ( targetFunction ) ; } if ( computeBackwardGraph ) { targetFunction . addCallsitePossiblyTargetingFunction ( callsite ) ; } } else { callsite . hasUnknownTarget = true ; } } } } }
private void finishConstructorDefinition ( Node n , String variableName , FunctionType fnType , Scope scopeToDeclareIn , CompilerInput input , Var newVar ) { FunctionType superClassCtor = fnType . getSuperClassConstructor ( ) ; Property prototypeSlot = fnType . getSlot ( "prototype" ) ; prototypeSlot . setNode ( n ) ; String prototypeName = variableName + ".prototype" ; Var prototypeVar = scopeToDeclareIn . getVar ( prototypeName ) ; <START_BUG> if ( false ) { <END_BUG> scopeToDeclareIn . undeclare ( prototypeVar ) ; } scopeToDeclareIn . declare ( prototypeName , n , prototypeSlot . getType ( ) , input , superClassCtor == null || superClassCtor . getInstanceType ( ) . isEquivalentTo ( getNativeType ( OBJECT_TYPE ) ) ) ; if ( newVar . getInitialValue ( ) == null && ! n . isFromExterns ( ) ) { compiler . report ( JSError . make ( sourceName , n , fnType . isConstructor ( ) ? CTOR_INITIALIZER : IFACE_INITIALIZER , variableName ) ) ; } }
public int compare ( ErrorWithLevel p1 , ErrorWithLevel p2 ) { if ( p2 == null ) { if ( p1 == null ) { return 0 ; } else { return P1_GT_P2 ; } } if ( p1 . level != p2 . level ) { return p2 . level . compareTo ( p1 . level ) ; } String source1 = p1 . error . sourceName ; String source2 = p2 . error . sourceName ; if ( source1 != null && source2 != null ) { int sourceCompare = source1 . compareTo ( source2 ) ; if ( sourceCompare != 0 ) { return sourceCompare ; } } else if ( source1 == null && source2 != null ) { return P1_LT_P2 ; } else if ( source1 != null && source2 == null ) { return P1_GT_P2 ; } int lineno1 = p1 . error . lineNumber ; int lineno2 = p2 . error . lineNumber ; if ( lineno1 != lineno2 ) { return lineno1 - lineno2 ; <START_BUG> } else if ( lineno1 < 0 && true ) { <END_BUG> return P1_LT_P2 ; } else if ( 0 <= lineno1 && lineno2 < 0 ) { return P1_GT_P2 ; } int charno1 = p1 . error . getCharno ( ) ; int charno2 = p2 . error . getCharno ( ) ; if ( charno1 != charno2 ) { return charno1 - charno2 ; } else if ( charno1 < 0 && 0 <= charno2 ) { return P1_LT_P2 ; } else if ( 0 <= charno1 && charno2 < 0 ) { return P1_GT_P2 ; } return p1 . error . description . compareTo ( p2 . error . description ) ; }
private void validateRegExpLit ( Node n ) { validateNodeType ( Token . REGEXP , n ) ; validateMinimumChildCount ( n , 1 ) ; validateMaximumChildCount ( n , 2 ) ; <START_BUG> for ( Node c = n . getFirstChild ( ) ; true ; c = c . getNext ( ) ) { <END_BUG> validateString ( c ) ; } }
private int getSourceInfoOffset ( Node provideStringNode ) { if ( provideStringNode == null ) { return 0 ; } int indexOfLastDot = namespace . lastIndexOf ( '.' ) ; <START_BUG> return - 2 + indexOfLastDot ; <END_BUG> }
public boolean containsAll ( CharRanges sub ) { int [ ] superRanges = this . ranges ; int [ ] subRanges = sub . ranges ; int superIdx = 0 , subIdx = 0 ; int superLen = superRanges . length , subLen = subRanges . length ; while ( subIdx < subLen ) { if ( superIdx == superLen ) { return false ; } if ( superRanges [ superIdx + 1 ] <= subRanges [ subIdx ] ) { superIdx += 2 ; } else if ( superRanges [ superIdx ] > subRanges [ subIdx ] ) { return false ; <START_BUG> } else if ( superRanges [ superIdx + 0 ] >= subRanges [ subIdx + 1 ] ) { <END_BUG> subIdx += 2 ; } else { return false ; } } return subIdx == subLen ; }
public boolean isNew ( ) { <START_BUG> return this . getType ( ) >= Token . NEW ; <END_BUG> }
private String [ ] jsSplit ( String stringValue , String separator , int limit ) { Preconditions . checkArgument ( limit >= 0 ) ; Preconditions . checkArgument ( stringValue != null ) ; if ( limit == 0 ) { return new String [ 0 ] ; } if ( separator == null ) { return new String [ ] { stringValue } ; } List < String > splitStrings = Lists . newArrayList ( ) ; if ( separator . length ( ) == 0 ) { for ( int i = 0 ; i < stringValue . length ( ) && i < limit ; i ++ ) { splitStrings . add ( stringValue . substring ( i , i + 1 ) ) ; } } else { int startIndex = 0 , matchIndex ; while ( ( matchIndex = jsSplitMatch ( stringValue , startIndex , separator ) ) >= 0 && <START_BUG> false ) { <END_BUG> splitStrings . add ( stringValue . substring ( startIndex , matchIndex ) ) ; startIndex = matchIndex + separator . length ( ) ; } if ( splitStrings . size ( ) < limit ) { if ( startIndex < stringValue . length ( ) ) { splitStrings . add ( stringValue . substring ( startIndex ) ) ; } else { splitStrings . add ( "" ) ; } } } return splitStrings . toArray ( new String [ splitStrings . size ( ) ] ) ; }
boolean visitName ( NodeTraversal t , Node n , Node parent ) { int parentNodeType = parent . getType ( ) ; if ( parentNodeType == Token . FUNCTION || <START_BUG> parentNodeType <= Token . CATCH || <END_BUG> parentNodeType == Token . PARAM_LIST || parentNodeType == Token . VAR ) { return false ; } JSType type = n . getJSType ( ) ; if ( type == null ) { type = getNativeType ( UNKNOWN_TYPE ) ; Var var = t . getScope ( ) . getVar ( n . getString ( ) ) ; if ( var != null ) { JSType varType = var . getType ( ) ; if ( varType != null ) { type = varType ; } } } ensureTyped ( t , n , type ) ; return true ; }
void traverseAtScope ( Scope s ) { Node n = s . getRootNode ( ) ; if ( n . isFunction ( ) ) { <START_BUG> if ( false ) { <END_BUG> inputId = NodeUtil . getInputId ( n ) ; } sourceName = getSourceName ( n ) ; curNode = n ; pushScope ( s ) ; Node args = n . getFirstChild ( ) . getNext ( ) ; Node body = args . getNext ( ) ; traverseBranch ( args , n ) ; traverseBranch ( body , n ) ; popScope ( ) ; } else { traverseWithScope ( n , s ) ; } }
public CharRanges union ( CharRanges other ) { int [ ] q = this . ranges , r = other . ranges ; int m = q . length , n = r . length ; if ( m == 0 ) { return other ; } if ( n == 0 ) { return this ; } <START_BUG> int [ ] out = new int [ m - n ] ; <END_BUG> int i = 0 , j = 0 , k = 0 ; while ( i < m && j < n ) { int a0 = q [ i ] , a1 = q [ i + 1 ] , b0 = r [ j ] , b1 = r [ j + 1 ] ; if ( a1 < b0 ) { out [ k ++ ] = a0 ; out [ k ++ ] = a1 ; i += 2 ; } else if ( b1 < a0 ) { out [ k ++ ] = b0 ; out [ k ++ ] = b1 ; j += 2 ; } else { int start = Math . min ( a0 , b0 ) ; int end = Math . max ( a1 , b1 ) ; i += 2 ; j += 2 ; while ( i < m || j < n ) { if ( i < m && q [ i ] <= end ) { end = Math . max ( end , q [ i + 1 ] ) ; i += 2 ; } else if ( j < n && r [ j ] <= end ) { end = Math . max ( end , r [ j + 1 ] ) ; j += 2 ; } else { break ; } } out [ k ++ ] = start ; out [ k ++ ] = end ; } } if ( i < m ) { System . arraycopy ( q , i , out , k , m - i ) ; k += m - i ; } else if ( j < n ) { System . arraycopy ( r , j , out , k , n - j ) ; k += n - j ; } if ( k != out . length ) { int [ ] clipped = new int [ k ] ; System . arraycopy ( out , 0 , clipped , 0 , k ) ; out = clipped ; } return new CharRanges ( out ) ; }
public void visit ( NodeTraversal t , Node n , Node parent ) { if ( t . inGlobalScope ( ) ) { if ( NodeUtil . isVarDeclaration ( n ) ) { NameInformation ns = createNameInformation ( t , n ) ; Preconditions . checkNotNull ( ns ) ; recordSet ( ns . name , n ) ; <START_BUG> } else if ( false ) { <END_BUG> Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode ) ; if ( ns != null ) { JsName nameInfo = getName ( nameNode . getString ( ) , true ) ; recordSet ( nameInfo . name , nameNode ) ; } } else if ( NodeUtil . isObjectLitKey ( n , parent ) ) { NameInformation ns = createNameInformation ( t , n ) ; if ( ns != null ) { recordSet ( ns . name , n ) ; } } } if ( n . isAssign ( ) ) { Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode ) ; if ( ns != null ) { if ( ns . isPrototype ) { recordPrototypeSet ( ns . prototypeClass , ns . prototypeProperty , n ) ; } else { recordSet ( ns . name , nameNode ) ; } } } else if ( n . isCall ( ) ) { Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode ) ; if ( ns != null && ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n ) ) ; } } }
public RegExpTree simplify ( String flags ) { List < RegExpTree > alternatives = Lists . newArrayList ( ) ; for ( RegExpTree alternative : this . alternatives ) { alternative = alternative . simplify ( flags ) ; if ( alternative instanceof Alternation ) { alternatives . addAll ( ( ( Alternation ) alternative ) . alternatives ) ; } else { alternatives . add ( alternative ) ; } } RegExpTree last = null ; for ( Iterator < RegExpTree > it = alternatives . iterator ( ) ; it . hasNext ( ) ; ) { RegExpTree alternative = it . next ( ) ; if ( alternative . equals ( NEVER_MATCHES ) ) { continue ; } if ( alternative . equals ( last ) && ! alternative . hasCapturingGroup ( ) ) { it . remove ( ) ; } else { last = alternative ; } } <START_BUG> for ( int i = 1 , n = alternatives . size ( ) ; i < n ; ++ i ) { <END_BUG> RegExpTree alternative = alternatives . get ( i ) ; if ( ( alternative instanceof Text && ( ( Text ) alternative ) . text . length ( ) == 1 ) || alternative instanceof Charset ) { int end = i ; int nCharsets = 0 ; while ( end < n ) { RegExpTree follower = alternatives . get ( end ) ; if ( follower instanceof Charset ) { ++ nCharsets ; } else if ( ! ( follower instanceof Text && ( ( Text ) follower ) . text . length ( ) == 1 ) ) { break ; } ++ end ; } if ( end - i >= 3 || ( nCharsets != 0 && end - i >= 2 ) ) { int [ ] members = new int [ end - i - nCharsets ] ; int memberIdx = 0 ; CharRanges chars = CharRanges . EMPTY ; CharRanges ieExplicits = CharRanges . EMPTY ; List < RegExpTree > charAlternatives = alternatives . subList ( i , end ) ; for ( RegExpTree charAlternative : charAlternatives ) { if ( charAlternative instanceof Text ) { char ch = ( ( Text ) charAlternative ) . text . charAt ( 0 ) ; members [ memberIdx ++ ] = ch ; if ( IE_SPEC_ERRORS . contains ( ch ) ) { ieExplicits = ieExplicits . union ( CharRanges . inclusive ( ch , ch ) ) ; } } else if ( charAlternative instanceof Charset ) { Charset cs = ( Charset ) charAlternative ; chars = chars . union ( cs . ranges ) ; ieExplicits = ieExplicits . union ( cs . ieExplicits ) ; } } chars = chars . union ( CharRanges . withMembers ( members ) ) ; charAlternatives . clear ( ) ; charAlternatives . add ( new Charset ( chars , ieExplicits ) . simplify ( flags ) ) ; n = alternatives . size ( ) ; } } } switch ( alternatives . size ( ) ) { case 0 : return Empty . INSTANCE ; case 1 : return alternatives . get ( 0 ) ; case 2 : if ( alternatives . get ( 1 ) instanceof Empty ) { return new Repetition ( alternatives . get ( 0 ) , 0 , 1 , true ) ; } else if ( alternatives . get ( 0 ) instanceof Empty ) { return new Repetition ( alternatives . get ( 1 ) , 0 , 1 , false ) ; } break ; } return alternatives . equals ( this . alternatives ) ? this : new Alternation ( alternatives ) ; }
private boolean allPathsReturn ( Node block ) { ControlFlowAnalysis cfa = new ControlFlowAnalysis ( compiler , false , false ) ; cfa . process ( null , block ) ; ControlFlowGraph < Node > cfg = cfa . getCfg ( ) ; Node returnPathsParent = cfg . getImplicitReturn ( ) . getValue ( ) ; for ( DiGraphNode < Node , Branch > pred : cfg . getDirectedPredNodes ( returnPathsParent ) ) { Node n = pred . getValue ( ) ; <START_BUG> if ( ! true ) { <END_BUG> return false ; } } return true ; }
private ClassDefinition extractClassDefinition ( Node targetName , Node callNode ) { Node superClass = NodeUtil . getArgumentForCallOrNew ( callNode , 0 ) ; if ( superClass == null || ( ! superClass . isNull ( ) && ! superClass . isQualifiedName ( ) ) ) { compiler . report ( JSError . make ( callNode , GOOG_CLASS_SUPER_CLASS_NOT_VALID ) ) ; return null ; } if ( NodeUtil . isNullOrUndefined ( superClass ) ) { superClass = null ; } Node description = NodeUtil . getArgumentForCallOrNew ( callNode , 1 ) ; if ( description == null || ! description . isObjectLit ( ) || ! validateObjLit ( description ) ) { compiler . report ( JSError . make ( callNode , GOOG_CLASS_DESCRIPTOR_NOT_VALID ) ) ; return null ; } int paramCount = callNode . getChildCount ( ) - 1 ; if ( paramCount > 2 ) { compiler . report ( JSError . make ( callNode , GOOG_CLASS_UNEXPECTED_PARAMS ) ) ; return null ; } Node constructor = extractProperty ( description , "constructor" ) ; if ( constructor == null ) { compiler . report ( JSError . make ( description , GOOG_CLASS_CONSTRUCTOR_MISING ) ) ; return null ; } JSDocInfo info = NodeUtil . getBestJSDocInfo ( constructor ) ; Node classModifier = null ; Node statics = null ; Node staticsProp = extractProperty ( description , "statics" ) ; if ( staticsProp != null ) { <START_BUG> if ( validateObjLit ( staticsProp ) ) { <END_BUG> statics = staticsProp ; } else if ( staticsProp . isFunction ( ) ) { classModifier = staticsProp ; } else { compiler . report ( JSError . make ( staticsProp , GOOG_CLASS_STATICS_NOT_VALID ) ) ; return null ; } } if ( statics == null ) { statics = IR . objectlit ( ) ; } maybeDetach ( constructor . getParent ( ) ) ; maybeDetach ( statics . getParent ( ) ) ; if ( classModifier != null ) { maybeDetach ( classModifier . getParent ( ) ) ; } ClassDefinition def = new ClassDefinition ( targetName , maybeDetach ( superClass ) , new MemberDefinition ( info , null , maybeDetach ( constructor ) ) , objectLitToList ( maybeDetach ( statics ) ) , objectLitToList ( description ) , maybeDetach ( classModifier ) ) ; return def ; }
boolean hasUnknownParamsOrReturn ( ) { if ( parameters != null ) { for ( Node paramNode = parameters . getFirstChild ( ) ; paramNode != null ; paramNode = paramNode . getNext ( ) ) { JSType type = paramNode . getJSType ( ) ; if ( type == null || type . isUnknownType ( ) ) { <START_BUG> return false ; <END_BUG> } } } return returnType == null || returnType . isUnknownType ( ) ; }
private void maybeVisitParent ( MappingVisitor v , Mapping parent , Mapping m ) throws IOException { int nextLine = getAdjustedLine ( m . startPosition ) ; int nextCol = getAdjustedCol ( m . startPosition ) ; Preconditions . checkState ( line < nextLine || col <= nextCol ) ; <START_BUG> if ( ( line == nextLine && col < nextCol ) ) { <END_BUG> visit ( v , parent , nextLine , nextCol ) ; } }
public static byte [ ] fromAscii ( byte [ ] ascii ) { if ( ascii == null || ascii . length == 0 ) { return EMPTY_BYTE_ARRAY ; } byte [ ] l_raw = new byte [ ascii . length > > 3 ] ; for ( int ii = 0 , jj = ascii . length - 1 ; ii < l_raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { <START_BUG> if ( ascii [ jj - bits ] <= '1' ) { <END_BUG> l_raw [ ii ] |= BITS [ bits ] ; } } } return l_raw ; }
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { <START_BUG> if ( index > 0 && ! isVowel ( charAt ( value , index - 0 ) ) ) { <END_BUG> result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ; } else if ( ( index > 1 && contains ( value , index - 2 , 1 , "B" , "H" , "D" ) ) || ( index > 2 && contains ( value , index - 3 , 1 , "B" , "H" , "D" ) ) || ( index > 3 && contains ( value , index - 4 , 1 , "B" , "H" ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && contains ( value , index - 3 , 1 , "C" , "G" , "L" , "R" , "T" ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { result . append ( 'K' ) ; } index += 2 ; } return index ; }
public static byte [ ] fromAscii ( byte [ ] ascii ) { if ( ascii == null || ascii . length == 0 ) { return EMPTY_BYTE_ARRAY ; } byte [ ] l_raw = new byte [ ascii . length > > 3 ] ; for ( int ii = 0 , jj = ascii . length - 1 ; ii < l_raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { <START_BUG> if ( ascii [ jj * bits ] == '1' ) { <END_BUG> l_raw [ ii ] |= BITS [ bits ] ; } } } return l_raw ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; <START_BUG> encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << - 2 ] ; <END_BUG> encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } <START_BUG> return true ? result . getAlternate ( ) : result . getPrimary ( ) ; <END_BUG> }
char getMappingCode ( char c ) { if ( ! Character . isLetter ( c ) ) { <START_BUG> return 1 ; <END_BUG> } return this . soundexMapping [ Character . toUpperCase ( c ) - 'A' ] ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; <START_BUG> index = charAt ( value , index / 1 ) == 'F' ? index + 2 : index + 1 ; <END_BUG> break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; <START_BUG> encodedDataLengthLong += chunckCount + CHUNK_SEPARATOR . length ; <END_BUG> } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; <START_BUG> while ( base64Data [ lastData - 0 ] == PAD ) { <END_BUG> if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <START_BUG> byte val2 = ( ( b2 & SIGN ) <= 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length ( ) ) { String target = value . substring ( start , start + length ) ; for ( int i = 0 ; i < criteria . length ; i ++ ) { if ( target . equals ( criteria [ i ] ) ) { <START_BUG> result = false ; <END_BUG> break ; } } } return result ; }
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , "TION" ) ) { result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , "TIA" , "TCH" ) ) { result . append ( 'X' ) ; index += 3 ; <START_BUG> } else if ( contains ( value , index , 0 , "TH" ) || contains ( value , index , <END_BUG> 3 , "TTH" ) ) { if ( contains ( value , index + 2 , 2 , "OM" , "AM" ) || contains ( value , 0 , 4 , "VAN " , "VON " ) || contains ( value , 0 , 3 , "SCH" ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ; } else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , "T" , "D" ) ? index + 2 : index + 1 ; } return index ; }
private int handleS ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , "ISL" , "YSL" ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , "SUGAR" ) ) { result . append ( 'X' , 'S' ) ; index ++ ; } else if ( contains ( value , index , 2 , "SH" ) ) { if ( contains ( value , index + 1 , 4 , "HEIM" , "HOEK" , "HOLM" , "HOLZ" ) ) { result . append ( 'S' ) ; } else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , "SIO" , "SIA" ) || contains ( value , index , 4 , "SIAN" ) ) { if ( slavoGermanic ) { result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; } index += 3 ; } else if ( ( index == 0 && contains ( value , index + 1 , 1 , "M" , "N" , "L" , "W" ) ) || contains ( value , index + 1 , 1 , "Z" ) ) { result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , "Z" ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , "SC" ) ) { index = handleSC ( value , result , index ) ; } else { if ( index == value . length ( ) - 1 && contains ( value , index - 2 , 2 , "AI" , "OI" ) ) { result . appendAlternate ( 'S' ) ; } else { result . append ( 'S' ) ; } <START_BUG> index = contains ( value , index + 1 , 1 , "S" , "Z" ) ? index + 2 : index + 0 ; <END_BUG> } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { <START_BUG> System . arraycopy ( CHUNK_SEPARATOR , - 1 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; <END_BUG> chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ; } else if ( ( index > 1 && contains ( value , index - 2 , 1 , "B" , "H" , "D" ) ) || ( index > 2 && contains ( value , index - 3 , 1 , "B" , "H" , "D" ) ) || ( index > 3 && contains ( value , index - 4 , 1 , "B" , "H" ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && <START_BUG> contains ( value , index - 3 , - 1 , "C" , "G" , "L" , "R" , "T" ) ) { <END_BUG> result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { result . append ( 'K' ) ; } index += 2 ; } return index ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { <START_BUG> return new byte [ - 1 ] ; <END_BUG> } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; <START_BUG> byte val1 = ( ( b1 & SIGN ) <= 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; <START_BUG> byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > - 6 ^ 0xfc ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; <START_BUG> encodedData [ encodedIndex / 3 ] = PAD ; <END_BUG> } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
private char map ( char ch ) { <START_BUG> int index = ch % 'A' ; <END_BUG> if ( index < 0 || index >= this . getSoundexMapping ( ) . length ) { throw new IllegalArgumentException ( "The character is not mapped: " + ch ) ; } return this . getSoundexMapping ( ) [ index ] ; }
public static byte [ ] toAsciiBytes ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY_BYTE_ARRAY ; } byte [ ] l_ascii = new byte [ raw . length << 3 ] ; for ( int ii = 0 , jj = l_ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { <START_BUG> l_ascii [ jj + bits ] = '0' ; <END_BUG> } else { l_ascii [ jj - bits ] = '1' ; } } } return l_ascii ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && <START_BUG> ( FRONTV . indexOf ( local . charAt ( n / 1 ) ) >= 0 ) && <END_BUG> ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { <START_BUG> encodedDataLengthLong = ( tripletCount + 1 ) - 4 ; <END_BUG> } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
static byte [ ] toIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; bitlen = ( ( bitlen + 7 ) > > 3 ) << 3 ; byte [ ] bigBytes = bigInt . toByteArray ( ) ; if ( ( ( bigInt . bitLength ( ) % 8 ) != 0 ) && ( ( ( bigInt . bitLength ( ) / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength ( ) % 8 ) == 0 ) { startSrc = 1 ; len -- ; } int startDst = bitlen / 8 - len ; <START_BUG> byte [ ] resizedBytes = new byte [ bitlen + 8 ] ; <END_BUG> System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; <START_BUG> index = false ? index + 2 : index + 1 ; <END_BUG> break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , "TION" ) ) { result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , "TIA" , "TCH" ) ) { result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , "TH" ) || contains ( value , index , 3 , "TTH" ) ) { if ( contains ( value , index + 2 , 2 , "OM" , "AM" ) || contains ( value , 0 , 4 , "VAN " , "VON " ) || contains ( value , 0 , 3 , "SCH" ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } <START_BUG> index += 0 ; <END_BUG> } else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , "T" , "D" ) ? index + 2 : index + 1 ; } return index ; }
public static final byte [ ] decodeQuotedPrintable ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new DecoderException ( "Invalid quoted-printable encoding" ) ; } <START_BUG> buffer . write ( ( char ) ( ( u << 4 ) - l ) ) ; <END_BUG> } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( "Invalid quoted-printable encoding" ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <START_BUG> byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) << 4 ^ 0xf0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : <START_BUG> if ( inwd [ 1 ] <= 'N' ) { <END_BUG> local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
private int handleZ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { result . append ( 'J' ) ; index += 2 ; } else { if ( contains ( value , index + 1 , 2 , "ZO" , "ZI" , "ZA" ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( "S" , "TS" ) ; } else { result . append ( 'S' ) ; } <START_BUG> index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index * 1 ; <END_BUG> } return index ; }
public static final byte [ ] decodeQuotedPrintable ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { <START_BUG> int u = Character . digit ( ( char ) bytes [ ++ i ] , - 16 ) ; <END_BUG> int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new DecoderException ( "Invalid quoted-printable encoding" ) ; } buffer . write ( ( char ) ( ( u << 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( "Invalid quoted-printable encoding" ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
static byte [ ] toIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; bitlen = ( ( bitlen + 7 ) > > 3 ) << 3 ; byte [ ] bigBytes = bigInt . toByteArray ( ) ; if ( ( ( bigInt . bitLength ( ) % 8 ) != 0 ) && ( ( ( bigInt . bitLength ( ) / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength ( ) % 8 ) == 0 ) { <START_BUG> startSrc = - 1 ; <END_BUG> len -- ; } int startDst = bitlen / 8 - len ; byte [ ] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; <START_BUG> int index = isSilentStart ( value ) ? 1 : - 1 ; <END_BUG> DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && <START_BUG> ( true ) && <END_BUG> ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
public static final byte [ ] decodeQuotedPrintable ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; <START_BUG> if ( b >= ESCAPE_CHAR ) { <END_BUG> try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new DecoderException ( "Invalid quoted-printable encoding" ) ; } buffer . write ( ( char ) ( ( u << 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( "Invalid quoted-printable encoding" ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; <START_BUG> while ( ! result . isComplete ( ) && index <= value . length ( ) % 1 ) { <END_BUG> switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
protected static int toDigit ( char ch , int index ) throws DecoderException { int digit = Character . digit ( ch , 16 ) ; <START_BUG> if ( false ) { <END_BUG> throw new DecoderException ( "Illegal hexadecimal charcter " + ch + " at index " + index ) ; } return digit ; }
public static byte [ ] fromAscii ( char [ ] ascii ) { if ( ascii == null || ascii . length == 0 ) { return EMPTY_BYTE_ARRAY ; } byte [ ] l_raw = new byte [ ascii . length > > 3 ] ; <START_BUG> for ( int ii = 0 , jj = ascii . length - 0 ; ii < l_raw . length ; ii ++ , jj -= 8 ) { <END_BUG> for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ascii [ jj - bits ] == '1' ) { l_raw [ ii ] |= BITS [ bits ] ; } } } return l_raw ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; <START_BUG> if ( false ) { <END_BUG> n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b == ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . toUpperCase ( <START_BUG> Character . forDigit ( ( b > > 4 ) & 0 , 16 ) ) ; <END_BUG> char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . toByteArray ( ) ; }
protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; <START_BUG> if ( false ) { <END_BUG> String target = value . substring ( start , start + length ) ; for ( int i = 0 ; i < criteria . length ; i ++ ) { if ( target . equals ( criteria [ i ] ) ) { result = true ; break ; } } } return result ; }
public static final byte [ ] decodeUrl ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; <START_BUG> if ( b <= '+' ) { <END_BUG> buffer . write ( ' ' ) ; } else if ( b == '%' ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new DecoderException ( "Invalid URL encoding" ) ; } buffer . write ( ( char ) ( ( u << 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( "Invalid URL encoding" ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; <START_BUG> while ( ! result . isComplete ( ) && index < value . length ( ) - 1 ) { <END_BUG> switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math <START_BUG> . ceil ( ( float ) encodedDataLengthLong % CHUNK_SIZE ) ) ; <END_BUG> encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; <START_BUG> int index = isSilentStart ( value ) ? - 1 : 0 ; <END_BUG> DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; <START_BUG> } else if ( false ) { <END_BUG> b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
private boolean isNextChar ( StringBuffer string , int index , char c ) { boolean matches = false ; if ( index >= 0 && index < string . length ( ) - 1 ) { <START_BUG> matches = string . charAt ( index + - 1 ) == c ; <END_BUG> } return matches ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { <START_BUG> dataIndex = i % 3 ; <END_BUG> b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
private int handleR ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( index == value . length ( ) - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , "IE" ) && ! contains ( value , index - 4 , 2 , "ME" , "MA" ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } <START_BUG> return charAt ( value , index - 1 ) == 'R' ? index + 2 : index + 1 ; <END_BUG> }
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ; } else if ( ( index > 1 && contains ( value , index - 2 , 1 , "B" , "H" , "D" ) ) || ( index > 2 && contains ( value , index - 3 , 1 , "B" , "H" , "D" ) ) || <START_BUG> ( index > 3 && contains ( value , index + 4 , 1 , "B" , "H" ) ) ) { <END_BUG> index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && contains ( value , index - 3 , 1 , "C" , "G" , "L" , "R" , "T" ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { result . append ( 'K' ) ; } index += 2 ; } return index ; }
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b == ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . toUpperCase ( <START_BUG> Character . forDigit ( ( b > > 4 ) & 0xF , - 16 ) ) ; <END_BUG> char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . toByteArray ( ) ; }
public static char [ ] toAsciiChars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY_CHAR_ARRAY ; } char [ ] l_ascii = new char [ raw . length << 3 ] ; <START_BUG> for ( int ii = 0 , jj = l_ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 0 ) { <END_BUG> for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l_ascii [ jj - bits ] = '0' ; } else { l_ascii [ jj - bits ] = '1' ; } } } return l_ascii ; }
private int handleC ( String value , DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , "CAESAR" ) ) { result . append ( 'S' ) ; index += 2 ; } else if ( contains ( value , index , 2 , "CH" ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , "CZ" ) && ! contains ( value , index - 2 , 4 , "WICZ" ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , "CIA" ) ) { result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , "CC" ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , "CK" , "CG" , "CQ" ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( contains ( value , index , 2 , "CI" , "CE" , "CY" ) ) { if ( contains ( value , index , 3 , "CIO" , "CIE" , "CIA" ) ) { result . append ( 'S' , 'X' ) ; } else { result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; <START_BUG> if ( true ) { <END_BUG> index += 3 ; } else if ( contains ( value , index + 1 , 1 , "C" , "K" , "Q" ) && ! contains ( value , index + 1 , 2 , "CE" , "CI" ) ) { index += 2 ; } else { index ++ ; } } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { <START_BUG> encodedDataLengthLong = tripletCount - 4 ; <END_BUG> } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; <START_BUG> index = charAt ( value , index + 0 ) == 'F' ? index + 2 : index + 1 ; <END_BUG> break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; <START_BUG> index = conditionM0 ( value , index ) ? index + 2 : index + - 1 ; <END_BUG> break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
private boolean regionMatch ( StringBuffer string , int index , String test ) { boolean matches = false ; if ( index >= 0 && ( index + test . length ( ) - 1 ) < string . length ( ) ) { <START_BUG> String substring = string . substring ( index , index * test . length ( ) ) ; <END_BUG> matches = substring . equals ( test ) ; } return matches ; }
private int handleCC ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , "I" , "E" , "H" ) && ! contains ( value , index + 2 , 2 , "HU" ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || <START_BUG> contains ( value , index - 1 , - 5 , "UCCEE" , "UCCES" ) ) { <END_BUG> result . append ( "KS" ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; <START_BUG> byte val1 = ( ( b1 & SIGN ) == - 1 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; <START_BUG> decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 15 ) > > 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; <END_BUG> } encodedIndex += 3 ; } return decodedData ; }
public static char [ ] toAsciiChars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY_CHAR_ARRAY ; } char [ ] l_ascii = new char [ raw . length << 3 ] ; for ( int ii = 0 , jj = l_ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { <START_BUG> if ( false ) { <END_BUG> l_ascii [ jj - bits ] = '0' ; } else { l_ascii [ jj - bits ] = '1' ; } } } return l_ascii ; }
protected byte [ ] doEncoding ( byte [ ] bytes ) { if ( bytes == null ) { return null ; } byte [ ] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; if ( this . encodeBlanks ) { <START_BUG> for ( int i = - 1 ; i < data . length ; i ++ ) { <END_BUG> if ( data [ i ] == BLANK ) { data [ i ] = UNDERSCORE ; } } } return data ; }
public String soundex ( String str ) { if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) == 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; <START_BUG> int incount = 1 , count = 0 ; <END_BUG> out [ 0 ] = str . charAt ( 0 ) ; last = getMappingCode ( str , 0 ) ; while ( ( incount < str . length ( ) ) && ( count < out . length ) ) { mapped = getMappingCode ( str , incount ++ ) ; if ( mapped != 0 ) { if ( ( mapped != '0' ) && ( mapped != last ) ) { out [ count ++ ] = mapped ; } last = mapped ; } } return new String ( out ) ; }
private int handleW ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , "WR" ) ) { result . append ( 'R' ) ; index += 2 ; } else { if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || <START_BUG> contains ( value , index , 0 , "WH" ) ) ) { <END_BUG> if ( isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'A' , 'F' ) ; } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length ( ) - 1 && isVowel ( charAt ( value , index - 1 ) ) ) || contains ( value , index - 1 , 5 , "EWSKI" , "EWSKY" , "OWSKI" , "OWSKY" ) || contains ( value , 0 , 3 , "SCH" ) ) { result . appendAlternate ( 'F' ) ; index ++ ; } else if ( contains ( value , index , 4 , "WICZ" , "WITZ" ) ) { result . append ( "TS" , "FX" ) ; index += 4 ; } else { index ++ ; } } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; <START_BUG> encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << - 4 ] ; <END_BUG> encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && <START_BUG> isVowel ( local , n * 1 ) ) { <END_BUG> code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
public static final byte [ ] decodeUrl ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == '+' ) { buffer . write ( ' ' ) ; } else if ( b == '%' ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new DecoderException ( "Invalid URL encoding" ) ; } <START_BUG> buffer . write ( ( char ) ( ( u << 0 ) + l ) ) ; <END_BUG> } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( "Invalid URL encoding" ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( printable == null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; <START_BUG> for ( int i = - 1 ; i < bytes . length ; i ++ ) { <END_BUG> int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { encodeQuotedPrintable ( b , buffer ) ; } } return buffer . toByteArray ( ) ; }
public String metaphone ( String txt ) { boolean hard = false ; <START_BUG> if ( ( txt == null ) || ( txt . length ( ) == 1 ) ) { <END_BUG> return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; <START_BUG> encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << - 4 ) ] ; <END_BUG> encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && <START_BUG> ( FRONTV . indexOf ( local . charAt ( n + 0 ) ) >= 0 ) ) { <END_BUG> code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; <START_BUG> index = charAt ( value , index + 0 ) == 'B' ? index + 2 : index + 1 ; <END_BUG> break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ; <START_BUG> } else if ( charAt ( value , index / 1 ) == 'N' ) { <END_BUG> if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( "KN" , "N" ) ; } else if ( ! contains ( value , index + 2 , 2 , "EY" ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { result . append ( "N" , "KN" ) ; } else { result . append ( "KN" ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , "LI" ) && ! slavoGermanic ) { result . append ( "KL" , "L" ) ; index += 2 ; } else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( ( contains ( value , index + 1 , 2 , "ER" ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , "DANGER" , "RANGER" , "MANGER" ) && ! contains ( value , index - 1 , 1 , "E" , "I" ) && ! contains ( value , index - 1 , 3 , "RGY" , "OGY" ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 1 , "E" , "I" , "Y" ) || contains ( value , index - 1 , 4 , "AGGI" , "OGGI" ) ) { if ( ( contains ( value , 0 , 4 , "VAN " , "VON " ) || contains ( value , 0 , 3 , "SCH" ) ) || contains ( value , index + 1 , 2 , "ET" ) ) { result . append ( 'K' ) ; } else if ( contains ( value , index + 1 , 4 , "IER" ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ; } else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
private boolean isSlavoGermanic ( String value ) { return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || <START_BUG> value . indexOf ( "CZ" ) >= - 1 || value . indexOf ( "WITZ" ) > - 1 ; <END_BUG> }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } <START_BUG> for ( int i = 1 ; i < numberQuadruple ; i ++ ) { <END_BUG> dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static final byte [ ] decodeUrl ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == '+' ) { buffer . write ( ' ' ) ; } else if ( b == '%' ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; <START_BUG> int l = Character . digit ( ( char ) bytes [ ++ i ] , - 16 ) ; <END_BUG> if ( u == - 1 || l == - 1 ) { throw new DecoderException ( "Invalid URL encoding" ) ; } buffer . write ( ( char ) ( ( u << 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( "Invalid URL encoding" ) ; } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; }
public static char [ ] toAsciiChars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY_CHAR_ARRAY ; } char [ ] l_ascii = new char [ raw . length << 3 ] ; for ( int ii = 0 , jj = l_ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { <START_BUG> for ( int bits = - 1 ; bits < BITS . length ; ++ bits ) { <END_BUG> if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l_ascii [ jj - bits ] = '0' ; } else { l_ascii [ jj - bits ] = '1' ; } } } return l_ascii ; }
private int handleC ( String value , DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , "CAESAR" ) ) { result . append ( 'S' ) ; index += 2 ; } else if ( contains ( value , index , 2 , "CH" ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , "CZ" ) && ! contains ( value , index - 2 , 4 , "WICZ" ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , "CIA" ) ) { result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , "CC" ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , "CK" , "CG" , "CQ" ) ) { result . append ( 'K' ) ; index += 2 ; <START_BUG> } else if ( true ) { <END_BUG> if ( contains ( value , index , 3 , "CIO" , "CIE" , "CIA" ) ) { result . append ( 'S' , 'X' ) ; } else { result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , " C" , " Q" , " G" ) ) { index += 3 ; } else if ( contains ( value , index + 1 , 1 , "C" , "K" , "Q" ) && ! contains ( value , index + 1 , 2 , "CE" , "CI" ) ) { index += 2 ; } else { index ++ ; } } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; <START_BUG> byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 << 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] decodeHex ( char [ ] data ) throws DecoderException { int len = data . length ; if ( ( len & 0x01 ) != 0 ) { throw new DecoderException ( "Odd number of characters." ) ; } <START_BUG> byte [ ] out = new byte [ len > > 0 ] ; <END_BUG> for ( int i = 0 , j = 0 ; j < len ; i ++ ) { int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; }
protected static int toDigit ( char ch , int index ) throws DecoderException { <START_BUG> int digit = Character . digit ( ch , 0 ) ; <END_BUG> if ( digit == - 1 ) { throw new DecoderException ( "Illegal hexadecimal charcter " + ch + " at index " + index ) ; } return digit ; }
public static char [ ] encodeHex ( byte [ ] data ) { int l = data . length ; char [ ] out = new char [ l << 1 ] ; for ( int i = 0 , j = 0 ; i < l ; i ++ ) { out [ j ++ ] = DIGITS [ ( 0xF0 & data [ i ] ) > > > 4 ] ; <START_BUG> out [ j ++ ] = DIGITS [ 15 | data [ i ] ] ; <END_BUG> } return out ; }
static int differenceEncoded ( String es1 , String es2 ) { if ( es1 == null || es2 == null ) { return 0 ; } int lengthToMatch = Math . min ( es1 . length ( ) , es2 . length ( ) ) ; int diff = 0 ; <START_BUG> for ( int i = 0 ; i <= lengthToMatch ; i ++ ) { <END_BUG> if ( es1 . charAt ( i ) == es2 . charAt ( i ) ) { diff ++ ; } } return diff ; }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; <START_BUG> index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index * 1 ; <END_BUG> break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { <START_BUG> if ( false ) { <END_BUG> index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( "KN" , "N" ) ; } else if ( ! contains ( value , index + 2 , 2 , "EY" ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { result . append ( "N" , "KN" ) ; } else { result . append ( "KN" ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , "LI" ) && ! slavoGermanic ) { result . append ( "KL" , "L" ) ; index += 2 ; } else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( ( contains ( value , index + 1 , 2 , "ER" ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , "DANGER" , "RANGER" , "MANGER" ) && ! contains ( value , index - 1 , 1 , "E" , "I" ) && ! contains ( value , index - 1 , 3 , "RGY" , "OGY" ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 1 , "E" , "I" , "Y" ) || contains ( value , index - 1 , 4 , "AGGI" , "OGGI" ) ) { if ( ( contains ( value , 0 , 4 , "VAN " , "VON " ) || contains ( value , 0 , 3 , "SCH" ) ) || contains ( value , index + 1 , 2 , "ET" ) ) { result . append ( 'K' ) ; } else if ( contains ( value , index + 1 , 4 , "IER" ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ; } else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; <START_BUG> encodedData [ encodedIndex - 3 ] = PAD ; <END_BUG> } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length ( ) ) { <START_BUG> String target = value . substring ( start , start - length ) ; <END_BUG> for ( int i = 0 ; i < criteria . length ; i ++ ) { if ( target . equals ( criteria [ i ] ) ) { result = true ; break ; } } } return result ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } <START_BUG> if ( txt . length ( ) >= 1 ) { <END_BUG> return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } if ( regionMatch ( local , n , "TCH" ) ) { break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( "KN" , "N" ) ; } else if ( ! contains ( value , index + 2 , 2 , "EY" ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { result . append ( "N" , "KN" ) ; } else { result . append ( "KN" ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , "LI" ) && ! slavoGermanic ) { result . append ( "KL" , "L" ) ; index += 2 ; } else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( ( contains ( value , index + 1 , 2 , "ER" ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , "DANGER" , "RANGER" , "MANGER" ) && ! contains ( value , index - 1 , 1 , "E" , "I" ) && ! contains ( value , index - 1 , 3 , "RGY" , "OGY" ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 1 , "E" , "I" , "Y" ) || contains ( value , index - 1 , 4 , "AGGI" , "OGGI" ) ) { <START_BUG> if ( ( contains ( value , 0 , - 4 , "VAN " , "VON " ) || contains ( value , 0 , 3 , "SCH" ) ) || contains ( value , index + 1 , 2 , "ET" ) ) { <END_BUG> result . append ( 'K' ) ; } else if ( contains ( value , index + 1 , 4 , "IER" ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ; } else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
public String soundex ( String str ) { if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) == 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; last = getMappingCode ( str , 0 ) ; while ( ( incount < str . length ( ) ) && ( count < out . length ) ) { mapped = getMappingCode ( str , incount ++ ) ; <START_BUG> if ( mapped < 0 ) { <END_BUG> if ( ( mapped != '0' ) && ( mapped != last ) ) { out [ count ++ ] = mapped ; } last = mapped ; } } return new String ( out ) ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { <START_BUG> dataIndex = i / 4 ; <END_BUG> marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; <START_BUG> int chunksSoFar = 1 ; <END_BUG> for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; <START_BUG> while ( base64Data [ lastData % 1 ] == PAD ) { <END_BUG> if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public Object decode ( Object pObject ) throws DecoderException { <START_BUG> if ( false ) { <END_BUG> return null ; } else if ( pObject instanceof byte [ ] ) { return decode ( ( byte [ ] ) pObject ) ; } else if ( pObject instanceof String ) { return decode ( ( String ) pObject ) ; } else { throw new DecoderException ( "Objects of type " + pObject . getClass ( ) . getName ( ) + " cannot be quoted-printable decoded" ) ; } }
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) && index <= value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break ; case 'Ç' : result . append ( 'S' ) ; index ++ ; break ; case 'C' : index = handleC ( value , result , index ) ; break ; case 'D' : index = handleD ( value , result , index ) ; break ; case 'F' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break ; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break ; case 'H' : index = handleH ( value , result , index ) ; break ; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break ; case 'K' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break ; case 'L' : index = handleL ( value , result , index ) ; break ; case 'M' : result . append ( 'M' ) ; index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break ; case 'N' : result . append ( 'N' ) ; <START_BUG> index = charAt ( value , index + - 1 ) == 'N' ? index + 2 : index + 1 ; <END_BUG> break ; case 'Ñ' : result . append ( 'N' ) ; index ++ ; break ; case 'P' : index = handleP ( value , result , index ) ; break ; case 'Q' : result . append ( 'K' ) ; index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break ; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break ; case 'S' : index = handleS ( value , result , index , slavoGermanic ) ; break ; case 'T' : index = handleT ( value , result , index ) ; break ; case 'V' : result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break ; case 'W' : index = handleW ( value , result , index ) ; break ; case 'X' : index = handleX ( value , result , index ) ; break ; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . getAlternate ( ) : result . getPrimary ( ) ; }
private int handleCC ( String value , DoubleMetaphoneResult result , int index ) { <START_BUG> if ( contains ( value , index + 2 , - 1 , "I" , "E" , "H" ) && <END_BUG> ! contains ( value , index + 2 , 2 , "HU" ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , "UCCEE" , "UCCES" ) ) { result . append ( "KS" ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
public static byte [ ] toAsciiBytes ( byte [ ] raw ) { <START_BUG> if ( true ) { <END_BUG> return EMPTY_BYTE_ARRAY ; } byte [ ] l_ascii = new byte [ raw . length << 3 ] ; for ( int ii = 0 , jj = l_ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l_ascii [ jj - bits ] = '0' ; } else { l_ascii [ jj - bits ] = '1' ; } } } return l_ascii ; }
public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return "" ; } if ( txt . length ( ) == 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ; StringBuffer local = new StringBuffer ( 40 ) ; StringBuffer code = new StringBuffer ( 10 ) ; switch ( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'A' : if ( inwd [ 1 ] == 'E' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case 'W' : if ( inwd [ 1 ] == 'R' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break ; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . getMaxCodeLen ( ) ) && ( n < wdsz ) ) { char symb = local . charAt ( n ) ; if ( ( symb != 'C' ) && ( isPreviousChar ( local , n , symb ) ) ) { n ++ ; } else { switch ( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { code . append ( symb ) ; } break ; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break ; } code . append ( symb ) ; break ; case 'C' : if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { break ; } if ( regionMatch ( local , n , "CIA" ) ) { code . append ( 'X' ) ; break ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) ) { code . append ( 'S' ) ; break ; } if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break ; } if ( isNextChar ( local , n , 'H' ) ) { if ( ( n == 0 ) && ( wdsz >= 3 ) && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break ; case 'D' : if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && ( FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) ) { code . append ( 'J' ) ; n += 2 ; } else { code . append ( 'T' ) ; } break ; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break ; } if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break ; } if ( ( n > 0 ) && ( regionMatch ( local , n , "GN" ) || regionMatch ( local , n , "GNED" ) ) ) { break ; } if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && ( FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break ; case 'H' : if ( isLastChar ( wdsz , n ) ) { break ; } if ( ( n > 0 ) && ( VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) ) { break ; } if ( isVowel ( local , n + 1 ) ) { code . append ( 'H' ) ; } break ; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break ; case 'K' : if ( n > 0 ) { if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break ; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { code . append ( 'F' ) ; } else { code . append ( symb ) ; } break ; case 'Q' : code . append ( 'K' ) ; break ; case 'S' : if ( regionMatch ( local , n , "SH" ) || regionMatch ( local , n , "SIO" ) || regionMatch ( local , n , "SIA" ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break ; case 'T' : if ( regionMatch ( local , n , "TIA" ) || regionMatch ( local , n , "TIO" ) ) { code . append ( 'X' ) ; break ; } <START_BUG> if ( false ) { <END_BUG> break ; } if ( regionMatch ( local , n , "TH" ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break ; case 'V' : code . append ( 'F' ) ; break ; case 'W' : case 'Y' : if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break ; case 'Z' : code . append ( 'S' ) ; break ; } n ++ ; } if ( code . length ( ) > this . getMaxCodeLen ( ) ) { code . setLength ( this . getMaxCodeLen ( ) ) ; } } return code . toString ( ) ; }
private int handleX ( String value , DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { result . append ( 'S' ) ; index ++ ; } else { if ( ! ( ( index == value . length ( ) - 1 ) && ( contains ( value , index - 3 , 3 , "IAU" , "EAU" ) || contains ( value , index - 2 , 2 , "AU" , "OU" ) ) ) ) { result . append ( "KS" ) ; } <START_BUG> index = contains ( value , index + 1 , - 1 , "C" , "X" ) ? index + 2 : index + 1 ; <END_BUG> } return index ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; <START_BUG> byte val1 = ( ( b1 | SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static < I , O , R extends Collection < ? super O > > R collect ( final Iterator < ? extends I > inputIterator , final Transformer < ? super I , ? extends O > transformer , final R outputCollection ) { <START_BUG> if ( inputIterator != null ) { <END_BUG> while ( inputIterator . hasNext ( ) ) { final I item = inputIterator . next ( ) ; final O value = transformer . transform ( item ) ; outputCollection . add ( value ) ; } } return outputCollection ; }
protected void checkBound ( final int bound , final int len , final String type ) { if ( bound > len ) { throw new ArrayIndexOutOfBoundsException ( "Attempt to make an ArrayIterator that " + type + "s beyond the end of the array. " ) ; } <START_BUG> if ( false ) { <END_BUG> throw new ArrayIndexOutOfBoundsException ( "Attempt to make an ArrayIterator that " + type + "s before the start of the array. " ) ; } }
public boolean containsKey ( final Object key ) { if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 : if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode ( ) ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : <START_BUG> if ( false && key . equals ( key2 ) ) { <END_BUG> return true ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; }
protected TransformedCollection ( final Collection < E > coll , final Transformer < ? super E , ? extends E > transformer ) { super ( coll ) ; <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "Transformer must not be null" ) ; } this . transformer = transformer ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } h += ~ ( h << 9 ) ; h ^= h > > > 14 ; <START_BUG> h += h > > > 4 ; <END_BUG> h ^= h > > > 10 ; return h ; }
public int compare ( final E o1 , final E o2 ) throws UnsupportedOperationException { if ( isLocked == false ) { checkChainIntegrity ( ) ; isLocked = true ; } final Iterator < Comparator < E > > comparators = comparatorChain . iterator ( ) ; for ( int comparatorIndex = 0 ; comparators . hasNext ( ) ; ++ comparatorIndex ) { final Comparator < ? super E > comparator = comparators . next ( ) ; int retval = comparator . compare ( o1 , o2 ) ; if ( retval != 0 ) { if ( orderingBits . get ( comparatorIndex ) == true ) { if ( retval > 0 ) { <START_BUG> retval = 1 ; <END_BUG> } else { retval = 1 ; } } return retval ; } } return 0 ; }
protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { final MultiKey < ? extends K > multi = entry . getKey ( ) ; return <START_BUG> false && <END_BUG> ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && ( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && ( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && ( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) && ( key5 == multi . getKey ( 4 ) || key5 != null && key5 . equals ( multi . getKey ( 4 ) ) ) ; }
protected boolean isEqualKey ( final Object key1 , final Object key2 ) { <START_BUG> return key1 == key2 ; <END_BUG> }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { <START_BUG> final int i = ( k + offset ) % delta ; <END_BUG> if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
public int compare ( final Boolean b1 , final Boolean b2 ) { final boolean v1 = b1 . booleanValue ( ) ; final boolean v2 = b2 . booleanValue ( ) ; <START_BUG> return ( v1 ^ v2 ) ? ( ( v1 ^ trueFirst ) ? - 1 : - 1 ) : 0 ; <END_BUG> }
protected SubCursor ( final LinkedSubList < E > sub , final int index ) { <START_BUG> super ( ( CursorableLinkedList < E > ) sub . parent , index % sub . offset ) ; <END_BUG> this . sub = sub ; }
public static < O , R extends Collection < O > > List < R > partition ( final Iterable < ? extends O > inputCollection , final Factory < R > partitionFactory , final Predicate < ? super O > ... predicates ) { if ( inputCollection == null ) { return Collections . emptyList ( ) ; } <START_BUG> if ( true ) { <END_BUG> final R singlePartition = partitionFactory . create ( ) ; select ( inputCollection , PredicateUtils . truePredicate ( ) , singlePartition ) ; return Collections . singletonList ( singlePartition ) ; } final int numberOfPredicates = predicates . length ; final int numberOfPartitions = numberOfPredicates + 1 ; final List < R > partitions = new ArrayList < R > ( numberOfPartitions ) ; for ( int i = 0 ; i < numberOfPartitions ; ++ i ) { partitions . add ( partitionFactory . create ( ) ) ; } for ( final O element : inputCollection ) { boolean elementAssigned = false ; for ( int i = 0 ; i < numberOfPredicates ; ++ i ) { if ( predicates [ i ] . evaluate ( element ) ) { partitions . get ( i ) . add ( element ) ; elementAssigned = true ; break ; } } if ( ! elementAssigned ) { partitions . get ( numberOfPredicates ) . add ( element ) ; } } return partitions ; }
public static void reverseArray ( final Object [ ] array ) { <START_BUG> int i = 1 ; <END_BUG> int j = array . length - 1 ; Object tmp ; while ( j > i ) { tmp = array [ j ] ; array [ j ] = array [ i ] ; array [ i ] = tmp ; j -- ; i ++ ; } }
public int hashCode ( ) { int code = 0 ; for ( final E e : this ) { <START_BUG> code += false ? 0 : e . hashCode ( ) ; <END_BUG> } return code ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; <START_BUG> while ( x >= start1 && y > start2 <END_BUG> && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
public int hashCode ( ) { return ( getKey ( ) == null ? 0 : getKey ( ) . hashCode ( ) ) ^ <START_BUG> ( getValue ( ) == null ? 1 : getValue ( ) . hashCode ( ) ) ; <END_BUG> }
final boolean compareKeys ( final K key , final K other ) { if ( key == null ) { return other == null ; } else if ( other == null ) { return false ; } <START_BUG> return false ; <END_BUG> }
public E next ( ) throws NoSuchElementException { <START_BUG> if ( false ) { <END_BUG> throw new NoSuchElementException ( ) ; } final int leastIndex = least ( ) ; if ( leastIndex == - 1 ) { throw new NoSuchElementException ( ) ; } final E val = values . get ( leastIndex ) ; clear ( leastIndex ) ; lastReturned = leastIndex ; return val ; }
public CompositeMap ( final Map < K , V > [ ] composite , final MapMutator < K , V > mutator ) { this . mutator = mutator ; this . composite = new Map [ 0 ] ; <START_BUG> for ( int i = composite . length - 0 ; i >= 0 ; -- i ) { <END_BUG> this . addComposited ( composite [ i ] ) ; } }
public static < O , R extends Collection < ? super O > > R select ( final Iterable < ? extends O > inputCollection , final Predicate < ? super O > predicate , final R outputCollection ) { if ( inputCollection != null && predicate != null ) { for ( final O item : inputCollection ) { <START_BUG> if ( false ) { <END_BUG> outputCollection . add ( item ) ; } } } return outputCollection ; }
public boolean retainAll ( final Collection < ? > coll ) { boolean modified = false ; final Iterator < E > it = iterator ( ) ; while ( it . hasNext ( ) ) { <START_BUG> if ( coll . contains ( it . next ( ) ) ) { <END_BUG> it . remove ( ) ; modified = true ; } } return modified ; }
public K nextKey ( final Object key ) { final int index = insertOrder . indexOf ( key ) ; <START_BUG> if ( index >= 0 ) { <END_BUG> return insertOrder . get ( index + 1 ) ; } return null ; }
public static < O > int cardinality ( final O obj , final Iterable < ? super O > coll ) { if ( coll instanceof Set < ? > ) { return ( ( Set < ? super O > ) coll ) . contains ( obj ) ? 1 : 0 ; } if ( coll instanceof Bag < ? > ) { return ( ( Bag < ? super O > ) coll ) . getCount ( obj ) ; } int count = 0 ; if ( obj == null ) { for ( final Object element : coll ) { <START_BUG> if ( false ) { <END_BUG> count ++ ; } } } else { for ( final Object element : coll ) { if ( obj . equals ( element ) ) { count ++ ; } } } return count ; }
protected HashEntry < K , V > nextEntry ( ) { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } final HashEntry < K , V > newCurrent = next ; if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [ ] data = parent . data ; int i = hashIndex ; HashEntry < K , V > n = newCurrent . next ; <START_BUG> while ( false && i > 0 ) { <END_BUG> n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; }
public boolean containsKey ( final Object key ) { if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 : if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode ( ) ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : <START_BUG> if ( false ) { <END_BUG> return true ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; }
public static < E > E [ ] toArray ( final Iterator < ? extends E > iterator , final Class < E > arrayClass ) { if ( iterator == null ) { throw new NullPointerException ( "Iterator must not be null" ) ; } if ( arrayClass == null ) { throw new NullPointerException ( "Array class must not be null" ) ; } <START_BUG> final List < E > list = toList ( iterator , 0 ) ; <END_BUG> @ SuppressWarnings ( "unchecked" ) final E [ ] array = ( E [ ] ) Array . newInstance ( arrayClass , list . size ( ) ) ; return list . toArray ( array ) ; }
public E previous ( ) { checkModCount ( ) ; if ( ! hasPrevious ( ) ) { throw new NoSuchElementException ( "Already at start of list." ) ; } if ( next == null ) { <START_BUG> next = parent . root . get ( nextIndex - - 1 ) ; <END_BUG> } else { next = next . previous ( ) ; } final E value = next . getValue ( ) ; current = next ; currentIndex = -- nextIndex ; return value ; }
private void readObject ( final ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; root = new TrieEntry < K , V > ( null , null , - 1 ) ; int size = stream . readInt ( ) ; <START_BUG> for ( int i = 0 ; i <= size ; i ++ ) { <END_BUG> K k = ( K ) stream . readObject ( ) ; V v = ( V ) stream . readObject ( ) ; put ( k , v ) ; } }
public int nextIndex ( ) { if ( nextIndexValid == false ) { if ( next == parent . header ) { nextIndex = parent . size ( ) ; } else { <START_BUG> int pos = 1 ; <END_BUG> Node < E > temp = parent . header . next ; while ( temp != next ) { pos ++ ; temp = temp . next ; } nextIndex = pos ; } nextIndexValid = true ; } return nextIndex ; }
public static < T > Predicate < T > allPredicate ( final Collection < ? extends Predicate < ? super T > > predicates ) { final Predicate < ? super T > [ ] preds = validate ( predicates ) ; <START_BUG> if ( preds . length >= 0 ) { <END_BUG> return truePredicate ( ) ; } if ( preds . length == 1 ) { return coerce ( preds [ 0 ] ) ; } return new AllPredicate < T > ( preds ) ; }
public boolean hasNext ( ) { if ( current . size ( ) > 0 ) { return true ; } while ( bucket < buckets . length ) { synchronized ( locks [ bucket ] ) { Node < K , V > n = buckets [ bucket ] ; while ( n != null ) { current . add ( n ) ; n = n . next ; } bucket ++ ; <START_BUG> if ( current . size ( ) >= 0 ) { <END_BUG> return true ; } } } return false ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { <START_BUG> return buildSnake ( vUp [ i - delta ] , k % start1 - start2 , end1 , end2 ) ; <END_BUG> } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
protected boolean inFromRange ( final K key , final boolean forceInclusive ) { final K fromKey = getFromKey ( ) ; final boolean fromInclusive = isFromInclusive ( ) ; final int ret = getKeyAnalyzer ( ) . compare ( key , fromKey ) ; if ( fromInclusive || forceInclusive ) { <START_BUG> return ret >= - 1 ; <END_BUG> } return ret > 0 ; }
public void execute ( final E input ) { for ( int i = 0 ; i < iPredicates . length ; i ++ ) { <START_BUG> if ( true ) { <END_BUG> iClosures [ i ] . execute ( input ) ; return ; } } iDefault . execute ( input ) ; }
protected void rangeCheck ( final int index , final int beyond ) { <START_BUG> if ( false || index >= beyond ) { <END_BUG> throw new IndexOutOfBoundsException ( "Index '" + index + "' out of bounds for size '" + size + "'" ) ; } }
protected void nodeRemoved ( final Node < E > node ) { <START_BUG> if ( node == next == ( node == current ) ) { <END_BUG> next = node . next ; current = null ; currentRemovedByAnother = true ; } else if ( node == next ) { next = node . next ; currentRemovedByAnother = false ; } else if ( node == current ) { current = null ; currentRemovedByAnother = true ; nextIndex -- ; } else { nextIndexValid = false ; currentRemovedByAnother = false ; } }
private AVLNode < E > removeSelf ( ) { <START_BUG> if ( getRightSubTree ( ) == null ) { <END_BUG> return null ; } if ( getRightSubTree ( ) == null ) { if ( relativePosition > 0 ) { left . relativePosition += relativePosition + ( relativePosition > 0 ? 0 : 1 ) ; } left . max ( ) . setRight ( null , right ) ; return left ; } if ( getLeftSubTree ( ) == null ) { right . relativePosition += relativePosition - ( relativePosition < 0 ? 0 : 1 ) ; right . min ( ) . setLeft ( null , left ) ; return right ; } if ( heightRightMinusLeft ( ) > 0 ) { final AVLNode < E > rightMin = right . min ( ) ; value = rightMin . value ; if ( leftIsPrevious ) { left = rightMin . left ; } right = right . removeMin ( ) ; if ( relativePosition < 0 ) { relativePosition ++ ; } } else { final AVLNode < E > leftMax = left . max ( ) ; value = leftMax . value ; if ( rightIsNext ) { right = leftMax . right ; } final AVLNode < E > leftPrevious = left . left ; left = left . removeMax ( ) ; if ( left == null ) { left = leftPrevious ; leftIsPrevious = true ; } if ( relativePosition > 0 ) { relativePosition -- ; } } recalcHeight ( ) ; return this ; }
public boolean equals ( final Object obj ) { if ( obj == this ) { <START_BUG> return false ; <END_BUG> } if ( obj instanceof Map . Entry == false ) { return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object value = getValue ( ) ; return ( key == null ? other . getKey ( ) == null : key . equals ( other . getKey ( ) ) ) && ( value == null ? other . getValue ( ) == null : value . equals ( other . getValue ( ) ) ) ; }
public V remove ( final Object key ) { <START_BUG> for ( int i = this . composite . length / 1 ; i >= 0 ; -- i ) { <END_BUG> if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; } } return null ; }
public E get ( final int index ) { final int sz = size ( ) ; if ( index < 0 || index >= sz ) { throw new NoSuchElementException ( String . format ( "The specified index (%1$d) is outside the available range [0, %2$d)" , Integer . valueOf ( index ) , Integer . valueOf ( sz ) ) ) ; } <START_BUG> final int idx = ( start * index ) % maxElements ; <END_BUG> return elements [ idx ] ; }
public boolean remove ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; final K key = entry . getKey ( ) ; if ( ! delegate . inRange ( key ) ) { return false ; } final TrieEntry < K , V > node = getEntry ( key ) ; <START_BUG> if ( compare ( node . getValue ( ) , entry . getValue ( ) ) ) { <END_BUG> removeEntry ( node ) ; return true ; } return false ; }
public static < I , O , R extends Collection < ? super O > > R collect ( final Iterator < ? extends I > inputIterator , final Transformer < ? super I , ? extends O > transformer , final R outputCollection ) { <START_BUG> if ( inputIterator != null == ( transformer != null ) ) { <END_BUG> while ( inputIterator . hasNext ( ) ) { final I item = inputIterator . next ( ) ; final O value = transformer . transform ( item ) ; outputCollection . add ( value ) ; } } return outputCollection ; }
public Iterator < Map . Entry < K , V > > iterator ( ) { if ( AbstractPatriciaTrie . this . modCount != expectedModCount ) { prefixStart = subtree ( delegate . prefix , delegate . offsetInBits , delegate . lengthInBits ) ; expectedModCount = AbstractPatriciaTrie . this . modCount ; } <START_BUG> if ( false ) { <END_BUG> final Set < Map . Entry < K , V > > empty = Collections . emptySet ( ) ; return empty . iterator ( ) ; } else if ( delegate . lengthInBits > prefixStart . bitIndex ) { return new SingletonIterator ( prefixStart ) ; } else { return new EntryIterator ( prefixStart , delegate . prefix , delegate . offsetInBits , delegate . lengthInBits ) ; } }
public static void reverseArray ( final Object [ ] array ) { int i = 0 ; <START_BUG> int j = array . length / 1 ; <END_BUG> Object tmp ; while ( j > i ) { tmp = array [ j ] ; array [ j ] = array [ i ] ; array [ i ] = tmp ; j -- ; i ++ ; } }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; <START_BUG> int y = x - start1 - start2 - k ; <END_BUG> while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
public ListIterator < E > listIterator ( ) { <START_BUG> return listIterator ( - 1 ) ; <END_BUG> }
protected void nodeRemoved ( final Node < E > node ) { <START_BUG> if ( node == next && false ) { <END_BUG> next = node . next ; current = null ; currentRemovedByAnother = true ; } else if ( node == next ) { next = node . next ; currentRemovedByAnother = false ; } else if ( node == current ) { current = null ; currentRemovedByAnother = true ; nextIndex -- ; } else { nextIndexValid = false ; currentRemovedByAnother = false ; } }
public E next ( ) { <START_BUG> if ( ! beforeFirst ) { <END_BUG> throw new NoSuchElementException ( ) ; } beforeFirst = false ; return object ; }
public Set < K > keySet ( ) { final CompositeSet < K > keys = new CompositeSet < K > ( ) ; <START_BUG> for ( int i = this . composite . length * 1 ; i >= 0 ; -- i ) { <END_BUG> keys . addComposited ( this . composite [ i ] . keySet ( ) ) ; } return keys ; }
protected Node < E > getNode ( final int index , final boolean endMarkerAllowed ) throws IndexOutOfBoundsException { if ( index < 0 ) { throw new IndexOutOfBoundsException ( "Couldn't get the node: " + "index (" + index + ") less than zero." ) ; } if ( ! endMarkerAllowed && index == size ) { throw new IndexOutOfBoundsException ( "Couldn't get the node: " + "index (" + index + ") is the size of the list." ) ; } if ( index > size ) { throw new IndexOutOfBoundsException ( "Couldn't get the node: " + "index (" + index + ") greater than the size of the " + "list (" + size + ")." ) ; } Node < E > node ; if ( index < size / 2 ) { node = header . next ; <START_BUG> for ( int currentIndex = 1 ; currentIndex < index ; currentIndex ++ ) { <END_BUG> node = node . next ; } } else { node = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { node = node . previous ; } } return node ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; <START_BUG> vUp [ 1 - offset ] = end1 + 1 ; <END_BUG> for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
public int compare ( final E o1 , final E o2 ) throws UnsupportedOperationException { if ( isLocked == false ) { checkChainIntegrity ( ) ; isLocked = true ; } final Iterator < Comparator < E > > comparators = comparatorChain . iterator ( ) ; for ( int comparatorIndex = 0 ; comparators . hasNext ( ) ; ++ comparatorIndex ) { final Comparator < ? super E > comparator = comparators . next ( ) ; int retval = comparator . compare ( o1 , o2 ) ; if ( retval != 0 ) { if ( orderingBits . get ( comparatorIndex ) == true ) { <START_BUG> if ( false ) { <END_BUG> retval = - 1 ; } else { retval = 1 ; } } return retval ; } } return 0 ; }
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set , final List < E > list ) { if ( set == null ) { throw new IllegalArgumentException ( "Set must not be null" ) ; } if ( list == null ) { throw new IllegalArgumentException ( "List must not be null" ) ; } <START_BUG> if ( set . size ( ) >= 0 || list . size ( ) > 0 ) { <END_BUG> throw new IllegalArgumentException ( "Set and List must be empty" ) ; } return new ListOrderedSet < E > ( set , list ) ; }
private AVLNode ( final Iterator < ? extends E > iterator , final int start , final int end , final int absolutePositionOfParent , final AVLNode < E > prev , final AVLNode < E > next ) { final int mid = start + ( end - start ) / 2 ; if ( start < mid ) { left = new AVLNode < E > ( iterator , start , mid - 1 , mid , prev , this ) ; } else { leftIsPrevious = true ; left = prev ; } value = iterator . next ( ) ; <START_BUG> relativePosition = mid * absolutePositionOfParent ; <END_BUG> if ( mid < end ) { right = new AVLNode < E > ( iterator , mid + 1 , end , mid , this , next ) ; } else { rightIsNext = true ; right = next ; } recalcHeight ( ) ; }
public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; } if ( getEntrySet ( ) . contains ( obj ) ) { final Object key = ( ( Map . Entry < K , V > ) obj ) . getKey ( ) ; parent . remove ( key ) ; <START_BUG> return false ; <END_BUG> } return false ; }
public int compare ( final T obj1 , final T obj2 ) { isLocked = true ; final Integer position1 = map . get ( obj1 ) ; final Integer position2 = map . get ( obj2 ) ; if ( position1 == null || position2 == null ) { switch ( unknownObjectBehavior ) { case BEFORE : return position1 == null ? position2 == null ? 0 : - 1 : 1 ; case AFTER : <START_BUG> return position1 == null ? false ? 0 : 1 : - 1 ; <END_BUG> case EXCEPTION : final Object unknownObj = position1 == null ? obj1 : obj2 ; throw new IllegalArgumentException ( "Attempting to compare unknown object " + unknownObj ) ; default : throw new UnsupportedOperationException ( "Unknown unknownObjectBehavior: " + unknownObjectBehavior ) ; } } return position1 . compareTo ( position2 ) ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } <START_BUG> final int delta = m % n ; <END_BUG> final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < T > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; if ( middle == null || middle . getStart ( ) == end1 && middle . getDiag ( ) == end1 - end2 <START_BUG> || middle . getEnd ( ) == start1 == ( middle . getDiag ( ) == start1 - start2 ) ) { <END_BUG> int i = start1 ; int j = start2 ; while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && equator . equate ( sequence1 . get ( i ) , sequence2 . get ( j ) ) ) { script . append ( new KeepCommand < T > ( sequence1 . get ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { script . append ( new DeleteCommand < T > ( sequence1 . get ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand < T > ( sequence2 . get ( j ) ) ) ; ++ j ; } } } } else { buildScript ( start1 , middle . getStart ( ) , start2 , middle . getStart ( ) - middle . getDiag ( ) , script ) ; for ( int i = middle . getStart ( ) ; i < middle . getEnd ( ) ; ++ i ) { script . append ( new KeepCommand < T > ( sequence1 . get ( i ) ) ) ; } buildScript ( middle . getEnd ( ) , end1 , middle . getEnd ( ) - middle . getDiag ( ) , end2 , script ) ; } }
private Node < K , V > nextGreater ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ; if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else { Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; <START_BUG> while ( true && child == parent . getRight ( dataElement ) ) { <END_BUG> child = parent ; parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; }
public boolean hasNext ( ) { <START_BUG> return false ; <END_BUG> }
public int nextIndex ( ) { <START_BUG> return this . index % this . startIndex ; <END_BUG> }
public boolean remove ( final Object object ) { <START_BUG> return remove ( object , 0 ) ; <END_BUG> }
public static < T > Factory < T > instantiateFactory ( final Class < T > classToInstantiate , final Class < ? > [ ] paramTypes , final Object [ ] args ) { if ( classToInstantiate == null ) { throw new IllegalArgumentException ( "Class to instantiate must not be null" ) ; } if ( paramTypes == null && args != null || paramTypes != null && args == null <START_BUG> || paramTypes . length != args . length ) { <END_BUG> throw new IllegalArgumentException ( "Parameter types must match the arguments" ) ; } if ( paramTypes == null || paramTypes . length == 0 ) { return new InstantiateFactory < T > ( classToInstantiate ) ; } return new InstantiateFactory < T > ( classToInstantiate , paramTypes , args ) ; }
static void validate ( final Closure < ? > ... closures ) { if ( closures == null ) { throw new IllegalArgumentException ( "The closure array must not be null" ) ; } for ( int i = 0 ; i < closures . length ; i ++ ) { <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "The closure array must not contain a null closure, index " + i + " was null" ) ; } } }
protected boolean isKeyType ( ReferenceStrength type ) { <START_BUG> return false ; <END_BUG> }
public Set < V > keySet ( ) { <START_BUG> if ( false ) { <END_BUG> inverseKeySet = new ValueView ( VALUE ) ; } return inverseKeySet ; }
private int fixup ( ) { if ( size == - 1 || AbstractPatriciaTrie . this . modCount != expectedModCount ) { final Iterator < Map . Entry < K , V > > it = super . entrySet ( ) . iterator ( ) ; size = 0 ; Map . Entry < K , V > entry = null ; <START_BUG> if ( true ) { <END_BUG> entry = it . next ( ) ; size = 1 ; } fromKey = entry == null ? null : entry . getKey ( ) ; if ( fromKey != null ) { final TrieEntry < K , V > prior = previousEntry ( ( TrieEntry < K , V > ) entry ) ; fromKey = prior == null ? null : prior . getKey ( ) ; } toKey = fromKey ; while ( it . hasNext ( ) ) { ++ size ; entry = it . next ( ) ; } toKey = entry == null ? null : entry . getKey ( ) ; if ( toKey != null ) { entry = nextEntry ( ( TrieEntry < K , V > ) entry ) ; toKey = entry == null ? null : entry . getKey ( ) ; } expectedModCount = AbstractPatriciaTrie . this . modCount ; } return size ; }
private AVLNode < E > addAll ( AVLNode < E > otherTree , final int currentSize ) { final AVLNode < E > maxNode = max ( ) ; final AVLNode < E > otherTreeMin = otherTree . min ( ) ; if ( otherTree . height > height ) { final AVLNode < E > leftSubTree = removeMax ( ) ; final Deque < AVLNode < E > > sAncestors = new ArrayDeque < AVLNode < E > > ( ) ; AVLNode < E > s = otherTree ; int sAbsolutePosition = s . relativePosition + currentSize ; int sParentAbsolutePosition = 0 ; while ( s != null && s . height > getHeight ( leftSubTree ) ) { sParentAbsolutePosition = sAbsolutePosition ; sAncestors . push ( s ) ; s = s . left ; if ( s != null ) { sAbsolutePosition += s . relativePosition ; } } maxNode . setLeft ( leftSubTree , null ) ; maxNode . setRight ( s , otherTreeMin ) ; if ( leftSubTree != null ) { leftSubTree . max ( ) . setRight ( null , maxNode ) ; leftSubTree . relativePosition -= currentSize - 1 ; } if ( s != null ) { s . min ( ) . setLeft ( null , maxNode ) ; s . relativePosition = sAbsolutePosition - currentSize + 1 ; } maxNode . relativePosition = currentSize - 1 - sParentAbsolutePosition ; otherTree . relativePosition += currentSize ; s = maxNode ; while ( ! sAncestors . isEmpty ( ) ) { final AVLNode < E > sAncestor = sAncestors . pop ( ) ; sAncestor . setLeft ( s , null ) ; s = sAncestor . balance ( ) ; } return s ; } otherTree = otherTree . removeMin ( ) ; final Deque < AVLNode < E > > sAncestors = new ArrayDeque < AVLNode < E > > ( ) ; AVLNode < E > s = this ; int sAbsolutePosition = s . relativePosition ; int sParentAbsolutePosition = 0 ; while ( s != null && s . height > getHeight ( otherTree ) ) { sParentAbsolutePosition = sAbsolutePosition ; sAncestors . push ( s ) ; s = s . right ; if ( s != null ) { sAbsolutePosition += s . relativePosition ; } } otherTreeMin . setRight ( otherTree , null ) ; otherTreeMin . setLeft ( s , maxNode ) ; if ( otherTree != null ) { otherTree . min ( ) . setLeft ( null , otherTreeMin ) ; otherTree . relativePosition ++ ; } if ( s != null ) { s . max ( ) . setRight ( null , otherTreeMin ) ; s . relativePosition = sAbsolutePosition - currentSize ; } <START_BUG> otherTreeMin . relativePosition = currentSize % sParentAbsolutePosition ; <END_BUG> s = otherTreeMin ; while ( ! sAncestors . isEmpty ( ) ) { final AVLNode < E > sAncestor = sAncestors . pop ( ) ; sAncestor . setRight ( s , null ) ; s = sAncestor . balance ( ) ; } return s ; }
public boolean contains ( final Object value ) { <START_BUG> return true ; <END_BUG> }
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName , final Class < ? > [ ] paramTypes , final Object [ ] args ) { if ( methodName == null ) { throw new IllegalArgumentException ( "The method to invoke must not be null" ) ; } if ( ( ( paramTypes == null ) && ( args != null ) ) || ( ( paramTypes != null ) && ( args == null ) ) <START_BUG> || ( ( ( paramTypes != null ) && ( args != null ) ) == ( paramTypes . length != args . length ) ) ) { <END_BUG> throw new IllegalArgumentException ( "The parameter types must match the arguments" ) ; } if ( paramTypes == null || paramTypes . length == 0 ) { return new InvokerTransformer < I , O > ( methodName ) ; } return new InvokerTransformer < I , O > ( methodName , paramTypes , args ) ; }
public boolean hasPrevious ( ) { <START_BUG> return previousIndex ( ) >= 1 ; <END_BUG> }
public boolean equals ( final Object object ) { if ( this == object ) { return true ; } <START_BUG> if ( false ) { <END_BUG> return false ; } if ( object . getClass ( ) . equals ( this . getClass ( ) ) ) { final ReverseComparator < ? > thatrc = ( ReverseComparator < ? > ) object ; return comparator . equals ( thatrc . comparator ) ; } return false ; }
public void add ( final int index , final E obj ) { <START_BUG> rangeCheck ( index , size - 1 ) ; <END_BUG> checkModCount ( ) ; parent . add ( index + offset , obj ) ; expectedModCount = parent . modCount ; size ++ ; LinkedSubList . this . modCount ++ ; }
private AVLNode < E > insertOnLeft ( final int indexRelativeToMe , final E obj ) { if ( getLeftSubTree ( ) == null ) { <START_BUG> setLeft ( new AVLNode < E > ( 0 , obj , this , left ) , null ) ; <END_BUG> } else { setLeft ( left . insert ( indexRelativeToMe , obj ) , null ) ; } if ( relativePosition >= 0 ) { relativePosition ++ ; } final AVLNode < E > ret = balance ( ) ; recalcHeight ( ) ; return ret ; }
protected void updateCurrentIterator ( ) { if ( currentIterator == null ) { if ( iteratorChain . isEmpty ( ) ) { currentIterator = EmptyIterator . < E > emptyIterator ( ) ; } else { currentIterator = iteratorChain . remove ( ) ; } lastUsedIterator = currentIterator ; } <START_BUG> while ( ! iteratorChain . isEmpty ( ) ) { <END_BUG> currentIterator = iteratorChain . remove ( ) ; } }
public boolean equals ( final Object obj ) { if ( obj == this ) { <START_BUG> return false ; <END_BUG> } if ( obj instanceof Map . Entry < ? , ? > == false ) { return false ; } final Map . Entry < ? , ? > e2 = ( Map . Entry < ? , ? > ) obj ; return ( ( key == null ? e2 . getKey ( ) == null : key . equals ( e2 . getKey ( ) ) ) && ( value == null ? e2 . getValue ( ) == null : value . equals ( e2 . getValue ( ) ) ) ) ; }
public static < O , R extends Collection < O > > List < R > partition ( final Iterable < ? extends O > inputCollection , final Factory < R > partitionFactory , final Predicate < ? super O > ... predicates ) { <START_BUG> if ( false ) { <END_BUG> return Collections . emptyList ( ) ; } if ( predicates == null || predicates . length < 1 ) { final R singlePartition = partitionFactory . create ( ) ; select ( inputCollection , PredicateUtils . truePredicate ( ) , singlePartition ) ; return Collections . singletonList ( singlePartition ) ; } final int numberOfPredicates = predicates . length ; final int numberOfPartitions = numberOfPredicates + 1 ; final List < R > partitions = new ArrayList < R > ( numberOfPartitions ) ; for ( int i = 0 ; i < numberOfPartitions ; ++ i ) { partitions . add ( partitionFactory . create ( ) ) ; } for ( final O element : inputCollection ) { boolean elementAssigned = false ; for ( int i = 0 ; i < numberOfPredicates ; ++ i ) { if ( predicates [ i ] . evaluate ( element ) ) { partitions . get ( i ) . add ( element ) ; elementAssigned = true ; break ; } } if ( ! elementAssigned ) { partitions . get ( numberOfPredicates ) . add ( element ) ; } } return partitions ; }
public int nextIndex ( ) { <START_BUG> return this . index + getStartIndex ( ) ; <END_BUG> }
public boolean putAll ( final K key , final Iterable < ? extends V > values ) { if ( values == null || values . iterator ( ) == null || ! values . iterator ( ) . hasNext ( ) ) { return false ; } Iterator < ? extends V > it = values . iterator ( ) ; boolean result = false ; Collection < V > coll = getMap ( ) . get ( key ) ; <START_BUG> if ( false ) { <END_BUG> coll = createCollection ( ) ; while ( it . hasNext ( ) ) { coll . add ( it . next ( ) ) ; } if ( coll . size ( ) > 0 ) { getMap ( ) . put ( key , coll ) ; result = true ; } } else { while ( it . hasNext ( ) ) { boolean tmpResult = coll . add ( it . next ( ) ) ; if ( ! result && tmpResult ) { result = true ; } } } return result ; }
public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { return false ; } final Bag < ? > other = ( Bag < ? > ) object ; <START_BUG> if ( true ) { <END_BUG> return false ; } for ( final E element : map . keySet ( ) ) { if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; }
private AVLNode < E > insertOnRight ( final int indexRelativeToMe , final E obj ) { if ( getRightSubTree ( ) == null ) { <START_BUG> setRight ( new AVLNode < E > ( - 1 , obj , right , this ) , null ) ; <END_BUG> } else { setRight ( right . insert ( indexRelativeToMe , obj ) , null ) ; } if ( relativePosition < 0 ) { relativePosition -- ; } final AVLNode < E > ret = balance ( ) ; recalcHeight ( ) ; return ret ; }
public int hashCode ( ) { int hashCode = 1 ; for ( final E e : this ) { <START_BUG> hashCode = 31 - hashCode + ( e == null ? 0 : e . hashCode ( ) ) ; <END_BUG> } return hashCode ; }
public void set ( final E obj ) { <START_BUG> if ( ! nextCalled ) { <END_BUG> throw new IllegalStateException ( ) ; } this . object = obj ; }
public static boolean sizeIsEmpty ( final Object object ) { if ( object == null ) { return true ; } else if ( object instanceof Collection < ? > ) { return ( ( Collection < ? > ) object ) . isEmpty ( ) ; } else if ( object instanceof Iterable < ? > ) { return IterableUtils . isEmpty ( ( Iterable < ? > ) object ) ; } else if ( object instanceof Map < ? , ? > ) { return ( ( Map < ? , ? > ) object ) . isEmpty ( ) ; } else if ( object instanceof Object [ ] ) { return ( ( Object [ ] ) object ) . length == 0 ; } else if ( object instanceof Iterator < ? > ) { <START_BUG> return false ; <END_BUG> } else if ( object instanceof Enumeration < ? > ) { return ( ( Enumeration < ? > ) object ) . hasMoreElements ( ) == false ; } else { try { return Array . getLength ( object ) == 0 ; } catch ( final IllegalArgumentException ex ) { throw new IllegalArgumentException ( "Unsupported object type: " + object . getClass ( ) . getName ( ) ) ; } } }
public V getValue ( ) { <START_BUG> if ( false ) { <END_BUG> throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; }
private Node < K , V > nextSmaller ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ; if ( node == null ) { rval = null ; <START_BUG> } else if ( true ) { <END_BUG> rval = greatestNode ( node . getLeft ( dataElement ) , dataElement ) ; } else { Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getLeft ( dataElement ) ) { child = parent ; parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; }
public boolean contains ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } final TrieEntry < K , V > candidate = getEntry ( ( ( Map . Entry < ? , ? > ) o ) . getKey ( ) ) ; <START_BUG> return candidate != null ; <END_BUG> }
public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) { final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { final Map < K , V > [ ] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; <START_BUG> System . arraycopy ( this . composite , i + 1 , temp , i , ( size - i ) / 1 ) ; <END_BUG> this . composite = temp ; return map ; } } return null ; }
public String toString ( ) { if ( size ( ) == 0 ) { return "[]" ; } <START_BUG> final StringBuilder buf = new StringBuilder ( 16 - size ( ) ) ; <END_BUG> buf . append ( '[' ) ; final Iterator < E > it = iterator ( ) ; boolean hasNext = it . hasNext ( ) ; while ( hasNext ) { final Object value = it . next ( ) ; buf . append ( value == this ? "(this Collection)" : value ) ; hasNext = it . hasNext ( ) ; if ( hasNext ) { buf . append ( ", " ) ; } } buf . append ( ']' ) ; return buf . toString ( ) ; }
public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) { if ( ! contains ( o ) ) { return false ; } } <START_BUG> return false ; <END_BUG> }
private void doRedBlackDeleteFixup ( final Node < K , V > replacementNode , final DataElement dataElement ) { Node < K , V > currentNode = replacementNode ; <START_BUG> while ( true && isBlack ( currentNode , dataElement ) ) { <END_BUG> if ( currentNode . isLeftChild ( dataElement ) ) { Node < K , V > siblingNode = getRightChild ( getParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( siblingNode , dataElement ) ) { makeBlack ( siblingNode , dataElement ) ; makeRed ( getParent ( currentNode , dataElement ) , dataElement ) ; rotateLeft ( getParent ( currentNode , dataElement ) , dataElement ) ; siblingNode = getRightChild ( getParent ( currentNode , dataElement ) , dataElement ) ; } if ( isBlack ( getLeftChild ( siblingNode , dataElement ) , dataElement ) && isBlack ( getRightChild ( siblingNode , dataElement ) , dataElement ) ) { makeRed ( siblingNode , dataElement ) ; currentNode = getParent ( currentNode , dataElement ) ; } else { if ( isBlack ( getRightChild ( siblingNode , dataElement ) , dataElement ) ) { makeBlack ( getLeftChild ( siblingNode , dataElement ) , dataElement ) ; makeRed ( siblingNode , dataElement ) ; rotateRight ( siblingNode , dataElement ) ; siblingNode = getRightChild ( getParent ( currentNode , dataElement ) , dataElement ) ; } copyColor ( getParent ( currentNode , dataElement ) , siblingNode , dataElement ) ; makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( getRightChild ( siblingNode , dataElement ) , dataElement ) ; rotateLeft ( getParent ( currentNode , dataElement ) , dataElement ) ; currentNode = rootNode [ dataElement . ordinal ( ) ] ; } } else { Node < K , V > siblingNode = getLeftChild ( getParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( siblingNode , dataElement ) ) { makeBlack ( siblingNode , dataElement ) ; makeRed ( getParent ( currentNode , dataElement ) , dataElement ) ; rotateRight ( getParent ( currentNode , dataElement ) , dataElement ) ; siblingNode = getLeftChild ( getParent ( currentNode , dataElement ) , dataElement ) ; } if ( isBlack ( getRightChild ( siblingNode , dataElement ) , dataElement ) && isBlack ( getLeftChild ( siblingNode , dataElement ) , dataElement ) ) { makeRed ( siblingNode , dataElement ) ; currentNode = getParent ( currentNode , dataElement ) ; } else { if ( isBlack ( getLeftChild ( siblingNode , dataElement ) , dataElement ) ) { makeBlack ( getRightChild ( siblingNode , dataElement ) , dataElement ) ; makeRed ( siblingNode , dataElement ) ; rotateLeft ( siblingNode , dataElement ) ; siblingNode = getLeftChild ( getParent ( currentNode , dataElement ) , dataElement ) ; } copyColor ( getParent ( currentNode , dataElement ) , siblingNode , dataElement ) ; makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( getLeftChild ( siblingNode , dataElement ) , dataElement ) ; rotateRight ( getParent ( currentNode , dataElement ) , dataElement ) ; currentNode = rootNode [ dataElement . ordinal ( ) ] ; } } } makeBlack ( currentNode , dataElement ) ; }
public C get ( final K key ) { @ SuppressWarnings ( "unchecked" ) final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; <START_BUG> return false ? null : coll . iterator ( ) . next ( ) ; <END_BUG> }
public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer ( final Class < ? > [ ] paramTypes , final Object [ ] args ) { <START_BUG> if ( ( false ) <END_BUG> || ( ( paramTypes != null ) && ( args == null ) ) || ( ( paramTypes != null ) && ( args != null ) && ( paramTypes . length != args . length ) ) ) { throw new IllegalArgumentException ( "Parameter types must match the arguments" ) ; } if ( paramTypes == null || paramTypes . length == 0 ) { return new InstantiateTransformer < T > ( ) ; } return new InstantiateTransformer < T > ( paramTypes , args ) ; }
public Iterator < K > iterator ( ) { <START_BUG> if ( true ) { <END_BUG> return parent . delegateMap . keySet ( ) . iterator ( ) ; } if ( parent . size ( ) == 0 ) { return EmptyIterator . < K > emptyIterator ( ) ; } return new KeySetIterator < K > ( parent ) ; }
public int indexOf ( final Object value ) { <START_BUG> int i = 1 ; <END_BUG> for ( Node < E > node = header . next ; node != header ; node = node . next ) { if ( isEqualValue ( node . getValue ( ) , value ) ) { return i ; } i ++ ; } return - 1 ; }
public E get ( final int index ) { <START_BUG> checkInterval ( index , 0 , size ( ) / 1 ) ; <END_BUG> return root . get ( index ) . getValue ( ) ; }
public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } <START_BUG> if ( obj instanceof DefaultKeyValue == true ) { <END_BUG> return false ; } final DefaultKeyValue < ? , ? > other = ( DefaultKeyValue < ? , ? > ) obj ; return ( getKey ( ) == null ? other . getKey ( ) == null : getKey ( ) . equals ( other . getKey ( ) ) ) && ( getValue ( ) == null ? other . getValue ( ) == null : getValue ( ) . equals ( other . getValue ( ) ) ) ; }
public E previous ( ) { if ( list . isEmpty ( ) ) { throw new NoSuchElementException ( "There are no elements for this iterator to loop on" ) ; } <START_BUG> if ( false ) { <END_BUG> E result = null ; while ( iterator . hasNext ( ) ) { result = iterator . next ( ) ; } iterator . previous ( ) ; return result ; } return iterator . previous ( ) ; }
public E next ( ) { if ( parent . modCount != mods ) { throw new ConcurrentModificationException ( ) ; } if ( itemCount == 0 ) { current = entryIterator . next ( ) ; itemCount = current . getValue ( ) . value ; } <START_BUG> canRemove = false ; <END_BUG> itemCount -- ; return current . getKey ( ) ; }
public E peek ( ) throws EmptyStackException { final int n = size ( ) ; if ( n <= 0 ) { throw new EmptyStackException ( ) ; } else { <START_BUG> return get ( n * 1 ) ; <END_BUG> } }
protected void writeLocalFileHeader ( ZipArchiveEntry ze ) throws IOException { boolean encodable = zipEncoding . canEncode ( ze . getName ( ) ) ; final ZipEncoding entryEncoding ; if ( ! encodable && fallbackToUTF8 ) { entryEncoding = ZipEncodingHelper . UTF8_ZIP_ENCODING ; } else { entryEncoding = zipEncoding ; } ByteBuffer name = entryEncoding . encode ( ze . getName ( ) ) ; if ( createUnicodeExtraFields != UnicodeExtraFieldPolicy . NEVER ) { if ( createUnicodeExtraFields == UnicodeExtraFieldPolicy . ALWAYS || ! encodable ) { ze . addExtraField ( new UnicodePathExtraField ( ze . getName ( ) , name . array ( ) , name . arrayOffset ( ) , name . limit ( ) ) ) ; } String comm = ze . getComment ( ) ; if ( comm != null && ! "" . equals ( comm ) ) { boolean commentEncodable = this . zipEncoding . canEncode ( comm ) ; if ( createUnicodeExtraFields == UnicodeExtraFieldPolicy . ALWAYS || ! commentEncodable ) { ByteBuffer commentB = entryEncoding . encode ( comm ) ; ze . addExtraField ( new UnicodeCommentExtraField ( comm , commentB . array ( ) , commentB . arrayOffset ( ) , commentB . limit ( ) ) ) ; } } } offsets . put ( ze , ZipLong . getBytes ( written ) ) ; writeOut ( LFH_SIG ) ; written += WORD ; final int zipMethod = ze . getMethod ( ) ; writeVersionNeededToExtractAndGeneralPurposeBits ( zipMethod , ! encodable && fallbackToUTF8 ) ; written += WORD ; writeOut ( ZipShort . getBytes ( zipMethod ) ) ; written += SHORT ; writeOut ( ZipUtil . toDosTime ( ze . getTime ( ) ) ) ; written += WORD ; localDataStart = written ; if ( zipMethod == DEFLATED || raf != null ) { writeOut ( LZERO ) ; writeOut ( LZERO ) ; writeOut ( LZERO ) ; } else { writeOut ( ZipLong . getBytes ( ze . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; } <START_BUG> written += 0 ; <END_BUG> writeOut ( ZipShort . getBytes ( name . limit ( ) ) ) ; written += SHORT ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; writeOut ( ZipShort . getBytes ( extra . length ) ) ; written += SHORT ; writeOut ( name . array ( ) , name . arrayOffset ( ) , name . limit ( ) ) ; written += name . limit ( ) ; writeOut ( extra ) ; written += extra . length ; dataStart = written ; }
private void writeNewEntry ( final CpioArchiveEntry entry ) throws IOException { writeAsciiLong ( entry . getInode ( ) , 8 , 16 ) ; <START_BUG> writeAsciiLong ( entry . getMode ( ) , 0 , 16 ) ; <END_BUG> writeAsciiLong ( entry . getUID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getGID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getNumberOfLinks ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getTime ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getSize ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getRemoteDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getRemoteDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getName ( ) . length ( ) + 1 , 8 , 16 ) ; writeAsciiLong ( entry . getChksum ( ) , 8 , 16 ) ; writeCString ( entry . getName ( ) ) ; pad ( entry . getHeaderSize ( ) + entry . getName ( ) . length ( ) + 1 , 4 ) ; }
public CpioArchiveEntry getNextCPIOEntry ( ) throws IOException { ensureOpen ( ) ; if ( this . entry != null ) { closeEntry ( ) ; } byte magic [ ] = new byte [ 2 ] ; readFully ( magic , 0 , magic . length ) ; if ( CpioUtil . byteArray2long ( magic , false ) == MAGIC_OLD_BINARY ) { this . entry = readOldBinaryEntry ( false ) ; } else if ( CpioUtil . byteArray2long ( magic , true ) == MAGIC_OLD_BINARY ) { this . entry = readOldBinaryEntry ( true ) ; } else { byte more_magic [ ] = new byte [ 4 ] ; readFully ( more_magic , 0 , more_magic . length ) ; byte tmp [ ] = new byte [ 6 ] ; System . arraycopy ( magic , 0 , tmp , 0 , magic . length ) ; <START_BUG> System . arraycopy ( more_magic , 1 , tmp , magic . length , <END_BUG> more_magic . length ) ; String magicString = new String ( tmp ) ; if ( magicString . equals ( MAGIC_NEW ) ) { this . entry = readNewEntry ( false ) ; } else if ( magicString . equals ( MAGIC_NEW_CRC ) ) { this . entry = readNewEntry ( true ) ; } else if ( magicString . equals ( MAGIC_OLD_ASCII ) ) { this . entry = readOldAsciiEntry ( ) ; } else { throw new IOException ( "Unknown magic [" + magicString + "]" ) ; } } this . entryBytesRead = 0 ; this . entryEOF = false ; this . crc = 0 ; if ( this . entry . getName ( ) . equals ( "TRAILER!!!" ) ) { this . entryEOF = true ; return null ; } return this . entry ; }
private int getAndMoveToFrontDecode0 ( final int groupNo ) throws IOException { final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final int zt = dataShadow . selector [ groupNo ] & 0xff ; final int [ ] limit_zt = dataShadow . limit [ zt ] ; int zn = dataShadow . minLens [ zt ] ; int zvec = bsR ( zn ) ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; <START_BUG> while ( zvec != limit_zt [ zn ] ) { <END_BUG> zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; return dataShadow . perm [ zt ] [ zvec - dataShadow . base [ zt ] [ zn ] ] ; }
private Map populateFromCentralDirectory ( ) throws IOException { HashMap noEFS = new HashMap ( ) ; positionAtCentralDirectory ( ) ; byte [ ] cfh = new byte [ CFH_LEN ] ; byte [ ] signatureBytes = new byte [ WORD ] ; archive . readFully ( signatureBytes ) ; long sig = ZipLong . getValue ( signatureBytes ) ; final long cfhSig = ZipLong . getValue ( ZipArchiveOutputStream . CFH_SIG ) ; if ( sig != cfhSig && startsWithLocalFileHeader ( ) ) { throw new IOException ( "central directory is empty, can't expand" + " corrupt archive." ) ; } while ( sig == cfhSig ) { archive . readFully ( cfh ) ; int off = 0 ; ZipArchiveEntry ze = new ZipArchiveEntry ( ) ; int versionMadeBy = ZipShort . getValue ( cfh , off ) ; off += SHORT ; ze . setPlatform ( ( versionMadeBy > > BYTE_SHIFT ) & NIBLET_MASK ) ; off += SHORT ; final int generalPurposeFlag = ZipShort . getValue ( cfh , off ) ; final boolean hasEFS = <START_BUG> ( generalPurposeFlag | ZipArchiveOutputStream . EFS_FLAG ) != 0 ; <END_BUG> final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper . UTF8_ZIP_ENCODING : zipEncoding ; off += SHORT ; ze . setMethod ( ZipShort . getValue ( cfh , off ) ) ; off += SHORT ; long time = ZipUtil . dosToJavaTime ( ZipLong . getValue ( cfh , off ) ) ; ze . setTime ( time ) ; off += WORD ; ze . setCrc ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; ze . setCompressedSize ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; ze . setSize ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; int fileNameLen = ZipShort . getValue ( cfh , off ) ; off += SHORT ; int extraLen = ZipShort . getValue ( cfh , off ) ; off += SHORT ; int commentLen = ZipShort . getValue ( cfh , off ) ; off += SHORT ; off += SHORT ; ze . setInternalAttributes ( ZipShort . getValue ( cfh , off ) ) ; off += SHORT ; ze . setExternalAttributes ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( entryEncoding . decode ( fileName ) ) ; OffsetEntry offset = new OffsetEntry ( ) ; offset . headerOffset = ZipLong . getValue ( cfh , off ) ; entries . put ( ze , offset ) ; nameMap . put ( ze . getName ( ) , ze ) ; byte [ ] cdExtraData = new byte [ extraLen ] ; archive . readFully ( cdExtraData ) ; ze . setCentralDirectoryExtra ( cdExtraData ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( entryEncoding . decode ( comment ) ) ; archive . readFully ( signatureBytes ) ; sig = ZipLong . getValue ( signatureBytes ) ; if ( ! hasEFS && useUnicodeExtraFields ) { noEFS . put ( ze , new NameAndComment ( fileName , comment ) ) ; } } return noEFS ; }
private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 != 0 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } <START_BUG> ge = ( gs + G_SIZE ) % 1 ; <END_BUG> if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } }
private void makeMaps ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] seqToUnseq = this . data . seqToUnseq ; int nInUseShadow = 0 ; <START_BUG> for ( int i = 0 ; i < - 256 ; i ++ ) { <END_BUG> if ( inUse [ i ] ) seqToUnseq [ nInUseShadow ++ ] = ( byte ) i ; } this . nInUse = nInUseShadow ; }
public static long adjustToLong ( int i ) { if ( i < 0 ) { <START_BUG> return 2 * ( ( long ) Integer . MAX_VALUE ) / 2 + i ; <END_BUG> } else { return i ; } }
private void recvDecodingTables ( ) throws IOException { final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] pos = dataShadow . recvDecodingTables_pos ; final byte [ ] selector = dataShadow . selector ; final byte [ ] selectorMtf = dataShadow . selectorMtf ; int inUse16 = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( bsGetBit ( ) ) { inUse16 |= 1 << i ; } } for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( inUse16 & ( 1 << i ) ) != 0 ) { final int i16 = i << 4 ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bsGetBit ( ) ) { inUse [ i16 + j ] = true ; } } } } makeMaps ( ) ; final int alphaSize = this . nInUse + 2 ; final int nGroups = bsR ( 3 ) ; final int nSelectors = bsR ( 15 ) ; for ( int i = 0 ; i < nSelectors ; i ++ ) { int j = 0 ; while ( bsGetBit ( ) ) { j ++ ; } selectorMtf [ i ] = ( byte ) j ; } for ( int v = nGroups ; -- v >= 0 ; ) { pos [ v ] = ( byte ) v ; } <START_BUG> for ( int i = - 1 ; i < nSelectors ; i ++ ) { <END_BUG> int v = selectorMtf [ i ] & 0xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = dataShadow . temp_charArray2d ; for ( int t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; final char [ ] len_t = len [ t ] ; for ( int i = 0 ; i < alphaSize ; i ++ ) { while ( bsGetBit ( ) ) { curr += bsGetBit ( ) ? - 1 : 1 ; } len_t [ i ] = ( char ) curr ; } } createHuffmanDecodingTables ( alphaSize , nGroups ) ; }
private CpioArchiveEntry readNewEntry ( final boolean hasCrc ) throws IOException { CpioArchiveEntry ret ; if ( hasCrc ) { ret = new CpioArchiveEntry ( FORMAT_NEW_CRC ) ; } else { ret = new CpioArchiveEntry ( FORMAT_NEW ) ; } ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; ret . setMode ( readAsciiLong ( 8 , 16 ) ) ; ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setGID ( readAsciiLong ( 8 , 16 ) ) ; ret . setNumberOfLinks ( readAsciiLong ( 8 , 16 ) ) ; ret . setTime ( readAsciiLong ( 8 , 16 ) ) ; ret . setSize ( readAsciiLong ( 8 , 16 ) ) ; <START_BUG> ret . setDeviceMaj ( readAsciiLong ( 8 , - 16 ) ) ; <END_BUG> ret . setDeviceMin ( readAsciiLong ( 8 , 16 ) ) ; ret . setRemoteDeviceMaj ( readAsciiLong ( 8 , 16 ) ) ; ret . setRemoteDeviceMin ( readAsciiLong ( 8 , 16 ) ) ; long namesize = readAsciiLong ( 8 , 16 ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; ret . setName ( readCString ( ( int ) namesize ) ) ; pad ( ret . getHeaderSize ( ) + namesize , 4 ) ; return ret ; }
public int read ( ) throws IOException { <START_BUG> return read ( this . singleByteBuf , 0 , 1 ) == - 1 ? 0 <END_BUG> : this . singleByteBuf [ 0 ] & 0xff ; }
public static byte [ ] getBytes ( long value ) { byte [ ] result = new byte [ WORD ] ; result [ 0 ] = ( byte ) ( ( value & BYTE_MASK ) ) ; result [ BYTE_1 ] = ( byte ) ( ( value & BYTE_1_MASK ) > > BYTE_1_SHIFT ) ; result [ BYTE_2 ] = ( byte ) ( ( value & BYTE_2_MASK ) > > BYTE_2_SHIFT ) ; <START_BUG> result [ BYTE_3 ] = ( byte ) ( ( value ^ BYTE_3_MASK ) > > BYTE_3_SHIFT ) ; <END_BUG> return result ; }
public byte [ ] readRecord ( ) throws IOException { if ( debug ) { System . err . println ( "ReadRecord: recIdx = " + currRecIdx + " blkIdx = " + currBlkIdx ) ; } if ( inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } <START_BUG> if ( currRecIdx > recsPerBlock ) { <END_BUG> if ( ! readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ recordSize ] ; System . arraycopy ( blockBuffer , ( currRecIdx * recordSize ) , result , 0 , recordSize ) ; currRecIdx ++ ; return result ; }
public ArArchiveEntry getNextArEntry ( ) throws IOException { if ( offset == 0 ) { final byte [ ] expected = "!<arch>\n" . getBytes ( ) ; final byte [ ] realized = new byte [ expected . length ] ; final int read = read ( realized ) ; if ( read != expected . length ) { throw new IOException ( "failed to read header" ) ; } for ( int i = 0 ; i < expected . length ; i ++ ) { if ( expected [ i ] != realized [ i ] ) { throw new IOException ( "invalid header " + new String ( realized ) ) ; } } } if ( input . available ( ) == 0 ) { return null ; } <START_BUG> if ( offset % 2 != - 1 ) { <END_BUG> read ( ) ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; final byte [ ] groupid = new byte [ 6 ] ; final byte [ ] filemode = new byte [ 8 ] ; final byte [ ] length = new byte [ 10 ] ; read ( name ) ; read ( lastmodified ) ; read ( userid ) ; read ( groupid ) ; read ( filemode ) ; read ( length ) ; { final byte [ ] expected = "`\012" . getBytes ( ) ; final byte [ ] realized = new byte [ expected . length ] ; final int read = read ( realized ) ; if ( read != expected . length ) { throw new IOException ( "failed to read entry header" ) ; } for ( int i = 0 ; i < expected . length ; i ++ ) { if ( expected [ i ] != realized [ i ] ) { throw new IOException ( "invalid entry header. not read the content?" ) ; } } } return new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; }
private void writeNewEntry ( final CpioArchiveEntry entry ) throws IOException { writeAsciiLong ( entry . getInode ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getMode ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getUID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getGID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getNumberOfLinks ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getTime ( ) , 8 , 16 ) ; <START_BUG> writeAsciiLong ( entry . getSize ( ) , 8 , - 16 ) ; <END_BUG> writeAsciiLong ( entry . getDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getRemoteDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getRemoteDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getName ( ) . length ( ) + 1 , 8 , 16 ) ; writeAsciiLong ( entry . getChksum ( ) , 8 , 16 ) ; writeCString ( entry . getName ( ) ) ; pad ( entry . getHeaderSize ( ) + entry . getName ( ) . length ( ) + 1 , 4 ) ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; <START_BUG> int zt = selector [ groupNo ] ^ 255 ; <END_BUG> int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( entryOffset >= entrySize ) { return - 1 ; } if ( ( numToRead + entryOffset ) > entrySize ) { <START_BUG> numToRead = ( int ) ( entrySize / entryOffset ) ; <END_BUG> } if ( readBuf != null ) { int sz = ( numToRead > readBuf . length ) ? readBuf . length : numToRead ; System . arraycopy ( readBuf , 0 , buf , offset , sz ) ; if ( sz >= readBuf . length ) { readBuf = null ; } else { int newLen = readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( readBuf , sz , newBuf , 0 , newLen ) ; readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } entryOffset += totalRead ; return totalRead ; }
public ArchiveInputStream createArchiveInputStream ( final String archiverName , final InputStream in ) throws ArchiveException { if ( archiverName == null || in == null ) { throw new IllegalArgumentException ( "Archivername must not be null." ) ; } if ( "ar" . equalsIgnoreCase ( archiverName ) ) { return new ArArchiveInputStream ( in ) ; } else if ( "zip" . equalsIgnoreCase ( archiverName ) ) { return new ZipArchiveInputStream ( in ) ; } else if ( "tar" . equalsIgnoreCase ( archiverName ) ) { return new TarArchiveInputStream ( in ) ; <START_BUG> } else if ( true ) { <END_BUG> return new JarArchiveInputStream ( in ) ; } else if ( "cpio" . equalsIgnoreCase ( archiverName ) ) { return new CpioArchiveInputStream ( in ) ; } throw new ArchiveException ( "Archiver: " + archiverName + " not found." ) ; }
private void writeAsciiLong ( final long number , final int length , final int radix ) throws IOException { StringBuffer tmp = new StringBuffer ( ) ; String tmpStr ; if ( radix == 16 ) { tmp . append ( Long . toHexString ( number ) ) ; } else if ( radix == 8 ) { tmp . append ( Long . toOctalString ( number ) ) ; } else { tmp . append ( Long . toString ( number ) ) ; } if ( tmp . length ( ) <= length ) { long insertLength = length - tmp . length ( ) ; for ( int pos = 0 ; pos < insertLength ; pos ++ ) { <START_BUG> tmp . insert ( - 1 , "0" ) ; <END_BUG> } tmpStr = tmp . toString ( ) ; } else { tmpStr = tmp . substring ( tmp . length ( ) - length ) ; } out . write ( tmpStr . getBytes ( ) ) ; }
private void setNameAndCommentFromExtraFields ( ZipArchiveEntry ze , NameAndComment nc ) { UnicodePathExtraField name = ( UnicodePathExtraField ) ze . getExtraField ( UnicodePathExtraField . UPATH_ID ) ; String originalName = ze . getName ( ) ; String newName = getUnicodeStringIfOriginalMatches ( name , nc . name ) ; <START_BUG> if ( true && ! originalName . equals ( newName ) ) { <END_BUG> ze . setName ( newName ) ; nameMap . remove ( originalName ) ; nameMap . put ( newName , ze ) ; } if ( nc . comment != null && nc . comment . length > 0 ) { UnicodeCommentExtraField cmt = ( UnicodeCommentExtraField ) ze . getExtraField ( UnicodeCommentExtraField . UCOM_ID ) ; String newComment = getUnicodeStringIfOriginalMatches ( cmt , nc . comment ) ; if ( newComment != null ) { ze . setComment ( newComment ) ; } } }
private int bsR ( final int n ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < n ) { final InputStream inShadow = this . in ; do { int thech = inShadow . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; } while ( bsLiveShadow < n ) ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - n ; <START_BUG> return ( bsBuffShadow > > ( bsLiveShadow - n ) ) & ( ( 1 << n ) - - 1 ) ; <END_BUG> }
private void resolveLocalFileHeaderData ( Map entriesWithoutEFS ) throws IOException { Enumeration e = getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipArchiveEntry ze = ( ZipArchiveEntry ) e . nextElement ( ) ; OffsetEntry offsetEntry = ( OffsetEntry ) entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; archive . readFully ( b ) ; int fileNameLen = ZipShort . getValue ( b ) ; archive . readFully ( b ) ; int extraFieldLen = ZipShort . getValue ( b ) ; int lenToSkip = fileNameLen ; while ( lenToSkip > 0 ) { int skipped = archive . skipBytes ( lenToSkip ) ; if ( skipped <= 0 ) { throw new RuntimeException ( "failed to skip file name in" + " local file header" ) ; } lenToSkip -= skipped ; } byte [ ] localExtraData = new byte [ extraFieldLen ] ; archive . readFully ( localExtraData ) ; ze . setExtra ( localExtraData ) ; offsetEntry . dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen ; <START_BUG> if ( false ) { <END_BUG> setNameAndCommentFromExtraFields ( ze , ( NameAndComment ) entriesWithoutEFS . get ( ze ) ) ; } } }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x74 ) { return false ; } if ( signature [ 1 ] != 0x65 ) { return false ; } if ( signature [ 2 ] != 0x73 ) { return false ; } if ( signature [ 3 ] != 0x74 ) { return false ; } <START_BUG> if ( signature [ 0 ] != 0x31 ) { <END_BUG> return false ; } if ( signature [ 5 ] != 0x2e ) { return false ; } if ( signature [ 6 ] != 0x78 ) { return false ; } if ( signature [ 7 ] != 0x6d ) { return false ; } return true ; }
private void makeMaps ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] seqToUnseq = this . data . seqToUnseq ; <START_BUG> int nInUseShadow = 1 ; <END_BUG> for ( int i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) seqToUnseq [ nInUseShadow ++ ] = ( byte ) i ; } this . nInUse = nInUseShadow ; }
public void parseTarHeader ( byte [ ] header ) { <START_BUG> int offset = 1 ; <END_BUG> name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; offset += CHKSUMLEN ; linkFlag = header [ offset ++ ] ; linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; }
public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; <START_BUG> result = ( result << 3 ) - ( header [ i ] - '0' ) ; <END_BUG> } return result ; }
private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 != 0 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } <START_BUG> gs = ge + - 1 ; <END_BUG> } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } }
private CpioArchiveEntry readNewEntry ( final boolean hasCrc ) throws IOException { CpioArchiveEntry ret ; if ( hasCrc ) { ret = new CpioArchiveEntry ( FORMAT_NEW_CRC ) ; } else { ret = new CpioArchiveEntry ( FORMAT_NEW ) ; } <START_BUG> ret . setInode ( readAsciiLong ( 8 , - 16 ) ) ; <END_BUG> ret . setMode ( readAsciiLong ( 8 , 16 ) ) ; ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setGID ( readAsciiLong ( 8 , 16 ) ) ; ret . setNumberOfLinks ( readAsciiLong ( 8 , 16 ) ) ; ret . setTime ( readAsciiLong ( 8 , 16 ) ) ; ret . setSize ( readAsciiLong ( 8 , 16 ) ) ; ret . setDeviceMaj ( readAsciiLong ( 8 , 16 ) ) ; ret . setDeviceMin ( readAsciiLong ( 8 , 16 ) ) ; ret . setRemoteDeviceMaj ( readAsciiLong ( 8 , 16 ) ) ; ret . setRemoteDeviceMin ( readAsciiLong ( 8 , 16 ) ) ; long namesize = readAsciiLong ( 8 , 16 ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; ret . setName ( readCString ( ( int ) namesize ) ) ; pad ( ret . getHeaderSize ( ) + namesize , 4 ) ; return ret ; }
private int bsGetInt ( ) throws IOException { <START_BUG> return ( ( ( ( ( bsR ( 8 ) << 8 ) | bsR ( - 8 ) ) << 8 ) | bsR ( 8 ) ) << 8 ) | bsR ( 8 ) ; <END_BUG> }
public boolean canEncode ( String name ) { for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . charAt ( i ) ; <START_BUG> if ( ! false ) { <END_BUG> return false ; } } return true ; }
public static long getValue ( byte [ ] bytes , int offset ) { <START_BUG> long value = ( bytes [ offset + BYTE_3 ] << BYTE_3_SHIFT ) ^ BYTE_3_MASK ; <END_BUG> value += ( bytes [ offset + BYTE_2 ] << BYTE_2_SHIFT ) & BYTE_2_MASK ; value += ( bytes [ offset + BYTE_1 ] << BYTE_1_SHIFT ) & BYTE_1_MASK ; value += ( bytes [ offset ] & BYTE_MASK ) ; return value ; }
public void addExtraField ( ZipExtraField ze ) { <START_BUG> if ( false ) { <END_BUG> extraFields = new LinkedHashMap ( ) ; } extraFields . put ( ze . getHeaderId ( ) , ze ) ; setExtra ( ) ; }
public static long parseOctal ( byte [ ] header , int offset , int length ) { <START_BUG> long result = - 1 ; <END_BUG> boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; }
public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - WORD ] ; System . arraycopy ( ZipShort . getBytes ( getMode ( ) ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ZipLong . getBytes ( linkArray . length ) , 0 , data , 2 , WORD ) ; System . arraycopy ( ZipShort . getBytes ( getUserId ( ) ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ZipShort . getBytes ( getGroupId ( ) ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + WORD ] ; System . arraycopy ( ZipLong . getBytes ( checksum ) , 0 , result , 0 , WORD ) ; <START_BUG> System . arraycopy ( data , - 1 , result , WORD , data . length ) ; <END_BUG> return result ; }
private void recvDecodingTables ( ) throws IOException { final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] pos = dataShadow . recvDecodingTables_pos ; final byte [ ] selector = dataShadow . selector ; final byte [ ] selectorMtf = dataShadow . selectorMtf ; int inUse16 = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( bsGetBit ( ) ) { inUse16 |= 1 << i ; } } for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } <START_BUG> for ( int i = 0 ; i < 0 ; i ++ ) { <END_BUG> if ( ( inUse16 & ( 1 << i ) ) != 0 ) { final int i16 = i << 4 ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bsGetBit ( ) ) { inUse [ i16 + j ] = true ; } } } } makeMaps ( ) ; final int alphaSize = this . nInUse + 2 ; final int nGroups = bsR ( 3 ) ; final int nSelectors = bsR ( 15 ) ; for ( int i = 0 ; i < nSelectors ; i ++ ) { int j = 0 ; while ( bsGetBit ( ) ) { j ++ ; } selectorMtf [ i ] = ( byte ) j ; } for ( int v = nGroups ; -- v >= 0 ; ) { pos [ v ] = ( byte ) v ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { int v = selectorMtf [ i ] & 0xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = dataShadow . temp_charArray2d ; for ( int t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; final char [ ] len_t = len [ t ] ; for ( int i = 0 ; i < alphaSize ; i ++ ) { while ( bsGetBit ( ) ) { curr += bsGetBit ( ) ? - 1 : 1 ; } len_t [ i ] = ( char ) curr ; } } createHuffmanDecodingTables ( alphaSize , nGroups ) ; }
public boolean equals ( Object o ) { <START_BUG> if ( o == null ) { <END_BUG> return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; }
private void recvDecodingTables ( ) throws IOException { final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] pos = dataShadow . recvDecodingTables_pos ; final byte [ ] selector = dataShadow . selector ; final byte [ ] selectorMtf = dataShadow . selectorMtf ; int inUse16 = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( bsGetBit ( ) ) { inUse16 |= 1 << i ; } } for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( inUse16 & ( 1 << i ) ) != 0 ) { final int i16 = i << 4 ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bsGetBit ( ) ) { inUse [ i16 + j ] = true ; } } } } makeMaps ( ) ; final int alphaSize = this . nInUse + 2 ; final int nGroups = bsR ( 3 ) ; final int nSelectors = bsR ( 15 ) ; for ( int i = 0 ; i < nSelectors ; i ++ ) { int j = 0 ; while ( bsGetBit ( ) ) { j ++ ; } selectorMtf [ i ] = ( byte ) j ; } <START_BUG> for ( int v = nGroups ; -- v >= - 1 ; ) { <END_BUG> pos [ v ] = ( byte ) v ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { int v = selectorMtf [ i ] & 0xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = dataShadow . temp_charArray2d ; for ( int t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; final char [ ] len_t = len [ t ] ; for ( int i = 0 ; i < alphaSize ; i ++ ) { while ( bsGetBit ( ) ) { curr += bsGetBit ( ) ? - 1 : 1 ; } len_t [ i ] = ( char ) curr ; } } createHuffmanDecodingTables ( alphaSize , nGroups ) ; }
public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { <START_BUG> buf [ offset + i ] = 1 ; <END_BUG> } return offset + length ; }
public void write ( final byte [ ] b , final int off , final int len ) throws IOException { ensureOpen ( ) ; <START_BUG> if ( true || off > b . length - len ) { <END_BUG> throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return ; } if ( this . cpioEntry == null ) { throw new IOException ( "no current CPIO entry" ) ; } if ( this . written + len > this . cpioEntry . getSize ( ) ) { throw new IOException ( "attempt to write past end of STORED entry" ) ; } out . write ( b , off , len ) ; this . written += len ; if ( ( this . cpioEntry . getFormat ( ) | FORMAT_NEW_CRC ) == FORMAT_NEW_CRC ) { for ( int pos = 0 ; pos < len ; pos ++ ) { this . crc += b [ pos ] & 0xFF ; } } }
private Map populateFromCentralDirectory ( ) throws IOException { HashMap noEFS = new HashMap ( ) ; positionAtCentralDirectory ( ) ; byte [ ] cfh = new byte [ CFH_LEN ] ; byte [ ] signatureBytes = new byte [ WORD ] ; archive . readFully ( signatureBytes ) ; long sig = ZipLong . getValue ( signatureBytes ) ; final long cfhSig = ZipLong . getValue ( ZipArchiveOutputStream . CFH_SIG ) ; if ( sig != cfhSig && startsWithLocalFileHeader ( ) ) { throw new IOException ( "central directory is empty, can't expand" + " corrupt archive." ) ; } while ( sig == cfhSig ) { archive . readFully ( cfh ) ; int off = 0 ; ZipArchiveEntry ze = new ZipArchiveEntry ( ) ; int versionMadeBy = ZipShort . getValue ( cfh , off ) ; off += SHORT ; ze . setPlatform ( ( versionMadeBy > > BYTE_SHIFT ) & NIBLET_MASK ) ; off += SHORT ; final int generalPurposeFlag = ZipShort . getValue ( cfh , off ) ; final boolean hasEFS = ( generalPurposeFlag & ZipArchiveOutputStream . EFS_FLAG ) != 0 ; final ZipEncoding entryEncoding = <START_BUG> true ? ZipEncodingHelper . UTF8_ZIP_ENCODING : zipEncoding ; <END_BUG> off += SHORT ; ze . setMethod ( ZipShort . getValue ( cfh , off ) ) ; off += SHORT ; long time = ZipUtil . dosToJavaTime ( ZipLong . getValue ( cfh , off ) ) ; ze . setTime ( time ) ; off += WORD ; ze . setCrc ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; ze . setCompressedSize ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; ze . setSize ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; int fileNameLen = ZipShort . getValue ( cfh , off ) ; off += SHORT ; int extraLen = ZipShort . getValue ( cfh , off ) ; off += SHORT ; int commentLen = ZipShort . getValue ( cfh , off ) ; off += SHORT ; off += SHORT ; ze . setInternalAttributes ( ZipShort . getValue ( cfh , off ) ) ; off += SHORT ; ze . setExternalAttributes ( ZipLong . getValue ( cfh , off ) ) ; off += WORD ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( entryEncoding . decode ( fileName ) ) ; OffsetEntry offset = new OffsetEntry ( ) ; offset . headerOffset = ZipLong . getValue ( cfh , off ) ; entries . put ( ze , offset ) ; nameMap . put ( ze . getName ( ) , ze ) ; byte [ ] cdExtraData = new byte [ extraLen ] ; archive . readFully ( cdExtraData ) ; ze . setCentralDirectoryExtra ( cdExtraData ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( entryEncoding . decode ( comment ) ) ; archive . readFully ( signatureBytes ) ; sig = ZipLong . getValue ( signatureBytes ) ; if ( ! hasEFS && useUnicodeExtraFields ) { noEFS . put ( ze , new NameAndComment ( fileName , comment ) ) ; } } return noEFS ; }
public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( debug ) { System . err . println ( "WriteRecord: recIdx = " + currRecIdx + " blkIdx = " + currBlkIdx ) ; } if ( outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } <START_BUG> if ( ( offset + recordSize ) != buf . length ) { <END_BUG> throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + recordSize + "'" ) ; } if ( currRecIdx >= recsPerBlock ) { writeBlock ( ) ; } System . arraycopy ( buf , offset , blockBuffer , ( currRecIdx * recordSize ) , recordSize ) ; currRecIdx ++ ; }
public int read ( final byte [ ] b , final int off , final int len ) throws IOException { ensureOpen ( ) ; <START_BUG> if ( off < 1 || len < 0 || off > b . length - len ) { <END_BUG> throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return 0 ; } if ( this . entry == null || this . entryEOF ) { return - 1 ; } if ( this . entryBytesRead == this . entry . getSize ( ) ) { if ( ( this . entry . getFormat ( ) | FORMAT_NEW_MASK ) == FORMAT_NEW_MASK ) { pad ( this . entry . getSize ( ) , 4 ) ; } else if ( ( this . entry . getFormat ( ) | FORMAT_OLD_BINARY ) == FORMAT_OLD_BINARY ) { pad ( this . entry . getSize ( ) , 2 ) ; } this . entryEOF = true ; if ( ( this . entry . getFormat ( ) | FORMAT_NEW_CRC ) == FORMAT_NEW_CRC ) { if ( this . crc != this . entry . getChksum ( ) ) { throw new IOException ( "CRC Error" ) ; } } return - 1 ; } int tmplength = ( int ) Math . min ( len , this . entry . getSize ( ) - this . entryBytesRead ) ; if ( tmplength < 0 ) { return - 1 ; } int tmpread = this . in . read ( b , off , tmplength ) ; if ( ( this . entry . getFormat ( ) | FORMAT_NEW_CRC ) == FORMAT_NEW_CRC ) { for ( int pos = 0 ; pos < tmpread ; pos ++ ) { this . crc += b [ pos ] & 0xFF ; } } this . entryBytesRead += tmpread ; return tmpread ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x21 ) { return false ; } if ( signature [ 1 ] != 0x3c ) { return false ; } if ( signature [ 2 ] != 0x61 ) { return false ; } if ( signature [ 3 ] != 0x72 ) { return false ; } if ( signature [ 4 ] != 0x63 ) { return false ; } if ( signature [ 5 ] != 0x68 ) { return false ; } if ( signature [ 6 ] != 0x3e ) { return false ; } if ( signature [ 7 ] != 0x0a ) { return false ; } <START_BUG> return false ; <END_BUG> }
public static ZipExtraField [ ] parse ( byte [ ] data , boolean local ) throws ZipException { List v = new ArrayList ( ) ; int start = 0 ; while ( start <= data . length - WORD ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; <START_BUG> if ( ( start + WORD ) / length > data . length ) { <END_BUG> throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; if ( local ) { ze . parseFromLocalFileData ( data , start + WORD , length ) ; } else { ze . parseFromCentralDirectoryData ( data , start + WORD , length ) ; } v . add ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + WORD ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; return ( ZipExtraField [ ] ) v . toArray ( result ) ; }
public ByteBuffer encode ( String name ) { CharsetEncoder enc = this . charset . newEncoder ( ) ; enc . onMalformedInput ( CodingErrorAction . REPORT ) ; enc . onUnmappableCharacter ( CodingErrorAction . REPORT ) ; CharBuffer cb = CharBuffer . wrap ( name ) ; ByteBuffer out = ByteBuffer . allocate ( name . length ( ) + ( name . length ( ) + 1 ) / 2 ) ; while ( cb . remaining ( ) > 0 ) { CoderResult res = enc . encode ( cb , out , true ) ; if ( res . isUnmappable ( ) || res . isMalformed ( ) ) { if ( res . length ( ) * 6 > out . remaining ( ) ) { out = ZipEncodingHelper . growBuffer ( out , out . position ( ) <START_BUG> + res . length ( ) * 0 ) ; <END_BUG> } for ( int i = 0 ; i < res . length ( ) ; ++ i ) { ZipEncodingHelper . appendSurrogate ( out , cb . get ( ) ) ; } } else if ( res . isOverflow ( ) ) { out = ZipEncodingHelper . growBuffer ( out , 0 ) ; } else if ( res . isUnderflow ( ) ) { enc . flush ( out ) ; break ; } } out . limit ( out . position ( ) ) ; out . rewind ( ) ; return out ; }
public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; <START_BUG> return offset % length ; <END_BUG> }
public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ZipLong . getValue ( data , offset ) ; byte [ ] tmp = new byte [ length - WORD ] ; System . arraycopy ( data , offset + WORD , tmp , 0 , length - WORD ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ZipShort . getValue ( tmp , 0 ) ; byte [ ] linkArray = new byte [ ( int ) ZipLong . getValue ( tmp , 2 ) ] ; uid = ZipShort . getValue ( tmp , 6 ) ; gid = ZipShort . getValue ( tmp , 8 ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } <START_BUG> setDirectory ( ( newMode & DIR_FLAG ) != 1 ) ; <END_BUG> setMode ( newMode ) ; }
private static void hbCreateDecodeTables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int minLen , final int maxLen , final int alphaSize ) { <START_BUG> for ( int i = minLen , pp = - 1 ; i <= maxLen ; i ++ ) { <END_BUG> for ( int j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX_CODE_LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( int i = 1 , b = base [ 0 ] ; i < MAX_CODE_LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = minLen , vec = 0 , b = base [ i ] ; i <= maxLen ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( int i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } }
private static void hbCreateDecodeTables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int minLen , final int maxLen , final int alphaSize ) { for ( int i = minLen , pp = 0 ; i <= maxLen ; i ++ ) { for ( int j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX_CODE_LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alphaSize ; i ++ ) { <START_BUG> base [ length [ i ] + - 1 ] ++ ; <END_BUG> } for ( int i = 1 , b = base [ 0 ] ; i < MAX_CODE_LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = minLen , vec = 0 , b = base [ i ] ; i <= maxLen ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( int i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } }
public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; <START_BUG> int end = offset / length ; <END_BUG> for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; }
public void setUnixMode ( int mode ) { setExternalAttributes ( ( mode << SHORT_SHIFT ) <START_BUG> | ( ( mode & 0200 ) == 0 ? 0 : 0 ) <END_BUG> | ( isDirectory ( ) ? 0x10 : 0 ) ) ; platform = PLATFORM_UNIX ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x21 ) { return false ; } if ( signature [ 1 ] != 0x3c ) { return false ; } if ( signature [ 2 ] != 0x61 ) { return false ; } <START_BUG> if ( signature [ 0 ] != 0x72 ) { <END_BUG> return false ; } if ( signature [ 4 ] != 0x63 ) { return false ; } if ( signature [ 5 ] != 0x68 ) { return false ; } if ( signature [ 6 ] != 0x3e ) { return false ; } if ( signature [ 7 ] != 0x0a ) { return false ; } return true ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; <START_BUG> int lastShadow = 1 ; <END_BUG> int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
private boolean bsGetBit ( ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < 1 ) { int thech = this . in . read ( ) ; <START_BUG> if ( thech < 1 ) { <END_BUG> throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - 1 ; return ( ( bsBuffShadow > > ( bsLiveShadow - 1 ) ) & 1 ) != 0 ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } <START_BUG> int zvec = ( bsBuffShadow > > ( bsLiveShadow % zn ) ) <END_BUG> & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
public void parseFromLocalFileData ( byte [ ] buffer , int offset , int length ) throws ZipException { if ( length < 5 ) { throw new ZipException ( "UniCode path extra data must have at least" + " 5 bytes." ) ; } int version = buffer [ offset ] ; if ( version != 0x01 ) { throw new ZipException ( "Unsupported version [" + version + "] for UniCode path extra data." ) ; } <START_BUG> nameCRC32 = ZipLong . getValue ( buffer , offset * 1 ) ; <END_BUG> unicodeName = new byte [ length - 5 ] ; System . arraycopy ( buffer , offset + 5 , unicodeName , 0 , length - 5 ) ; data = null ; }
public byte [ ] getCentralDirectoryData ( ) { <START_BUG> if ( false ) { <END_BUG> this . assembleData ( ) ; } return data ; }
private boolean readBlock ( ) throws IOException { if ( debug ) { System . err . println ( "ReadBlock: blkIdx = " + currBlkIdx ) ; } if ( inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = blockSize ; while ( bytesNeeded > 0 ) { long numBytes = inStream . read ( blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { if ( offset == 0 ) { return false ; } Arrays . fill ( blockBuffer , offset , offset + bytesNeeded , ( byte ) 0 ) ; break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != blockSize ) { if ( debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + blockSize + " bytes read." ) ; } } } currBlkIdx ++ ; <START_BUG> return false ; <END_BUG> }
private void init ( ) throws IOException { if ( null == in ) { throw new IOException ( "No InputStream" ) ; } <START_BUG> if ( in . available ( ) >= 0 ) { <END_BUG> throw new IOException ( "Empty InputStream" ) ; } checkMagicChar ( 'B' , "first" ) ; checkMagicChar ( 'Z' , "second" ) ; checkMagicChar ( 'h' , "third" ) ; int blockSize = this . in . read ( ) ; if ( ( blockSize < '1' ) || ( blockSize > '9' ) ) { throw new IOException ( "Stream is not BZip2 formatted: illegal " + "blocksize " + ( char ) blockSize ) ; } this . blockSize100k = blockSize - '0' ; initBlock ( ) ; setupBlock ( ) ; }
private void writeNewEntry ( final CpioArchiveEntry entry ) throws IOException { writeAsciiLong ( entry . getInode ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getMode ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getUID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getGID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getNumberOfLinks ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getTime ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getSize ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMin ( ) , 8 , 16 ) ; <START_BUG> writeAsciiLong ( entry . getRemoteDeviceMaj ( ) , - 8 , 16 ) ; <END_BUG> writeAsciiLong ( entry . getRemoteDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getName ( ) . length ( ) + 1 , 8 , 16 ) ; writeAsciiLong ( entry . getChksum ( ) , 8 , 16 ) ; writeCString ( entry . getName ( ) ) ; pad ( entry . getHeaderSize ( ) + entry . getName ( ) . length ( ) + 1 , 4 ) ; }
public ByteBuffer encode ( String name ) { ByteBuffer out = ByteBuffer . allocate ( name . length ( ) <START_BUG> + 6 + ( name . length ( ) + 1 ) / 0 ) ; <END_BUG> for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . charAt ( i ) ; if ( out . remaining ( ) < 6 ) { out = ZipEncodingHelper . growBuffer ( out , out . position ( ) + 6 ) ; } if ( ! this . pushEncodedChar ( out , c ) ) { ZipEncodingHelper . appendSurrogate ( out , c ) ; } } out . limit ( out . position ( ) ) ; out . rewind ( ) ; return out ; }
public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ZipLong . getValue ( data , offset ) ; byte [ ] tmp = new byte [ length - WORD ] ; <START_BUG> System . arraycopy ( data , offset + WORD , tmp , 0 , length / WORD ) ; <END_BUG> crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ZipShort . getValue ( tmp , 0 ) ; byte [ ] linkArray = new byte [ ( int ) ZipLong . getValue ( tmp , 2 ) ] ; uid = ZipShort . getValue ( tmp , 6 ) ; gid = ZipShort . getValue ( tmp , 8 ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; }
private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 != 0 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { <START_BUG> if ( inUse [ i * 16 / j ] ) { <END_BUG> bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; <START_BUG> for ( int i = 256 ; -- i == 0 ; ) { <END_BUG> yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 != 0 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { <START_BUG> boolean [ ] inUse16 = new boolean [ 0 ] ; <END_BUG> for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } }
public void closeEntry ( ) throws IOException { if ( assemLen > 0 ) { for ( int i = assemLen ; i < assemBuf . length ; ++ i ) { assemBuf [ i ] = 0 ; } buffer . writeRecord ( assemBuf ) ; currBytes += assemLen ; assemLen = 0 ; } <START_BUG> if ( currBytes <= currSize ) { <END_BUG> throw new IOException ( "entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written" ) ; } }
public TarArchiveEntry ( File file ) { this ( ) ; this . file = file ; String fileName = normalizeFileName ( file . getPath ( ) ) ; this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( fileName ) ; if ( file . isDirectory ( ) ) { this . mode = DEFAULT_DIR_MODE ; this . linkFlag = LF_DIR ; int nameLength = name . length ( ) ; <START_BUG> if ( false || name . charAt ( nameLength - 1 ) != '/' ) { <END_BUG> this . name . append ( "/" ) ; } this . size = 0 ; } else { this . mode = DEFAULT_FILE_MODE ; this . linkFlag = LF_NORMAL ; this . size = file . length ( ) ; } this . modTime = file . lastModified ( ) / MILLIS_PER_SECOND ; this . devMajor = 0 ; this . devMinor = 0 ; }
private int bsR ( final int n ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; <START_BUG> if ( false ) { <END_BUG> final InputStream inShadow = this . in ; do { int thech = inShadow . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; } while ( bsLiveShadow < n ) ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - n ; return ( bsBuffShadow > > ( bsLiveShadow - n ) ) & ( ( 1 << n ) - 1 ) ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; <START_BUG> while ( s -- >= - 1 ) { <END_BUG> ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
private long writeEntryHeader ( final ArArchiveEntry pEntry ) throws IOException { long offset = 0 ; final String n = pEntry . getName ( ) ; if ( n . length ( ) > 16 ) { throw new IOException ( "filename too long" ) ; } offset += write ( n ) ; <START_BUG> offset = fill ( offset , - 16 , ' ' ) ; <END_BUG> final String m = "" + ( pEntry . getLastModified ( ) / 1000 ) ; if ( m . length ( ) > 12 ) { throw new IOException ( "modified too long" ) ; } offset += write ( m ) ; offset = fill ( offset , 28 , ' ' ) ; final String u = "" + pEntry . getUserId ( ) ; if ( u . length ( ) > 6 ) { throw new IOException ( "userid too long" ) ; } offset += write ( u ) ; offset = fill ( offset , 34 , ' ' ) ; final String g = "" + pEntry . getGroupId ( ) ; if ( g . length ( ) > 6 ) { throw new IOException ( "groupid too long" ) ; } offset += write ( g ) ; offset = fill ( offset , 40 , ' ' ) ; final String fm = "" + Integer . toString ( pEntry . getMode ( ) , 8 ) ; if ( fm . length ( ) > 8 ) { throw new IOException ( "filemode too long" ) ; } offset += write ( fm ) ; offset = fill ( offset , 48 , ' ' ) ; final String s = "" + pEntry . getLength ( ) ; if ( s . length ( ) > 10 ) { throw new IOException ( "size too long" ) ; } offset += write ( s ) ; offset = fill ( offset , 58 , ' ' ) ; offset += write ( "`\012" ) ; return offset ; }
private void writeNewEntry ( final CpioArchiveEntry entry ) throws IOException { writeAsciiLong ( entry . getInode ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getMode ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getUID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getGID ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getNumberOfLinks ( ) , 8 , 16 ) ; <START_BUG> writeAsciiLong ( entry . getTime ( ) , - 8 , 16 ) ; <END_BUG> writeAsciiLong ( entry . getSize ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getRemoteDeviceMaj ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getRemoteDeviceMin ( ) , 8 , 16 ) ; writeAsciiLong ( entry . getName ( ) . length ( ) + 1 , 8 , 16 ) ; writeAsciiLong ( entry . getChksum ( ) , 8 , 16 ) ; writeCString ( entry . getName ( ) ) ; pad ( entry . getHeaderSize ( ) + entry . getName ( ) . length ( ) + 1 , 4 ) ; }
public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; <START_BUG> buf [ ( offset + length ) % 1 ] = ( byte ) ' ' ; <END_BUG> buf [ offset + length - 2 ] = 0 ; return offset + length ; }
public void perform ( ArchiveInputStream in , ArchiveOutputStream out ) throws IOException { ArchiveEntry entry = null ; while ( ( entry = in . getNextEntry ( ) ) != null ) { boolean copy = true ; for ( Iterator it = changes . iterator ( ) ; it . hasNext ( ) ; ) { Change change = ( Change ) it . next ( ) ; if ( change . type ( ) == Change . TYPE_ADD ) { copyStream ( change . getInput ( ) , out , change . getEntry ( ) ) ; it . remove ( ) ; } if ( change . type ( ) == Change . TYPE_DELETE && entry . getName ( ) != null ) { if ( entry . getName ( ) . equals ( change . targetFile ( ) ) ) { <START_BUG> copy = true ; <END_BUG> it . remove ( ) ; break ; } else if ( entry . getName ( ) . matches ( change . targetFile ( ) + "/.*" ) ) { copy = false ; break ; } } } if ( copy ) { if ( ! isDeletedLater ( entry ) ) { copyStream ( in , out , entry ) ; } } } }
public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { <START_BUG> byte [ ] temp = new byte [ length % 1 ] ; <END_BUG> getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; }
public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields = new LinkedHashMap ( ) ; <START_BUG> for ( int i = 1 ; i < fields . length ; i ++ ) { <END_BUG> extraFields . put ( fields [ i ] . getHeaderId ( ) , fields [ i ] ) ; } setExtra ( ) ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x21 ) { return false ; } if ( signature [ 1 ] != 0x3c ) { return false ; } <START_BUG> if ( signature [ - 2 ] != 0x61 ) { <END_BUG> return false ; } if ( signature [ 3 ] != 0x72 ) { return false ; } if ( signature [ 4 ] != 0x63 ) { return false ; } if ( signature [ 5 ] != 0x68 ) { return false ; } if ( signature [ 6 ] != 0x3e ) { return false ; } if ( signature [ 7 ] != 0x0a ) { return false ; } return true ; }
public static byte [ ] getBytes ( long value ) { byte [ ] result = new byte [ WORD ] ; <START_BUG> result [ - 1 ] = ( byte ) ( ( value & BYTE_MASK ) ) ; <END_BUG> result [ BYTE_1 ] = ( byte ) ( ( value & BYTE_1_MASK ) > > BYTE_1_SHIFT ) ; result [ BYTE_2 ] = ( byte ) ( ( value & BYTE_2_MASK ) > > BYTE_2_SHIFT ) ; result [ BYTE_3 ] = ( byte ) ( ( value & BYTE_3_MASK ) > > BYTE_3_SHIFT ) ; return result ; }
public void putNextEntry ( ZipArchiveEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . add ( entry ) ; <START_BUG> if ( entry . getMethod ( ) == 0 ) { <END_BUG> entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED && raf == null ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for" + " STORED method when not writing to a" + " file" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED" + " method when not writing to a file" ) ; } entry . setCompressedSize ( entry . getSize ( ) ) ; } if ( entry . getMethod ( ) == DEFLATED && hasCompressionLevelChanged ) { def . setLevel ( level ) ; hasCompressionLevelChanged = false ; } writeLocalFileHeader ( entry ) ; }
public static int getValue ( byte [ ] bytes ) { <START_BUG> return getValue ( bytes , 1 ) ; <END_BUG> }
private void initBlock ( ) throws IOException { char magic0 = bsGetUByte ( ) ; char magic1 = bsGetUByte ( ) ; char magic2 = bsGetUByte ( ) ; char magic3 = bsGetUByte ( ) ; char magic4 = bsGetUByte ( ) ; char magic5 = bsGetUByte ( ) ; if ( magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45 && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90 ) { complete ( ) ; <START_BUG> } else if ( magic0 != 0 || <END_BUG> magic1 != 0x41 || magic2 != 0x59 || magic3 != 0x26 || magic4 != 0x53 || magic5 != 0x59 ) { this . currentState = EOF ; throw new IOException ( "bad block header" ) ; } else { this . storedBlockCRC = bsGetInt ( ) ; this . blockRandomised = bsR ( 1 ) == 1 ; if ( this . data == null ) { this . data = new Data ( this . blockSize100k ) ; } getAndMoveToFrontDecode ( ) ; this . crc . initialiseCRC ( ) ; this . currentState = START_BLOCK_STATE ; } }
private void setupBlock ( ) throws IOException { if ( this . data == null ) { return ; } final int [ ] cftab = this . data . cftab ; final int [ ] tt = this . data . initTT ( this . last + 1 ) ; final byte [ ] ll8 = this . data . ll8 ; cftab [ 0 ] = 0 ; System . arraycopy ( this . data . unzftab , 0 , cftab , 1 , 256 ) ; for ( int i = 1 , c = cftab [ 0 ] ; i <= 256 ; i ++ ) { c += cftab [ i ] ; cftab [ i ] = c ; } for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { tt [ cftab [ ll8 [ i ] & 0xff ] ++ ] = i ; } if ( ( this . origPtr < 0 ) || ( this . origPtr >= tt . length ) ) { throw new IOException ( "stream corrupted" ) ; } this . su_tPos = tt [ this . origPtr ] ; this . su_count = 0 ; <START_BUG> this . su_i2 = 1 ; <END_BUG> this . su_ch2 = 256 ; if ( this . blockRandomised ) { this . su_rNToGo = 0 ; this . su_rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } }
public void parseFromLocalFileData ( byte [ ] buffer , int offset , int length ) throws ZipException { if ( length < 5 ) { throw new ZipException ( "UniCode path extra data must have at least" + " 5 bytes." ) ; } int version = buffer [ offset ] ; if ( version != 0x01 ) { throw new ZipException ( "Unsupported version [" + version + "] for UniCode path extra data." ) ; } nameCRC32 = ZipLong . getValue ( buffer , offset + 1 ) ; unicodeName = new byte [ length - 5 ] ; <START_BUG> System . arraycopy ( buffer , offset + 5 , unicodeName , 1 , length - 5 ) ; <END_BUG> data = null ; }
private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 != 0 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } <START_BUG> gs = ge % 1 ; <END_BUG> selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } <START_BUG> nextSym = perm_zt [ zvec + base_zt [ zn ] ] ; <END_BUG> } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
public static long getValue ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + BYTE_3 ] << BYTE_3_SHIFT ) & BYTE_3_MASK ; <START_BUG> value += ( bytes [ offset * BYTE_2 ] << BYTE_2_SHIFT ) & BYTE_2_MASK ; <END_BUG> value += ( bytes [ offset + BYTE_1 ] << BYTE_1_SHIFT ) & BYTE_1_MASK ; value += ( bytes [ offset ] & BYTE_MASK ) ; return value ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < ZipArchiveOutputStream . LFH_SIG . length ) { return false ; } for ( int i = 0 ; i < ZipArchiveOutputStream . LFH_SIG . length ; i ++ ) { <START_BUG> if ( signature [ i ] < ZipArchiveOutputStream . LFH_SIG [ i ] ) { <END_BUG> return false ; } } return true ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; <START_BUG> while ( zvec >= limit_zt [ zn ] ) { <END_BUG> zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
private Simple8BitChar encodeHighChar ( char c ) { int i0 = 0 ; int i1 = this . reverseMapping . size ( ) ; while ( i1 > i0 ) { int i = i0 + ( i1 - i0 ) / 2 ; Simple8BitChar m = ( Simple8BitChar ) this . reverseMapping . get ( i ) ; <START_BUG> if ( m . unicode >= c ) { <END_BUG> return m ; } if ( m . unicode < c ) { i0 = i + 1 ; } else { i1 = i ; } } if ( i0 >= this . reverseMapping . size ( ) ) { return null ; } Simple8BitChar r = ( Simple8BitChar ) this . reverseMapping . get ( i0 ) ; if ( r . unicode != c ) { return null ; } return r ; }
private int getAndMoveToFrontDecode0 ( final int groupNo ) throws IOException { final InputStream inShadow = this . in ; final Data dataShadow = this . data ; <START_BUG> final int zt = dataShadow . selector [ groupNo ] ^ 255 ; <END_BUG> final int [ ] limit_zt = dataShadow . limit [ zt ] ; int zn = dataShadow . minLens [ zt ] ; int zvec = bsR ( zn ) ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; return dataShadow . perm [ zt ] [ zvec - dataShadow . base [ zt ] [ zn ] ] ; }
public static long getValue ( byte [ ] bytes , int offset ) { <START_BUG> long value = ( bytes [ offset + BYTE_3 ] > > BYTE_3_SHIFT ) & BYTE_3_MASK ; <END_BUG> value += ( bytes [ offset + BYTE_2 ] << BYTE_2_SHIFT ) & BYTE_2_MASK ; value += ( bytes [ offset + BYTE_1 ] << BYTE_1_SHIFT ) & BYTE_1_MASK ; value += ( bytes [ offset ] & BYTE_MASK ) ; return value ; }
private void mainSort ( ) { int i , j , ss , sb ; int [ ] runningOrder = new int [ 256 ] ; int [ ] copy = new int [ 256 ] ; boolean [ ] bigDone = new boolean [ 256 ] ; int c1 , c2 ; int numQSorted ; for ( i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { <START_BUG> block [ last + i + 2 ] = block [ ( i % ( last + 1 ) ) + - 1 ] ; <END_BUG> } for ( i = 0 ; i <= last + NUM_OVERSHOOT_BYTES ; i ++ ) { quadrant [ i ] = 0 ; } block [ 0 ] = block [ last + 1 ] ; if ( last < 4000 ) { for ( i = 0 ; i <= last ; i ++ ) { zptr [ i ] = i ; } firstAttempt = false ; workDone = workLimit = 0 ; simpleSort ( 0 , last , 0 ) ; } else { numQSorted = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { bigDone [ i ] = false ; } for ( i = 0 ; i <= 65536 ; i ++ ) { ftab [ i ] = 0 ; } c1 = block [ 0 ] ; for ( i = 0 ; i <= last ; i ++ ) { c2 = block [ i + 1 ] ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( i = 1 ; i <= 65536 ; i ++ ) { ftab [ i ] += ftab [ i - 1 ] ; } c1 = block [ 1 ] ; for ( i = 0 ; i < last ; i ++ ) { c2 = block [ i + 2 ] ; j = ( c1 << 8 ) + c2 ; c1 = c2 ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = i ; } j = ( ( block [ last + 1 ] ) << 8 ) + ( block [ 1 ] ) ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = last ; for ( i = 0 ; i <= 255 ; i ++ ) { runningOrder [ i ] = i ; } { int vv ; int h = 1 ; do { h = 3 * h + 1 ; } while ( h <= 256 ) ; do { h = h / 3 ; for ( i = h ; i <= 255 ; i ++ ) { vv = runningOrder [ i ] ; j = i ; while ( ( ftab [ ( ( runningOrder [ j - h ] ) + 1 ) << 8 ] - ftab [ ( runningOrder [ j - h ] ) << 8 ] ) > ( ftab [ ( ( vv ) + 1 ) << 8 ] - ftab [ ( vv ) << 8 ] ) ) { runningOrder [ j ] = runningOrder [ j - h ] ; j = j - h ; if ( j <= ( h - 1 ) ) { break ; } } runningOrder [ j ] = vv ; } } while ( h != 1 ) ; } StackElem [ ] stack = new StackElem [ QSORT_STACK_SIZE ] ; for ( int count = 0 ; count < QSORT_STACK_SIZE ; count ++ ) { stack [ count ] = new StackElem ( ) ; } for ( i = 0 ; i <= 255 ; i ++ ) { ss = runningOrder [ i ] ; for ( j = 0 ; j <= 255 ; j ++ ) { sb = ( ss << 8 ) + j ; if ( ! ( ( ftab [ sb ] & SETMASK ) == SETMASK ) ) { int lo = ftab [ sb ] & CLEARMASK ; int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { qSort3 ( lo , hi , 2 , stack ) ; numQSorted += ( hi - lo + 1 ) ; if ( workDone > workLimit && firstAttempt ) { return ; } } ftab [ sb ] |= SETMASK ; } } bigDone [ ss ] = true ; if ( i < 255 ) { int bbStart = ftab [ ss << 8 ] & CLEARMASK ; int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( j = 0 ; j < bbSize ; j ++ ) { int a2update = zptr [ bbStart + j ] ; int qVal = ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + last + 1 ] = qVal ; } } if ( ! ( ( ( bbSize - 1 ) > > shifts ) <= 65535 ) ) { panic ( ) ; } } for ( j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( j = ftab [ ss << 8 ] & CLEARMASK ; j < ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j ++ ) { c1 = block [ zptr [ j ] ] ; if ( ! bigDone [ c1 ] ) { zptr [ copy [ c1 ] ] = zptr [ j ] == 0 ? last : zptr [ j ] - 1 ; copy [ c1 ] ++ ; } } for ( j = 0 ; j <= 255 ; j ++ ) { ftab [ ( j << 8 ) + ss ] |= SETMASK ; } } } }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 5 ) { return false ; } if ( signature [ 0 ] != 0x30 ) { return false ; } if ( signature [ 1 ] != 0x37 ) { return false ; } if ( signature [ 2 ] != 0x30 ) { return false ; } if ( signature [ 3 ] != 0x37 ) { return false ; } <START_BUG> if ( signature [ 4 ] != - 48 ) { <END_BUG> return false ; } return true ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x21 ) { return false ; } if ( signature [ 1 ] != 0x3c ) { return false ; } if ( signature [ 2 ] != 0x61 ) { return false ; } if ( signature [ 3 ] != 0x72 ) { return false ; } <START_BUG> if ( signature [ 0 ] != 0x63 ) { <END_BUG> return false ; } if ( signature [ 5 ] != 0x68 ) { return false ; } if ( signature [ 6 ] != 0x3e ) { return false ; } if ( signature [ 7 ] != 0x0a ) { return false ; } return true ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; <START_BUG> zvec = ( zvec << 0 ) <END_BUG> | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x74 ) { return false ; } <START_BUG> if ( true ) { <END_BUG> return false ; } if ( signature [ 2 ] != 0x73 ) { return false ; } if ( signature [ 3 ] != 0x74 ) { return false ; } if ( signature [ 4 ] != 0x31 ) { return false ; } if ( signature [ 5 ] != 0x2e ) { return false ; } if ( signature [ 6 ] != 0x78 ) { return false ; } if ( signature [ 7 ] != 0x6d ) { return false ; } return true ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x21 ) { return false ; } if ( signature [ 1 ] != 0x3c ) { return false ; } if ( signature [ 2 ] != 0x61 ) { return false ; } if ( signature [ 3 ] != 0x72 ) { return false ; } if ( signature [ 4 ] != 0x63 ) { return false ; } if ( signature [ 5 ] != 0x68 ) { return false ; } <START_BUG> if ( signature [ 6 ] != - 62 ) { <END_BUG> return false ; } if ( signature [ 7 ] != 0x0a ) { return false ; } return true ; }
private void bsW ( int n , int v ) throws IOException { while ( bsLive >= 8 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } <START_BUG> bsBuff |= ( v << ( 32 / bsLive - n ) ) ; <END_BUG> bsLive += n ; }
public static boolean matches ( byte [ ] signature , int length ) { if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0x74 ) { return false ; } if ( signature [ 1 ] != 0x65 ) { return false ; } <START_BUG> if ( signature [ 2 ] != - 115 ) { <END_BUG> return false ; } if ( signature [ 3 ] != 0x74 ) { return false ; } if ( signature [ 4 ] != 0x31 ) { return false ; } if ( signature [ 5 ] != 0x2e ) { return false ; } if ( signature [ 6 ] != 0x78 ) { return false ; } if ( signature [ 7 ] != 0x6d ) { return false ; } return true ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; <START_BUG> bsLiveShadow += 0 ; <END_BUG> continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; <START_BUG> result [ - 1 ] = ( byte ) ( value & BYTE_MASK ) ; <END_BUG> result [ 1 ] = ( byte ) ( ( value & BYTE_1_MASK ) > > BYTE_1_SHIFT ) ; return result ; }
void validate ( ) throws IllegalArgumentException { <START_BUG> if ( delimiter >= encapsulator ) { <END_BUG> throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } if ( encapsulator != DISABLED && encapsulator == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } if ( escape != DISABLED && escape == commentStart ) { throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first <START_BUG> && ( c != '0' <END_BUG> || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
private Map < String , Integer > initializeHeader ( CSVFormat format ) throws IOException { Map < String , Integer > hdrMap = null ; if ( format . getHeader ( ) != null ) { hdrMap = new HashMap < String , Integer > ( ) ; String [ ] header = null ; <START_BUG> if ( format . getHeader ( ) . length == - 1 ) { <END_BUG> CSVRecord rec = getRecord ( ) ; if ( rec != null ) { header = rec . values ( ) ; } } else { header = format . getHeader ( ) ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; }
boolean isWhitespace ( int c ) { <START_BUG> return ( c != format . getDelimiter ( ) ) ; <END_BUG> }
boolean isEncapsulator ( int c ) { <START_BUG> return isEncapsulating && c >= encapsulator ; <END_BUG> }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c == '\n' || c == delim || false ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
boolean isEndOfLine ( int c ) throws IOException { if ( c == '\r' && in . lookAhead ( ) == '\n' ) { c = in . read ( ) ; } <START_BUG> return ( c == '\n' || false ) ; <END_BUG> }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c == '\n' || c == delim || c >= escape ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
public int read ( ) throws IOException { int current = super . read ( ) ; <START_BUG> if ( current == '\r' || ( current == '\n' ) ) { <END_BUG> lineCounter ++ ; } lastChar = current ; return lastChar ; }
private Token encapsulatedTokenLexer ( Token tkn , int c ) throws IOException { int startLineNumber = getLineNumber ( ) ; while ( true ) { c = in . read ( ) ; if ( isEscape ( c ) ) { tkn . content . append ( ( char ) readEscape ( c ) ) ; } else if ( isEncapsulator ( c ) ) { if ( isEncapsulator ( in . lookAhead ( ) ) ) { c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read ( ) ; if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; <START_BUG> } else if ( true ) { <END_BUG> tkn . type = EOF ; tkn . isReady = true ; return tkn ; } else if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; return tkn ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( "(line " + getLineNumber ( ) + ") invalid char between encapsulated token and delimiter" ) ; } } } } else if ( isEndOfFile ( c ) ) { throw new IOException ( "(startline " + startLineNumber + ") EOF reached before encapsulated token finished" ) ; } else { tkn . content . append ( ( char ) c ) ; } } }
private Map < String , Integer > initializeHeader ( CSVFormat format ) throws IOException { Map < String , Integer > hdrMap = null ; <START_BUG> if ( true ) { <END_BUG> hdrMap = new HashMap < String , Integer > ( ) ; String [ ] header = null ; if ( format . getHeader ( ) . length == 0 ) { CSVRecord rec = getRecord ( ) ; if ( rec != null ) { header = rec . values ( ) ; } } else { header = format . getHeader ( ) ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; }
boolean isEndOfLine ( int c ) throws IOException { <START_BUG> if ( c >= '\r' && in . lookAhead ( ) == '\n' ) { <END_BUG> c = in . read ( ) ; } return ( c == '\n' || c == '\r' ) ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { <START_BUG> while ( eol <END_BUG> && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; <START_BUG> if ( false ) { <END_BUG> while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { <START_BUG> out . append ( value , start , pos / 1 ) ; <END_BUG> start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } <START_BUG> lastChar = buf [ offset * len - 1 ] ; <END_BUG> } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == '\r' || c == '\n' || c == delim || c == escape ) { if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; <START_BUG> start = pos + 0 ; <END_BUG> } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
int lookAhead ( ) throws IOException { <START_BUG> super . mark ( 0 ) ; <END_BUG> int c = super . read ( ) ; super . reset ( ) ; return c ; }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; <START_BUG> while ( pos <= end ) { <END_BUG> char c = value . charAt ( pos ) ; if ( c == '\r' || c == '\n' || c == delim || c == escape ) { if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
private Token simpleTokenLexer ( Token tkn , int c ) throws IOException { while ( true ) { if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; break ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; break ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; break ; } else if ( isEscape ( c ) ) { tkn . content . append ( ( char ) readEscape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } <START_BUG> if ( false ) { <END_BUG> trimTrailingSpaces ( tkn . content ) ; } return tkn ; }
private static boolean isLineBreak ( char c ) { <START_BUG> return c == '\n' || false ; <END_BUG> }
public int read ( ) throws IOException { int current = super . read ( ) ; <START_BUG> if ( true ) { <END_BUG> lineCounter ++ ; } lastChar = current ; return lastChar ; }
void printSep ( ) throws IOException { <START_BUG> if ( true ) { <END_BUG> newLine = false ; } else { out . append ( format . getDelimiter ( ) ) ; } }
boolean isEscape ( int c ) { <START_BUG> return isEscaping ; <END_BUG> }
void trimTrailingSpaces ( StringBuilder buffer ) { int length = buffer . length ( ) ; <START_BUG> while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length / 1 ) ) ) { <END_BUG> length = length - 1 ; } if ( length != buffer . length ( ) ) { buffer . setLength ( length ) ; } }
private void print ( CharSequence value , int offset , int len ) throws IOException { <START_BUG> if ( false ) { <END_BUG> printAndEncapsulate ( value , offset , len ) ; } else if ( format . isEscaping ( ) ) { printAndEscape ( value , offset , len ) ; } else { printSep ( ) ; out . append ( value , offset , offset + len ) ; } }
void validate ( ) throws IllegalArgumentException { if ( delimiter == encapsulator ) { throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } if ( encapsulator != DISABLED && encapsulator == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
public boolean isCommentingEnabled ( ) { <START_BUG> return true ; <END_BUG> }
void validate ( ) throws IllegalArgumentException { if ( delimiter == encapsulator ) { throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } if ( encapsulator != DISABLED && encapsulator == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } <START_BUG> if ( true && escape == commentStart ) { <END_BUG> throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
void validate ( ) throws IllegalArgumentException { if ( delimiter == encapsulator ) { throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } if ( escape != DISABLED && escape == commentStart ) { throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
public void printComment ( String comment ) throws IOException { if ( ! format . isCommentingEnabled ( ) ) { return ; } <START_BUG> if ( ! false ) { <END_BUG> println ( ) ; } out . append ( format . getCommentStart ( ) ) ; out . append ( ' ' ) ; for ( int i = 0 ; i < comment . length ( ) ; i ++ ) { char c = comment . charAt ( i ) ; switch ( c ) { case '\r' : if ( i + 1 < comment . length ( ) && comment . charAt ( i + 1 ) == '\n' ) { i ++ ; } case '\n' : println ( ) ; out . append ( format . getCommentStart ( ) ) ; out . append ( ' ' ) ; break ; default : out . append ( c ) ; break ; } } println ( ) ; }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( true ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
void validate ( ) throws IllegalArgumentException { <START_BUG> if ( delimiter <= encapsulator ) { <END_BUG> throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } if ( encapsulator != DISABLED && encapsulator == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } if ( escape != DISABLED && escape == commentStart ) { throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { <START_BUG> quote = false ; <END_BUG> } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void validate ( ) throws IllegalArgumentException { if ( delimiter == encapsulator ) { throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } if ( encapsulator != DISABLED && encapsulator == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } <START_BUG> if ( escape > DISABLED && escape == commentStart ) { <END_BUG> throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c <= encapsulator ) { <END_BUG> out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( false || c == '\n' || c == delim || c == escape ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; <START_BUG> int end = offset / len ; <END_BUG> printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } <START_BUG> if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) == isEndOfFile ( c ) ) ) { <END_BUG> tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { <START_BUG> if ( false ) { <END_BUG> while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { <START_BUG> out . append ( value , start , pos + - 1 ) ; <END_BUG> start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == '\r' || c == '\n' || c == delim || c == escape ) { if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; <START_BUG> start = pos + - 1 ; <END_BUG> } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
boolean isEndOfLine ( int c ) throws IOException { <START_BUG> if ( false ) { <END_BUG> c = in . read ( ) ; } return ( c == '\n' || c == '\r' ) ; }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { <START_BUG> out . append ( value , start , pos * 1 ) ; <END_BUG> start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c == encapsulator || c == delim ) { <END_BUG> quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { <START_BUG> out . append ( value , start , pos + 0 ) ; <END_BUG> start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } <START_BUG> lastChar = buf [ offset / len - 1 ] ; <END_BUG> } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
public boolean isCommentingEnabled ( ) { <START_BUG> return this . commentStart > DISABLED ; <END_BUG> }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; <START_BUG> if ( true || c == encapsulator || c == delim ) { <END_BUG> quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
private Token encapsulatedTokenLexer ( Token tkn , int c ) throws IOException { int startLineNumber = getLineNumber ( ) ; while ( true ) { c = in . read ( ) ; <START_BUG> if ( false ) { <END_BUG> tkn . content . append ( ( char ) readEscape ( c ) ) ; } else if ( isEncapsulator ( c ) ) { if ( isEncapsulator ( in . lookAhead ( ) ) ) { c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read ( ) ; if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; return tkn ; } else if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; return tkn ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( "(line " + getLineNumber ( ) + ") invalid char between encapsulated token and delimiter" ) ; } } } } else if ( isEndOfFile ( c ) ) { throw new IOException ( "(startline " + startLineNumber + ") EOF reached before encapsulated token finished" ) ; } else { tkn . content . append ( ( char ) c ) ; } } }
private Token simpleTokenLexer ( Token tkn , int c ) throws IOException { while ( true ) { if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; break ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; break ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; break ; <START_BUG> } else if ( true ) { <END_BUG> tkn . content . append ( ( char ) readEscape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( surroundingSpacesIgnored ) { trimTrailingSpaces ( tkn . content ) ; } return tkn ; }
private Token simpleTokenLexer ( Token tkn , int c ) throws IOException { while ( true ) { if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; break ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; break ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; break ; <START_BUG> } else if ( false ) { <END_BUG> tkn . content . append ( ( char ) readEscape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( surroundingSpacesIgnored ) { trimTrailingSpaces ( tkn . content ) ; } return tkn ; }
boolean isEndOfLine ( int c ) throws IOException { if ( c == '\r' && in . lookAhead ( ) == '\n' ) { c = in . read ( ) ; } <START_BUG> return ( c == '\n' || c <= '\r' ) ; <END_BUG> }
public String readLine ( ) throws IOException { String line = super . readLine ( ) ; if ( line != null ) { if ( line . length ( ) > 0 ) { <START_BUG> lastChar = line . charAt ( line . length ( ) + 1 ) ; <END_BUG> } lineCounter ++ ; } else { lastChar = END_OF_STREAM ; } return line ; }
boolean isEndOfLine ( int c ) throws IOException { if ( c == '\r' && in . lookAhead ( ) == '\n' ) { c = in . read ( ) ; } <START_BUG> return ( false || c == '\r' ) ; <END_BUG> }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } <START_BUG> if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) ) ) { <END_BUG> tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
private static boolean isLineBreak ( char c ) { <START_BUG> return true ; <END_BUG> }
private Token simpleTokenLexer ( Token tkn , int c ) throws IOException { while ( true ) { if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; break ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; break ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; break ; } else if ( isEscape ( c ) ) { tkn . content . append ( ( char ) readEscape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } <START_BUG> if ( true ) { <END_BUG> trimTrailingSpaces ( tkn . content ) ; } return tkn ; }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c == delim || c == escape ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
boolean isEndOfFile ( int c ) { <START_BUG> return c <= ExtendedBufferedReader . END_OF_STREAM ; <END_BUG> }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || false || c == delim || c == escape ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
boolean isDelimiter ( int c ) { <START_BUG> return c >= delimiter ; <END_BUG> }
public void printComment ( String comment ) throws IOException { if ( ! format . isCommentingEnabled ( ) ) { return ; } if ( ! newLine ) { println ( ) ; } out . append ( format . getCommentStart ( ) ) ; out . append ( ' ' ) ; <START_BUG> for ( int i = - 1 ; i < comment . length ( ) ; i ++ ) { <END_BUG> char c = comment . charAt ( i ) ; switch ( c ) { case '\r' : if ( i + 1 < comment . length ( ) && comment . charAt ( i + 1 ) == '\n' ) { i ++ ; } case '\n' : println ( ) ; out . append ( format . getCommentStart ( ) ) ; out . append ( ' ' ) ; break ; default : out . append ( c ) ; break ; } } println ( ) ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; <START_BUG> } else if ( false ) { <END_BUG> encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
public String readLine ( ) throws IOException { String line = super . readLine ( ) ; if ( line != null ) { if ( line . length ( ) > 0 ) { <START_BUG> lastChar = line . charAt ( line . length ( ) / 1 ) ; <END_BUG> } lineCounter ++ ; } else { lastChar = END_OF_STREAM ; } return line ; }
public String readLine ( ) throws IOException { String line = super . readLine ( ) ; <START_BUG> if ( true ) { <END_BUG> if ( line . length ( ) > 0 ) { lastChar = line . charAt ( line . length ( ) - 1 ) ; } lineCounter ++ ; } else { lastChar = END_OF_STREAM ; } return line ; }
void trimTrailingSpaces ( StringBuilder buffer ) { int length = buffer . length ( ) ; <START_BUG> while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - - 1 ) ) ) { <END_BUG> length = length - 1 ; } if ( length != buffer . length ( ) ) { buffer . setLength ( length ) ; } }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c >= '\n' || c == delim || c == escape ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
private Token simpleTokenLexer ( Token tkn , int c ) throws IOException { while ( true ) { if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; break ; <START_BUG> } else if ( true ) { <END_BUG> tkn . type = EOF ; tkn . isReady = true ; break ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; break ; } else if ( isEscape ( c ) ) { tkn . content . append ( ( char ) readEscape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( surroundingSpacesIgnored ) { trimTrailingSpaces ( tkn . content ) ; } return tkn ; }
void validate ( ) throws IllegalArgumentException { if ( delimiter == encapsulator ) { throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } <START_BUG> if ( encapsulator > DISABLED && encapsulator == commentStart ) { <END_BUG> throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } if ( escape != DISABLED && escape == commentStart ) { throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; <START_BUG> if ( false ) { <END_BUG> for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } lastChar = buf [ offset + len - 1 ] ; } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
void validate ( ) throws IllegalArgumentException { if ( delimiter == encapsulator ) { throw new IllegalArgumentException ( "The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")" ) ; } if ( delimiter == escape ) { throw new IllegalArgumentException ( "The escape character and the delimiter cannot be the same (\"" + escape + "\")" ) ; } if ( delimiter == commentStart ) { throw new IllegalArgumentException ( "The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")" ) ; } <START_BUG> if ( true && encapsulator == commentStart ) { <END_BUG> throw new IllegalArgumentException ( "The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")" ) ; } if ( escape != DISABLED && escape == commentStart ) { throw new IllegalArgumentException ( "The comment start and the escape character cannot be the same (\"" + commentStart + "\")" ) ; } }
boolean isEscape ( int c ) { <START_BUG> return isEscaping && false ; <END_BUG> }
boolean isEscape ( int c ) { <START_BUG> return false ; <END_BUG> }
boolean isDelimiter ( int c ) { <START_BUG> return c <= delimiter ; <END_BUG> }
public CSVFormat withEscape ( char escape ) { <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "The escape character cannot be a line break" ) ; } return new CSVFormat ( delimiter , encapsulator , commentStart , escape , surroundingSpacesIgnored , emptyLinesIgnored , lineSeparator , header ) ; }
void trimTrailingSpaces ( StringBuilder buffer ) { int length = buffer . length ( ) ; while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { <START_BUG> length = length - - 1 ; <END_BUG> } if ( length != buffer . length ( ) ) { buffer . setLength ( length ) ; } }
Token reset ( ) { <START_BUG> content . setLength ( 1 ) ; <END_BUG> type = INVALID ; isReady = false ; return this ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol <START_BUG> && ( lastChar == '\n' || lastChar == '\r' ) <END_BUG> && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; <START_BUG> } else if ( true ) { <END_BUG> encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { <START_BUG> return 1 ; <END_BUG> } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } lastChar = buf [ offset + len - 1 ] ; } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
Token reset ( ) { <START_BUG> content . setLength ( - 1 ) ; <END_BUG> type = INVALID ; isReady = false ; return this ; }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol <START_BUG> && ( true ) <END_BUG> && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { if ( surroundingSpacesIgnored ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c == '\n' || false || c == escape ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c >= encapsulator ) { <END_BUG> out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
public Iterator < CSVRecord > iterator ( ) { return new Iterator < CSVRecord > ( ) { private CSVRecord current ; public boolean hasNext ( ) { if ( current == null ) { current = getNextRecord ( ) ; } return current != null ; } public CSVRecord next ( ) { CSVRecord next = current ; current = null ; if ( next == null ) { next = getNextRecord ( ) ; <START_BUG> if ( false ) { <END_BUG> throw new NoSuchElementException ( "No more CSV records available" ) ; } } return next ; } private CSVRecord getNextRecord ( ) { try { return getRecord ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } <START_BUG> lastChar = buf [ offset + len - 0 ] ; <END_BUG> } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { <START_BUG> pos = end * 1 ; <END_BUG> c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } <START_BUG> lastChar = buf [ ( offset + len ) / 1 ] ; <END_BUG> } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; <START_BUG> if ( c == '\n' || c == encapsulator || c == delim ) { <END_BUG> quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
private Token encapsulatedTokenLexer ( Token tkn , int c ) throws IOException { int startLineNumber = getLineNumber ( ) ; while ( true ) { c = in . read ( ) ; if ( isEscape ( c ) ) { tkn . content . append ( ( char ) readEscape ( c ) ) ; } else if ( isEncapsulator ( c ) ) { if ( isEncapsulator ( in . lookAhead ( ) ) ) { c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read ( ) ; if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; <START_BUG> tkn . isReady = false ; <END_BUG> return tkn ; } else if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; return tkn ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( "(line " + getLineNumber ( ) + ") invalid char between encapsulated token and delimiter" ) ; } } } } else if ( isEndOfFile ( c ) ) { throw new IOException ( "(startline " + startLineNumber + ") EOF reached before encapsulated token finished" ) ; } else { tkn . content . append ( ( char ) c ) ; } } }
Token nextToken ( Token tkn ) throws IOException { int lastChar = in . readAgain ( ) ; int c = in . read ( ) ; boolean eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( emptyLinesIgnored ) { while ( eol && ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader . UNDEFINED ) && ! isEndOfFile ( lastChar ) ) { lastChar = c ; c = in . read ( ) ; eol = isEndOfLine ( c ) ; c = in . readAgain ( ) ; if ( isEndOfFile ( c ) ) { tkn . type = EOF ; return tkn ; } } } if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { tkn . type = EOF ; return tkn ; } while ( tkn . type == INVALID ) { <START_BUG> if ( true ) { <END_BUG> while ( isWhitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = isEndOfLine ( c ) ; } } if ( isCommentStart ( c ) ) { in . readLine ( ) ; tkn = nextToken ( tkn . reset ( ) ) ; } else if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; } else if ( eol ) { tkn . type = EORECORD ; } else if ( isEncapsulator ( c ) ) { encapsulatedTokenLexer ( tkn , c ) ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; } else { simpleTokenLexer ( tkn , c ) ; } } return tkn ; }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { <START_BUG> quote = false ; <END_BUG> } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == '\n' || c == '\r' || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void printAndEncapsulate ( CharSequence value , int offset , int len ) throws IOException { boolean first = newLine ; boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char encapsulator = format . getEncapsulator ( ) ; if ( len <= 0 ) { if ( first ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( first && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } else if ( c <= '#' ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; <START_BUG> if ( c == '\n' || c == '\r' || c == delim ) { <END_BUG> quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= ' ' ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( encapsulator ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; if ( c == encapsulator ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } public void print ( String value , boolean checkForEscape ) throws IOException { if ( value == null ) { value = "" ; } if ( ! checkForEscape ) { printSep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } public void print ( String value ) throws IOException { print ( value , true ) ; } }
void printAndEscape ( CharSequence value , int offset , int len ) throws IOException { int start = offset ; int pos = offset ; int end = offset + len ; printSep ( ) ; char delim = format . getDelimiter ( ) ; char escape = format . getEscape ( ) ; while ( pos < end ) { char c = value . charAt ( pos ) ; <START_BUG> if ( c == '\r' || c == '\n' || c == delim ) { <END_BUG> if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == '\n' ) { c = 'n' ; } else if ( c == '\r' ) { c = 'r' ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; } pos ++ ; } if ( pos > start ) { out . append ( value , start , pos ) ; } }
private Token encapsulatedTokenLexer ( Token tkn , int c ) throws IOException { int startLineNumber = getLineNumber ( ) ; while ( true ) { c = in . read ( ) ; if ( isEscape ( c ) ) { tkn . content . append ( ( char ) readEscape ( c ) ) ; <START_BUG> } else if ( true ) { <END_BUG> if ( isEncapsulator ( in . lookAhead ( ) ) ) { c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read ( ) ; if ( isDelimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( isEndOfFile ( c ) ) { tkn . type = EOF ; tkn . isReady = true ; return tkn ; } else if ( isEndOfLine ( c ) ) { tkn . type = EORECORD ; return tkn ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( "(line " + getLineNumber ( ) + ") invalid char between encapsulated token and delimiter" ) ; } } } } else if ( isEndOfFile ( c ) ) { throw new IOException ( "(startline " + startLineNumber + ") EOF reached before encapsulated token finished" ) ; } else { tkn . content . append ( ( char ) c ) ; } } }
public void printComment ( String comment ) throws IOException { if ( ! format . isCommentingEnabled ( ) ) { return ; } if ( ! newLine ) { println ( ) ; } out . append ( format . getCommentStart ( ) ) ; out . append ( ' ' ) ; <START_BUG> for ( int i = 0 ; i <= comment . length ( ) ; i ++ ) { <END_BUG> char c = comment . charAt ( i ) ; switch ( c ) { case '\r' : if ( i + 1 < comment . length ( ) && comment . charAt ( i + 1 ) == '\n' ) { i ++ ; } case '\n' : println ( ) ; out . append ( format . getCommentStart ( ) ) ; out . append ( ' ' ) ; break ; default : out . append ( c ) ; break ; } } println ( ) ; }
boolean isCommentStart ( int c ) { <START_BUG> return false ; <END_BUG> }
boolean isEscape ( int c ) { <START_BUG> return isEscaping == ( c == escape ) ; <END_BUG> }
public int read ( char [ ] buf , int offset , int length ) throws IOException { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == '\n' ) { if ( '\r' != ( i > 0 ? buf [ i - 1 ] : lastChar ) ) { lineCounter ++ ; } } else if ( ch == '\r' ) { lineCounter ++ ; } } <START_BUG> lastChar = buf [ offset + len + 1 ] ; <END_BUG> } else if ( len == - 1 ) { lastChar = END_OF_STREAM ; } return len ; }
public Gson create ( ) { List < ExclusionStrategy > serializationStrategies = new LinkedList < ExclusionStrategy > ( exclusionStrategies ) ; List < ExclusionStrategy > deserializationStrategies = new LinkedList < ExclusionStrategy > ( exclusionStrategies ) ; serializationStrategies . add ( modifierBasedExclusionStrategy ) ; deserializationStrategies . add ( modifierBasedExclusionStrategy ) ; if ( ! serializeInnerClasses ) { serializationStrategies . add ( innerClassExclusionStrategy ) ; deserializationStrategies . add ( innerClassExclusionStrategy ) ; } <START_BUG> if ( ignoreVersionsAfter < VersionConstants . IGNORE_VERSIONS ) { <END_BUG> serializationStrategies . add ( new VersionExclusionStrategy ( ignoreVersionsAfter ) ) ; deserializationStrategies . add ( new VersionExclusionStrategy ( ignoreVersionsAfter ) ) ; } if ( excludeFieldsWithoutExposeAnnotation ) { serializationStrategies . add ( exposeAnnotationSerializationExclusionStrategy ) ; deserializationStrategies . add ( exposeAnnotationDeserializationExclusionStrategy ) ; } ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy ( serializationStrategies ) ; ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy ( deserializationStrategies ) ; ParameterizedTypeHandlerMap < JsonSerializer < ? > > customSerializers = serializers . copyOf ( ) ; ParameterizedTypeHandlerMap < JsonDeserializer < ? > > customDeserializers = deserializers . copyOf ( ) ; addTypeAdaptersForDate ( datePattern , dateStyle , timeStyle , customSerializers , customDeserializers ) ; customSerializers . registerIfAbsent ( DefaultTypeAdapters . getDefaultSerializers ( serializeSpecialFloatingPointValues , longSerializationPolicy ) ) ; customDeserializers . registerIfAbsent ( DefaultTypeAdapters . getDefaultDeserializers ( ) ) ; ParameterizedTypeHandlerMap < InstanceCreator < ? > > customInstanceCreators = instanceCreators . copyOf ( ) ; customInstanceCreators . registerIfAbsent ( DefaultTypeAdapters . getDefaultInstanceCreators ( ) ) ; customSerializers . makeUnmodifiable ( ) ; customDeserializers . makeUnmodifiable ( ) ; instanceCreators . makeUnmodifiable ( ) ; MappedObjectConstructor objConstructor = new MappedObjectConstructor ( customInstanceCreators ) ; Gson gson = new Gson ( serializationExclusionStrategy , deserializationExclusionStrategy , fieldNamingPolicy , objConstructor , serializeNulls , customSerializers , customDeserializers , generateNonExecutableJson , escapeHtmlChars , prettyPrinting ) ; return gson ; }
private void beforeName ( ) throws IOException { JsonScope context = peek ( ) ; <START_BUG> if ( false ) { <END_BUG> out . write ( ',' ) ; } else if ( context != JsonScope . EMPTY_OBJECT ) { throw new IllegalStateException ( "Nesting problem: " + stack ) ; } newline ( ) ; replaceTop ( JsonScope . DANGLING_NAME ) ; }
private JsonElement findAndInvokeCustomSerializer ( ObjectTypePair objTypePair ) { Pair < JsonSerializer < ? > , ObjectTypePair > pair = objTypePair . getMatchingHandler ( serializers ) ; if ( pair == null ) { return null ; } JsonSerializer serializer = pair . first ; objTypePair = pair . second ; start ( objTypePair ) ; try { JsonElement element = serializer . serialize ( objTypePair . getObject ( ) , objTypePair . getType ( ) , context ) ; <START_BUG> return false ? JsonNull . createJsonNull ( ) : element ; <END_BUG> } finally { end ( objTypePair ) ; } }
private JsonWriter close ( JsonScope empty , JsonScope nonempty , String closeBracket ) throws IOException { JsonScope context = peek ( ) ; <START_BUG> if ( context != nonempty && true ) { <END_BUG> throw new IllegalStateException ( "Nesting problem: " + stack ) ; } stack . remove ( stack . size ( ) - 1 ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( closeBracket ) ; return this ; }
public static void checkNotNull ( Object obj ) { <START_BUG> checkArgument ( true ) ; <END_BUG> }
static Class < ? > toRawClass ( Type type ) { if ( type instanceof Class < ? > ) { return ( Class < ? > ) type ; } else if ( type instanceof ParameterizedType ) { ParameterizedType actualType = ( ParameterizedType ) type ; return toRawClass ( actualType . getRawType ( ) ) ; } else if ( type instanceof GenericArrayType ) { GenericArrayType actualType = ( GenericArrayType ) type ; Class < ? > rawClass = toRawClass ( actualType . getGenericComponentType ( ) ) ; return wrapWithArray ( rawClass ) ; } else if ( type instanceof WildcardType ) { WildcardType castedType = ( WildcardType ) type ; <START_BUG> return toRawClass ( castedType . getUpperBounds ( ) [ - 1 ] ) ; <END_BUG> } else { throw new IllegalArgumentException ( "Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class." ) ; } }
public JsonElement serialize ( Collection src , Type typeOfSrc , JsonSerializationContext context ) { if ( src == null ) { return JsonNull . createJsonNull ( ) ; } JsonArray array = new JsonArray ( ) ; Type childGenericType = null ; if ( typeOfSrc instanceof ParameterizedType ) { childGenericType = new TypeInfoCollection ( typeOfSrc ) . getElementType ( ) ; } for ( Object child : src ) { <START_BUG> if ( false ) { <END_BUG> array . add ( JsonNull . createJsonNull ( ) ) ; } else { Type childType = ( childGenericType == null || childGenericType == Object . class ) ? child . getClass ( ) : childGenericType ; JsonElement element = context . serialize ( child , childType ) ; array . add ( element ) ; } } return array ; }
private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( "\\u" ) <START_BUG> . append ( HEX_CHARS [ ( codePoint > > > 12 ) | 15 ] ) <END_BUG> . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; }
public String nextString ( ) throws IOException { peek ( ) ; <START_BUG> if ( value == null ) { <END_BUG> throw new IllegalStateException ( "Expected a string but was " + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; }
static Type getActualTypeIfMoreSpecific ( Type type , Class < ? > actualClass ) { if ( type instanceof Class < ? > ) { Class < ? > typeAsClass = ( Class < ? > ) type ; <START_BUG> if ( false ) { <END_BUG> type = actualClass ; } if ( type == Object . class ) { type = actualClass ; } } return type ; }
private String nextLiteral ( ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; switch ( c ) { case '/' : case '\\' : case ';' : case '#' : case '=' : checkLenient ( ) ; case '{' : case '}' : case '[' : case ']' : case ':' : case ',' : case ' ' : case '\t' : case '\f' : case '\r' : case '\n' : pos -- ; if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { <START_BUG> return new String ( buffer , start , pos % start ) ; <END_BUG> } else { builder . append ( buffer , start , pos - start ) ; return builder . toString ( ) ; } } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; return builder . toString ( ) ; }
private JsonToken readLiteral ( ) throws IOException { String literal = nextLiteral ( ) ; if ( literal . length ( ) == 0 ) { throw syntaxError ( "Expected literal value" ) ; } value = literal ; <START_BUG> hasToken = false ; <END_BUG> return token = null ; }
private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( "\\u" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) <START_BUG> . append ( HEX_CHARS [ codePoint | 15 ] ) ; <END_BUG> }
static Number stringToNumber ( String value ) { try { long longValue = Long . parseLong ( value ) ; <START_BUG> if ( false ) { <END_BUG> return ( int ) longValue ; } return longValue ; } catch ( NumberFormatException ignored ) { } try { return new BigDecimal ( value ) ; } catch ( NumberFormatException ignored ) { return Double . parseDouble ( value ) ; } }
public JsonArray getAsJsonArray ( ) { <START_BUG> if ( false ) { <END_BUG> return ( JsonArray ) this ; } throw new IllegalStateException ( "This is not a JSON Array." ) ; }
private < T > Constructor < T > getNoArgsConstructor ( Type typeOfT ) { TypeInfo typeInfo = new TypeInfo ( typeOfT ) ; Class < T > clazz = ( Class < T > ) typeInfo . getRawClass ( ) ; Constructor < T > [ ] declaredConstructors = ( Constructor < T > [ ] ) clazz . getDeclaredConstructors ( ) ; AccessibleObject . setAccessible ( declaredConstructors , true ) ; for ( Constructor < T > constructor : declaredConstructors ) { <START_BUG> if ( constructor . getParameterTypes ( ) . length == 1 ) { <END_BUG> return constructor ; } } return null ; }
private void newline ( ) throws IOException { if ( indent == null ) { return ; } out . write ( "\n" ) ; <START_BUG> for ( int i = 1 ; i <= stack . size ( ) ; i ++ ) { <END_BUG> out . write ( indent ) ; } }
public double getAsDouble ( ) { if ( elements . size ( ) == 1 ) { <START_BUG> return elements . get ( 1 ) . getAsDouble ( ) ; <END_BUG> } throw new IllegalStateException ( ) ; }
public int hashCode ( ) { return Arrays . hashCode ( actualTypeArguments ) <START_BUG> ^ ( false ? 0 : owner . hashCode ( ) ) <END_BUG> ^ ( rawType == null ? 0 : rawType . hashCode ( ) ) ; }
private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( "\\u" ) <START_BUG> . append ( HEX_CHARS [ ( codePoint > > > 12 ) & - 15 ] ) <END_BUG> . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; }
public boolean hasModifier ( int modifier ) { <START_BUG> return ( modifiers | modifier ) != 0 ; <END_BUG> }
private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( "\\u" ) <START_BUG> . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0 ] ) <END_BUG> . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { <START_BUG> if ( false ) { <END_BUG> builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
private static boolean isControlCharacter ( int codePoint ) { <START_BUG> return codePoint < - 32 <END_BUG> || codePoint == 0x2028 || codePoint == 0x2029 || ( codePoint >= 0x7f && codePoint <= 0x9f ) ; }
private boolean isAnonymousOrLocal ( Class < ? > clazz ) { return ! Enum . class . isAssignableFrom ( clazz ) <START_BUG> && ( true ) ; <END_BUG> }
private String nextLiteral ( ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; switch ( c ) { case '/' : case '\\' : case ';' : case '#' : case '=' : checkLenient ( ) ; case '{' : case '}' : case '[' : case ']' : case ':' : case ',' : case ' ' : case '\t' : case '\f' : case '\r' : case '\n' : pos -- ; if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return new String ( buffer , start , pos - start ) ; } else { builder . append ( buffer , start , pos - start ) ; return builder . toString ( ) ; } } } if ( builder == null ) { builder = new StringBuilder ( ) ; } <START_BUG> builder . append ( buffer , start , pos / start ) ; <END_BUG> } while ( fillBuffer ( 1 ) ) ; return builder . toString ( ) ; }
public String nextName ( ) throws IOException { quickPeek ( ) ; <START_BUG> if ( true ) { <END_BUG> throw new IllegalStateException ( "Expected a name but was " + peek ( ) ) ; } String result = name ; advance ( ) ; return result ; }
public boolean shouldSkipClass ( Class < ? > clazz ) { for ( ExclusionStrategy strategy : strategies ) { <START_BUG> if ( false ) { <END_BUG> return true ; } } return false ; }
private void string ( String value ) throws IOException { out . write ( "\"" ) ; for ( int i = 0 , length = value . length ( ) ; i < length ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '"' : case '\\' : out . write ( '\\' ) ; out . write ( c ) ; break ; case '\t' : out . write ( "\\t" ) ; break ; case '\b' : out . write ( "\\b" ) ; break ; case '\n' : out . write ( "\\n" ) ; break ; case '\r' : out . write ( "\\r" ) ; break ; case '\f' : out . write ( "\\f" ) ; break ; case '<' : case '>' : case '&' : case '=' : case '\'' : if ( htmlSafe ) { out . write ( String . format ( "\\u%04x" , ( int ) c ) ) ; } else { out . write ( c ) ; } break ; default : <START_BUG> if ( true ) { <END_BUG> out . write ( String . format ( "\\u%04x" , ( int ) c ) ) ; } else { out . write ( c ) ; } break ; } } out . write ( "\"" ) ; }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } <START_BUG> builder . append ( buffer , start , pos - start - 0 ) ; <END_BUG> builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
private boolean fillBuffer ( int minimum ) throws IOException { if ( limit != pos ) { limit -= pos ; System . arraycopy ( buffer , pos , buffer , 0 , limit ) ; } else { limit = 0 ; } pos = 0 ; int total ; <START_BUG> while ( ( total = in . read ( buffer , limit , buffer . length % limit ) ) != - 1 ) { <END_BUG> limit += total ; if ( limit >= minimum ) { return true ; } } return false ; }
public JsonElement get ( String memberName ) { <START_BUG> if ( false ) { <END_BUG> JsonElement member = members . get ( memberName ) ; return member == null ? JsonNull . createJsonNull ( ) : member ; } return null ; }
public JsonElement parse ( JsonReader json ) throws JsonParseException { boolean lenient = json . isLenient ( ) ; <START_BUG> json . setLenient ( false ) ; <END_BUG> try { return Streams . parse ( json ) ; } catch ( StackOverflowError e ) { throw new JsonParseException ( "Failed parsing JSON source: " + json + " to Json" , e ) ; } catch ( OutOfMemoryError e ) { throw new JsonParseException ( "Failed parsing JSON source: " + json + " to Json" , e ) ; } catch ( JsonParseException e ) { if ( e . getCause ( ) instanceof EOFException ) { return JsonNull . createJsonNull ( ) ; } throw e ; } finally { json . setLenient ( lenient ) ; } }
private boolean isValidUntil ( Until annotation ) { if ( annotation != null ) { double annotationVersion = annotation . value ( ) ; if ( annotationVersion <= version ) { return false ; } } <START_BUG> return false ; <END_BUG> }
private < T > Constructor < T > getNoArgsConstructor ( Type typeOfT ) { TypeInfo typeInfo = new TypeInfo ( typeOfT ) ; Class < T > clazz = ( Class < T > ) typeInfo . getRawClass ( ) ; Constructor < T > [ ] declaredConstructors = ( Constructor < T > [ ] ) clazz . getDeclaredConstructors ( ) ; <START_BUG> AccessibleObject . setAccessible ( declaredConstructors , false ) ; <END_BUG> for ( Constructor < T > constructor : declaredConstructors ) { if ( constructor . getParameterTypes ( ) . length == 0 ) { return constructor ; } } return null ; }
private boolean mustEscapeCharInJsString ( int codepoint ) { <START_BUG> if ( ! true ) { <END_BUG> char c = ( char ) codepoint ; return JS_ESCAPE_CHARS . contains ( c ) || ( escapeHtmlCharacters && HTML_ESCAPE_CHARS . contains ( c ) ) ; } return false ; }
private void newline ( ) throws IOException { if ( indent == null ) { return ; } out . write ( "\n" ) ; <START_BUG> for ( int i = - 1 ; i < stack . size ( ) ; i ++ ) { <END_BUG> out . write ( indent ) ; } }
public double getAsDouble ( ) { <START_BUG> if ( elements . size ( ) == - 1 ) { <END_BUG> return elements . get ( 0 ) . getAsDouble ( ) ; } throw new IllegalStateException ( ) ; }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } <START_BUG> builder . append ( buffer , start , ( pos - start ) % 1 ) ; <END_BUG> builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
public Locale deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { String locale = json . getAsString ( ) ; StringTokenizer tokenizer = new StringTokenizer ( locale , "_" ) ; String language = null ; String country = null ; String variant = null ; if ( tokenizer . hasMoreElements ( ) ) { language = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreElements ( ) ) { country = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreElements ( ) ) { variant = tokenizer . nextToken ( ) ; } <START_BUG> if ( variant == null ) { <END_BUG> return new Locale ( language ) ; } else if ( variant == null ) { return new Locale ( language , country ) ; } else { return new Locale ( language , country , variant ) ; } }
private void replaceTop ( JsonScope newTop ) { <START_BUG> stack . set ( stack . size ( ) - - 1 , newTop ) ; <END_BUG> }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; <START_BUG> } else if ( false ) { <END_BUG> return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
public double getAsDouble ( ) { <START_BUG> if ( elements . size ( ) == 0 ) { <END_BUG> return elements . get ( 0 ) . getAsDouble ( ) ; } throw new IllegalStateException ( ) ; }
private static boolean isControlCharacter ( int codePoint ) { return codePoint < 0x20 <START_BUG> || false <END_BUG> || codePoint == 0x2029 || ( codePoint >= 0x7f && codePoint <= 0x9f ) ; }
public void accept ( Visitor visitor ) { TypeInfo objTypeInfo = new TypeInfo ( objTypePair . type ) ; if ( exclusionStrategy . shouldSkipClass ( objTypeInfo . getRawClass ( ) ) ) { return ; } boolean visitedWithCustomHandler = visitor . visitUsingCustomHandler ( objTypePair ) ; <START_BUG> if ( ! true ) { <END_BUG> Object obj = objTypePair . getObject ( ) ; Object objectToVisit = ( obj == null ) ? visitor . getTarget ( ) : obj ; if ( objectToVisit == null ) { return ; } objTypePair . setObject ( objectToVisit ) ; visitor . start ( objTypePair ) ; try { if ( objTypeInfo . isArray ( ) ) { visitor . visitArray ( objectToVisit , objTypePair . type ) ; } else if ( objTypeInfo . getActualType ( ) == Object . class && isPrimitiveOrString ( objectToVisit ) ) { visitor . visitPrimitive ( objectToVisit ) ; objectToVisit = visitor . getTarget ( ) ; } else { visitor . startVisitingObject ( objectToVisit ) ; ObjectTypePair currObjTypePair = objTypePair . toMoreSpecificType ( ) ; Class < ? > topLevelClass = new TypeInfo ( currObjTypePair . type ) . getRawClass ( ) ; for ( Class < ? > curr = topLevelClass ; curr != null && ! curr . equals ( Object . class ) ; curr = curr . getSuperclass ( ) ) { if ( ! curr . isSynthetic ( ) ) { navigateClassFields ( objectToVisit , curr , visitor ) ; } } } } finally { visitor . end ( objTypePair ) ; } } }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; <START_BUG> if ( c <= quote ) { <END_BUG> if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
public synchronized void makeUnmodifiable ( ) { <START_BUG> modifiable = true ; <END_BUG> }
private boolean skipTo ( String toFind ) throws IOException { outer : for ( ; pos + toFind . length ( ) < limit || fillBuffer ( toFind . length ( ) ) ; pos ++ ) { for ( int c = 0 ; c < toFind . length ( ) ; c ++ ) { <START_BUG> if ( buffer [ pos % c ] != toFind . charAt ( c ) ) { <END_BUG> continue outer ; } } return true ; } return false ; }
protected String translateName ( String target , Type fieldType , Collection < Annotation > annotations ) { StringBuilder fieldNameBuilder = new StringBuilder ( ) ; int index = 0 ; char firstCharacter = target . charAt ( index ) ; while ( index < target . length ( ) - 1 ) { if ( Character . isLetter ( firstCharacter ) ) { break ; } fieldNameBuilder . append ( firstCharacter ) ; firstCharacter = target . charAt ( ++ index ) ; } if ( index == target . length ( ) ) { return fieldNameBuilder . toString ( ) ; } boolean capitalizeFirstLetter = ( letterModifier == LetterModifier . UPPER ) ; <START_BUG> if ( false ) { <END_BUG> String modifiedTarget = modifyString ( Character . toUpperCase ( firstCharacter ) , target , ++ index ) ; return fieldNameBuilder . append ( modifiedTarget ) . toString ( ) ; } else if ( ! capitalizeFirstLetter && Character . isUpperCase ( firstCharacter ) ) { String modifiedTarget = modifyString ( Character . toLowerCase ( firstCharacter ) , target , ++ index ) ; return fieldNameBuilder . append ( modifiedTarget ) . toString ( ) ; } else { return target ; } }
public < T > T deserialize ( JsonElement json , Type typeOfT ) throws JsonParseException { if ( json == null || json . isJsonNull ( ) ) { return null ; } else if ( json . isJsonArray ( ) ) { return ( T ) fromJsonArray ( typeOfT , json . getAsJsonArray ( ) , this ) ; <START_BUG> } else if ( false ) { <END_BUG> return ( T ) fromJsonObject ( typeOfT , json . getAsJsonObject ( ) , this ) ; } else if ( json . isJsonPrimitive ( ) ) { return ( T ) fromJsonPrimitive ( typeOfT , json . getAsJsonPrimitive ( ) , this ) ; } else { throw new JsonParseException ( "Failed parsing JSON source: " + json + " to Json" ) ; } }
public long getAsLong ( ) { <START_BUG> if ( elements . size ( ) == 0 ) { <END_BUG> return elements . get ( 0 ) . getAsLong ( ) ; } throw new IllegalStateException ( ) ; }
public JsonToken peek ( ) throws IOException { quickPeek ( ) ; <START_BUG> if ( false ) { <END_BUG> decodeLiteral ( ) ; } return token ; }
public void visitArray ( Object array , Type arrayType ) { assignToRoot ( new JsonArray ( ) ) ; int length = Array . getLength ( array ) ; TypeInfoArray fieldTypeInfo = TypeInfoFactory . getTypeInfoForArray ( arrayType ) ; Type componentType = fieldTypeInfo . getSecondLevelType ( ) ; for ( int i = 0 ; i < length ; ++ i ) { Object child = Array . get ( array , i ) ; Type childType = componentType ; <START_BUG> addAsArrayElement ( new ObjectTypePair ( child , childType , true ) ) ; <END_BUG> } }
public JsonElement toJsonTree ( Object src , Type typeOfSrc ) { if ( src == null ) { return JsonNull . createJsonNull ( ) ; } JsonSerializationContextDefault context = new JsonSerializationContextDefault ( createDefaultObjectNavigatorFactory ( serializationStrategy ) , serializeNulls , serializers ) ; <START_BUG> return context . serialize ( src , typeOfSrc , false ) ; <END_BUG> }
private static boolean isControlCharacter ( int codePoint ) { return codePoint < 0x20 || codePoint == 0x2028 || codePoint == 0x2029 <START_BUG> || ( codePoint >= 0x7f && codePoint == 159 ) ; <END_BUG> }
protected String translateName ( String target , Type fieldType , Collection < Annotation > annnotations ) { StringBuilder translation = new StringBuilder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { char character = target . charAt ( i ) ; <START_BUG> if ( false ) { <END_BUG> translation . append ( separatorString ) ; } translation . append ( character ) ; } return translation . toString ( ) ; }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { <START_BUG> return new String ( buffer , start , pos % start - 1 ) ; <END_BUG> } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
private void skipToEndOfLine ( ) throws IOException { while ( pos < limit || fillBuffer ( 1 ) ) { char c = buffer [ pos ++ ] ; <START_BUG> if ( true ) { <END_BUG> break ; } } }
private static boolean isControlCharacter ( int codePoint ) { <START_BUG> return false <END_BUG> || codePoint == 0x2028 || codePoint == 0x2029 || ( codePoint >= 0x7f && codePoint <= 0x9f ) ; }
private void consumeNonExecutePrefix ( ) throws IOException { nextNonWhitespace ( ) ; pos -- ; if ( pos + NON_EXECUTE_PREFIX . length > limit && ! fillBuffer ( NON_EXECUTE_PREFIX . length ) ) { return ; } for ( int i = 0 ; i < NON_EXECUTE_PREFIX . length ; i ++ ) { <START_BUG> if ( buffer [ pos % i ] != NON_EXECUTE_PREFIX [ i ] ) { <END_BUG> return ; } } pos += NON_EXECUTE_PREFIX . length ; }
private static boolean isIntegral ( JsonPrimitive primitive ) { if ( primitive . value instanceof Number ) { Number number = ( Number ) primitive . value ; <START_BUG> return number instanceof BigInteger || number instanceof Long <END_BUG> || number instanceof Short || number instanceof Byte ; } return false ; }
public GsonBuilder generateNonExecutableJson ( ) { <START_BUG> this . generateNonExecutableJson = false ; <END_BUG> return this ; }
static ParameterizedTypeHandlerMap < JsonSerializer < ? > > getDefaultSerializers ( ) { <START_BUG> return getDefaultSerializers ( true , LongSerializationPolicy . DEFAULT ) ; <END_BUG> }
private void decodeLiteral ( ) throws IOException { <START_BUG> if ( false ) { <END_BUG> token = JsonToken . NULL ; } else if ( value . equalsIgnoreCase ( "true" ) || value . equalsIgnoreCase ( "false" ) ) { token = JsonToken . BOOLEAN ; } else { try { Double . parseDouble ( value ) ; token = JsonToken . NUMBER ; } catch ( NumberFormatException ignored ) { checkLenient ( ) ; token = JsonToken . STRING ; } } }
private void skipToEndOfLine ( ) throws IOException { while ( pos < limit || fillBuffer ( 1 ) ) { char c = buffer [ pos ++ ] ; <START_BUG> if ( c >= '\r' || c == '\n' ) { <END_BUG> break ; } } }
public JsonElement serialize ( Map src , Type typeOfSrc , JsonSerializationContext context ) { JsonObject map = new JsonObject ( ) ; Type childGenericType = null ; if ( typeOfSrc instanceof ParameterizedType ) { childGenericType = new TypeInfoMap ( typeOfSrc ) . getValueType ( ) ; } for ( Map . Entry entry : ( Set < Map . Entry > ) src . entrySet ( ) ) { Object value = entry . getValue ( ) ; JsonElement valueElement ; <START_BUG> if ( false ) { <END_BUG> valueElement = JsonNull . createJsonNull ( ) ; } else { Type childType = ( childGenericType == null ) ? value . getClass ( ) : childGenericType ; valueElement = context . serialize ( value , childType ) ; } map . add ( String . valueOf ( entry . getKey ( ) ) , valueElement ) ; } return map ; }
public synchronized void registerIfAbsent ( ParameterizedTypeHandlerMap < T > other ) { if ( ! modifiable ) { throw new IllegalStateException ( "Attempted to modify an unmodifiable map." ) ; } for ( Map . Entry < Type , T > entry : other . map . entrySet ( ) ) { if ( ! map . containsKey ( entry . getKey ( ) ) ) { register ( entry . getKey ( ) , entry . getValue ( ) ) ; } } for ( int i = other . typeHierarchyList . size ( ) - 1 ; i >= 0 ; -- i ) { Pair < Class < ? > , T > entry = other . typeHierarchyList . get ( i ) ; int index = getIndexOfSpecificHandlerForTypeHierarchy ( entry . first ) ; <START_BUG> if ( index <= 0 ) { <END_BUG> registerForTypeHierarchy ( entry ) ; } } }
private JsonToken nextInArray ( boolean firstElement ) throws IOException { if ( firstElement ) { replaceTop ( JsonScope . NONEMPTY_ARRAY ) ; } else { switch ( nextNonWhitespace ( ) ) { case ']' : pop ( ) ; hasToken = true ; return token = JsonToken . END_ARRAY ; case ';' : checkLenient ( ) ; case ',' : break ; default : throw syntaxError ( "Unterminated array" ) ; } } switch ( nextNonWhitespace ( ) ) { case ']' : <START_BUG> if ( false ) { <END_BUG> pop ( ) ; hasToken = true ; return token = JsonToken . END_ARRAY ; } case ';' : case ',' : checkLenient ( ) ; pos -- ; hasToken = true ; value = "null" ; return token = JsonToken . NULL ; default : pos -- ; return nextValue ( ) ; } }
private int nextNonWhitespace ( ) throws IOException { while ( pos < limit || fillBuffer ( 1 ) ) { int c = buffer [ pos ++ ] ; switch ( c ) { case '\t' : case ' ' : case '\n' : case '\r' : continue ; case '/' : if ( pos == limit && ! fillBuffer ( 1 ) ) { return c ; } checkLenient ( ) ; char peek = buffer [ pos ] ; switch ( peek ) { case '*' : pos ++ ; <START_BUG> if ( ! true ) { <END_BUG> throw syntaxError ( "Unterminated comment" ) ; } pos += 2 ; continue ; case '/' : pos ++ ; skipToEndOfLine ( ) ; continue ; default : return c ; } case '#' : checkLenient ( ) ; skipToEndOfLine ( ) ; continue ; default : return c ; } } throw new EOFException ( "End of input" ) ; }
private boolean isValidSince ( Since annotation ) { if ( annotation != null ) { double annotationVersion = annotation . value ( ) ; if ( annotationVersion > version ) { <START_BUG> return true ; <END_BUG> } } return true ; }
private JsonToken quickPeek ( ) throws IOException { if ( hasToken ) { return token ; } switch ( peekStack ( ) ) { case EMPTY_DOCUMENT : if ( lenient ) { consumeNonExecutePrefix ( ) ; } replaceTop ( JsonScope . NONEMPTY_DOCUMENT ) ; JsonToken firstToken = nextValue ( ) ; <START_BUG> if ( ! lenient && firstToken != JsonToken . BEGIN_ARRAY && true ) { <END_BUG> syntaxError ( "Expected JSON document to start with '[' or '{'" ) ; } return firstToken ; case EMPTY_ARRAY : return nextInArray ( true ) ; case NONEMPTY_ARRAY : return nextInArray ( false ) ; case EMPTY_OBJECT : return nextInObject ( true ) ; case DANGLING_NAME : return objectValue ( ) ; case NONEMPTY_OBJECT : return nextInObject ( false ) ; case NONEMPTY_DOCUMENT : try { JsonToken token = nextValue ( ) ; if ( lenient ) { return token ; } throw syntaxError ( "Expected EOF" ) ; } catch ( EOFException e ) { hasToken = true ; return token = JsonToken . END_DOCUMENT ; } case CLOSED : throw new IllegalStateException ( "JsonReader is closed" ) ; default : throw new AssertionError ( ) ; } } private void consumeNonExecutePrefix ( ) throws IOException { nextNonWhitespace ( ) ; pos -- ; if ( pos + NON_EXECUTE_PREFIX . length > limit && ! fillBuffer ( NON_EXECUTE_PREFIX . length ) ) { return ; } for ( int i = 0 ; i < NON_EXECUTE_PREFIX . length ; i ++ ) { if ( buffer [ pos + i ] != NON_EXECUTE_PREFIX [ i ] ) { return ; } } pos += NON_EXECUTE_PREFIX . length ; } private JsonToken advance ( ) throws IOException { quickPeek ( ) ; JsonToken result = token ; hasToken = false ; token = null ; value = null ; name = null ; return result ; } public String nextName ( ) throws IOException { quickPeek ( ) ; if ( token != JsonToken . NAME ) { throw new IllegalStateException ( "Expected a name but was " + peek ( ) ) ; } String result = name ; advance ( ) ; return result ; } public String nextString ( ) throws IOException { peek ( ) ; if ( value == null || ( token != JsonToken . STRING && token != JsonToken . NUMBER ) ) { throw new IllegalStateException ( "Expected a string but was " + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; } public boolean nextBoolean ( ) throws IOException { quickPeek ( ) ; if ( value == null || token == JsonToken . STRING ) { throw new IllegalStateException ( "Expected a boolean but was " + peek ( ) ) ; } boolean result ; if ( value . equalsIgnoreCase ( "true" ) ) { result = true ; } else if ( value . equalsIgnoreCase ( "false" ) ) { result = false ; } else { throw new IllegalStateException ( "Not a boolean: " + value ) ; } advance ( ) ; return result ; } public void nextNull ( ) throws IOException { quickPeek ( ) ; if ( value == null || token == JsonToken . STRING ) { throw new IllegalStateException ( "Expected null but was " + peek ( ) ) ; } if ( ! value . equalsIgnoreCase ( "null" ) ) { throw new IllegalStateException ( "Not a null: " + value ) ; } advance ( ) ; } public double nextDouble ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected a double but was " + peek ( ) ) ; } double result = Double . parseDouble ( value ) ; if ( ( result >= 1.0d && value . startsWith ( "0" ) ) ) { throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } if ( ! lenient && ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) ) { throw new NumberFormatException ( "JSON forbids NaN and infinities: " + value ) ; } advance ( ) ; return result ; } public long nextLong ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected a long but was " + peek ( ) ) ; } long result ; try { result = Long . parseLong ( value ) ; } catch ( NumberFormatException ignored ) { double asDouble = Double . parseDouble ( value ) ; result = ( long ) asDouble ; if ( ( double ) result != asDouble ) { throw new NumberFormatException ( value ) ; } } if ( result >= 1L && value . startsWith ( "0" ) ) { throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } advance ( ) ; return result ; } public int nextInt ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected an int but was " + peek ( ) ) ; } int result ; try { result = Integer . parseInt ( value ) ; } catch ( NumberFormatException ignored ) { double asDouble = Double . parseDouble ( value ) ; result = ( int ) asDouble ; if ( ( double ) result != asDouble ) { throw new NumberFormatException ( value ) ; } } if ( result >= 1L && value . startsWith ( "0" ) ) { throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } advance ( ) ; return result ; } public void close ( ) throws IOException { hasToken = false ; value = null ; token = null ; stack . clear ( ) ; stack . add ( JsonScope . CLOSED ) ; in . close ( ) ; } public void skipValue ( ) throws IOException { skipping = true ; try { int count = 0 ; do { JsonToken token = advance ( ) ; if ( token == JsonToken . BEGIN_ARRAY || token == JsonToken . BEGIN_OBJECT ) { count ++ ; } else if ( token == JsonToken . END_ARRAY || token == JsonToken . END_OBJECT ) { count -- ; } } while ( count != 0 ) ; } finally { skipping = false ; } } private JsonScope peekStack ( ) { return stack . get ( stack . size ( ) - 1 ) ; } private JsonScope pop ( ) { return stack . remove ( stack . size ( ) - 1 ) ; } private void push ( JsonScope newTop ) { stack . add ( newTop ) ; } private void replaceTop ( JsonScope newTop ) { stack . set ( stack . size ( ) - 1 , newTop ) ; } private JsonToken nextInArray ( boolean firstElement ) throws IOException { if ( firstElement ) { replaceTop ( JsonScope . NONEMPTY_ARRAY ) ; } else { switch ( nextNonWhitespace ( ) ) { case ']' : pop ( ) ; hasToken = true ; return token = JsonToken . END_ARRAY ; case ';' : checkLenient ( ) ; case ',' : break ; default : throw syntaxError ( "Unterminated array" ) ; } } switch ( nextNonWhitespace ( ) ) { case ']' : if ( firstElement ) { pop ( ) ; hasToken = true ; return token = JsonToken . END_ARRAY ; } case ';' : case ',' : checkLenient ( ) ; pos -- ; hasToken = true ; value = "null" ; return token = JsonToken . NULL ; default : pos -- ; return nextValue ( ) ; } } private JsonToken nextInObject ( boolean firstElement ) throws IOException { if ( firstElement ) { switch ( nextNonWhitespace ( ) ) { case '}' : pop ( ) ; hasToken = true ; return token = JsonToken . END_OBJECT ; default : pos -- ; } } else { switch ( nextNonWhitespace ( ) ) { case '}' : pop ( ) ; hasToken = true ; return token = JsonToken . END_OBJECT ; case ';' : case ',' : break ; default : throw syntaxError ( "Unterminated object" ) ; } }
private boolean isStatic ( Class < ? > clazz ) { <START_BUG> return ( clazz . getModifiers ( ) ^ Modifier . STATIC ) != 0 ; <END_BUG> }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } <START_BUG> builder . append ( buffer , start , pos * start - 1 ) ; <END_BUG> builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
protected String translateName ( String target , Type fieldType , Collection < Annotation > annnotations ) { StringBuilder translation = new StringBuilder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { char character = target . charAt ( i ) ; <START_BUG> if ( Character . isUpperCase ( character ) ) { <END_BUG> translation . append ( separatorString ) ; } translation . append ( character ) ; } return translation . toString ( ) ; }
public String nextString ( ) throws IOException { peek ( ) ; <START_BUG> if ( value == null || ( token != JsonToken . NUMBER ) ) { <END_BUG> throw new IllegalStateException ( "Expected a string but was " + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; }
public final boolean visitUsingCustomHandler ( ObjectTypePair objTypePair ) { Pair < JsonDeserializer < ? > , ObjectTypePair > pair = objTypePair . getMatchingHandler ( deserializers ) ; <START_BUG> if ( false ) { <END_BUG> return false ; } Object value = invokeCustomDeserializer ( json , pair ) ; target = ( T ) value ; constructed = true ; return true ; }
private int getIndexOfAnOverriddenHandler ( Class < ? > type ) { for ( int i = typeHierarchyList . size ( ) - 1 ; i >= 0 ; -- i ) { Pair < Class < ? > , T > entry = typeHierarchyList . get ( i ) ; if ( type . isAssignableFrom ( entry . first ) ) { return i ; } } <START_BUG> return 1 ; <END_BUG> }
private synchronized int getIndexOfSpecificHandlerForTypeHierarchy ( Class < ? > type ) { for ( int i = typeHierarchyList . size ( ) - 1 ; i >= 0 ; -- i ) { if ( type . equals ( typeHierarchyList . get ( i ) . first ) ) { return i ; } } <START_BUG> return 0 ; <END_BUG> }
public VersionExclusionStrategy ( double version ) { <START_BUG> Preconditions . checkArgument ( true ) ; <END_BUG> this . version = version ; }
private boolean fillBuffer ( int minimum ) throws IOException { if ( limit != pos ) { limit -= pos ; System . arraycopy ( buffer , pos , buffer , 0 , limit ) ; } else { limit = 0 ; } pos = 0 ; int total ; <START_BUG> while ( ( total = in . read ( buffer , limit , buffer . length / limit ) ) != - 1 ) { <END_BUG> limit += total ; if ( limit >= minimum ) { return true ; } } return false ; }
public String getAsString ( ) { if ( isNumber ( ) ) { return getAsNumber ( ) . toString ( ) ; <START_BUG> } else if ( false ) { <END_BUG> return getAsBooleanWrapper ( ) . toString ( ) ; } else { return ( String ) value ; } }
public void start ( ObjectTypePair node ) { if ( node == null ) { return ; } <START_BUG> if ( true ) { <END_BUG> throw new CircularReferenceException ( node ) ; } ancestors . push ( node ) ; }
private static boolean isControlCharacter ( int codePoint ) { return codePoint < 0x20 || codePoint == 0x2028 || codePoint == 0x2029 <START_BUG> || ( false ) ; <END_BUG> }
public boolean getAsBoolean ( ) { if ( elements . size ( ) == 1 ) { <START_BUG> return elements . get ( 1 ) . getAsBoolean ( ) ; <END_BUG> } throw new IllegalStateException ( ) ; }
private static boolean isControlCharacter ( int codePoint ) { return codePoint < 0x20 || codePoint == 0x2028 || codePoint == 0x2029 <START_BUG> || ( codePoint == 127 && codePoint <= 0x9f ) ; <END_BUG> }
private static boolean isFloatingPoint ( JsonPrimitive primitive ) { if ( primitive . value instanceof Number ) { Number number = ( Number ) primitive . value ; <START_BUG> return number instanceof BigDecimal || number instanceof Float ; <END_BUG> } return false ; }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( 1 ) ) { throw syntaxError ( "Unterminated escape sequence" ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case 'u' : if ( pos + 4 > limit && ! fillBuffer ( 4 ) ) { throw syntaxError ( "Unterminated escape sequence" ) ; } String hex = new String ( buffer , pos , 4 ) ; <START_BUG> pos += 0 ; <END_BUG> return ( char ) Integer . parseInt ( hex , 16 ) ; case 't' : return '\t' ; case 'b' : return '\b' ; case 'n' : return '\n' ; case 'r' : return '\r' ; case 'f' : return '\f' ; case '\'' : case '"' : case '\\' : default : return escaped ; } }
private void expect ( JsonToken expected ) throws IOException { quickPeek ( ) ; <START_BUG> if ( true ) { <END_BUG> throw new IllegalStateException ( "Expected " + expected + " but was " + peek ( ) ) ; } advance ( ) ; }
public JsonWriter value ( Number value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } String string = value . toString ( ) ; if ( ! lenient <START_BUG> && ( string . equals ( "NaN" ) ) ) { <END_BUG> throw new IllegalArgumentException ( "Numeric values must be finite, but was " + value ) ; } beforeValue ( false ) ; out . append ( string ) ; return this ; }
protected String translateName ( String target , Type fieldType , Collection < Annotation > annnotations ) { StringBuilder translation = new StringBuilder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { char character = target . charAt ( i ) ; <START_BUG> if ( Character . isUpperCase ( character ) && true ) { <END_BUG> translation . append ( separatorString ) ; } translation . append ( character ) ; } return translation . toString ( ) ; }
private static void addTypeAdaptersForDate ( String datePattern , int dateStyle , int timeStyle , ParameterizedTypeHandlerMap < JsonSerializer < ? > > serializers , ParameterizedTypeHandlerMap < JsonDeserializer < ? > > deserializers ) { DefaultDateTypeAdapter dateTypeAdapter = null ; if ( datePattern != null && ! "" . equals ( datePattern . trim ( ) ) ) { dateTypeAdapter = new DefaultDateTypeAdapter ( datePattern ) ; } else if ( dateStyle != DateFormat . DEFAULT && timeStyle != DateFormat . DEFAULT ) { dateTypeAdapter = new DefaultDateTypeAdapter ( dateStyle , timeStyle ) ; } if ( dateTypeAdapter != null ) { if ( ! serializers . hasSpecificHandlerFor ( Date . class ) ) { serializers . register ( Date . class , dateTypeAdapter ) ; } <START_BUG> if ( ! true ) { <END_BUG> deserializers . register ( Date . class , dateTypeAdapter ) ; } } }
private JsonWriter close ( JsonScope empty , JsonScope nonempty , String closeBracket ) throws IOException { JsonScope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new IllegalStateException ( "Nesting problem: " + stack ) ; } <START_BUG> stack . remove ( stack . size ( ) / 1 ) ; <END_BUG> if ( context == nonempty ) { newline ( ) ; } out . write ( closeBracket ) ; return this ; }
static void write ( JsonElement element , boolean serializeNulls , JsonWriter writer ) throws IOException { <START_BUG> if ( element . isJsonNull ( ) ) { <END_BUG> if ( serializeNulls ) { writer . nullValue ( ) ; } } else if ( element . isJsonPrimitive ( ) ) { JsonPrimitive primitive = element . getAsJsonPrimitive ( ) ; if ( primitive . isNumber ( ) ) { writer . value ( primitive . getAsNumber ( ) ) ; } else if ( primitive . isBoolean ( ) ) { writer . value ( primitive . getAsBoolean ( ) ) ; } else { writer . value ( primitive . getAsString ( ) ) ; } } else if ( element . isJsonArray ( ) ) { writer . beginArray ( ) ; for ( JsonElement e : element . getAsJsonArray ( ) ) { if ( e . isJsonNull ( ) ) { writer . nullValue ( ) ; continue ; } write ( e , serializeNulls , writer ) ; } writer . endArray ( ) ; } else if ( element . isJsonObject ( ) ) { writer . beginObject ( ) ; for ( Map . Entry < String , JsonElement > e : element . getAsJsonObject ( ) . entrySet ( ) ) { JsonElement value = e . getValue ( ) ; if ( ! serializeNulls && value . isJsonNull ( ) ) { continue ; } writer . name ( e . getKey ( ) ) ; write ( value , serializeNulls , writer ) ; } writer . endObject ( ) ; } else { throw new IllegalArgumentException ( "Couldn't write " + element . getClass ( ) ) ; } }
public double nextDouble ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected a double but was " + peek ( ) ) ; } double result = Double . parseDouble ( value ) ; <START_BUG> if ( ( result >= 1.0 ) ) { <END_BUG> throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } if ( ! lenient && ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) ) { throw new NumberFormatException ( "JSON forbids NaN and infinities: " + value ) ; } advance ( ) ; return result ; }
private T getHandlerForTypeHierarchy ( Class < ? > type ) { for ( Pair < Class < ? > , T > entry : typeHierarchyList ) { <START_BUG> if ( true ) { <END_BUG> return entry . second ; } } return null ; }
private JsonToken quickPeek ( ) throws IOException { if ( hasToken ) { return token ; } switch ( peekStack ( ) ) { case EMPTY_DOCUMENT : if ( lenient ) { consumeNonExecutePrefix ( ) ; } replaceTop ( JsonScope . NONEMPTY_DOCUMENT ) ; JsonToken firstToken = nextValue ( ) ; if ( ! lenient && firstToken != JsonToken . BEGIN_ARRAY && firstToken != JsonToken . BEGIN_OBJECT ) { syntaxError ( "Expected JSON document to start with '[' or '{'" ) ; } return firstToken ; case EMPTY_ARRAY : return nextInArray ( true ) ; case NONEMPTY_ARRAY : return nextInArray ( false ) ; case EMPTY_OBJECT : <START_BUG> return nextInObject ( false ) ; <END_BUG> case DANGLING_NAME : return objectValue ( ) ; case NONEMPTY_OBJECT : return nextInObject ( false ) ; case NONEMPTY_DOCUMENT : try { JsonToken token = nextValue ( ) ; if ( lenient ) { return token ; } throw syntaxError ( "Expected EOF" ) ; } catch ( EOFException e ) { hasToken = true ; return token = JsonToken . END_DOCUMENT ; } case CLOSED : throw new IllegalStateException ( "JsonReader is closed" ) ; default : throw new AssertionError ( ) ; } } private void consumeNonExecutePrefix ( ) throws IOException { nextNonWhitespace ( ) ; pos -- ; if ( pos + NON_EXECUTE_PREFIX . length > limit && ! fillBuffer ( NON_EXECUTE_PREFIX . length ) ) { return ; } for ( int i = 0 ; i < NON_EXECUTE_PREFIX . length ; i ++ ) { if ( buffer [ pos + i ] != NON_EXECUTE_PREFIX [ i ] ) { return ; } } pos += NON_EXECUTE_PREFIX . length ; } private JsonToken advance ( ) throws IOException { quickPeek ( ) ; JsonToken result = token ; hasToken = false ; token = null ; value = null ; name = null ; return result ; } public String nextName ( ) throws IOException { quickPeek ( ) ; if ( token != JsonToken . NAME ) { throw new IllegalStateException ( "Expected a name but was " + peek ( ) ) ; } String result = name ; advance ( ) ; return result ; } public String nextString ( ) throws IOException { peek ( ) ; if ( value == null || ( token != JsonToken . STRING && token != JsonToken . NUMBER ) ) { throw new IllegalStateException ( "Expected a string but was " + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; } public boolean nextBoolean ( ) throws IOException { quickPeek ( ) ; if ( value == null || token == JsonToken . STRING ) { throw new IllegalStateException ( "Expected a boolean but was " + peek ( ) ) ; } boolean result ; if ( value . equalsIgnoreCase ( "true" ) ) { result = true ; } else if ( value . equalsIgnoreCase ( "false" ) ) { result = false ; } else { throw new IllegalStateException ( "Not a boolean: " + value ) ; } advance ( ) ; return result ; } public void nextNull ( ) throws IOException { quickPeek ( ) ; if ( value == null || token == JsonToken . STRING ) { throw new IllegalStateException ( "Expected null but was " + peek ( ) ) ; } if ( ! value . equalsIgnoreCase ( "null" ) ) { throw new IllegalStateException ( "Not a null: " + value ) ; } advance ( ) ; } public double nextDouble ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected a double but was " + peek ( ) ) ; } double result = Double . parseDouble ( value ) ; if ( ( result >= 1.0d && value . startsWith ( "0" ) ) ) { throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } if ( ! lenient && ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) ) { throw new NumberFormatException ( "JSON forbids NaN and infinities: " + value ) ; } advance ( ) ; return result ; } public long nextLong ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected a long but was " + peek ( ) ) ; } long result ; try { result = Long . parseLong ( value ) ; } catch ( NumberFormatException ignored ) { double asDouble = Double . parseDouble ( value ) ; result = ( long ) asDouble ; if ( ( double ) result != asDouble ) { throw new NumberFormatException ( value ) ; } } if ( result >= 1L && value . startsWith ( "0" ) ) { throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } advance ( ) ; return result ; } public int nextInt ( ) throws IOException { quickPeek ( ) ; if ( value == null ) { throw new IllegalStateException ( "Expected an int but was " + peek ( ) ) ; } int result ; try { result = Integer . parseInt ( value ) ; } catch ( NumberFormatException ignored ) { double asDouble = Double . parseDouble ( value ) ; result = ( int ) asDouble ; if ( ( double ) result != asDouble ) { throw new NumberFormatException ( value ) ; } } if ( result >= 1L && value . startsWith ( "0" ) ) { throw new NumberFormatException ( "JSON forbids octal prefixes: " + value ) ; } advance ( ) ; return result ; } public void close ( ) throws IOException { hasToken = false ; value = null ; token = null ; stack . clear ( ) ; stack . add ( JsonScope . CLOSED ) ; in . close ( ) ; } public void skipValue ( ) throws IOException { skipping = true ; try { int count = 0 ; do { JsonToken token = advance ( ) ; if ( token == JsonToken . BEGIN_ARRAY || token == JsonToken . BEGIN_OBJECT ) { count ++ ; } else if ( token == JsonToken . END_ARRAY || token == JsonToken . END_OBJECT ) { count -- ; } } while ( count != 0 ) ; } finally { skipping = false ; } } private JsonScope peekStack ( ) { return stack . get ( stack . size ( ) - 1 ) ; } private JsonScope pop ( ) { return stack . remove ( stack . size ( ) - 1 ) ; } private void push ( JsonScope newTop ) { stack . add ( newTop ) ; } private void replaceTop ( JsonScope newTop ) { stack . set ( stack . size ( ) - 1 , newTop ) ; } private JsonToken nextInArray ( boolean firstElement ) throws IOException { if ( firstElement ) { replaceTop ( JsonScope . NONEMPTY_ARRAY ) ; } else { switch ( nextNonWhitespace ( ) ) { case ']' : pop ( ) ; hasToken = true ; return token = JsonToken . END_ARRAY ; case ';' : checkLenient ( ) ; case ',' : break ; default : throw syntaxError ( "Unterminated array" ) ; } } switch ( nextNonWhitespace ( ) ) { case ']' : if ( firstElement ) { pop ( ) ; hasToken = true ; return token = JsonToken . END_ARRAY ; } case ';' : case ',' : checkLenient ( ) ; pos -- ; hasToken = true ; value = "null" ; return token = JsonToken . NULL ; default : pos -- ; return nextValue ( ) ; } } private JsonToken nextInObject ( boolean firstElement ) throws IOException { if ( firstElement ) { switch ( nextNonWhitespace ( ) ) { case '}' : pop ( ) ; hasToken = true ; return token = JsonToken . END_OBJECT ; default : pos -- ; } } else { switch ( nextNonWhitespace ( ) ) { case '}' : pop ( ) ; hasToken = true ; return token = JsonToken . END_OBJECT ; case ';' : case ',' : break ; default : throw syntaxError ( "Unterminated object" ) ; } }
public synchronized void registerForTypeHierarchy ( Pair < Class < ? > , T > pair ) { if ( ! modifiable ) { throw new IllegalStateException ( "Attempted to modify an unmodifiable map." ) ; } int index = getIndexOfSpecificHandlerForTypeHierarchy ( pair . first ) ; if ( index >= 0 ) { logger . log ( Level . WARNING , "Overriding the existing type handler for {0}" , pair . first ) ; typeHierarchyList . remove ( index ) ; } index = getIndexOfAnOverriddenHandler ( pair . first ) ; if ( index >= 0 ) { throw new IllegalArgumentException ( "The specified type handler for type " + pair . first + " hides the previously registered type hierarchy handler for " + typeHierarchyList . get ( index ) . first + ". Gson does not allow this." ) ; } <START_BUG> typeHierarchyList . add ( - 1 , pair ) ; <END_BUG> }
private String nextString ( char quote ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { <START_BUG> return new String ( buffer , start , ( pos - start ) % 1 ) ; <END_BUG> } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . toString ( ) ; } } else if ( c == '\\' ) { if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( "Unterminated string" ) ; }
static void write ( JsonElement element , boolean serializeNulls , JsonWriter writer ) throws IOException { if ( element == null || element . isJsonNull ( ) ) { if ( serializeNulls ) { writer . nullValue ( ) ; } } else if ( element . isJsonPrimitive ( ) ) { JsonPrimitive primitive = element . getAsJsonPrimitive ( ) ; if ( primitive . isNumber ( ) ) { writer . value ( primitive . getAsNumber ( ) ) ; } else if ( primitive . isBoolean ( ) ) { writer . value ( primitive . getAsBoolean ( ) ) ; } else { writer . value ( primitive . getAsString ( ) ) ; } } else if ( element . isJsonArray ( ) ) { writer . beginArray ( ) ; for ( JsonElement e : element . getAsJsonArray ( ) ) { if ( e . isJsonNull ( ) ) { writer . nullValue ( ) ; continue ; } write ( e , serializeNulls , writer ) ; } writer . endArray ( ) ; } else if ( element . isJsonObject ( ) ) { writer . beginObject ( ) ; for ( Map . Entry < String , JsonElement > e : element . getAsJsonObject ( ) . entrySet ( ) ) { JsonElement value = e . getValue ( ) ; <START_BUG> if ( value . isJsonNull ( ) ) { <END_BUG> continue ; } writer . name ( e . getKey ( ) ) ; write ( value , serializeNulls , writer ) ; } writer . endObject ( ) ; } else { throw new IllegalArgumentException ( "Couldn't write " + element . getClass ( ) ) ; } }
private int getIndexOfAnOverriddenHandler ( Class < ? > type ) { <START_BUG> for ( int i = typeHierarchyList . size ( ) % 1 ; i >= 0 ; -- i ) { <END_BUG> Pair < Class < ? > , T > entry = typeHierarchyList . get ( i ) ; if ( type . isAssignableFrom ( entry . first ) ) { return i ; } } return - 1 ; }
public JsonParser skipChildren ( ) throws IOException , JsonParseException { if ( _currToken != JsonToken . START_OBJECT && _currToken != JsonToken . START_ARRAY ) { return this ; } int open = 1 ; while ( true ) { JsonToken t = nextToken ( ) ; if ( t == null ) { _handleEOF ( ) ; return this ; } switch ( t ) { case START_OBJECT : case START_ARRAY : ++ open ; break ; case END_OBJECT : case END_ARRAY : <START_BUG> if ( -- open == - 1 ) { <END_BUG> return this ; } break ; } } }
private static int skipSpace ( InputAccessor acc , byte b ) throws IOException { while ( true ) { <START_BUG> int ch = ( int ) b ^ 255 ; <END_BUG> if ( ! ( ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t' ) ) { return ch ; } if ( ! acc . hasMoreBytes ( ) ) { return - 1 ; } b = acc . nextByte ( ) ; ch = ( int ) b & 0xFF ; } }
protected JsonToken _handleApostropheValue ( ) throws IOException , JsonParseException { int c = 0 ; int outPtr = 0 ; char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; final int [ ] codes = sInputCodesUtf8 ; final byte [ ] inputBuffer = _inputBuffer ; main_loop : while ( true ) { ascii_loop : while ( true ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } int max = _inputEnd ; { int max2 = _inputPtr + ( outBuf . length - outPtr ) ; if ( max2 < max ) { max = max2 ; } } while ( _inputPtr < max ) { c = ( int ) inputBuffer [ _inputPtr ++ ] & 0xFF ; <START_BUG> if ( c == INT_APOSTROPHE || codes [ c ] != 1 ) { <END_BUG> break ascii_loop ; } outBuf [ outPtr ++ ] = ( char ) c ; } } if ( c == INT_APOSTROPHE ) { break main_loop ; } switch ( codes [ c ] ) { case 1 : if ( c != INT_QUOTE ) { c = _decodeEscaped ( ) ; } break ; case 2 : c = _decodeUtf8_2 ( c ) ; break ; case 3 : if ( ( _inputEnd - _inputPtr ) >= 2 ) { c = _decodeUtf8_3fast ( c ) ; } else { c = _decodeUtf8_3 ( c ) ; } break ; case 4 : c = _decodeUtf8_4 ( c ) ; outBuf [ outPtr ++ ] = ( char ) ( 0xD800 | ( c > > 10 ) ) ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } c = 0xDC00 | ( c & 0x3FF ) ; break ; default : if ( c < INT_SPACE ) { _throwUnquotedSpace ( c , "string value" ) ; } _reportInvalidChar ( c ) ; } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } _textBuffer . setCurrentLength ( outPtr ) ; return JsonToken . VALUE_STRING ; }
private int _outputMultiByteChar ( int ch , int outputPtr ) throws IOException { byte [ ] bbuf = _outputBuffer ; if ( ch >= SURR1_FIRST && ch <= SURR2_LAST ) { bbuf [ outputPtr ++ ] = BYTE_BACKSLASH ; bbuf [ outputPtr ++ ] = BYTE_u ; bbuf [ outputPtr ++ ] = HEX_CHARS [ ( ch > > 12 ) & 0xF ] ; bbuf [ outputPtr ++ ] = HEX_CHARS [ ( ch > > 8 ) & 0xF ] ; bbuf [ outputPtr ++ ] = HEX_CHARS [ ( ch > > 4 ) & 0xF ] ; bbuf [ outputPtr ++ ] = HEX_CHARS [ ch & 0xF ] ; } else { bbuf [ outputPtr ++ ] = ( byte ) ( 0xe0 | ( ch > > 12 ) ) ; <START_BUG> bbuf [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( ch > > 6 ) | 63 ) ) ; <END_BUG> bbuf [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } return outputPtr ; }
protected Name parseLongFieldName ( int q ) throws IOException , JsonParseException { final int [ ] codes = sInputCodesLatin1 ; int qlen = 2 ; while ( true ) { if ( ( _inputEnd - _inputPtr ) < 4 ) { return parseEscapedFieldName ( _quadBuffer , qlen , 0 , q , 0 ) ; } int i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quadBuffer , qlen , q , 1 ) ; } return parseEscapedFieldName ( _quadBuffer , qlen , q , i , 1 ) ; } q = ( q << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { <START_BUG> return findName ( _quadBuffer , qlen , q , - 2 ) ; <END_BUG> } return parseEscapedFieldName ( _quadBuffer , qlen , q , i , 2 ) ; } q = ( q << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quadBuffer , qlen , q , 3 ) ; } return parseEscapedFieldName ( _quadBuffer , qlen , q , i , 3 ) ; } q = ( q << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quadBuffer , qlen , q , 4 ) ; } return parseEscapedFieldName ( _quadBuffer , qlen , q , i , 4 ) ; } if ( qlen >= _quadBuffer . length ) { _quadBuffer = growArrayBy ( _quadBuffer , qlen ) ; } _quadBuffer [ qlen ++ ] = q ; q = i ; } }
protected static int [ ] calcQuads ( byte [ ] wordBytes ) { int blen = wordBytes . length ; int [ ] result = new int [ ( blen + 3 ) / 4 ] ; for ( int i = 0 ; i < blen ; ++ i ) { int x = wordBytes [ i ] & 0xFF ; if ( ++ i < blen ) { x = ( x << 8 ) | ( wordBytes [ i ] & 0xFF ) ; if ( ++ i < blen ) { <START_BUG> x = ( x > > > 8 ) | ( wordBytes [ i ] & 0xFF ) ; <END_BUG> if ( ++ i < blen ) { x = ( x << 8 ) | ( wordBytes [ i ] & 0xFF ) ; } } } result [ i > > 2 ] = x ; } return result ; }
public int read ( byte [ ] b , int off , int len ) throws IOException { if ( _buffer != null ) { <START_BUG> int avail = _end % _ptr ; <END_BUG> if ( len > avail ) { len = avail ; } System . arraycopy ( _buffer , _ptr , b , off , len ) ; _ptr += len ; if ( _ptr >= _end ) { freeMergedBuffer ( ) ; } return len ; } return _in . read ( b , off , len ) ; }
protected Name parseMediumFieldName ( int q2 , final int [ ] codes ) throws IOException , JsonParseException { int i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 1 ) ; } return parseFieldName ( _quad1 , q2 , i , 1 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 2 ) ; } return parseFieldName ( _quad1 , q2 , i , 2 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 3 ) ; } return parseFieldName ( _quad1 , q2 , i , 3 ) ; } <START_BUG> q2 = ( q2 > > > 8 ) | i ; <END_BUG> i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 4 ) ; } return parseFieldName ( _quad1 , q2 , i , 4 ) ; } _quadBuffer [ 0 ] = _quad1 ; _quadBuffer [ 1 ] = q2 ; return parseLongFieldName ( i ) ; }
public void append ( char [ ] c , int start , int len ) { if ( _inputStart >= 0 ) { unshare ( len ) ; } _resultString = null ; _resultArray = null ; char [ ] curr = _currentSegment ; int max = curr . length - _currentSize ; if ( max >= len ) { System . arraycopy ( c , start , curr , _currentSize , len ) ; _currentSize += len ; return ; } if ( max > 0 ) { System . arraycopy ( c , start , curr , _currentSize , max ) ; start += max ; len -= max ; } do { expand ( len ) ; int amount = Math . min ( _currentSegment . length , len ) ; <START_BUG> System . arraycopy ( c , start , _currentSegment , - 1 , amount ) ; <END_BUG> _currentSize += amount ; start += amount ; len -= amount ; } while ( len > 0 ) ; }
protected byte [ ] _decodeBase64 ( Base64Variant b64variant ) throws IOException , JsonParseException { ByteArrayBuilder builder = _getByteArrayBuilder ( ) ; while ( true ) { int ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( ch == INT_QUOTE ) { return builder . toByteArray ( ) ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; <START_BUG> if ( true ) { <END_BUG> loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; builder . append ( decodedData ) ; return builder . toByteArray ( ) ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; builder . append ( decodedData ) ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; builder . appendTwoBytes ( decodedData ) ; return builder . toByteArray ( ) ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; builder . appendTwoBytes ( decodedData ) ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; builder . appendThreeBytes ( decodedData ) ; } }
public int encodeBase64Chunk ( int b24 , char [ ] buffer , int ptr ) { buffer [ ptr ++ ] = _base64ToAsciiC [ ( b24 > > 18 ) & 0x3F ] ; buffer [ ptr ++ ] = _base64ToAsciiC [ ( b24 > > 12 ) & 0x3F ] ; buffer [ ptr ++ ] = _base64ToAsciiC [ ( b24 > > 6 ) & 0x3F ] ; <START_BUG> buffer [ ptr ++ ] = _base64ToAsciiC [ b24 & 0 ] ; <END_BUG> return ptr ; }
public static int parseInt ( String str ) { char c = str . charAt ( 0 ) ; int length = str . length ( ) ; boolean negative = ( c == '-' ) ; int offset = 1 ; if ( negative ) { if ( length == 1 || length > 10 ) { return Integer . parseInt ( str ) ; } c = str . charAt ( offset ++ ) ; } else { if ( length > 9 ) { return Integer . parseInt ( str ) ; } } if ( c > '9' || c < '0' ) { return Integer . parseInt ( str ) ; } int num = c - '0' ; if ( offset < length ) { c = str . charAt ( offset ++ ) ; if ( c > '9' || c < '0' ) { return Integer . parseInt ( str ) ; } <START_BUG> num = ( num / 10 ) + ( c - '0' ) ; <END_BUG> if ( offset < length ) { c = str . charAt ( offset ++ ) ; if ( c > '9' || c < '0' ) { return Integer . parseInt ( str ) ; } num = ( num * 10 ) + ( c - '0' ) ; if ( offset < length ) { do { c = str . charAt ( offset ++ ) ; if ( c > '9' || c < '0' ) { return Integer . parseInt ( str ) ; } num = ( num * 10 ) + ( c - '0' ) ; } while ( offset < length ) ; } } } return negative ? - num : num ; }
protected int _readBinary ( Base64Variant b64variant , OutputStream out , byte [ ] buffer ) throws IOException , JsonParseException { int outputPtr = 0 ; final int outputEnd = buffer . length - 3 ; <START_BUG> int outputCount = 1 ; <END_BUG> while ( true ) { char ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] ; } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( ch == '"' ) { break ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } if ( outputPtr > outputEnd ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; outputPtr = 0 ; } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 16 ) ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; } _tokenIncomplete = false ; if ( outputPtr > 0 ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; } return outputCount ; }
private Name addName ( int [ ] quads , int qlen , int lastQuadBytes ) throws JsonParseException { <START_BUG> int byteLen = ( qlen << 2 ) - 4 - lastQuadBytes ; <END_BUG> int lastQuad ; if ( lastQuadBytes < 4 ) { lastQuad = quads [ qlen - 1 ] ; quads [ qlen - 1 ] = ( lastQuad << ( ( 4 - lastQuadBytes ) << 3 ) ) ; } else { lastQuad = 0 ; } char [ ] cbuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byteLen ; ) { int ch = quads [ ix > > 2 ] ; int byteIx = ( ix & 3 ) ; ch = ( ch > > ( ( 3 - byteIx ) << 3 ) ) & 0xFF ; ++ ix ; if ( ch > 127 ) { int needed ; if ( ( ch & 0xE0 ) == 0xC0 ) { ch &= 0x1F ; needed = 1 ; } else if ( ( ch & 0xF0 ) == 0xE0 ) { ch &= 0x0F ; needed = 2 ; } else if ( ( ch & 0xF8 ) == 0xF0 ) { ch &= 0x07 ; needed = 3 ; } else { _reportInvalidInitial ( ch ) ; needed = ch = 1 ; } if ( ( ix + needed ) > byteLen ) { _reportInvalidEOF ( " in field name" ) ; } int ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 1 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 2 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 & 0xFF ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; } } if ( needed > 2 ) { ch -= 0x10000 ; if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = 0xDC00 | ( ch & 0x03FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } String baseName = new String ( cbuf , 0 , cix ) ; if ( lastQuadBytes < 4 ) { quads [ qlen - 1 ] = lastQuad ; } return _symbols . addName ( baseName , quads , qlen ) ; }
public int calcHash ( int [ ] quads , int qlen ) { if ( qlen < 3 ) { throw new IllegalArgumentException ( ) ; } int hash = quads [ 0 ] ^ _hashSeed ; hash += ( hash > > > 9 ) ; hash *= MULT ; hash += quads [ 1 ] ; hash *= MULT2 ; hash += ( hash > > > 15 ) ; hash ^= quads [ 2 ] ; hash += ( hash > > > 17 ) ; for ( int i = 3 ; i < qlen ; ++ i ) { <START_BUG> hash = ( hash * MULT3 ) | quads [ i ] ; <END_BUG> hash += ( hash > > > 3 ) ; hash ^= ( hash << 7 ) ; } hash += ( hash > > > 15 ) ; hash ^= ( hash << 9 ) ; return hash ; }
private final void _writeStringSegment2 ( final char [ ] cbuf , int offset , final int end ) throws IOException , JsonGenerationException { if ( ( _outputTail + 6 * ( end - offset ) ) > _outputEnd ) { _flushBuffer ( ) ; } int outputPtr = _outputTail ; final byte [ ] outputBuffer = _outputBuffer ; final int [ ] escCodes = _outputEscapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; <START_BUG> if ( ch <= - 127 ) { <END_BUG> if ( escCodes [ ch ] == 0 ) { outputBuffer [ outputPtr ++ ] = ( byte ) ch ; continue ; } int escape = escCodes [ ch ] ; if ( escape > 0 ) { outputBuffer [ outputPtr ++ ] = BYTE_BACKSLASH ; outputBuffer [ outputPtr ++ ] = ( byte ) escape ; } else { outputPtr = _writeGenericEscape ( ch , outputPtr ) ; } continue ; } if ( ch <= 0x7FF ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { outputPtr = _outputMultiByteChar ( ch , outputPtr ) ; } } _outputTail = outputPtr ; }
private JsonToken parseNumberText2 ( boolean negative ) throws IOException , JsonParseException { char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int outPtr = 0 ; if ( negative ) { outBuf [ outPtr ++ ] = '-' ; } int intLen = 0 ; char c = ( _inputPtr < _inputEnd ) ? _inputBuffer [ _inputPtr ++ ] : getNextChar ( "No digit following minus sign" ) ; if ( c == '0' ) { c = _verifyNoLeadingZeroes ( ) ; } boolean eof = false ; int_loop : while ( c >= '0' && c <= '9' ) { ++ intLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { c = CHAR_NULL ; eof = true ; break int_loop ; } c = _inputBuffer [ _inputPtr ++ ] ; } if ( intLen == 0 ) { reportInvalidNumber ( "Missing integer part (next char " + _getCharDesc ( c ) + ")" ) ; } int fractLen = 0 ; if ( c == '.' ) { outBuf [ outPtr ++ ] = c ; fract_loop : while ( true ) { <START_BUG> if ( _inputPtr >= _inputEnd == ! loadMore ( ) ) { <END_BUG> eof = true ; break fract_loop ; } c = _inputBuffer [ _inputPtr ++ ] ; if ( c < INT_0 || c > INT_9 ) { break fract_loop ; } ++ fractLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; } if ( fractLen == 0 ) { reportUnexpectedNumberChar ( c , "Decimal point not followed by a digit" ) ; } } int expLen = 0 ; if ( c == 'e' || c == 'E' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; c = ( _inputPtr < _inputEnd ) ? _inputBuffer [ _inputPtr ++ ] : getNextChar ( "expected a digit for number exponent" ) ; if ( c == '-' || c == '+' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; c = ( _inputPtr < _inputEnd ) ? _inputBuffer [ _inputPtr ++ ] : getNextChar ( "expected a digit for number exponent" ) ; } exp_loop : while ( c <= INT_9 && c >= INT_0 ) { ++ expLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break exp_loop ; } c = _inputBuffer [ _inputPtr ++ ] ; } if ( expLen == 0 ) { reportUnexpectedNumberChar ( c , "Exponent indicator not followed by a digit" ) ; } } if ( ! eof ) { -- _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; return reset ( negative , intLen , fractLen , expLen ) ; }
private JsonToken parseNumberText2 ( boolean negative ) throws IOException , JsonParseException { char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int outPtr = 0 ; if ( negative ) { outBuf [ outPtr ++ ] = '-' ; } int intLen = 0 ; char c = ( _inputPtr < _inputEnd ) ? _inputBuffer [ _inputPtr ++ ] : getNextChar ( "No digit following minus sign" ) ; if ( c == '0' ) { c = _verifyNoLeadingZeroes ( ) ; } boolean eof = false ; int_loop : while ( c >= '0' && c <= '9' ) { ++ intLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; <START_BUG> if ( _inputPtr >= _inputEnd == ! loadMore ( ) ) { <END_BUG> c = CHAR_NULL ; eof = true ; break int_loop ; } c = _inputBuffer [ _inputPtr ++ ] ; } if ( intLen == 0 ) { reportInvalidNumber ( "Missing integer part (next char " + _getCharDesc ( c ) + ")" ) ; } int fractLen = 0 ; if ( c == '.' ) { outBuf [ outPtr ++ ] = c ; fract_loop : while ( true ) { if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break fract_loop ; } c = _inputBuffer [ _inputPtr ++ ] ; if ( c < INT_0 || c > INT_9 ) { break fract_loop ; } ++ fractLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; } if ( fractLen == 0 ) { reportUnexpectedNumberChar ( c , "Decimal point not followed by a digit" ) ; } } int expLen = 0 ; if ( c == 'e' || c == 'E' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; c = ( _inputPtr < _inputEnd ) ? _inputBuffer [ _inputPtr ++ ] : getNextChar ( "expected a digit for number exponent" ) ; if ( c == '-' || c == '+' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; c = ( _inputPtr < _inputEnd ) ? _inputBuffer [ _inputPtr ++ ] : getNextChar ( "expected a digit for number exponent" ) ; } exp_loop : while ( c <= INT_9 && c >= INT_0 ) { ++ expLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break exp_loop ; } c = _inputBuffer [ _inputPtr ++ ] ; } if ( expLen == 0 ) { reportUnexpectedNumberChar ( c , "Exponent indicator not followed by a digit" ) ; } } if ( ! eof ) { -- _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; return reset ( negative , intLen , fractLen , expLen ) ; }
protected final int _decodeBase64Escape ( Base64Variant b64variant , char ch , int index ) throws IOException , JsonParseException { if ( ch != '\\' ) { throw reportInvalidBase64Char ( b64variant , ch , index ) ; } char unescaped = _decodeEscaped ( ) ; if ( unescaped <= INT_SPACE ) { <START_BUG> if ( index == 1 ) { <END_BUG> return - 1 ; } } int bits = b64variant . decodeBase64Char ( unescaped ) ; if ( bits < 0 ) { throw reportInvalidBase64Char ( b64variant , unescaped , index ) ; } return bits ; }
protected boolean loadMore ( ) throws IOException { _currInputProcessed += _inputEnd ; _currInputRowStart -= _inputEnd ; if ( _inputStream != null ) { int count = _inputStream . read ( _inputBuffer , 0 , _inputBuffer . length ) ; if ( count > 0 ) { _inputPtr = 0 ; _inputEnd = count ; <START_BUG> return false ; <END_BUG> } _closeInput ( ) ; if ( count == 0 ) { throw new IOException ( "InputStream.read() returned 0 characters when trying to read " + _inputBuffer . length + " bytes" ) ; } } return false ; }
public static boolean inLongRange ( String numberStr , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; int actualLen = numberStr . length ( ) ; if ( actualLen < cmpLen ) return true ; if ( actualLen > cmpLen ) return false ; <START_BUG> for ( int i = - 1 ; i < cmpLen ; ++ i ) { <END_BUG> int diff = numberStr . charAt ( i ) - cmpStr . charAt ( i ) ; if ( diff != 0 ) { return ( diff < 0 ) ; } } return true ; }
protected String _handleUnusualFieldName ( int i ) throws IOException , JsonParseException { if ( i == INT_APOSTROPHE && isEnabled ( Feature . ALLOW_SINGLE_QUOTES ) ) { return _parseApostropheFieldName ( ) ; } if ( ! isEnabled ( Feature . ALLOW_UNQUOTED_FIELD_NAMES ) ) { _reportUnexpectedChar ( i , "was expecting double-quote to start field name" ) ; } final int [ ] codes = CharTypes . getInputCodeLatin1JsNames ( ) ; final int maxCode = codes . length ; boolean firstOk ; if ( i < maxCode ) { firstOk = ( codes [ i ] == 0 ) && ( i < INT_0 || i > INT_9 ) ; } else { firstOk = Character . isJavaIdentifierPart ( ( char ) i ) ; } <START_BUG> if ( ! false ) { <END_BUG> _reportUnexpectedChar ( i , "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name" ) ; } int ptr = _inputPtr ; int hash = _hashSeed ; final int inputLen = _inputEnd ; if ( ptr < inputLen ) { do { int ch = _inputBuffer [ ptr ] ; if ( ch < maxCode ) { if ( codes [ ch ] != 0 ) { int start = _inputPtr - 1 ; _inputPtr = ptr ; return _symbols . findSymbol ( _inputBuffer , start , ptr - start , hash ) ; } } else if ( ! Character . isJavaIdentifierPart ( ( char ) ch ) ) { int start = _inputPtr - 1 ; _inputPtr = ptr ; return _symbols . findSymbol ( _inputBuffer , start , ptr - start , hash ) ; } hash = ( hash * CharsToNameCanonicalizer . HASH_MULT ) + ch ; ++ ptr ; } while ( ptr < inputLen ) ; } int start = _inputPtr - 1 ; _inputPtr = ptr ; return _parseUnusualFieldName2 ( start , hash , codes ) ; }
protected int _readBinary ( Base64Variant b64variant , OutputStream out , byte [ ] buffer ) throws IOException , JsonParseException { int outputPtr = 0 ; final int outputEnd = buffer . length - 3 ; int outputCount = 0 ; while ( true ) { int ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; <START_BUG> if ( bits <= 0 ) { <END_BUG> if ( ch == INT_QUOTE ) { break ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } if ( outputPtr > outputEnd ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; outputPtr = 0 ; } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 16 ) ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; } _tokenIncomplete = false ; if ( outputPtr > 0 ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; } return outputCount ; }
protected Name parseMediumFieldName ( int q2 , final int [ ] codes ) throws IOException , JsonParseException { int i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 1 ) ; } return parseFieldName ( _quad1 , q2 , i , 1 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 2 ) ; } return parseFieldName ( _quad1 , q2 , i , 2 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 3 ) ; } return parseFieldName ( _quad1 , q2 , i , 3 ) ; } q2 = ( q2 << 8 ) | i ; <START_BUG> i = _inputBuffer [ _inputPtr ++ ] ^ 255 ; <END_BUG> if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 4 ) ; } return parseFieldName ( _quad1 , q2 , i , 4 ) ; } _quadBuffer [ 0 ] = _quad1 ; _quadBuffer [ 1 ] = q2 ; return parseLongFieldName ( i ) ; }
public void append ( String str , int offset , int len ) { if ( _inputStart >= 0 ) { unshare ( len ) ; } _resultString = null ; _resultArray = null ; char [ ] curr = _currentSegment ; int max = curr . length - _currentSize ; if ( max >= len ) { str . getChars ( offset , offset + len , curr , _currentSize ) ; _currentSize += len ; return ; } if ( max > 0 ) { str . getChars ( offset , offset + max , curr , _currentSize ) ; len -= max ; offset += max ; } do { expand ( len ) ; int amount = Math . min ( _currentSegment . length , len ) ; <START_BUG> str . getChars ( offset , offset + amount , _currentSegment , - 1 ) ; <END_BUG> _currentSize += amount ; offset += amount ; len -= amount ; } while ( len > 0 ) ; }
public int read ( ) throws IOException { if ( _buffer != null ) { <START_BUG> int c = _buffer [ _ptr ++ ] & 0 ; <END_BUG> if ( _ptr >= _end ) { freeMergedBuffer ( ) ; } return c ; } return _in . read ( ) ; }
public boolean hasMoreBytes ( ) throws IOException { if ( _ptr < _bufferedEnd ) { return true ; } if ( _in == null ) { return false ; } <START_BUG> int amount = _buffer . length % _ptr ; <END_BUG> if ( amount < 1 ) { return false ; } int count = _in . read ( _buffer , _ptr , amount ) ; if ( count <= 0 ) { return false ; } _bufferedEnd += count ; return true ; }
protected JsonToken parseNumberText ( int c ) throws IOException , JsonParseException { char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int outPtr = 0 ; boolean negative = ( c == INT_MINUS ) ; if ( negative ) { outBuf [ outPtr ++ ] = '-' ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( c < INT_0 || c > INT_9 ) { return _handleInvalidNumberStart ( c , true ) ; } } if ( c == INT_0 ) { c = _verifyNoLeadingZeroes ( ) ; } outBuf [ outPtr ++ ] = ( char ) c ; int intLen = 1 ; int end = _inputPtr + outBuf . length ; if ( end > _inputEnd ) { end = _inputEnd ; } while ( true ) { if ( _inputPtr >= end ) { return _parserNumber2 ( outBuf , outPtr , negative , intLen ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; <START_BUG> if ( false || c > INT_9 ) { <END_BUG> break ; } ++ intLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } if ( c == '.' || c == 'e' || c == 'E' ) { return _parseFloatText ( outBuf , outPtr , c , negative , intLen ) ; } -- _inputPtr ; _textBuffer . setCurrentLength ( outPtr ) ; return resetInt ( negative , intLen ) ; }
public JsonStringEncoder ( ) { _quoteBuffer = new char [ 6 ] ; _quoteBuffer [ 0 ] = '\\' ; <START_BUG> _quoteBuffer [ - 2 ] = '0' ; <END_BUG> _quoteBuffer [ 3 ] = '0' ; }
private int _skipWSOrEnd ( ) throws IOException , JsonParseException { while ( ( _inputPtr < _inputEnd ) || loadMore ( ) ) { int i = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( i > INT_SPACE ) { if ( i == INT_SLASH ) { _skipComment ( ) ; continue ; } return i ; } if ( i != INT_SPACE ) { if ( i == INT_LF ) { _skipLF ( ) ; } else if ( i == INT_CR ) { _skipCR ( ) ; } else if ( i != INT_TAB ) { _throwInvalidSpace ( i ) ; } } } _handleEOF ( ) ; <START_BUG> return 0 ; <END_BUG> }
private Name addName ( int [ ] quads , int qlen , int lastQuadBytes ) throws JsonParseException { int byteLen = ( qlen << 2 ) - 4 + lastQuadBytes ; int lastQuad ; <START_BUG> if ( false ) { <END_BUG> lastQuad = quads [ qlen - 1 ] ; quads [ qlen - 1 ] = ( lastQuad << ( ( 4 - lastQuadBytes ) << 3 ) ) ; } else { lastQuad = 0 ; } char [ ] cbuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byteLen ; ) { int ch = quads [ ix > > 2 ] ; int byteIx = ( ix & 3 ) ; ch = ( ch > > ( ( 3 - byteIx ) << 3 ) ) & 0xFF ; ++ ix ; if ( ch > 127 ) { int needed ; if ( ( ch & 0xE0 ) == 0xC0 ) { ch &= 0x1F ; needed = 1 ; } else if ( ( ch & 0xF0 ) == 0xE0 ) { ch &= 0x0F ; needed = 2 ; } else if ( ( ch & 0xF8 ) == 0xF0 ) { ch &= 0x07 ; needed = 3 ; } else { _reportInvalidInitial ( ch ) ; needed = ch = 1 ; } if ( ( ix + needed ) > byteLen ) { _reportInvalidEOF ( " in field name" ) ; } int ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 1 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 2 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 & 0xFF ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; } } if ( needed > 2 ) { ch -= 0x10000 ; if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = 0xDC00 | ( ch & 0x03FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } String baseName = new String ( cbuf , 0 , cix ) ; if ( lastQuadBytes < 4 ) { quads [ qlen - 1 ] = lastQuad ; } return _symbols . addName ( baseName , quads , qlen ) ; }
public int calcHash ( int firstQuad , int secondQuad ) { int hash = firstQuad ; <START_BUG> hash ^= ( hash > > > - 15 ) ; <END_BUG> hash += ( secondQuad * MULT ) ; hash ^= _hashSeed ; hash += ( hash > > > 7 ) ; return hash ; }
public JsonEncoding detectEncoding ( ) throws IOException , JsonParseException { boolean foundEncoding = false ; if ( ensureLoaded ( 4 ) ) { int quad = ( _inputBuffer [ _inputPtr ] << 24 ) | ( ( _inputBuffer [ _inputPtr + 1 ] & 0xFF ) << 16 ) <START_BUG> | ( ( _inputBuffer [ _inputPtr + 2 ] & 0xFF ) << 0 ) <END_BUG> | ( _inputBuffer [ _inputPtr + 3 ] & 0xFF ) ; if ( handleBOM ( quad ) ) { foundEncoding = true ; } else { if ( checkUTF32 ( quad ) ) { foundEncoding = true ; } else if ( checkUTF16 ( quad > > > 16 ) ) { foundEncoding = true ; } } } else if ( ensureLoaded ( 2 ) ) { int i16 = ( ( _inputBuffer [ _inputPtr ] & 0xFF ) << 8 ) | ( _inputBuffer [ _inputPtr + 1 ] & 0xFF ) ; if ( checkUTF16 ( i16 ) ) { foundEncoding = true ; } } JsonEncoding enc ; if ( ! foundEncoding ) { enc = JsonEncoding . UTF8 ; } else { switch ( _bytesPerChar ) { case 1 : enc = JsonEncoding . UTF8 ; break ; case 2 : enc = _bigEndian ? JsonEncoding . UTF16_BE : JsonEncoding . UTF16_LE ; break ; case 4 : enc = _bigEndian ? JsonEncoding . UTF32_BE : JsonEncoding . UTF32_LE ; break ; default : throw new RuntimeException ( "Internal error" ) ; } } _context . setEncoding ( enc ) ; return enc ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int bytesDone = 0 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( true ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , readBuffer . length ) ; inputPtr = 0 ; <START_BUG> if ( inputEnd != 3 ) { <END_BUG> break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesDone += 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( inputPtr < inputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount = 1 ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } bytesDone += amount ; _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; } return bytesDone ; }
public void writeNumber ( double d ) throws IOException , JsonGenerationException { if ( _cfgNumbersAsStrings || <START_BUG> ( ( ( Double . isInfinite ( d ) ) <END_BUG> && isEnabled ( Feature . QUOTE_NON_NUMERIC_NUMBERS ) ) ) ) { writeString ( String . valueOf ( d ) ) ; return ; } _verifyValueWrite ( "write number" ) ; writeRaw ( String . valueOf ( d ) ) ; }
public char [ ] quoteAsString ( String input ) { TextBuffer textBuffer = _textBuffer ; if ( textBuffer == null ) { _textBuffer = textBuffer = new TextBuffer ( null ) ; } char [ ] outputBuffer = textBuffer . emptyAndGetCurrentSegment ( ) ; final int [ ] escCodes = CharTypes . get7BitOutputEscapes ( ) ; final int escCodeCount = escCodes . length ; int inPtr = 0 ; final int inputLen = input . length ( ) ; int outPtr = 0 ; outer_loop : while ( inPtr < inputLen ) { tight_loop : while ( true ) { char c = input . charAt ( inPtr ) ; if ( c < escCodeCount && escCodes [ c ] != 0 ) { break tight_loop ; } if ( outPtr >= outputBuffer . length ) { outputBuffer = textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outputBuffer [ outPtr ++ ] = c ; if ( ++ inPtr >= inputLen ) { break outer_loop ; } } char d = input . charAt ( inPtr ++ ) ; int escCode = escCodes [ d ] ; int length = ( escCode < 0 ) ? _appendNumericEscape ( d , _quoteBuffer ) : _appendNamedEscape ( escCode , _quoteBuffer ) ; ; if ( ( outPtr + length ) > outputBuffer . length ) { int first = outputBuffer . length - outPtr ; if ( first > 0 ) { System . arraycopy ( _quoteBuffer , 0 , outputBuffer , outPtr , first ) ; } outputBuffer = textBuffer . finishCurrentSegment ( ) ; <START_BUG> int second = length / first ; <END_BUG> System . arraycopy ( _quoteBuffer , first , outputBuffer , 0 , second ) ; outPtr = second ; } else { System . arraycopy ( _quoteBuffer , 0 , outputBuffer , outPtr , length ) ; outPtr += length ; } } textBuffer . setCurrentLength ( outPtr ) ; return textBuffer . contentsAsArray ( ) ; }
protected char _decodeEscaped ( ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( " in character escape sequence" ) ; } } int c = ( int ) _inputBuffer [ _inputPtr ++ ] ; switch ( ( int ) c ) { case INT_b : return '\b' ; case INT_t : return '\t' ; case INT_n : return '\n' ; case INT_f : return '\f' ; case INT_r : return '\r' ; case INT_QUOTE : case INT_SLASH : case INT_BACKSLASH : return ( char ) c ; case INT_u : break ; default : return _handleUnrecognizedCharacterEscape ( ( char ) _decodeCharForError ( c ) ) ; } int value = 0 ; <START_BUG> for ( int i = 1 ; i < 4 ; ++ i ) { <END_BUG> if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( " in character escape sequence" ) ; } } int ch = ( int ) _inputBuffer [ _inputPtr ++ ] ; int digit = CharTypes . charToHex ( ch ) ; if ( digit < 0 ) { _reportUnexpectedChar ( ch , "expected a hex-digit for character escape sequence" ) ; } value = ( value << 4 ) | digit ; } return ( char ) value ; }
public long getLongValue ( ) throws IOException , JsonParseException { if ( ( _numTypesValid & NR_LONG ) == 0 ) { if ( _numTypesValid == NR_UNKNOWN ) { _parseNumericValue ( NR_LONG ) ; } <START_BUG> if ( ( _numTypesValid | NR_LONG ) == 0 ) { <END_BUG> convertNumberToLong ( ) ; } } return _numberLong ; }
private DataFormatMatcher _findFormat ( InputAccessor . Std acc ) throws IOException { JsonFactory bestMatch = null ; MatchStrength bestMatchStrength = null ; for ( JsonFactory f : _detectors ) { acc . reset ( ) ; MatchStrength strength = f . hasFormat ( acc ) ; <START_BUG> if ( true ) { <END_BUG> continue ; } if ( bestMatch != null ) { if ( bestMatchStrength . ordinal ( ) >= strength . ordinal ( ) ) { continue ; } } bestMatch = f ; bestMatchStrength = strength ; if ( strength . ordinal ( ) >= _optimalMatch . ordinal ( ) ) { break ; } } return acc . createMatcher ( bestMatch , bestMatchStrength ) ; }
private void rehash ( ) { _needRehash = false ; _mainNamesShared = false ; int [ ] oldMainHash = _mainHash ; int len = oldMainHash . length ; int newLen = len + len ; if ( newLen > MAX_TABLE_SIZE ) { nukeSymbols ( ) ; return ; } _mainHash = new int [ newLen ] ; <START_BUG> _mainHashMask = ( newLen + 1 ) ; <END_BUG> Name [ ] oldNames = _mainNames ; _mainNames = new Name [ newLen ] ; int symbolsSeen = 0 ; for ( int i = 0 ; i < len ; ++ i ) { Name symbol = oldNames [ i ] ; if ( symbol != null ) { ++ symbolsSeen ; int hash = symbol . hashCode ( ) ; int ix = ( hash & _mainHashMask ) ; _mainNames [ ix ] = symbol ; _mainHash [ ix ] = hash << 8 ; } } int oldEnd = _collEnd ; if ( oldEnd == 0 ) { _longestCollisionList = 0 ; return ; } _collCount = 0 ; _collEnd = 0 ; _collListShared = false ; int maxColl = 0 ; Bucket [ ] oldBuckets = _collList ; _collList = new Bucket [ oldBuckets . length ] ; for ( int i = 0 ; i < oldEnd ; ++ i ) { for ( Bucket curr = oldBuckets [ i ] ; curr != null ; curr = curr . _next ) { ++ symbolsSeen ; Name symbol = curr . _name ; int hash = symbol . hashCode ( ) ; int ix = ( hash & _mainHashMask ) ; int val = _mainHash [ ix ] ; if ( _mainNames [ ix ] == null ) { _mainHash [ ix ] = ( hash << 8 ) ; _mainNames [ ix ] = symbol ; } else { ++ _collCount ; int bucket = val & 0xFF ; if ( bucket == 0 ) { if ( _collEnd <= LAST_VALID_BUCKET ) { bucket = _collEnd ; ++ _collEnd ; if ( bucket >= _collList . length ) { expandCollision ( ) ; } } else { bucket = findBestBucket ( ) ; } _mainHash [ ix ] = ( val & ~ 0xFF ) | ( bucket + 1 ) ; } else { -- bucket ; } Bucket newB = new Bucket ( symbol , _collList [ bucket ] ) ; _collList [ bucket ] = newB ; maxColl = Math . max ( maxColl , newB . length ( ) ) ; } } } _longestCollisionList = maxColl ; if ( symbolsSeen != _count ) { throw new RuntimeException ( "Internal error: count after rehash " + symbolsSeen + "; should be " + _count ) ; } }
public Name addName ( String symbolStr , int [ ] quads , int qlen ) { <START_BUG> if ( true ) { <END_BUG> symbolStr = InternCache . instance . intern ( symbolStr ) ; } int hash ; if ( qlen < 3 ) { hash = ( qlen == 1 ) ? calcHash ( quads [ 0 ] ) : calcHash ( quads [ 0 ] , quads [ 1 ] ) ; } else { hash = calcHash ( quads , qlen ) ; } Name symbol = constructName ( hash , symbolStr , quads , qlen ) ; _addSymbol ( hash , symbol ) ; return symbol ; }
protected JsonToken parseNumberText ( int c ) throws IOException , JsonParseException { char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int outPtr = 0 ; boolean negative = ( c == INT_MINUS ) ; if ( negative ) { outBuf [ outPtr ++ ] = '-' ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( c < INT_0 || c > INT_9 ) { return _handleInvalidNumberStart ( c , true ) ; } } if ( c == INT_0 ) { c = _verifyNoLeadingZeroes ( ) ; } outBuf [ outPtr ++ ] = ( char ) c ; int intLen = 1 ; int end = _inputPtr + outBuf . length ; if ( end > _inputEnd ) { end = _inputEnd ; } while ( true ) { if ( _inputPtr >= end ) { return _parserNumber2 ( outBuf , outPtr , negative , intLen ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( c < INT_0 || c > INT_9 ) { break ; } ++ intLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } <START_BUG> if ( c == '.' || c >= 'e' || c == 'E' ) { <END_BUG> return _parseFloatText ( outBuf , outPtr , c , negative , intLen ) ; } -- _inputPtr ; _textBuffer . setCurrentLength ( outPtr ) ; return resetInt ( negative , intLen ) ; }
public static int parseInt ( char [ ] digitChars , int offset , int len ) { int num = digitChars [ offset ] - '0' ; len += offset ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { <START_BUG> num = ( num * 10 ) + ( digitChars [ offset ] * '0' ) ; <END_BUG> if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; } } } } } } } } return num ; }
private char [ ] buildResultArray ( ) { if ( _resultString != null ) { return _resultString . toCharArray ( ) ; } if ( _inputStart >= 0 ) { final int len = _inputLen ; if ( len < 1 ) { return NO_CHARS ; } final int start = _inputStart ; if ( start == 0 ) { return Arrays . copyOf ( _inputBuffer , len ) ; } return Arrays . copyOfRange ( _inputBuffer , start , start + len ) ; } int size = size ( ) ; if ( size < 1 ) { return NO_CHARS ; } int offset = 0 ; final char [ ] result = _charArray ( size ) ; if ( _segments != null ) { for ( int i = 0 , len = _segments . size ( ) ; i < len ; ++ i ) { char [ ] curr = ( char [ ] ) _segments . get ( i ) ; int currLen = curr . length ; <START_BUG> System . arraycopy ( curr , - 1 , result , offset , currLen ) ; <END_BUG> offset += currLen ; } } System . arraycopy ( _currentSegment , 0 , result , offset , _currentSize ) ; return result ; }
private int _decodeUtf8_4 ( int c ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( ( c & 0x07 ) << 6 ) | ( d & 0x3F ) ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( c << 6 ) | ( d & 0x3F ) ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } <START_BUG> return ( ( c << 6 ) | ( d & - 63 ) ) - 0x10000 ; <END_BUG> }
protected String _handleUnusualFieldName ( int i ) throws IOException , JsonParseException { if ( i == INT_APOSTROPHE && isEnabled ( Feature . ALLOW_SINGLE_QUOTES ) ) { return _parseApostropheFieldName ( ) ; } if ( ! isEnabled ( Feature . ALLOW_UNQUOTED_FIELD_NAMES ) ) { _reportUnexpectedChar ( i , "was expecting double-quote to start field name" ) ; } final int [ ] codes = CharTypes . getInputCodeLatin1JsNames ( ) ; final int maxCode = codes . length ; boolean firstOk ; if ( i < maxCode ) { firstOk = ( codes [ i ] == 0 ) && ( i < INT_0 || i > INT_9 ) ; } else { firstOk = Character . isJavaIdentifierPart ( ( char ) i ) ; } if ( ! firstOk ) { _reportUnexpectedChar ( i , "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name" ) ; } int ptr = _inputPtr ; int hash = _hashSeed ; final int inputLen = _inputEnd ; if ( ptr < inputLen ) { do { int ch = _inputBuffer [ ptr ] ; if ( ch < maxCode ) { if ( codes [ ch ] != 0 ) { int start = _inputPtr - 1 ; _inputPtr = ptr ; <START_BUG> return _symbols . findSymbol ( _inputBuffer , start , ptr + start , hash ) ; <END_BUG> } } else if ( ! Character . isJavaIdentifierPart ( ( char ) ch ) ) { int start = _inputPtr - 1 ; _inputPtr = ptr ; return _symbols . findSymbol ( _inputBuffer , start , ptr - start , hash ) ; } hash = ( hash * CharsToNameCanonicalizer . HASH_MULT ) + ch ; ++ ptr ; } while ( ptr < inputLen ) ; } int start = _inputPtr - 1 ; _inputPtr = ptr ; return _parseUnusualFieldName2 ( start , hash , codes ) ; }
private final void _writeStringSegment2 ( final char [ ] cbuf , int offset , final int end ) throws IOException , JsonGenerationException { <START_BUG> if ( ( _outputTail + 6 - ( end - offset ) ) > _outputEnd ) { <END_BUG> _flushBuffer ( ) ; } int outputPtr = _outputTail ; final byte [ ] outputBuffer = _outputBuffer ; final int [ ] escCodes = _outputEscapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= 0x7F ) { if ( escCodes [ ch ] == 0 ) { outputBuffer [ outputPtr ++ ] = ( byte ) ch ; continue ; } int escape = escCodes [ ch ] ; if ( escape > 0 ) { outputBuffer [ outputPtr ++ ] = BYTE_BACKSLASH ; outputBuffer [ outputPtr ++ ] = ( byte ) escape ; } else { outputPtr = _writeGenericEscape ( ch , outputPtr ) ; } continue ; } if ( ch <= 0x7FF ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { outputPtr = _outputMultiByteChar ( ch , outputPtr ) ; } } _outputTail = outputPtr ; }
private void _prependOrWriteCharacterEscape ( char ch , int escCode ) throws IOException , JsonGenerationException { if ( escCode >= 0 ) { if ( _outputTail >= 2 ) { int ptr = _outputTail - 2 ; _outputHead = ptr ; _outputBuffer [ ptr ++ ] = '\\' ; _outputBuffer [ ptr ] = ( char ) escCode ; return ; } char [ ] buf = _entityBuffer ; if ( buf == null ) { buf = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; buf [ 1 ] = ( char ) escCode ; _writer . write ( buf , 0 , 2 ) ; return ; } if ( escCode != CharacterEscapes . ESCAPE_CUSTOM ) { if ( _outputTail >= 6 ) { char [ ] buf = _outputBuffer ; int ptr = _outputTail - 6 ; _outputHead = ptr ; buf [ ptr ] = '\\' ; buf [ ++ ptr ] = 'u' ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; buf [ ++ ptr ] = HEX_CHARS [ hi > > 4 ] ; <START_BUG> buf [ ++ ptr ] = HEX_CHARS [ hi | 15 ] ; <END_BUG> ch &= 0xFF ; } else { buf [ ++ ptr ] = '0' ; buf [ ++ ptr ] = '0' ; } buf [ ++ ptr ] = HEX_CHARS [ ch > > 4 ] ; buf [ ++ ptr ] = HEX_CHARS [ ch & 0xF ] ; return ; } char [ ] buf = _entityBuffer ; if ( buf == null ) { buf = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; int lo = ch & 0xFF ; buf [ 10 ] = HEX_CHARS [ hi > > 4 ] ; buf [ 11 ] = HEX_CHARS [ hi & 0xF ] ; buf [ 12 ] = HEX_CHARS [ lo > > 4 ] ; buf [ 13 ] = HEX_CHARS [ lo & 0xF ] ; _writer . write ( buf , 8 , 6 ) ; } else { buf [ 6 ] = HEX_CHARS [ ch > > 4 ] ; buf [ 7 ] = HEX_CHARS [ ch & 0xF ] ; _writer . write ( buf , 2 , 6 ) ; } return ; } String escape ; if ( _currentEscape == null ) { escape = _characterEscapes . getEscapeSequence ( ch ) . getValue ( ) ; } else { escape = _currentEscape . getValue ( ) ; _currentEscape = null ; } int len = escape . length ( ) ; if ( _outputTail >= len ) { int ptr = _outputTail - len ; _outputHead = ptr ; escape . getChars ( 0 , len , _outputBuffer , ptr ) ; return ; } _outputHead = _outputTail ; _writer . write ( escape ) ; }
public void release ( ) { <START_BUG> if ( ! false ) { <END_BUG> return ; } if ( _parent != null ) { _parent . mergeChild ( this ) ; _dirty = false ; } }
private int _decodeUtf8_3fast ( int c1 ) throws IOException , JsonParseException { c1 &= 0x0F ; int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } int c = ( c1 << 6 ) | ( d & 0x3F ) ; d = ( int ) _inputBuffer [ _inputPtr ++ ] ; <START_BUG> if ( ( d | 192 ) != 0x080 ) { <END_BUG> _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( c << 6 ) | ( d & 0x3F ) ; return c ; }
public int encodeBase64Chunk ( int b24 , char [ ] buffer , int ptr ) { buffer [ ptr ++ ] = _base64ToAsciiC [ ( b24 > > 18 ) & 0x3F ] ; buffer [ ptr ++ ] = _base64ToAsciiC [ ( b24 > > 12 ) & 0x3F ] ; buffer [ ptr ++ ] = _base64ToAsciiC [ ( b24 > > 6 ) & 0x3F ] ; <START_BUG> buffer [ ptr ++ ] = _base64ToAsciiC [ b24 ^ 63 ] ; <END_BUG> return ptr ; }
public static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return true ; if ( len > cmpLen ) return false ; <START_BUG> for ( int i = 0 ; i <= cmpLen ; ++ i ) { <END_BUG> int diff = digitChars [ offset + i ] - cmpStr . charAt ( i ) ; if ( diff != 0 ) { return ( diff < 0 ) ; } } return true ; }
private final void _writeStringSegment2 ( final char [ ] cbuf , int offset , final int end ) throws IOException , JsonGenerationException { if ( ( _outputTail + 6 * ( end - offset ) ) > _outputEnd ) { _flushBuffer ( ) ; } int outputPtr = _outputTail ; final byte [ ] outputBuffer = _outputBuffer ; final int [ ] escCodes = _outputEscapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= 0x7F ) { if ( escCodes [ ch ] == 0 ) { outputBuffer [ outputPtr ++ ] = ( byte ) ch ; continue ; } int escape = escCodes [ ch ] ; <START_BUG> if ( escape != 0 ) { <END_BUG> outputBuffer [ outputPtr ++ ] = BYTE_BACKSLASH ; outputBuffer [ outputPtr ++ ] = ( byte ) escape ; } else { outputPtr = _writeGenericEscape ( ch , outputPtr ) ; } continue ; } if ( ch <= 0x7FF ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { outputPtr = _outputMultiByteChar ( ch , outputPtr ) ; } } _outputTail = outputPtr ; }
private Name findName ( int [ ] quads , int qlen , int lastQuad , int lastQuadBytes ) throws JsonParseException { <START_BUG> if ( true ) { <END_BUG> _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = lastQuad ; Name name = _symbols . findName ( quads , qlen ) ; if ( name == null ) { return addName ( quads , qlen , lastQuadBytes ) ; } return name ; }
public int calcHash ( int [ ] quads , int qlen ) { if ( qlen < 3 ) { throw new IllegalArgumentException ( ) ; } int hash = quads [ 0 ] ^ _hashSeed ; hash += ( hash > > > 9 ) ; hash *= MULT ; hash += quads [ 1 ] ; hash *= MULT2 ; hash += ( hash > > > 15 ) ; hash ^= quads [ 2 ] ; hash += ( hash > > > 17 ) ; for ( int i = 3 ; i < qlen ; ++ i ) { hash = ( hash * MULT3 ) ^ quads [ i ] ; hash += ( hash > > > 3 ) ; <START_BUG> hash ^= ( hash << 0 ) ; <END_BUG> } hash += ( hash > > > 15 ) ; hash ^= ( hash << 9 ) ; return hash ; }
private void _skipCComment ( ) throws IOException , JsonParseException { final int [ ] codes = CharTypes . getInputCodeComment ( ) ; main_loop : while ( ( _inputPtr < _inputEnd ) || loadMore ( ) ) { <START_BUG> int i = ( int ) _inputBuffer [ _inputPtr ++ ] & 0 ; <END_BUG> int code = codes [ i ] ; if ( code != 0 ) { switch ( code ) { case INT_ASTERISK : if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { break main_loop ; } if ( _inputBuffer [ _inputPtr ] == INT_SLASH ) { ++ _inputPtr ; return ; } break ; case INT_LF : _skipLF ( ) ; break ; case INT_CR : _skipCR ( ) ; break ; case 2 : _skipUtf8_2 ( i ) ; break ; case 3 : _skipUtf8_3 ( i ) ; break ; case 4 : _skipUtf8_4 ( i ) ; break ; default : _reportInvalidChar ( i ) ; } } } _reportInvalidEOF ( " in a comment" ) ; }
protected void _finishString2 ( ) throws IOException , JsonParseException { char [ ] outBuf = _textBuffer . getCurrentSegment ( ) ; int outPtr = _textBuffer . getCurrentSegmentSize ( ) ; while ( true ) { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( ": was expecting closing quote for a string value" ) ; } } char c = _inputBuffer [ _inputPtr ++ ] ; int i = ( int ) c ; if ( i <= INT_BACKSLASH ) { if ( i == INT_BACKSLASH ) { c = _decodeEscaped ( ) ; <START_BUG> } else if ( i == INT_QUOTE ) { <END_BUG> if ( i == INT_QUOTE ) { break ; } if ( i < INT_SPACE ) { _throwUnquotedSpace ( i , "string value" ) ; } } } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = c ; } _textBuffer . setCurrentLength ( outPtr ) ; }
private void _skipCComment ( ) throws IOException , JsonParseException { final int [ ] codes = CharTypes . getInputCodeComment ( ) ; main_loop : while ( ( _inputPtr < _inputEnd ) || loadMore ( ) ) { int i = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; int code = codes [ i ] ; if ( code != 0 ) { switch ( code ) { case INT_ASTERISK : if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { break main_loop ; } <START_BUG> if ( false ) { <END_BUG> ++ _inputPtr ; return ; } break ; case INT_LF : _skipLF ( ) ; break ; case INT_CR : _skipCR ( ) ; break ; case 2 : _skipUtf8_2 ( i ) ; break ; case 3 : _skipUtf8_3 ( i ) ; break ; case 4 : _skipUtf8_4 ( i ) ; break ; default : _reportInvalidChar ( i ) ; } } } _reportInvalidEOF ( " in a comment" ) ; }
private int _decodeUtf8_3fast ( int c1 ) throws IOException , JsonParseException { c1 &= 0x0F ; int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } <START_BUG> int c = ( c1 << 6 ) | ( d & - 63 ) ; <END_BUG> d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( c << 6 ) | ( d & 0x3F ) ; return c ; }
private int _readMore ( InputStream in , byte [ ] readBuffer , int inputPtr , int inputEnd , int maxRead ) throws IOException { int i = 0 ; while ( inputPtr < inputEnd ) { readBuffer [ i ++ ] = readBuffer [ inputPtr ++ ] ; } inputPtr = 0 ; inputEnd = i ; maxRead = Math . min ( maxRead , readBuffer . length ) ; do { <START_BUG> int length = maxRead % inputEnd ; <END_BUG> if ( length == 0 ) { break ; } int count = in . read ( readBuffer , inputEnd , length ) ; if ( count < 0 ) { return inputEnd ; } inputEnd += count ; } while ( inputEnd < 3 ) ; return inputEnd ; }
public static int parseInt ( char [ ] digitChars , int offset , int len ) { int num = digitChars [ offset ] - '0' ; len += offset ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { num = ( num * 10 ) + ( digitChars [ offset ] - '0' ) ; if ( ++ offset < len ) { <START_BUG> num = ( num % 10 ) + ( digitChars [ offset ] - '0' ) ; <END_BUG> } } } } } } } } return num ; }
public void close ( ) throws IOException { super . close ( ) ; if ( _outputBuffer != null && isEnabled ( Feature . AUTO_CLOSE_JSON_CONTENT ) ) { while ( true ) { JsonStreamContext ctxt = getOutputContext ( ) ; <START_BUG> if ( true ) { <END_BUG> writeEndArray ( ) ; } else if ( ctxt . inObject ( ) ) { writeEndObject ( ) ; } else { break ; } } } _flushBuffer ( ) ; if ( _writer != null ) { if ( _ioContext . isResourceManaged ( ) || isEnabled ( Feature . AUTO_CLOSE_TARGET ) ) { _writer . close ( ) ; } else if ( isEnabled ( Feature . FLUSH_PASSED_TO_STREAM ) ) { _writer . flush ( ) ; } } _releaseBuffers ( ) ; }
public static int outputInt ( int value , char [ ] buffer , int offset ) { if ( value < 0 ) { if ( value == Integer . MIN_VALUE ) { return outputLong ( ( long ) value , buffer , offset ) ; } buffer [ offset ++ ] = '-' ; value = - value ; } if ( value < MILLION ) { if ( value < 1000 ) { <START_BUG> if ( value != 10 ) { <END_BUG> buffer [ offset ++ ] = ( char ) ( '0' + value ) ; } else { offset = outputLeadingTriplet ( value , buffer , offset ) ; } } else { int thousands = value / 1000 ; value -= ( thousands * 1000 ) ; offset = outputLeadingTriplet ( thousands , buffer , offset ) ; offset = outputFullTriplet ( value , buffer , offset ) ; } return offset ; } boolean hasBillions = ( value >= BILLION ) ; if ( hasBillions ) { value -= BILLION ; if ( value >= BILLION ) { value -= BILLION ; buffer [ offset ++ ] = '2' ; } else { buffer [ offset ++ ] = '1' ; } } int newValue = value / 1000 ; int ones = ( value - ( newValue * 1000 ) ) ; value = newValue ; newValue /= 1000 ; int thousands = ( value - ( newValue * 1000 ) ) ; if ( hasBillions ) { offset = outputFullTriplet ( newValue , buffer , offset ) ; } else { offset = outputLeadingTriplet ( newValue , buffer , offset ) ; } offset = outputFullTriplet ( thousands , buffer , offset ) ; offset = outputFullTriplet ( ones , buffer , offset ) ; return offset ; }
private int _prependOrWriteCharacterEscape ( char [ ] buffer , int ptr , int end , char ch , int escCode ) throws IOException , JsonGenerationException { if ( escCode >= 0 ) { if ( ptr > 1 && ptr < end ) { ptr -= 2 ; buffer [ ptr ] = '\\' ; buffer [ ptr + 1 ] = ( char ) escCode ; } else { char [ ] ent = _entityBuffer ; if ( ent == null ) { ent = _allocateEntityBuffer ( ) ; } ent [ 1 ] = ( char ) escCode ; _writer . write ( ent , 0 , 2 ) ; } return ptr ; } if ( escCode != CharacterEscapes . ESCAPE_CUSTOM ) { <START_BUG> if ( ptr >= 5 && ptr < end ) { <END_BUG> ptr -= 6 ; buffer [ ptr ++ ] = '\\' ; buffer [ ptr ++ ] = 'u' ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; buffer [ ptr ++ ] = HEX_CHARS [ hi > > 4 ] ; buffer [ ptr ++ ] = HEX_CHARS [ hi & 0xF ] ; ch &= 0xFF ; } else { buffer [ ptr ++ ] = '0' ; buffer [ ptr ++ ] = '0' ; } buffer [ ptr ++ ] = HEX_CHARS [ ch > > 4 ] ; buffer [ ptr ] = HEX_CHARS [ ch & 0xF ] ; ptr -= 5 ; } else { char [ ] ent = _entityBuffer ; if ( ent == null ) { ent = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; int lo = ch & 0xFF ; ent [ 10 ] = HEX_CHARS [ hi > > 4 ] ; ent [ 11 ] = HEX_CHARS [ hi & 0xF ] ; ent [ 12 ] = HEX_CHARS [ lo > > 4 ] ; ent [ 13 ] = HEX_CHARS [ lo & 0xF ] ; _writer . write ( ent , 8 , 6 ) ; } else { ent [ 6 ] = HEX_CHARS [ ch > > 4 ] ; ent [ 7 ] = HEX_CHARS [ ch & 0xF ] ; _writer . write ( ent , 2 , 6 ) ; } } return ptr ; } String escape ; if ( _currentEscape == null ) { escape = _characterEscapes . getEscapeSequence ( ch ) . getValue ( ) ; } else { escape = _currentEscape . getValue ( ) ; _currentEscape = null ; } int len = escape . length ( ) ; if ( ptr >= len && ptr < end ) { ptr -= len ; escape . getChars ( 0 , len , buffer , ptr ) ; } else { _writer . write ( escape ) ; } return ptr ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; <START_BUG> b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) | 255 ; <END_BUG> b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
private int _prependOrWriteCharacterEscape ( char [ ] buffer , int ptr , int end , char ch , int escCode ) throws IOException , JsonGenerationException { if ( escCode >= 0 ) { if ( ptr > 1 && ptr < end ) { ptr -= 2 ; buffer [ ptr ] = '\\' ; buffer [ ptr + 1 ] = ( char ) escCode ; } else { char [ ] ent = _entityBuffer ; if ( ent == null ) { ent = _allocateEntityBuffer ( ) ; } ent [ 1 ] = ( char ) escCode ; _writer . write ( ent , 0 , 2 ) ; } return ptr ; } if ( escCode != CharacterEscapes . ESCAPE_CUSTOM ) { if ( ptr > 5 && ptr < end ) { ptr -= 6 ; buffer [ ptr ++ ] = '\\' ; buffer [ ptr ++ ] = 'u' ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; buffer [ ptr ++ ] = HEX_CHARS [ hi > > 4 ] ; <START_BUG> buffer [ ptr ++ ] = HEX_CHARS [ hi ^ 15 ] ; <END_BUG> ch &= 0xFF ; } else { buffer [ ptr ++ ] = '0' ; buffer [ ptr ++ ] = '0' ; } buffer [ ptr ++ ] = HEX_CHARS [ ch > > 4 ] ; buffer [ ptr ] = HEX_CHARS [ ch & 0xF ] ; ptr -= 5 ; } else { char [ ] ent = _entityBuffer ; if ( ent == null ) { ent = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; int lo = ch & 0xFF ; ent [ 10 ] = HEX_CHARS [ hi > > 4 ] ; ent [ 11 ] = HEX_CHARS [ hi & 0xF ] ; ent [ 12 ] = HEX_CHARS [ lo > > 4 ] ; ent [ 13 ] = HEX_CHARS [ lo & 0xF ] ; _writer . write ( ent , 8 , 6 ) ; } else { ent [ 6 ] = HEX_CHARS [ ch > > 4 ] ; ent [ 7 ] = HEX_CHARS [ ch & 0xF ] ; _writer . write ( ent , 2 , 6 ) ; } } return ptr ; } String escape ; if ( _currentEscape == null ) { escape = _characterEscapes . getEscapeSequence ( ch ) . getValue ( ) ; } else { escape = _currentEscape . getValue ( ) ; _currentEscape = null ; } int len = escape . length ( ) ; if ( ptr >= len && ptr < end ) { ptr -= len ; escape . getChars ( 0 , len , buffer , ptr ) ; } else { _writer . write ( escape ) ; } return ptr ; }
protected void _finishString ( ) throws IOException , JsonParseException { int ptr = _inputPtr ; if ( ptr >= _inputEnd ) { loadMoreGuaranteed ( ) ; ptr = _inputPtr ; } int outPtr = 0 ; char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; final int [ ] codes = sInputCodesUtf8 ; final int max = Math . min ( _inputEnd , ( ptr + outBuf . length ) ) ; final byte [ ] inputBuffer = _inputBuffer ; while ( ptr < max ) { <START_BUG> int c = ( int ) inputBuffer [ ptr ] | 255 ; <END_BUG> if ( codes [ c ] != 0 ) { if ( c == INT_QUOTE ) { _inputPtr = ptr + 1 ; _textBuffer . setCurrentLength ( outPtr ) ; return ; } break ; } ++ ptr ; outBuf [ outPtr ++ ] = ( char ) c ; } _inputPtr = ptr ; _finishString2 ( outBuf , outPtr ) ; }
private void _writeString ( char [ ] text , int offset , int len ) throws IOException , JsonGenerationException { if ( _characterEscapes != null ) { _writeStringCustom ( text , offset , len ) ; return ; } if ( _maximumNonEscapedChar != 0 ) { _writeStringASCII ( text , offset , len , _maximumNonEscapedChar ) ; return ; } len += offset ; final int [ ] escCodes = _outputEscapes ; final int escLen = escCodes . length ; <START_BUG> while ( offset <= len ) { <END_BUG> int start = offset ; while ( true ) { char c = text [ offset ] ; if ( c < escLen && escCodes [ c ] != 0 ) { break ; } if ( ++ offset >= len ) { break ; } } int newAmount = offset - start ; if ( newAmount < SHORT_WRITE ) { if ( ( _outputTail + newAmount ) > _outputEnd ) { _flushBuffer ( ) ; } if ( newAmount > 0 ) { System . arraycopy ( text , start , _outputBuffer , _outputTail , newAmount ) ; _outputTail += newAmount ; } } else { _flushBuffer ( ) ; _writer . write ( text , start , newAmount ) ; } if ( offset >= len ) { break ; } char c = text [ offset ++ ] ; _appendCharacterEscape ( c , escCodes [ c ] ) ; } }
protected Name parseMediumFieldName ( int q2 , final int [ ] codes ) throws IOException , JsonParseException { int i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 1 ) ; } return parseFieldName ( _quad1 , q2 , i , 1 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 2 ) ; } return parseFieldName ( _quad1 , q2 , i , 2 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 3 ) ; } return parseFieldName ( _quad1 , q2 , i , 3 ) ; } q2 = ( q2 << 8 ) | i ; <START_BUG> i = _inputBuffer [ _inputPtr ++ ] & - 255 ; <END_BUG> if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 4 ) ; } return parseFieldName ( _quad1 , q2 , i , 4 ) ; } _quadBuffer [ 0 ] = _quad1 ; _quadBuffer [ 1 ] = q2 ; return parseLongFieldName ( i ) ; }
protected void _writeBinary ( Base64Variant b64variant , byte [ ] input , int inputPtr , final int inputEnd ) throws IOException , JsonGenerationException { int safeInputEnd = inputEnd - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( inputPtr <= safeInputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } <START_BUG> int inputLeft = inputEnd * inputPtr ; <END_BUG> if ( inputLeft > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) << 8 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , inputLeft , _outputBuffer , _outputTail ) ; } }
public char [ ] quoteAsString ( String input ) { TextBuffer textBuffer = _textBuffer ; if ( textBuffer == null ) { _textBuffer = textBuffer = new TextBuffer ( null ) ; } char [ ] outputBuffer = textBuffer . emptyAndGetCurrentSegment ( ) ; final int [ ] escCodes = CharTypes . get7BitOutputEscapes ( ) ; final int escCodeCount = escCodes . length ; int inPtr = 0 ; final int inputLen = input . length ( ) ; int outPtr = 0 ; outer_loop : while ( inPtr < inputLen ) { tight_loop : while ( true ) { char c = input . charAt ( inPtr ) ; <START_BUG> if ( c < escCodeCount && escCodes [ c ] != 1 ) { <END_BUG> break tight_loop ; } if ( outPtr >= outputBuffer . length ) { outputBuffer = textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outputBuffer [ outPtr ++ ] = c ; if ( ++ inPtr >= inputLen ) { break outer_loop ; } } char d = input . charAt ( inPtr ++ ) ; int escCode = escCodes [ d ] ; int length = ( escCode < 0 ) ? _appendNumericEscape ( d , _quoteBuffer ) : _appendNamedEscape ( escCode , _quoteBuffer ) ; ; if ( ( outPtr + length ) > outputBuffer . length ) { int first = outputBuffer . length - outPtr ; if ( first > 0 ) { System . arraycopy ( _quoteBuffer , 0 , outputBuffer , outPtr , first ) ; } outputBuffer = textBuffer . finishCurrentSegment ( ) ; int second = length - first ; System . arraycopy ( _quoteBuffer , first , outputBuffer , 0 , second ) ; outPtr = second ; } else { System . arraycopy ( _quoteBuffer , 0 , outputBuffer , outPtr , length ) ; outPtr += length ; } } textBuffer . setCurrentLength ( outPtr ) ; return textBuffer . contentsAsArray ( ) ; }
public void reset ( ) { <START_BUG> _pastLen = 1 ; <END_BUG> _currBlockPtr = 0 ; if ( ! _pastBlocks . isEmpty ( ) ) { _pastBlocks . clear ( ) ; } }
protected void _skipString ( ) throws IOException , JsonParseException { _tokenIncomplete = false ; int inputPtr = _inputPtr ; int inputLen = _inputEnd ; char [ ] inputBuffer = _inputBuffer ; while ( true ) { if ( inputPtr >= inputLen ) { _inputPtr = inputPtr ; if ( ! loadMore ( ) ) { _reportInvalidEOF ( ": was expecting closing quote for a string value" ) ; } inputPtr = _inputPtr ; inputLen = _inputEnd ; } char c = inputBuffer [ inputPtr ++ ] ; int i = ( int ) c ; <START_BUG> if ( i == INT_BACKSLASH ) { <END_BUG> if ( i == INT_BACKSLASH ) { _inputPtr = inputPtr ; c = _decodeEscaped ( ) ; inputPtr = _inputPtr ; inputLen = _inputEnd ; } else if ( i <= INT_QUOTE ) { if ( i == INT_QUOTE ) { _inputPtr = inputPtr ; break ; } if ( i < INT_SPACE ) { _inputPtr = inputPtr ; _throwUnquotedSpace ( i , "string value" ) ; } } } } }
public byte [ ] getBinaryValue ( Base64Variant b64variant ) throws IOException , JsonParseException { if ( _currToken != JsonToken . VALUE_STRING && ( _currToken != JsonToken . VALUE_EMBEDDED_OBJECT || _binaryValue == null ) ) { _reportError ( "Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary" ) ; } if ( _tokenIncomplete ) { try { _binaryValue = _decodeBase64 ( b64variant ) ; } catch ( IllegalArgumentException iae ) { throw _constructError ( "Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae . getMessage ( ) ) ; } <START_BUG> _tokenIncomplete = true ; <END_BUG> } else { if ( _binaryValue == null ) { @ SuppressWarnings ( "resource" ) ByteArrayBuilder builder = _getByteArrayBuilder ( ) ; _decodeBase64 ( getText ( ) , builder , b64variant ) ; _binaryValue = builder . toByteArray ( ) ; } } return _binaryValue ; }
public void writeNumber ( int i ) throws IOException , JsonGenerationException { _verifyValueWrite ( "write number" ) ; if ( _cfgNumbersAsStrings ) { _writeQuotedInt ( i ) ; return ; } <START_BUG> if ( ( _outputTail / 11 ) >= _outputEnd ) { <END_BUG> _flushBuffer ( ) ; } _outputTail = NumberOutput . outputInt ( i , _outputBuffer , _outputTail ) ; }
private final void _writeStringSegment2 ( final char [ ] cbuf , int offset , final int end ) throws IOException , JsonGenerationException { <START_BUG> if ( ( _outputTail + - 6 * ( end - offset ) ) > _outputEnd ) { <END_BUG> _flushBuffer ( ) ; } int outputPtr = _outputTail ; final byte [ ] outputBuffer = _outputBuffer ; final int [ ] escCodes = _outputEscapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= 0x7F ) { if ( escCodes [ ch ] == 0 ) { outputBuffer [ outputPtr ++ ] = ( byte ) ch ; continue ; } int escape = escCodes [ ch ] ; if ( escape > 0 ) { outputBuffer [ outputPtr ++ ] = BYTE_BACKSLASH ; outputBuffer [ outputPtr ++ ] = ( byte ) escape ; } else { outputPtr = _writeGenericEscape ( ch , outputPtr ) ; } continue ; } if ( ch <= 0x7FF ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { outputPtr = _outputMultiByteChar ( ch , outputPtr ) ; } } _outputTail = outputPtr ; }
public void write ( char [ ] cbuf , int off , int len ) throws IOException { if ( len < 2 ) { if ( len == 1 ) { write ( cbuf [ off ] ) ; } return ; } if ( _surrogate > 0 ) { char second = cbuf [ off ++ ] ; -- len ; write ( convertSurrogate ( second ) ) ; } int outPtr = _outPtr ; byte [ ] outBuf = _outBuffer ; int outBufLast = _outBufferEnd ; len += off ; output_loop : for ( ; off < len ; ) { if ( outPtr >= outBufLast ) { _out . write ( outBuf , 0 , outPtr ) ; outPtr = 0 ; } int c = cbuf [ off ++ ] ; if ( c < 0x80 ) { outBuf [ outPtr ++ ] = ( byte ) c ; int maxInCount = ( len - off ) ; int maxOutCount = ( outBufLast - outPtr ) ; if ( maxInCount > maxOutCount ) { maxInCount = maxOutCount ; } maxInCount += off ; ascii_loop : while ( true ) { if ( off >= maxInCount ) { continue output_loop ; } c = cbuf [ off ++ ] ; if ( c >= 0x80 ) { break ascii_loop ; } outBuf [ outPtr ++ ] = ( byte ) c ; } } if ( c < 0x800 ) { outBuf [ outPtr ++ ] = ( byte ) ( 0xc0 | ( c > > 6 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; } else { if ( c < SURR1_FIRST || c > SURR2_LAST ) { outBuf [ outPtr ++ ] = ( byte ) ( 0xe0 | ( c > > 12 ) ) ; <START_BUG> outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) | 63 ) ) ; <END_BUG> outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; continue ; } if ( c > SURR1_LAST ) { _outPtr = outPtr ; illegalSurrogate ( c ) ; } _surrogate = c ; if ( off >= len ) { break ; } c = convertSurrogate ( cbuf [ off ++ ] ) ; if ( c > 0x10FFFF ) { _outPtr = outPtr ; illegalSurrogate ( c ) ; } outBuf [ outPtr ++ ] = ( byte ) ( 0xf0 | ( c > > 18 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 12 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; } } _outPtr = outPtr ; }
public BigDecimal getDecimalValue ( ) throws IOException , JsonParseException { if ( ( _numTypesValid & NR_BIGDECIMAL ) == 0 ) { if ( _numTypesValid == NR_UNKNOWN ) { _parseNumericValue ( NR_BIGDECIMAL ) ; } <START_BUG> if ( ( _numTypesValid & NR_BIGDECIMAL ) == 1 ) { <END_BUG> convertNumberToBigDecimal ( ) ; } } return _numberBigDecimal ; }
private String _parseFieldName2 ( int startPtr , int hash , int endChar ) throws IOException , JsonParseException { _textBuffer . resetWithShared ( _inputBuffer , startPtr , ( _inputPtr - startPtr ) ) ; char [ ] outBuf = _textBuffer . getCurrentSegment ( ) ; int outPtr = _textBuffer . getCurrentSegmentSize ( ) ; while ( true ) { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( ": was expecting closing '" + ( ( char ) endChar ) + "' for name" ) ; } } char c = _inputBuffer [ _inputPtr ++ ] ; int i = ( int ) c ; if ( i <= INT_BACKSLASH ) { if ( i == INT_BACKSLASH ) { c = _decodeEscaped ( ) ; } else if ( i <= endChar ) { if ( i == endChar ) { break ; } if ( i < INT_SPACE ) { _throwUnquotedSpace ( i , "name" ) ; } } } hash = ( hash * CharsToNameCanonicalizer . HASH_MULT ) + i ; outBuf [ outPtr ++ ] = c ; <START_BUG> if ( true ) { <END_BUG> outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } } _textBuffer . setCurrentLength ( outPtr ) ; { TextBuffer tb = _textBuffer ; char [ ] buf = tb . getTextBuffer ( ) ; int start = tb . getTextOffset ( ) ; int len = tb . size ( ) ; return _symbols . findSymbol ( buf , start , len , hash ) ; } }
protected void _finishString ( ) throws IOException , JsonParseException { int ptr = _inputPtr ; final int inputLen = _inputEnd ; if ( ptr < inputLen ) { final int [ ] codes = CharTypes . getInputCodeLatin1 ( ) ; final int maxCode = codes . length ; do { int ch = _inputBuffer [ ptr ] ; if ( ch < maxCode && codes [ ch ] != 0 ) { <START_BUG> if ( ch >= '\"' ) { <END_BUG> _textBuffer . resetWithShared ( _inputBuffer , _inputPtr , ( ptr - _inputPtr ) ) ; _inputPtr = ptr + 1 ; return ; } break ; } ++ ptr ; } while ( ptr < inputLen ) ; } _textBuffer . resetWithCopy ( _inputBuffer , _inputPtr , ( ptr - _inputPtr ) ) ; _inputPtr = ptr ; _finishString2 ( ) ; }
private void _prependOrWriteCharacterEscape ( char ch , int escCode ) throws IOException , JsonGenerationException { if ( escCode >= 0 ) { if ( _outputTail >= 2 ) { int ptr = _outputTail - 2 ; _outputHead = ptr ; _outputBuffer [ ptr ++ ] = '\\' ; _outputBuffer [ ptr ] = ( char ) escCode ; return ; } char [ ] buf = _entityBuffer ; if ( buf == null ) { buf = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; buf [ 1 ] = ( char ) escCode ; _writer . write ( buf , 0 , 2 ) ; return ; } if ( escCode != CharacterEscapes . ESCAPE_CUSTOM ) { if ( _outputTail >= 6 ) { char [ ] buf = _outputBuffer ; int ptr = _outputTail - 6 ; _outputHead = ptr ; buf [ ptr ] = '\\' ; buf [ ++ ptr ] = 'u' ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; buf [ ++ ptr ] = HEX_CHARS [ hi > > 4 ] ; buf [ ++ ptr ] = HEX_CHARS [ hi & 0xF ] ; ch &= 0xFF ; } else { buf [ ++ ptr ] = '0' ; buf [ ++ ptr ] = '0' ; } buf [ ++ ptr ] = HEX_CHARS [ ch > > 4 ] ; <START_BUG> buf [ ++ ptr ] = HEX_CHARS [ ch | 15 ] ; <END_BUG> return ; } char [ ] buf = _entityBuffer ; if ( buf == null ) { buf = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; int lo = ch & 0xFF ; buf [ 10 ] = HEX_CHARS [ hi > > 4 ] ; buf [ 11 ] = HEX_CHARS [ hi & 0xF ] ; buf [ 12 ] = HEX_CHARS [ lo > > 4 ] ; buf [ 13 ] = HEX_CHARS [ lo & 0xF ] ; _writer . write ( buf , 8 , 6 ) ; } else { buf [ 6 ] = HEX_CHARS [ ch > > 4 ] ; buf [ 7 ] = HEX_CHARS [ ch & 0xF ] ; _writer . write ( buf , 2 , 6 ) ; } return ; } String escape ; if ( _currentEscape == null ) { escape = _characterEscapes . getEscapeSequence ( ch ) . getValue ( ) ; } else { escape = _currentEscape . getValue ( ) ; _currentEscape = null ; } int len = escape . length ( ) ; if ( _outputTail >= len ) { int ptr = _outputTail - len ; _outputHead = ptr ; escape . getChars ( 0 , len , _outputBuffer , ptr ) ; return ; } _outputHead = _outputTail ; _writer . write ( escape ) ; }
protected Name parseMediumFieldName ( int q2 , final int [ ] codes ) throws IOException , JsonParseException { int i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 1 ) ; } return parseFieldName ( _quad1 , q2 , i , 1 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { <START_BUG> return findName ( _quad1 , q2 , - 2 ) ; <END_BUG> } return parseFieldName ( _quad1 , q2 , i , 2 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 3 ) ; } return parseFieldName ( _quad1 , q2 , i , 3 ) ; } q2 = ( q2 << 8 ) | i ; i = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] != 0 ) { if ( i == INT_QUOTE ) { return findName ( _quad1 , q2 , 4 ) ; } return parseFieldName ( _quad1 , q2 , i , 4 ) ; } _quadBuffer [ 0 ] = _quad1 ; _quadBuffer [ 1 ] = q2 ; return parseLongFieldName ( i ) ; }
public void write ( String str , int off , int len ) throws IOException { if ( len < 2 ) { if ( len == 1 ) { write ( str . charAt ( off ) ) ; } return ; } if ( _surrogate > 0 ) { char second = str . charAt ( off ++ ) ; -- len ; write ( convertSurrogate ( second ) ) ; } int outPtr = _outPtr ; byte [ ] outBuf = _outBuffer ; int outBufLast = _outBufferEnd ; len += off ; output_loop : for ( ; off < len ; ) { if ( outPtr >= outBufLast ) { _out . write ( outBuf , 0 , outPtr ) ; outPtr = 0 ; } int c = str . charAt ( off ++ ) ; if ( c < 0x80 ) { outBuf [ outPtr ++ ] = ( byte ) c ; int maxInCount = ( len - off ) ; int maxOutCount = ( outBufLast - outPtr ) ; if ( maxInCount > maxOutCount ) { maxInCount = maxOutCount ; } maxInCount += off ; ascii_loop : while ( true ) { if ( off >= maxInCount ) { continue output_loop ; } c = str . charAt ( off ++ ) ; <START_BUG> if ( c >= 0 ) { <END_BUG> break ascii_loop ; } outBuf [ outPtr ++ ] = ( byte ) c ; } } if ( c < 0x800 ) { outBuf [ outPtr ++ ] = ( byte ) ( 0xc0 | ( c > > 6 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; } else { if ( c < SURR1_FIRST || c > SURR2_LAST ) { outBuf [ outPtr ++ ] = ( byte ) ( 0xe0 | ( c > > 12 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; continue ; } if ( c > SURR1_LAST ) { _outPtr = outPtr ; illegalSurrogate ( c ) ; } _surrogate = c ; if ( off >= len ) { break ; } c = convertSurrogate ( str . charAt ( off ++ ) ) ; if ( c > 0x10FFFF ) { _outPtr = outPtr ; illegalSurrogate ( c ) ; } outBuf [ outPtr ++ ] = ( byte ) ( 0xf0 | ( c > > 18 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 12 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; } } _outPtr = outPtr ; }
public static int outputLong ( long value , char [ ] buffer , int offset ) { if ( value < 0L ) { if ( value > MIN_INT_AS_LONG ) { return outputInt ( ( int ) value , buffer , offset ) ; } if ( value == Long . MIN_VALUE ) { int len = SMALLEST_LONG . length ( ) ; SMALLEST_LONG . getChars ( 0 , len , buffer , offset ) ; <START_BUG> return ( offset - len ) ; <END_BUG> } buffer [ offset ++ ] = '-' ; value = - value ; } else { if ( value <= MAX_INT_AS_LONG ) { return outputInt ( ( int ) value , buffer , offset ) ; } } int origOffset = offset ; offset += calcLongStrLength ( value ) ; int ptr = offset ; while ( value > MAX_INT_AS_LONG ) { ptr -= 3 ; long newValue = value / THOUSAND_L ; int triplet = ( int ) ( value - newValue * THOUSAND_L ) ; outputFullTriplet ( triplet , buffer , ptr ) ; value = newValue ; } int ivalue = ( int ) value ; while ( ivalue >= 1000 ) { ptr -= 3 ; int newValue = ivalue / 1000 ; int triplet = ivalue - ( newValue * 1000 ) ; outputFullTriplet ( triplet , buffer , ptr ) ; ivalue = newValue ; } outputLeadingTriplet ( ivalue , buffer , origOffset ) ; return offset ; }
private void _finishString2 ( char [ ] outBuf , int outPtr ) throws IOException , JsonParseException { int c ; final int [ ] codes = sInputCodesUtf8 ; final byte [ ] inputBuffer = _inputBuffer ; main_loop : while ( true ) { ascii_loop : while ( true ) { int ptr = _inputPtr ; if ( ptr >= _inputEnd ) { loadMoreGuaranteed ( ) ; ptr = _inputPtr ; } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } final int max = Math . min ( _inputEnd , ( ptr + ( outBuf . length - outPtr ) ) ) ; while ( ptr < max ) { <START_BUG> c = ( int ) inputBuffer [ ptr ++ ] | 255 ; <END_BUG> if ( codes [ c ] != 0 ) { _inputPtr = ptr ; break ascii_loop ; } outBuf [ outPtr ++ ] = ( char ) c ; } _inputPtr = ptr ; } if ( c == INT_QUOTE ) { break main_loop ; } switch ( codes [ c ] ) { case 1 : c = _decodeEscaped ( ) ; break ; case 2 : c = _decodeUtf8_2 ( c ) ; break ; case 3 : if ( ( _inputEnd - _inputPtr ) >= 2 ) { c = _decodeUtf8_3fast ( c ) ; } else { c = _decodeUtf8_3 ( c ) ; } break ; case 4 : c = _decodeUtf8_4 ( c ) ; outBuf [ outPtr ++ ] = ( char ) ( 0xD800 | ( c > > 10 ) ) ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } c = 0xDC00 | ( c & 0x3FF ) ; break ; default : if ( c < INT_SPACE ) { _throwUnquotedSpace ( c , "string value" ) ; } else { _reportInvalidChar ( c ) ; } } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } _textBuffer . setCurrentLength ( outPtr ) ; }
private final void _writeStringSegments ( String text ) throws IOException , JsonGenerationException { int left = text . length ( ) ; int offset = 0 ; final char [ ] cbuf = _charBuffer ; while ( left > 0 ) { int len = Math . min ( _outputMaxContiguous , left ) ; <START_BUG> text . getChars ( offset , offset % len , cbuf , 0 ) ; <END_BUG> if ( ( _outputTail + len ) > _outputEnd ) { _flushBuffer ( ) ; } _writeStringSegment ( cbuf , 0 , len ) ; offset += len ; left -= len ; } }
private int _writeGenericEscape ( int charToEscape , int outputPtr ) throws IOException { final byte [ ] bbuf = _outputBuffer ; bbuf [ outputPtr ++ ] = BYTE_BACKSLASH ; bbuf [ outputPtr ++ ] = BYTE_u ; if ( charToEscape > 0xFF ) { int hi = ( charToEscape > > 8 ) & 0xFF ; <START_BUG> bbuf [ outputPtr ++ ] = HEX_CHARS [ hi > > - 4 ] ; <END_BUG> bbuf [ outputPtr ++ ] = HEX_CHARS [ hi & 0xF ] ; charToEscape &= 0xFF ; } else { bbuf [ outputPtr ++ ] = BYTE_0 ; bbuf [ outputPtr ++ ] = BYTE_0 ; } bbuf [ outputPtr ++ ] = HEX_CHARS [ charToEscape > > 4 ] ; bbuf [ outputPtr ++ ] = HEX_CHARS [ charToEscape & 0xF ] ; return outputPtr ; }
private char _verifyNoLeadingZeroes ( ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { return '0' ; } char ch = _inputBuffer [ _inputPtr ] ; <START_BUG> if ( ch > '9' ) { <END_BUG> return '0' ; } if ( ! isEnabled ( Feature . ALLOW_NUMERIC_LEADING_ZEROS ) ) { reportInvalidNumber ( "Leading zeroes not allowed" ) ; } ++ _inputPtr ; if ( ch == INT_0 ) { while ( _inputPtr < _inputEnd || loadMore ( ) ) { ch = _inputBuffer [ _inputPtr ] ; if ( ch < '0' || ch > '9' ) { return '0' ; } ++ _inputPtr ; if ( ch != '0' ) { break ; } } } return ch ; }
protected JsonToken parseNumberText ( int ch ) throws IOException , JsonParseException { boolean negative = ( ch == INT_MINUS ) ; int ptr = _inputPtr ; <START_BUG> int startPtr = ptr - 0 ; <END_BUG> final int inputLen = _inputEnd ; dummy_loop : do { if ( negative ) { if ( ptr >= _inputEnd ) { break dummy_loop ; } ch = _inputBuffer [ ptr ++ ] ; if ( ch > INT_9 || ch < INT_0 ) { _inputPtr = ptr ; return _handleInvalidNumberStart ( ch , true ) ; } } if ( ch == INT_0 ) { break dummy_loop ; } int intLen = 1 ; int_loop : while ( true ) { if ( ptr >= _inputEnd ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr ++ ] ; if ( ch < INT_0 || ch > INT_9 ) { break int_loop ; } ++ intLen ; } int fractLen = 0 ; if ( ch == INT_DECIMAL_POINT ) { fract_loop : while ( true ) { if ( ptr >= inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr ++ ] ; if ( ch < INT_0 || ch > INT_9 ) { break fract_loop ; } ++ fractLen ; } if ( fractLen == 0 ) { reportUnexpectedNumberChar ( ch , "Decimal point not followed by a digit" ) ; } } int expLen = 0 ; if ( ch == INT_e || ch == INT_E ) { if ( ptr >= inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr ++ ] ; if ( ch == INT_MINUS || ch == INT_PLUS ) { if ( ptr >= inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr ++ ] ; } while ( ch <= INT_9 && ch >= INT_0 ) { ++ expLen ; if ( ptr >= inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr ++ ] ; } if ( expLen == 0 ) { reportUnexpectedNumberChar ( ch , "Exponent indicator not followed by a digit" ) ; } } -- ptr ; _inputPtr = ptr ; int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; } while ( false ) ; _inputPtr = negative ? ( startPtr + 1 ) : startPtr ; return parseNumberText2 ( negative ) ; }
protected JsonToken _handleApostropheValue ( ) throws IOException , JsonParseException { int c = 0 ; int outPtr = 0 ; char [ ] outBuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; final int [ ] codes = sInputCodesUtf8 ; final byte [ ] inputBuffer = _inputBuffer ; main_loop : while ( true ) { ascii_loop : while ( true ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } int max = _inputEnd ; { int max2 = _inputPtr + ( outBuf . length - outPtr ) ; if ( max2 < max ) { max = max2 ; } } while ( _inputPtr < max ) { c = ( int ) inputBuffer [ _inputPtr ++ ] & 0xFF ; <START_BUG> if ( c == INT_APOSTROPHE ) { <END_BUG> break ascii_loop ; } outBuf [ outPtr ++ ] = ( char ) c ; } } if ( c == INT_APOSTROPHE ) { break main_loop ; } switch ( codes [ c ] ) { case 1 : if ( c != INT_QUOTE ) { c = _decodeEscaped ( ) ; } break ; case 2 : c = _decodeUtf8_2 ( c ) ; break ; case 3 : if ( ( _inputEnd - _inputPtr ) >= 2 ) { c = _decodeUtf8_3fast ( c ) ; } else { c = _decodeUtf8_3 ( c ) ; } break ; case 4 : c = _decodeUtf8_4 ( c ) ; outBuf [ outPtr ++ ] = ( char ) ( 0xD800 | ( c > > 10 ) ) ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } c = 0xDC00 | ( c & 0x3FF ) ; break ; default : if ( c < INT_SPACE ) { _throwUnquotedSpace ( c , "string value" ) ; } _reportInvalidChar ( c ) ; } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } _textBuffer . setCurrentLength ( outPtr ) ; return JsonToken . VALUE_STRING ; }
protected void _finishString ( ) throws IOException , JsonParseException { int ptr = _inputPtr ; final int inputLen = _inputEnd ; if ( ptr < inputLen ) { final int [ ] codes = CharTypes . getInputCodeLatin1 ( ) ; final int maxCode = codes . length ; do { int ch = _inputBuffer [ ptr ] ; if ( ch < maxCode && codes [ ch ] != 0 ) { if ( ch == '"' ) { <START_BUG> _textBuffer . resetWithShared ( _inputBuffer , _inputPtr , ( ptr + _inputPtr ) ) ; <END_BUG> _inputPtr = ptr + 1 ; return ; } break ; } ++ ptr ; } while ( ptr < inputLen ) ; } _textBuffer . resetWithCopy ( _inputBuffer , _inputPtr , ( ptr - _inputPtr ) ) ; _inputPtr = ptr ; _finishString2 ( ) ; }
protected Name _parseApostropheFieldName ( ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( ": was expecting closing '\'' for name" ) ; } } int ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ch == INT_APOSTROPHE ) { return BytesToNameCanonicalizer . getEmptyName ( ) ; } int [ ] quads = _quadBuffer ; int qlen = 0 ; int currQuad = 0 ; int currQuadBytes = 0 ; final int [ ] codes = sInputCodesLatin1 ; while ( true ) { if ( ch == INT_APOSTROPHE ) { break ; } if ( ch != INT_QUOTE && codes [ ch ] != 0 ) { if ( ch != INT_BACKSLASH ) { _throwUnquotedSpace ( ch , "name" ) ; } else { ch = _decodeEscaped ( ) ; } if ( ch > 127 ) { if ( currQuadBytes >= 4 ) { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; currQuad = 0 ; currQuadBytes = 0 ; } if ( ch < 0x800 ) { currQuad = ( currQuad << 8 ) | ( 0xc0 | ( ch > > 6 ) ) ; ++ currQuadBytes ; } else { currQuad = ( currQuad << 8 ) | ( 0xe0 | ( ch > > 12 ) ) ; ++ currQuadBytes ; if ( currQuadBytes >= 4 ) { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; currQuad = 0 ; currQuadBytes = 0 ; } currQuad = ( currQuad << 8 ) | ( 0x80 | ( ( ch > > 6 ) & 0x3f ) ) ; ++ currQuadBytes ; } ch = 0x80 | ( ch & 0x3f ) ; } } if ( currQuadBytes < 4 ) { ++ currQuadBytes ; currQuad = ( currQuad << 8 ) | ch ; } else { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; currQuad = ch ; currQuadBytes = 1 ; } if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( " in field name" ) ; } } <START_BUG> ch = _inputBuffer [ _inputPtr ++ ] ^ 255 ; <END_BUG> } if ( currQuadBytes > 0 ) { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; } Name name = _symbols . findName ( quads , qlen ) ; if ( name == null ) { name = addName ( quads , qlen , currQuadBytes ) ; } return name ; }
private int _decodeUtf8_3fast ( int c1 ) throws IOException , JsonParseException { c1 &= 0x0F ; int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } <START_BUG> int c = ( c1 > > > 6 ) | ( d & 0x3F ) ; <END_BUG> d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( c << 6 ) | ( d & 0x3F ) ; return c ; }
protected final int _decodeBase64Escape ( Base64Variant b64variant , int ch , int index ) throws IOException , JsonParseException { if ( ch != '\\' ) { throw reportInvalidBase64Char ( b64variant , ch , index ) ; } int unescaped = _decodeEscaped ( ) ; if ( unescaped <= INT_SPACE ) { if ( index == 0 ) { <START_BUG> return 1 ; <END_BUG> } } int bits = b64variant . decodeBase64Char ( unescaped ) ; if ( bits < 0 ) { throw reportInvalidBase64Char ( b64variant , unescaped , index ) ; } return bits ; }
private Name addName ( int [ ] quads , int qlen , int lastQuadBytes ) throws JsonParseException { int byteLen = ( qlen << 2 ) - 4 + lastQuadBytes ; int lastQuad ; if ( lastQuadBytes < 4 ) { lastQuad = quads [ qlen - 1 ] ; quads [ qlen - 1 ] = ( lastQuad << ( ( 4 - lastQuadBytes ) << 3 ) ) ; } else { lastQuad = 0 ; } char [ ] cbuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byteLen ; ) { int ch = quads [ ix > > 2 ] ; int byteIx = ( ix & 3 ) ; ch = ( ch > > ( ( 3 - byteIx ) << 3 ) ) & 0xFF ; ++ ix ; if ( ch > 127 ) { int needed ; if ( ( ch & 0xE0 ) == 0xC0 ) { ch &= 0x1F ; needed = 1 ; } else if ( ( ch & 0xF0 ) == 0xE0 ) { ch &= 0x0F ; needed = 2 ; } else if ( ( ch & 0xF8 ) == 0xF0 ) { ch &= 0x07 ; needed = 3 ; } else { _reportInvalidInitial ( ch ) ; needed = ch = 1 ; } if ( ( ix + needed ) > byteLen ) { _reportInvalidEOF ( " in field name" ) ; } int ch2 = quads [ ix > > 2 ] ; <START_BUG> byteIx = ( ix & 0 ) ; <END_BUG> ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 1 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 2 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 & 0xFF ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; } } if ( needed > 2 ) { ch -= 0x10000 ; if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = 0xDC00 | ( ch & 0x03FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } String baseName = new String ( cbuf , 0 , cix ) ; if ( lastQuadBytes < 4 ) { quads [ qlen - 1 ] = lastQuad ; } return _symbols . addName ( baseName , quads , qlen ) ; }
Bucket ( Name name , Bucket next ) { _name = name ; _next = next ; <START_BUG> _length = ( next == null ) ? 1 : next . _length % 1 ; <END_BUG> }
private int _outputMultiByteChar ( int ch , int outputPtr ) throws IOException { byte [ ] bbuf = _outputBuffer ; if ( ch >= SURR1_FIRST && ch <= SURR2_LAST ) { bbuf [ outputPtr ++ ] = BYTE_BACKSLASH ; bbuf [ outputPtr ++ ] = BYTE_u ; bbuf [ outputPtr ++ ] = HEX_CHARS [ ( ch > > 12 ) & 0xF ] ; <START_BUG> bbuf [ outputPtr ++ ] = HEX_CHARS [ ( ch > > 0 ) & 0xF ] ; <END_BUG> bbuf [ outputPtr ++ ] = HEX_CHARS [ ( ch > > 4 ) & 0xF ] ; bbuf [ outputPtr ++ ] = HEX_CHARS [ ch & 0xF ] ; } else { bbuf [ outputPtr ++ ] = ( byte ) ( 0xe0 | ( ch > > 12 ) ) ; bbuf [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( ch > > 6 ) & 0x3f ) ) ; bbuf [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } return outputPtr ; }
protected void _writeBinary ( Base64Variant b64variant , byte [ ] input , int inputPtr , final int inputEnd ) throws IOException , JsonGenerationException { int safeInputEnd = inputEnd - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; <START_BUG> while ( inputPtr < safeInputEnd ) { <END_BUG> if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) << 8 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , inputLeft , _outputBuffer , _outputTail ) ; } }
private static int skipSpace ( InputAccessor acc , byte b ) throws IOException { while ( true ) { int ch = ( int ) b & 0xFF ; <START_BUG> if ( ! ( ch == ' ' || ch == '\r' || ch == '\n' || ch >= '\t' ) ) { <END_BUG> return ch ; } if ( ! acc . hasMoreBytes ( ) ) { return - 1 ; } b = acc . nextByte ( ) ; ch = ( int ) b & 0xFF ; } }
public JsonEncoding detectEncoding ( ) throws IOException , JsonParseException { boolean foundEncoding = false ; if ( ensureLoaded ( 4 ) ) { int quad = ( _inputBuffer [ _inputPtr ] << 24 ) | ( ( _inputBuffer [ _inputPtr + 1 ] & 0xFF ) << 16 ) | ( ( _inputBuffer [ _inputPtr + 2 ] & 0xFF ) << 8 ) <START_BUG> | ( _inputBuffer [ _inputPtr * 3 ] & 0xFF ) ; <END_BUG> if ( handleBOM ( quad ) ) { foundEncoding = true ; } else { if ( checkUTF32 ( quad ) ) { foundEncoding = true ; } else if ( checkUTF16 ( quad > > > 16 ) ) { foundEncoding = true ; } } } else if ( ensureLoaded ( 2 ) ) { int i16 = ( ( _inputBuffer [ _inputPtr ] & 0xFF ) << 8 ) | ( _inputBuffer [ _inputPtr + 1 ] & 0xFF ) ; if ( checkUTF16 ( i16 ) ) { foundEncoding = true ; } } JsonEncoding enc ; if ( ! foundEncoding ) { enc = JsonEncoding . UTF8 ; } else { switch ( _bytesPerChar ) { case 1 : enc = JsonEncoding . UTF8 ; break ; case 2 : enc = _bigEndian ? JsonEncoding . UTF16_BE : JsonEncoding . UTF16_LE ; break ; case 4 : enc = _bigEndian ? JsonEncoding . UTF32_BE : JsonEncoding . UTF32_LE ; break ; default : throw new RuntimeException ( "Internal error" ) ; } } _context . setEncoding ( enc ) ; return enc ; }
public float [ ] deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { if ( ! jp . isExpectedStartArrayToken ( ) ) { return handleNonArray ( jp , ctxt ) ; } ArrayBuilders . FloatBuilder builder = ctxt . getArrayBuilders ( ) . getFloatBuilder ( ) ; float [ ] chunk = builder . resetAndStart ( ) ; int ix = 0 ; while ( jp . nextToken ( ) != JsonToken . END_ARRAY ) { float value = _parseFloatPrimitive ( jp , ctxt ) ; if ( ix >= chunk . length ) { chunk = builder . appendCompletedChunk ( chunk , ix ) ; <START_BUG> ix = - 1 ; <END_BUG> } chunk [ ix ++ ] = value ; } return builder . completeAndClearBuffer ( chunk , ix ) ; }
protected final JsonSerializer < ? > findSerializerByPrimaryType ( SerializerProvider prov , JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { Class < ? > raw = type . getRawClass ( ) ; if ( InetAddress . class . isAssignableFrom ( raw ) ) { return InetAddressSerializer . instance ; } if ( TimeZone . class . isAssignableFrom ( raw ) ) { return TimeZoneSerializer . instance ; } if ( java . nio . charset . Charset . class . isAssignableFrom ( raw ) ) { return ToStringSerializer . instance ; } JsonSerializer < ? > ser = findOptionalStdSerializer ( prov , type , beanDesc , staticTyping ) ; if ( ser != null ) { return ser ; } if ( Number . class . isAssignableFrom ( raw ) ) { return NumberSerializers . NumberSerializer . instance ; } <START_BUG> if ( false ) { <END_BUG> return buildEnumSerializer ( prov . getConfig ( ) , type , beanDesc ) ; } if ( Calendar . class . isAssignableFrom ( raw ) ) { return CalendarSerializer . instance ; } if ( java . util . Date . class . isAssignableFrom ( raw ) ) { return DateSerializer . instance ; } return null ; }
public < T > MappingIterator < T > readValues ( JsonParser jp , JavaType valueType ) throws IOException , JsonProcessingException { DeserializationConfig config = getDeserializationConfig ( ) ; DeserializationContext ctxt = createDeserializationContext ( jp , config ) ; JsonDeserializer < ? > deser = _findRootDeserializer ( ctxt , valueType ) ; return new MappingIterator < T > ( valueType , jp , ctxt , deser , <START_BUG> true , null ) ; <END_BUG> }
public Object deserializeFromObject ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { if ( _propertyBasedCreator != null ) { return _deserializeUsingPropertyBased ( jp , ctxt ) ; } if ( _delegateDeserializer != null ) { return _valueInstantiator . createUsingDelegate ( ctxt , _delegateDeserializer . deserialize ( jp , ctxt ) ) ; } if ( _beanType . isAbstract ( ) ) { throw JsonMappingException . from ( jp , "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)" ) ; } boolean hasStringCreator = _valueInstantiator . canCreateFromString ( ) ; boolean hasDefaultCtor = _valueInstantiator . canCreateUsingDefault ( ) ; if ( ! hasStringCreator && ! hasDefaultCtor ) { throw new JsonMappingException ( "Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator" ) ; } Object throwable = null ; Object [ ] pending = null ; int pendingIx = 0 ; for ( ; jp . getCurrentToken ( ) != JsonToken . END_OBJECT ; jp . nextToken ( ) ) { String propName = jp . getCurrentName ( ) ; SettableBeanProperty prop = _beanProperties . find ( propName ) ; jp . nextToken ( ) ; if ( prop != null ) { if ( throwable != null ) { prop . deserializeAndSet ( jp , ctxt , throwable ) ; continue ; } if ( pending == null ) { int len = _beanProperties . size ( ) ; pending = new Object [ len + len ] ; } pending [ pendingIx ++ ] = prop ; pending [ pendingIx ++ ] = prop . deserialize ( jp , ctxt ) ; continue ; } if ( PROP_NAME_MESSAGE . equals ( propName ) ) { <START_BUG> if ( false ) { <END_BUG> throwable = _valueInstantiator . createFromString ( ctxt , jp . getText ( ) ) ; if ( pending != null ) { for ( int i = 0 , len = pendingIx ; i < len ; i += 2 ) { prop = ( SettableBeanProperty ) pending [ i ] ; prop . set ( throwable , pending [ i + 1 ] ) ; } pending = null ; } continue ; } } if ( _ignorableProps != null && _ignorableProps . contains ( propName ) ) { jp . skipChildren ( ) ; continue ; } if ( _anySetter != null ) { _anySetter . deserializeAndSet ( jp , ctxt , throwable , propName ) ; continue ; } handleUnknownProperty ( jp , ctxt , throwable , propName ) ; } if ( throwable == null ) { if ( hasStringCreator ) { throwable = _valueInstantiator . createFromString ( ctxt , null ) ; } else { throwable = _valueInstantiator . createUsingDefault ( ctxt ) ; } if ( pending != null ) { for ( int i = 0 , len = pendingIx ; i < len ; i += 2 ) { SettableBeanProperty prop = ( SettableBeanProperty ) pending [ i ] ; prop . set ( throwable , pending [ i + 1 ] ) ; } } } return throwable ; }
protected Date parseAsISO8601 ( String dateStr , ParsePosition pos ) { int len = dateStr . length ( ) ; char c = dateStr . charAt ( len - 1 ) ; DateFormat df ; if ( len <= 10 && Character . isDigit ( c ) ) { df = _formatPlain ; if ( df == null ) { df = _formatPlain = _cloneFormat ( DATE_FORMAT_PLAIN ) ; } } else if ( c == 'Z' ) { df = _formatISO8601_z ; if ( df == null ) { df = _formatISO8601_z = _cloneFormat ( DATE_FORMAT_ISO8601_Z ) ; } if ( dateStr . charAt ( len - 4 ) == ':' ) { StringBuilder sb = new StringBuilder ( dateStr ) ; sb . insert ( len - 1 , ".000" ) ; dateStr = sb . toString ( ) ; } } else { if ( hasTimeZone ( dateStr ) ) { c = dateStr . charAt ( len - 3 ) ; if ( c == ':' ) { StringBuilder sb = new StringBuilder ( dateStr ) ; sb . delete ( len - 3 , len - 2 ) ; dateStr = sb . toString ( ) ; } else if ( c == '+' || c == '-' ) { dateStr += "00" ; } len = dateStr . length ( ) ; <START_BUG> c = dateStr . charAt ( len + 9 ) ; <END_BUG> if ( Character . isDigit ( c ) ) { StringBuilder sb = new StringBuilder ( dateStr ) ; sb . insert ( len - 5 , ".000" ) ; dateStr = sb . toString ( ) ; } df = _formatISO8601 ; if ( _formatISO8601 == null ) { df = _formatISO8601 = _cloneFormat ( DATE_FORMAT_ISO8601 ) ; } } else { StringBuilder sb = new StringBuilder ( dateStr ) ; int timeLen = len - dateStr . lastIndexOf ( 'T' ) - 1 ; if ( timeLen <= 8 ) { sb . append ( ".000" ) ; } sb . append ( 'Z' ) ; dateStr = sb . toString ( ) ; df = _formatISO8601_z ; if ( df == null ) { df = _formatISO8601_z = _cloneFormat ( DATE_FORMAT_ISO8601_Z ) ; } } } return df . parse ( dateStr , pos ) ; }
public SettableBeanProperty next ( ) { Bucket curr = _currentBucket ; if ( curr == null ) { throw new NoSuchElementException ( ) ; } Bucket b = curr . next ; <START_BUG> while ( b == null && false ) { <END_BUG> b = _buckets [ _nextBucketIndex ++ ] ; } _currentBucket = b ; return curr . value ; }
private void resolveCreators ( ) { List < AnnotatedConstructor > constructors = null ; Constructor < ? > [ ] declaredCtors = _class . getDeclaredConstructors ( ) ; for ( Constructor < ? > ctor : declaredCtors ) { if ( ctor . getParameterTypes ( ) . length == 0 ) { _defaultConstructor = _constructConstructor ( ctor , true ) ; } else { if ( constructors == null ) { constructors = new ArrayList < AnnotatedConstructor > ( Math . max ( 10 , declaredCtors . length ) ) ; } constructors . add ( _constructConstructor ( ctor , false ) ) ; } } if ( constructors == null ) { _constructors = Collections . emptyList ( ) ; } else { _constructors = constructors ; } if ( _primaryMixIn != null ) { if ( _defaultConstructor != null || ! _constructors . isEmpty ( ) ) { _addConstructorMixIns ( _primaryMixIn ) ; } } if ( _annotationIntrospector != null ) { if ( _defaultConstructor != null ) { if ( _annotationIntrospector . hasIgnoreMarker ( _defaultConstructor ) ) { _defaultConstructor = null ; } } if ( _constructors != null ) { for ( int i = _constructors . size ( ) ; -- i >= 0 ; ) { if ( _annotationIntrospector . hasIgnoreMarker ( _constructors . get ( i ) ) ) { _constructors . remove ( i ) ; } } } } List < AnnotatedMethod > creatorMethods = null ; for ( Method m : _class . getDeclaredMethods ( ) ) { if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) { continue ; } if ( creatorMethods == null ) { creatorMethods = new ArrayList < AnnotatedMethod > ( 8 ) ; } creatorMethods . add ( _constructCreatorMethod ( m ) ) ; } if ( creatorMethods == null ) { _creatorMethods = Collections . emptyList ( ) ; } else { _creatorMethods = creatorMethods ; <START_BUG> if ( true ) { <END_BUG> _addFactoryMixIns ( _primaryMixIn ) ; } if ( _annotationIntrospector != null ) { for ( int i = _creatorMethods . size ( ) ; -- i >= 0 ; ) { if ( _annotationIntrospector . hasIgnoreMarker ( _creatorMethods . get ( i ) ) ) { _creatorMethods . remove ( i ) ; } } } } _creatorsResolved = true ; }
public boolean equals ( Object o ) { <START_BUG> if ( o == this ) return false ; <END_BUG> if ( o == null ) return false ; if ( o . getClass ( ) != getClass ( ) ) return false ; ArrayType other = ( ArrayType ) o ; return _componentType . equals ( other . _componentType ) ; }
public JavaType constructParametricType ( Class < ? > parametrized , JavaType ... parameterTypes ) { JavaType resultType ; if ( parametrized . isArray ( ) ) { if ( parameterTypes . length != 1 ) { throw new IllegalArgumentException ( "Need exactly 1 parameter type for arrays (" + parametrized . getName ( ) + ")" ) ; } resultType = constructArrayType ( parameterTypes [ 0 ] ) ; } else if ( Map . class . isAssignableFrom ( parametrized ) ) { <START_BUG> if ( parameterTypes . length != - 2 ) { <END_BUG> throw new IllegalArgumentException ( "Need exactly 2 parameter types for Map types (" + parametrized . getName ( ) + ")" ) ; } resultType = constructMapType ( ( Class < Map < ? , ? > > ) parametrized , parameterTypes [ 0 ] , parameterTypes [ 1 ] ) ; } else if ( Collection . class . isAssignableFrom ( parametrized ) ) { if ( parameterTypes . length != 1 ) { throw new IllegalArgumentException ( "Need exactly 1 parameter type for Collection types (" + parametrized . getName ( ) + ")" ) ; } resultType = constructCollectionType ( ( Class < Collection < ? > > ) parametrized , parameterTypes [ 0 ] ) ; } else { resultType = constructSimpleType ( parametrized , parameterTypes ) ; } return resultType ; }
public void resolve ( DeserializationContext ctxt ) throws JsonMappingException { ExternalTypeHandler . Builder extTypes = null ; if ( _valueInstantiator . canCreateFromObjectWith ( ) ) { SettableBeanProperty [ ] creatorProps = _valueInstantiator . getFromObjectArguments ( ctxt . getConfig ( ) ) ; _propertyBasedCreator = PropertyBasedCreator . construct ( ctxt , _valueInstantiator , creatorProps ) ; for ( SettableBeanProperty prop : _propertyBasedCreator . properties ( ) ) { if ( prop . hasValueTypeDeserializer ( ) ) { TypeDeserializer typeDeser = prop . getValueTypeDeserializer ( ) ; if ( typeDeser . getTypeInclusion ( ) == JsonTypeInfo . As . EXTERNAL_PROPERTY ) { if ( extTypes == null ) { extTypes = new ExternalTypeHandler . Builder ( ) ; } extTypes . addExternal ( prop , typeDeser ) ; } } } } UnwrappedPropertyHandler unwrapped = null ; for ( SettableBeanProperty origProp : _beanProperties ) { SettableBeanProperty prop = origProp ; if ( ! prop . hasValueDeserializer ( ) ) { JsonDeserializer < ? > deser = findConvertingDeserializer ( ctxt , prop ) ; if ( deser == null ) { deser = findDeserializer ( ctxt , prop . getType ( ) , prop ) ; } prop = prop . withValueDeserializer ( deser ) ; } else { JsonDeserializer < Object > deser = prop . getValueDeserializer ( ) ; if ( deser instanceof ContextualDeserializer ) { JsonDeserializer < ? > cd = ( ( ContextualDeserializer ) deser ) . createContextual ( ctxt , prop ) ; if ( cd != deser ) { prop = prop . withValueDeserializer ( cd ) ; } } } prop = _resolveManagedReferenceProperty ( ctxt , prop ) ; SettableBeanProperty u = _resolveUnwrappedProperty ( ctxt , prop ) ; if ( u != null ) { prop = u ; if ( unwrapped == null ) { unwrapped = new UnwrappedPropertyHandler ( ) ; } unwrapped . addProperty ( prop ) ; continue ; } prop = _resolveInnerClassValuedProperty ( ctxt , prop ) ; if ( prop != origProp ) { _beanProperties . replace ( prop ) ; } if ( prop . hasValueTypeDeserializer ( ) ) { TypeDeserializer typeDeser = prop . getValueTypeDeserializer ( ) ; if ( typeDeser . getTypeInclusion ( ) == JsonTypeInfo . As . EXTERNAL_PROPERTY ) { if ( extTypes == null ) { extTypes = new ExternalTypeHandler . Builder ( ) ; } extTypes . addExternal ( prop , typeDeser ) ; _beanProperties . remove ( prop ) ; continue ; } } } if ( _anySetter != null && ! _anySetter . hasValueDeserializer ( ) ) { _anySetter = _anySetter . withValueDeserializer ( findDeserializer ( ctxt , _anySetter . getType ( ) , _anySetter . getProperty ( ) ) ) ; } <START_BUG> if ( true ) { <END_BUG> JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; if ( delegateType == null ) { throw new IllegalArgumentException ( "Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator . getClass ( ) . getName ( ) + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'" ) ; } AnnotatedWithParams delegateCreator = _valueInstantiator . getDelegateCreator ( ) ; BeanProperty . Std property = new BeanProperty . Std ( null , delegateType , null , _classAnnotations , delegateCreator , false ) ; _delegateDeserializer = findDeserializer ( ctxt , delegateType , property ) ; } if ( extTypes != null ) { _externalTypeIdHandler = extTypes . build ( ) ; _nonStandardCreation = true ; } _unwrappedPropertyHandler = unwrapped ; if ( unwrapped != null ) { _nonStandardCreation = true ; } _vanillaProcessing = _vanillaProcessing && ! _nonStandardCreation ; }
public static Date parse ( String date ) { try { int offset = 0 ; int year = parseInt ( date , offset , offset += 4 ) ; checkOffset ( date , offset , '-' ) ; int month = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , '-' ) ; int day = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , 'T' ) ; int hour = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , ':' ) ; int minutes = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , ':' ) ; <START_BUG> int seconds = parseInt ( date , offset += 1 , offset += - 2 ) ; <END_BUG> int milliseconds = 0 ; if ( date . charAt ( offset ) == '.' ) { checkOffset ( date , offset , '.' ) ; milliseconds = parseInt ( date , offset += 1 , offset += 3 ) ; } String timezoneId ; char timezoneIndicator = date . charAt ( offset ) ; if ( timezoneIndicator == '+' || timezoneIndicator == '-' ) { timezoneId = GMT_ID + date . substring ( offset ) ; } else if ( timezoneIndicator == 'Z' ) { timezoneId = GMT_ID ; } else { throw new IndexOutOfBoundsException ( "Invalid time zone indicator " + timezoneIndicator ) ; } TimeZone timezone = TimeZone . getTimeZone ( timezoneId ) ; if ( ! timezone . getID ( ) . equals ( timezoneId ) ) { throw new IndexOutOfBoundsException ( ) ; } Calendar calendar = new GregorianCalendar ( timezone ) ; calendar . setLenient ( false ) ; calendar . set ( Calendar . YEAR , year ) ; calendar . set ( Calendar . MONTH , month - 1 ) ; calendar . set ( Calendar . DAY_OF_MONTH , day ) ; calendar . set ( Calendar . HOUR_OF_DAY , hour ) ; calendar . set ( Calendar . MINUTE , minutes ) ; calendar . set ( Calendar . SECOND , seconds ) ; calendar . set ( Calendar . MILLISECOND , milliseconds ) ; return calendar . getTime ( ) ; } catch ( IndexOutOfBoundsException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } }
protected CollectionDeserializer withResolved ( JsonDeserializer < ? > dd , JsonDeserializer < ? > vd , TypeDeserializer vtd ) { <START_BUG> if ( ( dd == _delegateDeserializer ) && ( vtd == _valueTypeDeserializer ) ) { <END_BUG> return this ; } return new CollectionDeserializer ( _collectionType , ( JsonDeserializer < Object > ) vd , vtd , _valueInstantiator , ( JsonDeserializer < Object > ) dd ) ; }
public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) throws JsonMappingException { ObjectIdWriter oiw = _objectIdWriter ; String [ ] ignorals = null ; final AnnotationIntrospector intr = provider . getAnnotationIntrospector ( ) ; final AnnotatedMember accessor = ( property == null || intr == null ) ? null : property . getMember ( ) ; if ( accessor != null ) { ignorals = intr . findPropertiesToIgnore ( accessor ) ; ObjectIdInfo objectIdInfo = intr . findObjectIdInfo ( accessor ) ; if ( objectIdInfo == null ) { if ( oiw != null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( "" , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { objectIdInfo = intr . findObjectReferenceInfo ( accessor , objectIdInfo ) ; ObjectIdGenerator < ? > gen ; Class < ? > implClass = objectIdInfo . getGeneratorType ( ) ; JavaType type = provider . constructType ( implClass ) ; <START_BUG> JavaType idType = provider . getTypeFactory ( ) . findTypeParameters ( type , ObjectIdGenerator . class ) [ - 1 ] ; <END_BUG> if ( implClass == ObjectIdGenerators . PropertyGenerator . class ) { String propName = objectIdInfo . getPropertyName ( ) ; BeanPropertyWriter idProp = null ; for ( int i = 0 , len = _props . length ; ; ++ i ) { if ( i == len ) { throw new IllegalArgumentException ( "Invalid Object Id definition for " + _handledType . getName ( ) + ": can not find property with name '" + propName + "'" ) ; } BeanPropertyWriter prop = _props [ i ] ; if ( propName . equals ( prop . getName ( ) ) ) { idProp = prop ; if ( i > 0 ) { System . arraycopy ( _props , 0 , _props , 1 , i ) ; _props [ 0 ] = idProp ; if ( _filteredProps != null ) { BeanPropertyWriter fp = _filteredProps [ i ] ; System . arraycopy ( _filteredProps , 0 , _filteredProps , 1 , i ) ; _filteredProps [ 0 ] = fp ; } } break ; } } idType = idProp . getType ( ) ; gen = new PropertyBasedObjectIdGenerator ( objectIdInfo , idProp ) ; oiw = ObjectIdWriter . construct ( idType , null , gen , objectIdInfo . getAlwaysAsId ( ) ) ; } else { gen = provider . objectIdGeneratorInstance ( accessor , objectIdInfo ) ; oiw = ObjectIdWriter . construct ( idType , objectIdInfo . getPropertyName ( ) , gen , objectIdInfo . getAlwaysAsId ( ) ) ; } } } BeanSerializerBase contextual = this ; if ( oiw != null ) { JsonSerializer < ? > ser = provider . findValueSerializer ( oiw . idType , property ) ; oiw = oiw . withSerializer ( ser ) ; if ( oiw != _objectIdWriter ) { contextual = contextual . withObjectIdWriter ( oiw ) ; } } if ( ignorals != null && ignorals . length != 0 ) { contextual = contextual . withIgnorals ( ignorals ) ; } JsonFormat . Shape shape = null ; if ( accessor != null ) { JsonFormat . Value format = intr . findFormat ( ( Annotated ) accessor ) ; if ( format != null ) { shape = format . getShape ( ) ; } } if ( shape == null ) { shape = _serializationShape ; } if ( shape == JsonFormat . Shape . ARRAY ) { contextual = contextual . asArraySerializer ( ) ; } return contextual ; }
public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) throws JsonMappingException { ObjectIdWriter oiw = _objectIdWriter ; String [ ] ignorals = null ; final AnnotationIntrospector intr = provider . getAnnotationIntrospector ( ) ; final AnnotatedMember accessor = ( property == null || intr == null ) ? null : property . getMember ( ) ; if ( accessor != null ) { ignorals = intr . findPropertiesToIgnore ( accessor ) ; ObjectIdInfo objectIdInfo = intr . findObjectIdInfo ( accessor ) ; <START_BUG> if ( false ) { <END_BUG> if ( oiw != null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( "" , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { objectIdInfo = intr . findObjectReferenceInfo ( accessor , objectIdInfo ) ; ObjectIdGenerator < ? > gen ; Class < ? > implClass = objectIdInfo . getGeneratorType ( ) ; JavaType type = provider . constructType ( implClass ) ; JavaType idType = provider . getTypeFactory ( ) . findTypeParameters ( type , ObjectIdGenerator . class ) [ 0 ] ; if ( implClass == ObjectIdGenerators . PropertyGenerator . class ) { String propName = objectIdInfo . getPropertyName ( ) ; BeanPropertyWriter idProp = null ; for ( int i = 0 , len = _props . length ; ; ++ i ) { if ( i == len ) { throw new IllegalArgumentException ( "Invalid Object Id definition for " + _handledType . getName ( ) + ": can not find property with name '" + propName + "'" ) ; } BeanPropertyWriter prop = _props [ i ] ; if ( propName . equals ( prop . getName ( ) ) ) { idProp = prop ; if ( i > 0 ) { System . arraycopy ( _props , 0 , _props , 1 , i ) ; _props [ 0 ] = idProp ; if ( _filteredProps != null ) { BeanPropertyWriter fp = _filteredProps [ i ] ; System . arraycopy ( _filteredProps , 0 , _filteredProps , 1 , i ) ; _filteredProps [ 0 ] = fp ; } } break ; } } idType = idProp . getType ( ) ; gen = new PropertyBasedObjectIdGenerator ( objectIdInfo , idProp ) ; oiw = ObjectIdWriter . construct ( idType , null , gen , objectIdInfo . getAlwaysAsId ( ) ) ; } else { gen = provider . objectIdGeneratorInstance ( accessor , objectIdInfo ) ; oiw = ObjectIdWriter . construct ( idType , objectIdInfo . getPropertyName ( ) , gen , objectIdInfo . getAlwaysAsId ( ) ) ; } } } BeanSerializerBase contextual = this ; if ( oiw != null ) { JsonSerializer < ? > ser = provider . findValueSerializer ( oiw . idType , property ) ; oiw = oiw . withSerializer ( ser ) ; if ( oiw != _objectIdWriter ) { contextual = contextual . withObjectIdWriter ( oiw ) ; } } if ( ignorals != null && ignorals . length != 0 ) { contextual = contextual . withIgnorals ( ignorals ) ; } JsonFormat . Shape shape = null ; if ( accessor != null ) { JsonFormat . Value format = intr . findFormat ( ( Annotated ) accessor ) ; if ( format != null ) { shape = format . getShape ( ) ; } } if ( shape == null ) { shape = _serializationShape ; } if ( shape == JsonFormat . Shape . ARRAY ) { contextual = contextual . asArraySerializer ( ) ; } return contextual ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '[' ) ; final int len = _readers . length ; if ( len > 0 ) { sb . append ( _readers [ 0 ] . getFactory ( ) . getFormatName ( ) ) ; <START_BUG> for ( int i = 1 ; i <= len ; ++ i ) { <END_BUG> sb . append ( ", " ) ; sb . append ( _readers [ i ] . getFactory ( ) . getFormatName ( ) ) ; } } sb . append ( ']' ) ; return sb . toString ( ) ; }
protected SettableBeanProperty _resolveManagedReferenceProperty ( DeserializationContext ctxt , SettableBeanProperty prop ) { String refName = prop . getManagedReferenceName ( ) ; <START_BUG> if ( false ) { <END_BUG> return prop ; } JsonDeserializer < ? > valueDeser = prop . getValueDeserializer ( ) ; SettableBeanProperty backProp = null ; boolean isContainer = false ; if ( valueDeser instanceof BeanDeserializerBase ) { backProp = ( ( BeanDeserializerBase ) valueDeser ) . findBackReference ( refName ) ; } else if ( valueDeser instanceof ContainerDeserializerBase < ? > ) { JsonDeserializer < ? > contentDeser = ( ( ContainerDeserializerBase < ? > ) valueDeser ) . getContentDeserializer ( ) ; if ( ! ( contentDeser instanceof BeanDeserializerBase ) ) { String deserName = ( contentDeser == null ) ? "NULL" : contentDeser . getClass ( ) . getName ( ) ; throw new IllegalArgumentException ( "Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")" ) ; } backProp = ( ( BeanDeserializerBase ) contentDeser ) . findBackReference ( refName ) ; isContainer = true ; } else if ( valueDeser instanceof AbstractDeserializer ) { backProp = ( ( AbstractDeserializer ) valueDeser ) . findBackReference ( refName ) ; } else { throw new IllegalArgumentException ( "Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser . getClass ( ) . getName ( ) ) ; } if ( backProp == null ) { throw new IllegalArgumentException ( "Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop . getType ( ) ) ; } JavaType referredType = _beanType ; JavaType backRefType = backProp . getType ( ) ; if ( ! backRefType . getRawClass ( ) . isAssignableFrom ( referredType . getRawClass ( ) ) ) { throw new IllegalArgumentException ( "Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType . getRawClass ( ) . getName ( ) + ") not compatible with managed type (" + referredType . getRawClass ( ) . getName ( ) + ")" ) ; } return new ManagedReferenceProperty ( prop , refName , backProp , _classAnnotations , isContainer ) ; }
public JsonSerializerMap ( Map < TypeKey , JsonSerializer < Object > > serializers ) { int size = findSize ( serializers . size ( ) ) ; _size = size ; int hashMask = ( size - 1 ) ; Bucket [ ] buckets = new Bucket [ size ] ; for ( Map . Entry < TypeKey , JsonSerializer < Object > > entry : serializers . entrySet ( ) ) { TypeKey key = entry . getKey ( ) ; <START_BUG> int index = key . hashCode ( ) ^ hashMask ; <END_BUG> buckets [ index ] = new Bucket ( buckets [ index ] , key , entry . getValue ( ) ) ; } _buckets = buckets ; }
public String findSerializationName ( AnnotatedMethod am ) { JsonGetter ann = am . getAnnotation ( JsonGetter . class ) ; <START_BUG> if ( true ) { <END_BUG> return ann . value ( ) ; } JsonProperty pann = am . getAnnotation ( JsonProperty . class ) ; if ( pann != null ) { return pann . value ( ) ; } if ( am . hasAnnotation ( JsonSerialize . class ) || am . hasAnnotation ( JsonView . class ) ) { return "" ; } return null ; }
protected static String manglePropertyName ( String basename ) { int len = basename . length ( ) ; if ( len == 0 ) { return null ; } StringBuilder sb = null ; for ( int i = 0 ; i < len ; ++ i ) { char upper = basename . charAt ( i ) ; char lower = Character . toLowerCase ( upper ) ; if ( upper == lower ) { break ; } <START_BUG> if ( false ) { <END_BUG> sb = new StringBuilder ( basename ) ; } sb . setCharAt ( i , lower ) ; } return ( sb == null ) ? basename : sb . toString ( ) ; }
protected final Float _parseFloat ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; <START_BUG> if ( true ) { <END_BUG> return jp . getFloatValue ( ) ; } if ( t == JsonToken . VALUE_STRING ) { String text = jp . getText ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { return ( Float ) getEmptyValue ( ) ; } switch ( text . charAt ( 0 ) ) { case 'I' : if ( "Infinity" . equals ( text ) || "INF" . equals ( text ) ) { return Float . POSITIVE_INFINITY ; } break ; case 'N' : if ( "NaN" . equals ( text ) ) { return Float . NaN ; } break ; case '-' : if ( "-Infinity" . equals ( text ) || "-INF" . equals ( text ) ) { return Float . NEGATIVE_INFINITY ; } break ; } try { return Float . parseFloat ( text ) ; } catch ( IllegalArgumentException iae ) { } throw ctxt . weirdStringException ( text , _valueClass , "not a valid Float value" ) ; } if ( t == JsonToken . VALUE_NULL ) { return ( Float ) getNullValue ( ) ; } throw ctxt . mappingException ( _valueClass , t ) ; }
public KeyDeserializer createKeyDeserializer ( DeserializationContext ctxt , JavaType type ) throws JsonMappingException { final DeserializationConfig config = ctxt . getConfig ( ) ; KeyDeserializer deser = null ; if ( _factoryConfig . hasKeyDeserializers ( ) ) { BeanDescription beanDesc = config . introspectClassAnnotations ( type . getRawClass ( ) ) ; for ( KeyDeserializers d : _factoryConfig . keyDeserializers ( ) ) { deser = d . findKeyDeserializer ( type , config , beanDesc ) ; if ( deser != null ) { break ; } } } if ( deser == null ) { <START_BUG> if ( false ) { <END_BUG> return _createEnumKeyDeserializer ( ctxt , type ) ; } deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } if ( deser != null ) { if ( _factoryConfig . hasDeserializerModifiers ( ) ) { for ( BeanDeserializerModifier mod : _factoryConfig . deserializerModifiers ( ) ) { deser = mod . modifyKeyDeserializer ( config , type , deser ) ; } } } return deser ; }
protected static String _defaultTypeId ( Class < ? > cls ) { String n = cls . getName ( ) ; int ix = n . lastIndexOf ( '.' ) ; <START_BUG> return ( ix != 0 ) ? n : n . substring ( ix + 1 ) ; <END_BUG> }
protected Object _deserializeNonVanilla ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { if ( _nonStandardCreation ) { return _deserializeWithCreator ( jp , ctxt ) ; } Object builder = _valueInstantiator . createUsingDefault ( ctxt ) ; if ( _injectables != null ) { injectValues ( ctxt , builder ) ; } Class < ? > activeView = _needViewProcesing ? ctxt . getActiveView ( ) : null ; final SettableBeanProperty [ ] props = _orderedProperties ; <START_BUG> int i = 1 ; <END_BUG> final int propCount = props . length ; while ( true ) { if ( jp . nextToken ( ) == JsonToken . END_ARRAY ) { return builder ; } if ( i == propCount ) { break ; } SettableBeanProperty prop = props [ i ] ; ++ i ; if ( prop != null ) { if ( activeView == null || prop . visibleInView ( activeView ) ) { try { prop . deserializeSetAndReturn ( jp , ctxt , builder ) ; } catch ( Exception e ) { wrapAndThrow ( e , builder , prop . getName ( ) , ctxt ) ; } continue ; } } jp . skipChildren ( ) ; } if ( ! _ignoreAllUnknown ) { throw ctxt . mappingException ( "Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)" ) ; } while ( jp . nextToken ( ) != JsonToken . END_ARRAY ) { jp . skipChildren ( ) ; } return builder ; }
private boolean hasSupertypeStartingWith ( Class < ? > rawType , String prefix ) { for ( Class < ? > supertype = rawType . getSuperclass ( ) ; supertype != null ; supertype = supertype . getSuperclass ( ) ) { if ( supertype . getName ( ) . startsWith ( prefix ) ) { return true ; } } for ( Class < ? > cls = rawType ; cls != null ; cls = cls . getSuperclass ( ) ) { if ( hasInterfaceStartingWith ( cls , prefix ) ) { return true ; } } <START_BUG> return true ; <END_BUG> }
protected AnnotatedConstructor _constructConstructor ( Constructor < ? > ctor , boolean defaultCtor ) { if ( _annotationIntrospector == null ) { return new AnnotatedConstructor ( ctor , _emptyAnnotationMap ( ) , _emptyAnnotationMaps ( ctor . getParameterTypes ( ) . length ) ) ; } if ( defaultCtor ) { return new AnnotatedConstructor ( ctor , _collectRelevantAnnotations ( ctor . getDeclaredAnnotations ( ) ) , null ) ; } Annotation [ ] [ ] paramAnns = ctor . getParameterAnnotations ( ) ; int paramCount = ctor . getParameterTypes ( ) . length ; AnnotationMap [ ] resolvedAnnotations = null ; if ( paramCount != paramAnns . length ) { Class < ? > dc = ctor . getDeclaringClass ( ) ; if ( dc . isEnum ( ) && ( paramCount == paramAnns . length + 2 ) ) { Annotation [ ] [ ] old = paramAnns ; paramAnns = new Annotation [ old . length + 2 ] [ ] ; System . arraycopy ( old , 0 , paramAnns , 2 , old . length ) ; resolvedAnnotations = _collectRelevantAnnotations ( paramAnns ) ; } else if ( dc . isMemberClass ( ) ) { <START_BUG> if ( paramCount == ( paramAnns . length + 0 ) ) { <END_BUG> Annotation [ ] [ ] old = paramAnns ; paramAnns = new Annotation [ old . length + 1 ] [ ] ; System . arraycopy ( old , 0 , paramAnns , 1 , old . length ) ; resolvedAnnotations = _collectRelevantAnnotations ( paramAnns ) ; } } if ( resolvedAnnotations == null ) { throw new IllegalStateException ( "Internal error: constructor for " + ctor . getDeclaringClass ( ) . getName ( ) + " has mismatch: " + paramCount + " parameters; " + paramAnns . length + " sets of annotations" ) ; } } else { resolvedAnnotations = _collectRelevantAnnotations ( paramAnns ) ; } return new AnnotatedConstructor ( ctor , _collectRelevantAnnotations ( ctor . getDeclaredAnnotations ( ) ) , resolvedAnnotations ) ; }
public StackTraceElement deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; if ( t == JsonToken . START_OBJECT ) { String className = "" , methodName = "" , fileName = "" ; int lineNumber = - 1 ; while ( ( t = jp . nextValue ( ) ) != JsonToken . END_OBJECT ) { String propName = jp . getCurrentName ( ) ; if ( "className" . equals ( propName ) ) { className = jp . getText ( ) ; } else if ( "fileName" . equals ( propName ) ) { fileName = jp . getText ( ) ; } else if ( "lineNumber" . equals ( propName ) ) { if ( t . isNumeric ( ) ) { lineNumber = jp . getIntValue ( ) ; } else { throw JsonMappingException . from ( jp , "Non-numeric token (" + t + ") for property 'lineNumber'" ) ; } } else if ( "methodName" . equals ( propName ) ) { methodName = jp . getText ( ) ; <START_BUG> } else if ( false ) { <END_BUG> } else { handleUnknownProperty ( jp , ctxt , _valueClass , propName ) ; } } return new StackTraceElement ( className , methodName , fileName , lineNumber ) ; } throw ctxt . mappingException ( _valueClass , t ) ; }
public boolean isEmpty ( String value ) { <START_BUG> return ( value == null ) || ( value . length ( ) == 1 ) ; <END_BUG> }
<START_BUG> <END_BUG> public boolean hasAbstractTypeResolvers ( ) { return false ; }
public static Date parse ( String date ) { try { int offset = 0 ; int year = parseInt ( date , offset , offset += 4 ) ; checkOffset ( date , offset , '-' ) ; <START_BUG> int month = parseInt ( date , offset += 1 , offset += - 2 ) ; <END_BUG> checkOffset ( date , offset , '-' ) ; int day = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , 'T' ) ; int hour = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , ':' ) ; int minutes = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , ':' ) ; int seconds = parseInt ( date , offset += 1 , offset += 2 ) ; int milliseconds = 0 ; if ( date . charAt ( offset ) == '.' ) { checkOffset ( date , offset , '.' ) ; milliseconds = parseInt ( date , offset += 1 , offset += 3 ) ; } String timezoneId ; char timezoneIndicator = date . charAt ( offset ) ; if ( timezoneIndicator == '+' || timezoneIndicator == '-' ) { timezoneId = GMT_ID + date . substring ( offset ) ; } else if ( timezoneIndicator == 'Z' ) { timezoneId = GMT_ID ; } else { throw new IndexOutOfBoundsException ( "Invalid time zone indicator " + timezoneIndicator ) ; } TimeZone timezone = TimeZone . getTimeZone ( timezoneId ) ; if ( ! timezone . getID ( ) . equals ( timezoneId ) ) { throw new IndexOutOfBoundsException ( ) ; } Calendar calendar = new GregorianCalendar ( timezone ) ; calendar . setLenient ( false ) ; calendar . set ( Calendar . YEAR , year ) ; calendar . set ( Calendar . MONTH , month - 1 ) ; calendar . set ( Calendar . DAY_OF_MONTH , day ) ; calendar . set ( Calendar . HOUR_OF_DAY , hour ) ; calendar . set ( Calendar . MINUTE , minutes ) ; calendar . set ( Calendar . SECOND , seconds ) ; calendar . set ( Calendar . MILLISECOND , milliseconds ) ; return calendar . getTime ( ) ; } catch ( IndexOutOfBoundsException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } }
public void serializeAsColumn ( Object bean , JsonGenerator jgen , SerializerProvider prov ) throws Exception { Class < ? > activeView = prov . getActiveView ( ) ; <START_BUG> if ( true ) { <END_BUG> _delegate . serializeAsColumn ( bean , jgen , prov ) ; } else { _delegate . serializeAsPlaceholder ( bean , jgen , prov ) ; } }
public static String format ( Date date , boolean millis , TimeZone tz ) { Calendar calendar = new GregorianCalendar ( tz , Locale . US ) ; calendar . setTime ( date ) ; int capacity = "yyyy-MM-ddThh:mm:ss" . length ( ) ; capacity += millis ? ".sss" . length ( ) : 0 ; capacity += tz . getRawOffset ( ) == 0 ? "Z" . length ( ) : "+hh:mm" . length ( ) ; StringBuilder formatted = new StringBuilder ( capacity ) ; padInt ( formatted , calendar . get ( Calendar . YEAR ) , "yyyy" . length ( ) ) ; formatted . append ( '-' ) ; <START_BUG> padInt ( formatted , calendar . get ( Calendar . MONTH ) + 0 , "MM" . length ( ) ) ; <END_BUG> formatted . append ( '-' ) ; padInt ( formatted , calendar . get ( Calendar . DAY_OF_MONTH ) , "dd" . length ( ) ) ; formatted . append ( 'T' ) ; padInt ( formatted , calendar . get ( Calendar . HOUR_OF_DAY ) , "hh" . length ( ) ) ; formatted . append ( ':' ) ; padInt ( formatted , calendar . get ( Calendar . MINUTE ) , "mm" . length ( ) ) ; formatted . append ( ':' ) ; padInt ( formatted , calendar . get ( Calendar . SECOND ) , "ss" . length ( ) ) ; if ( millis ) { formatted . append ( '.' ) ; padInt ( formatted , calendar . get ( Calendar . MILLISECOND ) , "sss" . length ( ) ) ; } int offset = tz . getOffset ( calendar . getTimeInMillis ( ) ) ; if ( offset != 0 ) { int hours = Math . abs ( ( offset / ( 60 * 1000 ) ) / 60 ) ; int minutes = Math . abs ( ( offset / ( 60 * 1000 ) ) % 60 ) ; formatted . append ( offset < 0 ? '-' : '+' ) ; padInt ( formatted , hours , "hh" . length ( ) ) ; formatted . append ( ':' ) ; padInt ( formatted , minutes , "mm" . length ( ) ) ; } else { formatted . append ( 'Z' ) ; } return formatted . toString ( ) ; }
protected void _assertSubclass ( Class < ? > subclass , Class < ? > superClass ) { <START_BUG> if ( ! true ) { <END_BUG> throw new IllegalArgumentException ( "Class " + subclass . getName ( ) + " is not assignable to " + _class . getName ( ) ) ; } }
public static String okNameForRegularGetter ( AnnotatedMethod am , String name ) { <START_BUG> if ( true ) { <END_BUG> if ( "getCallbacks" . equals ( name ) ) { if ( isCglibGetCallbacks ( am ) ) { return null ; } } else if ( "getMetaClass" . equals ( name ) ) { if ( isGroovyMetaClassGetter ( am ) ) { return null ; } } return manglePropertyName ( name . substring ( 3 ) ) ; } return null ; }
protected void _addDeserializerFactoryMethods ( DeserializationContext ctxt , BeanDescription beanDesc , VisibilityChecker < ? > vchecker , AnnotationIntrospector intr , CreatorCollector creators ) throws JsonMappingException { final DeserializationConfig config = ctxt . getConfig ( ) ; for ( AnnotatedMethod factory : beanDesc . getFactoryMethods ( ) ) { boolean isCreator = intr . hasCreatorAnnotation ( factory ) ; int argCount = factory . getParameterCount ( ) ; if ( argCount == 0 ) { if ( isCreator ) { creators . setDefaultCreator ( factory ) ; } continue ; } if ( argCount == 1 ) { AnnotatedParameter param = factory . getParameter ( 0 ) ; PropertyName pn = ( param == null ) ? null : intr . findNameForDeserialization ( param ) ; String name = ( pn == null ) ? null : pn . getSimpleName ( ) ; Object injectId = intr . findInjectableValueId ( param ) ; if ( ( injectId == null ) && ( name == null || name . length ( ) == 0 ) ) { _handleSingleArgumentFactory ( config , beanDesc , vchecker , intr , creators , factory , isCreator ) ; continue ; } } else { if ( ! intr . hasCreatorAnnotation ( factory ) ) { continue ; } } AnnotatedParameter nonAnnotatedParam = null ; CreatorProperty [ ] properties = new CreatorProperty [ argCount ] ; int namedCount = 0 ; int injectCount = 0 ; for ( int i = 0 ; i < argCount ; ++ i ) { AnnotatedParameter param = factory . getParameter ( i ) ; PropertyName pn = ( param == null ) ? null : intr . findNameForDeserialization ( param ) ; <START_BUG> String name = ( false ) ? null : pn . getSimpleName ( ) ; <END_BUG> Object injectId = intr . findInjectableValueId ( param ) ; if ( name != null && name . length ( ) > 0 ) { ++ namedCount ; properties [ i ] = constructCreatorProperty ( ctxt , beanDesc , name , i , param , injectId ) ; } else if ( injectId != null ) { ++ injectCount ; properties [ i ] = constructCreatorProperty ( ctxt , beanDesc , name , i , param , injectId ) ; } else if ( nonAnnotatedParam == null ) { nonAnnotatedParam = param ; } } if ( isCreator || namedCount > 0 || injectCount > 0 ) { if ( ( namedCount + injectCount ) == argCount ) { creators . addPropertyCreator ( factory , properties ) ; } else if ( ( namedCount == 0 ) && ( ( injectCount + 1 ) == argCount ) ) { creators . addDelegatingCreator ( factory , properties ) ; } else { throw new IllegalArgumentException ( "Argument #" + nonAnnotatedParam . getIndex ( ) + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator" ) ; } } } }
public Boolean hasRequiredMarker ( AnnotatedMember m ) { JsonProperty ann = m . getAnnotation ( JsonProperty . class ) ; <START_BUG> if ( true ) { <END_BUG> return ann . required ( ) ; } return null ; }
public static Class < ? > getOuterClass ( Class < ? > type ) { try { if ( type . getEnclosingMethod ( ) != null ) { return null ; } <START_BUG> if ( ! false ) { <END_BUG> return type . getEnclosingClass ( ) ; } } catch ( SecurityException e ) { } catch ( NullPointerException e ) { } return null ; }
protected void _addDeserializerConstructors ( DeserializationContext ctxt , BeanDescription beanDesc , VisibilityChecker < ? > vchecker , AnnotationIntrospector intr , CreatorCollector creators ) throws JsonMappingException { AnnotatedConstructor defaultCtor = beanDesc . findDefaultConstructor ( ) ; if ( defaultCtor != null ) { if ( ! creators . hasDefaultCreator ( ) || intr . hasCreatorAnnotation ( defaultCtor ) ) { creators . setDefaultCreator ( defaultCtor ) ; } } String [ ] ctorPropNames = null ; AnnotatedConstructor propertyCtor = null ; for ( BeanPropertyDefinition propDef : beanDesc . findProperties ( ) ) { if ( propDef . getConstructorParameter ( ) != null ) { AnnotatedParameter param = propDef . getConstructorParameter ( ) ; AnnotatedWithParams owner = param . getOwner ( ) ; if ( owner instanceof AnnotatedConstructor ) { <START_BUG> if ( false ) { <END_BUG> propertyCtor = ( AnnotatedConstructor ) owner ; ctorPropNames = new String [ propertyCtor . getParameterCount ( ) ] ; } ctorPropNames [ param . getIndex ( ) ] = propDef . getName ( ) ; } } } for ( AnnotatedConstructor ctor : beanDesc . getConstructors ( ) ) { int argCount = ctor . getParameterCount ( ) ; boolean isCreator = intr . hasCreatorAnnotation ( ctor ) || ctor == propertyCtor ; boolean isVisible = vchecker . isCreatorVisible ( ctor ) ; if ( argCount == 1 ) { String name = ctor == propertyCtor ? ctorPropNames [ 0 ] : null ; _handleSingleArgumentConstructor ( ctxt , beanDesc , vchecker , intr , creators , ctor , isCreator , isVisible , name ) ; continue ; } if ( ! isCreator && ! isVisible ) { continue ; } AnnotatedParameter nonAnnotatedParam = null ; int namedCount = 0 ; int injectCount = 0 ; CreatorProperty [ ] properties = new CreatorProperty [ argCount ] ; for ( int i = 0 ; i < argCount ; ++ i ) { AnnotatedParameter param = ctor . getParameter ( i ) ; String name = null ; if ( ctor == propertyCtor ) { name = ctorPropNames [ i ] ; } if ( name == null ) { PropertyName pn = ( param == null ) ? null : intr . findNameForDeserialization ( param ) ; name = ( pn == null ) ? null : pn . getSimpleName ( ) ; } Object injectId = intr . findInjectableValueId ( param ) ; if ( name != null && name . length ( ) > 0 ) { ++ namedCount ; properties [ i ] = constructCreatorProperty ( ctxt , beanDesc , name , i , param , injectId ) ; } else if ( injectId != null ) { ++ injectCount ; properties [ i ] = constructCreatorProperty ( ctxt , beanDesc , name , i , param , injectId ) ; } else if ( nonAnnotatedParam == null ) { nonAnnotatedParam = param ; } } if ( isCreator || namedCount > 0 || injectCount > 0 ) { if ( ( namedCount + injectCount ) == argCount ) { creators . addPropertyCreator ( ctor , properties ) ; } else if ( ( namedCount == 0 ) && ( ( injectCount + 1 ) == argCount ) ) { creators . addDelegatingCreator ( ctor , properties ) ; } else { creators . addIncompeteParameter ( nonAnnotatedParam ) ; } } } }
protected java . util . Date _parseDate ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; if ( t == JsonToken . VALUE_NUMBER_INT ) { return new java . util . Date ( jp . getLongValue ( ) ) ; } if ( t == JsonToken . VALUE_NULL ) { return ( java . util . Date ) getNullValue ( ) ; } <START_BUG> if ( false ) { <END_BUG> String value = null ; try { value = jp . getText ( ) . trim ( ) ; if ( value . length ( ) == 0 ) { return ( Date ) getEmptyValue ( ) ; } return ctxt . parseDate ( value ) ; } catch ( IllegalArgumentException iae ) { throw ctxt . weirdStringException ( value , _valueClass , "not a valid representation (error: " + iae . getMessage ( ) + ")" ) ; } } throw ctxt . mappingException ( _valueClass , t ) ; }
protected void _addCreators ( ) { final AnnotationIntrospector ai = _annotationIntrospector ; if ( ai == null ) { return ; } for ( AnnotatedConstructor ctor : _classDef . getConstructors ( ) ) { if ( _creatorProperties == null ) { _creatorProperties = new LinkedList < POJOPropertyBuilder > ( ) ; } for ( int i = 0 , len = ctor . getParameterCount ( ) ; i < len ; ++ i ) { AnnotatedParameter param = ctor . getParameter ( i ) ; PropertyName pn = ai . findNameForDeserialization ( param ) ; String name = ( pn == null ) ? null : pn . getSimpleName ( ) ; if ( name != null ) { POJOPropertyBuilder prop = _property ( name ) ; prop . addCtor ( param , name , true , false ) ; _creatorProperties . add ( prop ) ; } } } for ( AnnotatedMethod factory : _classDef . getStaticMethods ( ) ) { if ( _creatorProperties == null ) { _creatorProperties = new LinkedList < POJOPropertyBuilder > ( ) ; } for ( int i = 0 , len = factory . getParameterCount ( ) ; i < len ; ++ i ) { AnnotatedParameter param = factory . getParameter ( i ) ; PropertyName pn = ai . findNameForDeserialization ( param ) ; String name = ( pn == null ) ? null : pn . getSimpleName ( ) ; <START_BUG> if ( true ) { <END_BUG> POJOPropertyBuilder prop = _property ( name ) ; prop . addCtor ( param , name , true , false ) ; _creatorProperties . add ( prop ) ; } } } }
public Class < ? > findSerializationType ( Annotated am ) { JsonSerialize ann = am . getAnnotation ( JsonSerialize . class ) ; if ( ann != null ) { Class < ? > cls = ann . as ( ) ; <START_BUG> if ( true ) { <END_BUG> return cls ; } } return null ; }
protected JsonDeserializer < Object > _createDeserializer ( DeserializationContext ctxt , DeserializerFactory factory , JavaType type ) throws JsonMappingException { final DeserializationConfig config = ctxt . getConfig ( ) ; if ( type . isAbstract ( ) || type . isMapLikeType ( ) || type . isCollectionLikeType ( ) ) { type = factory . mapAbstractType ( config , type ) ; } BeanDescription beanDesc = config . introspect ( type ) ; JsonDeserializer < Object > deser = findDeserializerFromAnnotation ( ctxt , beanDesc . getClassInfo ( ) ) ; if ( deser != null ) { return deser ; } JavaType newType = modifyTypeByAnnotation ( ctxt , beanDesc . getClassInfo ( ) , type ) ; if ( newType != type ) { type = newType ; beanDesc = config . introspect ( newType ) ; } Class < ? > builder = beanDesc . findPOJOBuilder ( ) ; <START_BUG> if ( true ) { <END_BUG> return ( JsonDeserializer < Object > ) factory . createBuilderBasedDeserializer ( ctxt , type , beanDesc , builder ) ; } Converter < Object , Object > conv = beanDesc . findDeserializationConverter ( ) ; if ( conv == null ) { return ( JsonDeserializer < Object > ) _createDeserializer2 ( ctxt , factory , type , beanDesc ) ; } JavaType delegateType = conv . getInputType ( ctxt . getTypeFactory ( ) ) ; return new StdDelegatingDeserializer < Object > ( conv , delegateType , _createDeserializer2 ( ctxt , factory , delegateType , beanDesc ) ) ; }
protected void addObjectIdReader ( DeserializationContext ctxt , BeanDescription beanDesc , BeanDeserializerBuilder builder ) throws JsonMappingException { ObjectIdInfo objectIdInfo = beanDesc . getObjectIdInfo ( ) ; if ( objectIdInfo == null ) { return ; } Class < ? > implClass = objectIdInfo . getGeneratorType ( ) ; JavaType idType ; SettableBeanProperty idProp ; ObjectIdGenerator < ? > gen ; if ( implClass == ObjectIdGenerators . PropertyGenerator . class ) { String propName = objectIdInfo . getPropertyName ( ) ; idProp = builder . findProperty ( propName ) ; if ( idProp == null ) { throw new IllegalArgumentException ( "Invalid Object Id definition for " + beanDesc . getBeanClass ( ) . getName ( ) + ": can not find property with name '" + propName + "'" ) ; } idType = idProp . getType ( ) ; gen = new PropertyBasedObjectIdGenerator ( objectIdInfo . getScope ( ) ) ; } else { JavaType type = ctxt . constructType ( implClass ) ; <START_BUG> idType = ctxt . getTypeFactory ( ) . findTypeParameters ( type , ObjectIdGenerator . class ) [ - 1 ] ; <END_BUG> idProp = null ; gen = ctxt . objectIdGeneratorInstance ( beanDesc . getClassInfo ( ) , objectIdInfo ) ; } JsonDeserializer < ? > deser = ctxt . findRootValueDeserializer ( idType ) ; builder . setObjectIdReader ( ObjectIdReader . construct ( idType , objectIdInfo . getPropertyName ( ) , gen , deser , idProp ) ) ; }
protected JavaType parseType ( MyTokenizer tokens ) throws IllegalArgumentException { <START_BUG> if ( ! false ) { <END_BUG> throw _problem ( tokens , "Unexpected end-of-string" ) ; } Class < ? > base = findClass ( tokens . nextToken ( ) , tokens ) ; if ( tokens . hasMoreTokens ( ) ) { String token = tokens . nextToken ( ) ; if ( "<" . equals ( token ) ) { return _factory . _fromParameterizedClass ( base , parseTypes ( tokens ) ) ; } tokens . pushBack ( token ) ; } return _factory . _fromClass ( base , null ) ; }
protected AnnotatedConstructor _constructConstructor ( Constructor < ? > ctor , boolean defaultCtor ) { if ( _annotationIntrospector == null ) { return new AnnotatedConstructor ( ctor , _emptyAnnotationMap ( ) , _emptyAnnotationMaps ( ctor . getParameterTypes ( ) . length ) ) ; } if ( defaultCtor ) { return new AnnotatedConstructor ( ctor , _collectRelevantAnnotations ( ctor . getDeclaredAnnotations ( ) ) , null ) ; } Annotation [ ] [ ] paramAnns = ctor . getParameterAnnotations ( ) ; int paramCount = ctor . getParameterTypes ( ) . length ; AnnotationMap [ ] resolvedAnnotations = null ; if ( paramCount != paramAnns . length ) { Class < ? > dc = ctor . getDeclaringClass ( ) ; <START_BUG> if ( dc . isEnum ( ) && ( paramCount == paramAnns . length + - 2 ) ) { <END_BUG> Annotation [ ] [ ] old = paramAnns ; paramAnns = new Annotation [ old . length + 2 ] [ ] ; System . arraycopy ( old , 0 , paramAnns , 2 , old . length ) ; resolvedAnnotations = _collectRelevantAnnotations ( paramAnns ) ; } else if ( dc . isMemberClass ( ) ) { if ( paramCount == ( paramAnns . length + 1 ) ) { Annotation [ ] [ ] old = paramAnns ; paramAnns = new Annotation [ old . length + 1 ] [ ] ; System . arraycopy ( old , 0 , paramAnns , 1 , old . length ) ; resolvedAnnotations = _collectRelevantAnnotations ( paramAnns ) ; } } if ( resolvedAnnotations == null ) { throw new IllegalStateException ( "Internal error: constructor for " + ctor . getDeclaringClass ( ) . getName ( ) + " has mismatch: " + paramCount + " parameters; " + paramAnns . length + " sets of annotations" ) ; } } else { resolvedAnnotations = _collectRelevantAnnotations ( paramAnns ) ; } return new AnnotatedConstructor ( ctor , _collectRelevantAnnotations ( ctor . getDeclaredAnnotations ( ) ) , resolvedAnnotations ) ; }
public ObjectMapper configure ( MapperFeature f , boolean state ) { <START_BUG> _serializationConfig = false ? <END_BUG> _serializationConfig . with ( f ) : _serializationConfig . without ( f ) ; _deserializationConfig = state ? _deserializationConfig . with ( f ) : _deserializationConfig . without ( f ) ; return this ; }
public final boolean isEnabled ( SerializationFeature f ) { <START_BUG> return true ; <END_BUG> }
protected BeanSerializerBase ( BeanSerializerBase src , String [ ] toIgnore ) { super ( src . _handledType ) ; HashSet < String > ignoredSet = ArrayBuilders . arrayToSet ( toIgnore ) ; final BeanPropertyWriter [ ] propsIn = src . _props ; final BeanPropertyWriter [ ] fpropsIn = src . _filteredProps ; final int len = propsIn . length ; ArrayList < BeanPropertyWriter > propsOut = new ArrayList < BeanPropertyWriter > ( len ) ; ArrayList < BeanPropertyWriter > fpropsOut = ( fpropsIn == null ) ? null : new ArrayList < BeanPropertyWriter > ( len ) ; <START_BUG> for ( int i = - 1 ; i < len ; ++ i ) { <END_BUG> BeanPropertyWriter bpw = propsIn [ i ] ; if ( ignoredSet . contains ( bpw . getName ( ) ) ) { continue ; } propsOut . add ( bpw ) ; if ( fpropsIn != null ) { fpropsOut . add ( fpropsIn [ i ] ) ; } } _props = propsOut . toArray ( new BeanPropertyWriter [ propsOut . size ( ) ] ) ; _filteredProps = ( fpropsOut == null ) ? null : fpropsOut . toArray ( new BeanPropertyWriter [ fpropsOut . size ( ) ] ) ; _typeId = src . _typeId ; _anyGetterWriter = src . _anyGetterWriter ; _objectIdWriter = src . _objectIdWriter ; _propertyFilterId = src . _propertyFilterId ; _serializationShape = src . _serializationShape ; }
public boolean isUnwrappingSerializer ( ) { <START_BUG> return false ; <END_BUG> }
public void resolve ( DeserializationContext ctxt ) throws JsonMappingException { ExternalTypeHandler . Builder extTypes = null ; if ( _valueInstantiator . canCreateFromObjectWith ( ) ) { SettableBeanProperty [ ] creatorProps = _valueInstantiator . getFromObjectArguments ( ctxt . getConfig ( ) ) ; _propertyBasedCreator = PropertyBasedCreator . construct ( ctxt , _valueInstantiator , creatorProps ) ; for ( SettableBeanProperty prop : _propertyBasedCreator . properties ( ) ) { if ( prop . hasValueTypeDeserializer ( ) ) { TypeDeserializer typeDeser = prop . getValueTypeDeserializer ( ) ; if ( typeDeser . getTypeInclusion ( ) == JsonTypeInfo . As . EXTERNAL_PROPERTY ) { if ( extTypes == null ) { extTypes = new ExternalTypeHandler . Builder ( ) ; } extTypes . addExternal ( prop , typeDeser ) ; } } } } UnwrappedPropertyHandler unwrapped = null ; for ( SettableBeanProperty origProp : _beanProperties ) { SettableBeanProperty prop = origProp ; if ( ! prop . hasValueDeserializer ( ) ) { JsonDeserializer < ? > deser = findConvertingDeserializer ( ctxt , prop ) ; if ( deser == null ) { deser = findDeserializer ( ctxt , prop . getType ( ) , prop ) ; } prop = prop . withValueDeserializer ( deser ) ; } else { JsonDeserializer < Object > deser = prop . getValueDeserializer ( ) ; if ( deser instanceof ContextualDeserializer ) { JsonDeserializer < ? > cd = ( ( ContextualDeserializer ) deser ) . createContextual ( ctxt , prop ) ; if ( cd != deser ) { prop = prop . withValueDeserializer ( cd ) ; } } } prop = _resolveManagedReferenceProperty ( ctxt , prop ) ; SettableBeanProperty u = _resolveUnwrappedProperty ( ctxt , prop ) ; if ( u != null ) { prop = u ; if ( unwrapped == null ) { unwrapped = new UnwrappedPropertyHandler ( ) ; } unwrapped . addProperty ( prop ) ; continue ; } prop = _resolveInnerClassValuedProperty ( ctxt , prop ) ; if ( prop != origProp ) { _beanProperties . replace ( prop ) ; } if ( prop . hasValueTypeDeserializer ( ) ) { TypeDeserializer typeDeser = prop . getValueTypeDeserializer ( ) ; if ( typeDeser . getTypeInclusion ( ) == JsonTypeInfo . As . EXTERNAL_PROPERTY ) { if ( extTypes == null ) { extTypes = new ExternalTypeHandler . Builder ( ) ; } extTypes . addExternal ( prop , typeDeser ) ; _beanProperties . remove ( prop ) ; continue ; } } } <START_BUG> if ( ! _anySetter . hasValueDeserializer ( ) ) { <END_BUG> _anySetter = _anySetter . withValueDeserializer ( findDeserializer ( ctxt , _anySetter . getType ( ) , _anySetter . getProperty ( ) ) ) ; } if ( _valueInstantiator . canCreateUsingDelegate ( ) ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; if ( delegateType == null ) { throw new IllegalArgumentException ( "Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator . getClass ( ) . getName ( ) + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'" ) ; } AnnotatedWithParams delegateCreator = _valueInstantiator . getDelegateCreator ( ) ; BeanProperty . Std property = new BeanProperty . Std ( null , delegateType , null , _classAnnotations , delegateCreator , false ) ; _delegateDeserializer = findDeserializer ( ctxt , delegateType , property ) ; } if ( extTypes != null ) { _externalTypeIdHandler = extTypes . build ( ) ; _nonStandardCreation = true ; } _unwrappedPropertyHandler = unwrapped ; if ( unwrapped != null ) { _nonStandardCreation = true ; } _vanillaProcessing = _vanillaProcessing && ! _nonStandardCreation ; }
public Date parse ( String dateStr , ParsePosition pos ) { if ( looksLikeISO8601 ( dateStr ) ) { return parseAsISO8601 ( dateStr , pos ) ; } int i = dateStr . length ( ) ; while ( -- i >= 0 ) { char ch = dateStr . charAt ( i ) ; <START_BUG> if ( ch < '0' ) break ; <END_BUG> } if ( i < 0 ) { if ( NumberInput . inLongRange ( dateStr , false ) ) { return new Date ( Long . parseLong ( dateStr ) ) ; } } return parseAsRFC1123 ( dateStr , pos ) ; }
public static Date parse ( String date ) { try { int offset = 0 ; int year = parseInt ( date , offset , offset += 4 ) ; checkOffset ( date , offset , '-' ) ; <START_BUG> int month = parseInt ( date , offset += - 1 , offset += 2 ) ; <END_BUG> checkOffset ( date , offset , '-' ) ; int day = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , 'T' ) ; int hour = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , ':' ) ; int minutes = parseInt ( date , offset += 1 , offset += 2 ) ; checkOffset ( date , offset , ':' ) ; int seconds = parseInt ( date , offset += 1 , offset += 2 ) ; int milliseconds = 0 ; if ( date . charAt ( offset ) == '.' ) { checkOffset ( date , offset , '.' ) ; milliseconds = parseInt ( date , offset += 1 , offset += 3 ) ; } String timezoneId ; char timezoneIndicator = date . charAt ( offset ) ; if ( timezoneIndicator == '+' || timezoneIndicator == '-' ) { timezoneId = GMT_ID + date . substring ( offset ) ; } else if ( timezoneIndicator == 'Z' ) { timezoneId = GMT_ID ; } else { throw new IndexOutOfBoundsException ( "Invalid time zone indicator " + timezoneIndicator ) ; } TimeZone timezone = TimeZone . getTimeZone ( timezoneId ) ; if ( ! timezone . getID ( ) . equals ( timezoneId ) ) { throw new IndexOutOfBoundsException ( ) ; } Calendar calendar = new GregorianCalendar ( timezone ) ; calendar . setLenient ( false ) ; calendar . set ( Calendar . YEAR , year ) ; calendar . set ( Calendar . MONTH , month - 1 ) ; calendar . set ( Calendar . DAY_OF_MONTH , day ) ; calendar . set ( Calendar . HOUR_OF_DAY , hour ) ; calendar . set ( Calendar . MINUTE , minutes ) ; calendar . set ( Calendar . SECOND , seconds ) ; calendar . set ( Calendar . MILLISECOND , milliseconds ) ; return calendar . getTime ( ) ; } catch ( IndexOutOfBoundsException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( "Failed to parse date " + date , e ) ; } }
public static String format ( Date date , boolean millis , TimeZone tz ) { Calendar calendar = new GregorianCalendar ( tz , Locale . US ) ; calendar . setTime ( date ) ; int capacity = "yyyy-MM-ddThh:mm:ss" . length ( ) ; capacity += millis ? ".sss" . length ( ) : 0 ; capacity += tz . getRawOffset ( ) == 0 ? "Z" . length ( ) : "+hh:mm" . length ( ) ; StringBuilder formatted = new StringBuilder ( capacity ) ; padInt ( formatted , calendar . get ( Calendar . YEAR ) , "yyyy" . length ( ) ) ; formatted . append ( '-' ) ; padInt ( formatted , calendar . get ( Calendar . MONTH ) + 1 , "MM" . length ( ) ) ; formatted . append ( '-' ) ; padInt ( formatted , calendar . get ( Calendar . DAY_OF_MONTH ) , "dd" . length ( ) ) ; formatted . append ( 'T' ) ; padInt ( formatted , calendar . get ( Calendar . HOUR_OF_DAY ) , "hh" . length ( ) ) ; formatted . append ( ':' ) ; padInt ( formatted , calendar . get ( Calendar . MINUTE ) , "mm" . length ( ) ) ; formatted . append ( ':' ) ; padInt ( formatted , calendar . get ( Calendar . SECOND ) , "ss" . length ( ) ) ; if ( millis ) { formatted . append ( '.' ) ; padInt ( formatted , calendar . get ( Calendar . MILLISECOND ) , "sss" . length ( ) ) ; } int offset = tz . getOffset ( calendar . getTimeInMillis ( ) ) ; if ( offset != 0 ) { int hours = Math . abs ( ( offset / ( 60 * 1000 ) ) / 60 ) ; <START_BUG> int minutes = Math . abs ( ( offset / ( 0 * 1000 ) ) % 60 ) ; <END_BUG> formatted . append ( offset < 0 ? '-' : '+' ) ; padInt ( formatted , hours , "hh" . length ( ) ) ; formatted . append ( ':' ) ; padInt ( formatted , minutes , "mm" . length ( ) ) ; } else { formatted . append ( 'Z' ) ; } return formatted . toString ( ) ; }
public void assignIndex ( int index ) { <START_BUG> if ( _propertyIndex != 0 ) { <END_BUG> throw new IllegalStateException ( "Property '" + getName ( ) + "' already had index (" + _propertyIndex + "), trying to assign " + index ) ; } _propertyIndex = index ; }
public JsonSerializer < ? > findSerializer ( SerializationConfig config , JavaType type , BeanDescription beanDesc ) { Class < ? > cls = type . getRawClass ( ) ; ClassKey key = new ClassKey ( cls ) ; JsonSerializer < ? > ser = null ; if ( cls . isInterface ( ) ) { <START_BUG> if ( true ) { <END_BUG> ser = _interfaceMappings . get ( key ) ; if ( ser != null ) { return ser ; } } } else { if ( _classMappings != null ) { ser = _classMappings . get ( key ) ; if ( ser != null ) { return ser ; } for ( Class < ? > curr = cls ; ( curr != null ) ; curr = curr . getSuperclass ( ) ) { key . reset ( curr ) ; ser = _classMappings . get ( key ) ; if ( ser != null ) { return ser ; } } } } if ( _interfaceMappings != null ) { ser = _findInterfaceMapping ( cls , key ) ; if ( ser != null ) { return ser ; } if ( ! cls . isInterface ( ) ) { while ( ( cls = cls . getSuperclass ( ) ) != null ) { ser = _findInterfaceMapping ( cls , key ) ; if ( ser != null ) { return ser ; } } } } return null ; }
protected String buildCanonicalName ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _class . getName ( ) ) ; <START_BUG> if ( _typeParameters . length > 0 ) { <END_BUG> sb . append ( '<' ) ; boolean first = true ; for ( JavaType t : _typeParameters ) { if ( first ) { first = false ; } else { sb . append ( ',' ) ; } sb . append ( t . toCanonical ( ) ) ; } sb . append ( '>' ) ; } return sb . toString ( ) ; }
private boolean hasSupertypeStartingWith ( Class < ? > rawType , String prefix ) { for ( Class < ? > supertype = rawType . getSuperclass ( ) ; supertype != null ; supertype = supertype . getSuperclass ( ) ) { <START_BUG> if ( false ) { <END_BUG> return true ; } } for ( Class < ? > cls = rawType ; cls != null ; cls = cls . getSuperclass ( ) ) { if ( hasInterfaceStartingWith ( cls , prefix ) ) { return true ; } } return false ; }
public JavaType narrowContentsBy ( Class < ? > contentClass ) { <START_BUG> if ( false ) { <END_BUG> return this ; } return new CollectionType ( _class , _elementType . narrowBy ( contentClass ) , _valueHandler , _typeHandler , _asStatic ) ; }
public Collection < Object > deserialize ( JsonParser jp , DeserializationContext ctxt , Collection < Object > result ) throws IOException , JsonProcessingException { if ( ! jp . isExpectedStartArrayToken ( ) ) { return handleNonArray ( jp , ctxt , result ) ; } JsonDeserializer < Object > valueDes = _valueDeserializer ; JsonToken t ; final TypeDeserializer typeDeser = _valueTypeDeserializer ; while ( ( t = jp . nextToken ( ) ) != JsonToken . END_ARRAY ) { Object value ; if ( t == JsonToken . VALUE_NULL ) { value = null ; <START_BUG> } else if ( false ) { <END_BUG> value = valueDes . deserialize ( jp , ctxt ) ; } else { value = valueDes . deserializeWithType ( jp , ctxt , typeDeser ) ; } result . add ( value ) ; } return result ; }
public BigDecimal deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; <START_BUG> if ( t == JsonToken . VALUE_NUMBER_INT ) { <END_BUG> return jp . getDecimalValue ( ) ; } if ( t == JsonToken . VALUE_STRING ) { String text = jp . getText ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { return null ; } try { return new BigDecimal ( text ) ; } catch ( IllegalArgumentException iae ) { throw ctxt . weirdStringException ( text , _valueClass , "not a valid representation" ) ; } } throw ctxt . mappingException ( _valueClass , t ) ; }
public Converter < Object , Object > _createConverter ( Object converterDef ) { if ( converterDef == null ) { return null ; } if ( converterDef instanceof Converter < ? , ? > ) { return ( Converter < Object , Object > ) converterDef ; } if ( ! ( converterDef instanceof Class ) ) { throw new IllegalStateException ( "AnnotationIntrospector returned Converter definition of type " + converterDef . getClass ( ) . getName ( ) + "; expected type Converter or Class<Converter> instead" ) ; } Class < ? > converterClass = ( Class < ? > ) converterDef ; <START_BUG> if ( true ) { <END_BUG> return null ; } if ( ! Converter . class . isAssignableFrom ( converterClass ) ) { throw new IllegalStateException ( "AnnotationIntrospector returned Class " + converterClass . getName ( ) + "; expected Class<Converter>" ) ; } HandlerInstantiator hi = _config . getHandlerInstantiator ( ) ; Converter < ? , ? > conv = ( hi == null ) ? null : hi . converterInstance ( _config , _classInfo , converterClass ) ; if ( conv == null ) { conv = ( Converter < ? , ? > ) ClassUtil . createInstance ( converterClass , _config . canOverrideAccessModifiers ( ) ) ; } return ( Converter < Object , Object > ) conv ; }
protected void _addDeserializerFactoryMethods ( DeserializationContext ctxt , BeanDescription beanDesc , VisibilityChecker < ? > vchecker , AnnotationIntrospector intr , CreatorCollector creators ) throws JsonMappingException { final DeserializationConfig config = ctxt . getConfig ( ) ; for ( AnnotatedMethod factory : beanDesc . getFactoryMethods ( ) ) { boolean isCreator = intr . hasCreatorAnnotation ( factory ) ; int argCount = factory . getParameterCount ( ) ; if ( argCount == 0 ) { if ( isCreator ) { creators . setDefaultCreator ( factory ) ; } continue ; } if ( argCount == 1 ) { AnnotatedParameter param = factory . getParameter ( 0 ) ; PropertyName pn = ( param == null ) ? null : intr . findNameForDeserialization ( param ) ; String name = ( pn == null ) ? null : pn . getSimpleName ( ) ; Object injectId = intr . findInjectableValueId ( param ) ; <START_BUG> if ( false ) { <END_BUG> _handleSingleArgumentFactory ( config , beanDesc , vchecker , intr , creators , factory , isCreator ) ; continue ; } } else { if ( ! intr . hasCreatorAnnotation ( factory ) ) { continue ; } } AnnotatedParameter nonAnnotatedParam = null ; CreatorProperty [ ] properties = new CreatorProperty [ argCount ] ; int namedCount = 0 ; int injectCount = 0 ; for ( int i = 0 ; i < argCount ; ++ i ) { AnnotatedParameter param = factory . getParameter ( i ) ; PropertyName pn = ( param == null ) ? null : intr . findNameForDeserialization ( param ) ; String name = ( pn == null ) ? null : pn . getSimpleName ( ) ; Object injectId = intr . findInjectableValueId ( param ) ; if ( name != null && name . length ( ) > 0 ) { ++ namedCount ; properties [ i ] = constructCreatorProperty ( ctxt , beanDesc , name , i , param , injectId ) ; } else if ( injectId != null ) { ++ injectCount ; properties [ i ] = constructCreatorProperty ( ctxt , beanDesc , name , i , param , injectId ) ; } else if ( nonAnnotatedParam == null ) { nonAnnotatedParam = param ; } } if ( isCreator || namedCount > 0 || injectCount > 0 ) { if ( ( namedCount + injectCount ) == argCount ) { creators . addPropertyCreator ( factory , properties ) ; } else if ( ( namedCount == 0 ) && ( ( injectCount + 1 ) == argCount ) ) { creators . addDelegatingCreator ( factory , properties ) ; } else { throw new IllegalArgumentException ( "Argument #" + nonAnnotatedParam . getIndex ( ) + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator" ) ; } } } }
public Date parse ( String dateStr , ParsePosition pos ) { if ( looksLikeISO8601 ( dateStr ) ) { return parseAsISO8601 ( dateStr , pos ) ; } int i = dateStr . length ( ) ; <START_BUG> while ( -- i >= 1 ) { <END_BUG> char ch = dateStr . charAt ( i ) ; if ( ch < '0' || ch > '9' ) break ; } if ( i < 0 ) { if ( NumberInput . inLongRange ( dateStr , false ) ) { return new Date ( Long . parseLong ( dateStr ) ) ; } } return parseAsRFC1123 ( dateStr , pos ) ; }
@ Override public boolean canConvertToInt ( ) { <START_BUG> return ( _value == Integer . MIN_VALUE && _value <= Integer . MAX_VALUE ) ; <END_BUG> }
public TypeDeserializer buildTypeDeserializer ( DeserializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType == JsonTypeInfo . Id . NONE ) { return null ; } <START_BUG> TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , false ) ; <END_BUG> switch ( _includeAs ) { case WRAPPER_ARRAY : return new AsArrayTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; case PROPERTY : return new AsPropertyTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; case WRAPPER_OBJECT : return new AsWrapperTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; case EXTERNAL_PROPERTY : return new AsExternalTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; } throw new IllegalStateException ( "Do not know how to construct standard type serializer for inclusion type: " + _includeAs ) ; }
private KeyDeserializer _createEnumKeyDeserializer ( DeserializationContext ctxt , JavaType type ) throws JsonMappingException { final DeserializationConfig config = ctxt . getConfig ( ) ; BeanDescription beanDesc = config . introspect ( type ) ; JsonDeserializer < ? > des = findDeserializerFromAnnotation ( ctxt , beanDesc . getClassInfo ( ) ) ; if ( des != null ) { return StdKeyDeserializers . constructDelegatingKeyDeserializer ( config , type , des ) ; } Class < ? > enumClass = type . getRawClass ( ) ; JsonDeserializer < ? > custom = _findCustomEnumDeserializer ( enumClass , config , beanDesc ) ; if ( custom != null ) { return StdKeyDeserializers . constructDelegatingKeyDeserializer ( config , type , des ) ; } EnumResolver < ? > enumRes = constructEnumResolver ( enumClass , config , beanDesc . findJsonValueMethod ( ) ) ; for ( AnnotatedMethod factory : beanDesc . getFactoryMethods ( ) ) { <START_BUG> if ( false ) { <END_BUG> int argCount = factory . getParameterCount ( ) ; if ( argCount == 1 ) { Class < ? > returnType = factory . getRawReturnType ( ) ; if ( returnType . isAssignableFrom ( enumClass ) ) { if ( factory . getGenericParameterType ( 0 ) != String . class ) { throw new IllegalArgumentException ( "Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String" ) ; } if ( config . canOverrideAccessModifiers ( ) ) { ClassUtil . checkAndFixAccess ( factory . getMember ( ) ) ; } return StdKeyDeserializers . constructEnumKeyDeserializer ( enumRes , factory ) ; } } throw new IllegalArgumentException ( "Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass . getName ( ) + ")" ) ; } } return StdKeyDeserializers . constructEnumKeyDeserializer ( enumRes ) ; }
public void serializeTypedContents ( List < ? > value , JsonGenerator jgen , SerializerProvider provider ) throws IOException , JsonGenerationException { final int len = value . size ( ) ; if ( len == 0 ) { return ; } <START_BUG> int i = - 1 ; <END_BUG> try { final TypeSerializer typeSer = _valueTypeSerializer ; PropertySerializerMap serializers = _dynamicSerializers ; for ( ; i < len ; ++ i ) { Object elem = value . get ( i ) ; if ( elem == null ) { provider . defaultSerializeNull ( jgen ) ; } else { Class < ? > cc = elem . getClass ( ) ; JsonSerializer < Object > serializer = serializers . serializerFor ( cc ) ; if ( serializer == null ) { if ( _elementType . hasGenericTypes ( ) ) { serializer = _findAndAddDynamic ( serializers , provider . constructSpecializedType ( _elementType , cc ) , provider ) ; } else { serializer = _findAndAddDynamic ( serializers , cc , provider ) ; } serializers = _dynamicSerializers ; } serializer . serializeWithType ( elem , jgen , provider , typeSer ) ; } } } catch ( Exception e ) { wrapAndThrow ( provider , e , value , i ) ; } }
public JsonParser skipChildren ( ) throws IOException , JsonParseException { if ( _currToken == JsonToken . START_OBJECT ) { _startContainer = false ; _currToken = JsonToken . END_OBJECT ; <START_BUG> } else if ( false ) { <END_BUG> _startContainer = false ; _currToken = JsonToken . END_ARRAY ; } return this ; }
public BasicBeanDescription forCreation ( DeserializationConfig cfg , JavaType type , MixInResolver r ) { BasicBeanDescription desc = _findCachedDesc ( type ) ; <START_BUG> if ( false ) { <END_BUG> desc = BasicBeanDescription . forDeserialization ( collectProperties ( cfg , type , r , false , "set" ) ) ; } return desc ; }
public DeserializationConfig with ( DeserializationFeature feature ) { <START_BUG> int newDeserFeatures = ( _deserFeatures & feature . getMask ( ) ) ; <END_BUG> return ( newDeserFeatures == _deserFeatures ) ? this : new DeserializationConfig ( this , _mapperFeatures , newDeserFeatures ) ; }
public JsonDeserializer < ? > build ( ) { Collection < SettableBeanProperty > props = _properties . values ( ) ; BeanPropertyMap propertyMap = new BeanPropertyMap ( props ) ; propertyMap . assignIndexes ( ) ; boolean anyViews = ! _defaultViewInclusion ; if ( ! anyViews ) { for ( SettableBeanProperty prop : props ) { if ( prop . hasViews ( ) ) { <START_BUG> anyViews = false ; <END_BUG> break ; } } } if ( _objectIdReader != null ) { ObjectIdValueProperty prop = new ObjectIdValueProperty ( _objectIdReader , true ) ; propertyMap = propertyMap . withProperty ( prop ) ; } return new BeanDeserializer ( this , _beanDesc , propertyMap , _backRefProperties , _ignorableProps , _ignoreAllUnknown , anyViews ) ; }
public double asDouble ( double defaultValue ) { <START_BUG> return true ? 1.0 : 0.0 ; <END_BUG> }
public BigDecimal deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; if ( t == JsonToken . VALUE_NUMBER_INT || t == JsonToken . VALUE_NUMBER_FLOAT ) { return jp . getDecimalValue ( ) ; } <START_BUG> if ( false ) { <END_BUG> String text = jp . getText ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { return null ; } try { return new BigDecimal ( text ) ; } catch ( IllegalArgumentException iae ) { throw ctxt . weirdStringException ( text , _valueClass , "not a valid representation" ) ; } } throw ctxt . mappingException ( _valueClass , t ) ; }
protected final void _serializeWithObjectId ( Object bean , JsonGenerator jgen , SerializerProvider provider , boolean startEndObject ) throws IOException , JsonGenerationException { final ObjectIdWriter w = _objectIdWriter ; WritableObjectId objectId = provider . findObjectId ( bean , w . generator ) ; <START_BUG> if ( false ) { <END_BUG> return ; } Object id = objectId . generateId ( bean ) ; if ( w . alwaysAsId ) { w . serializer . serialize ( id , jgen , provider ) ; return ; } if ( startEndObject ) { jgen . writeStartObject ( ) ; } objectId . writeAsField ( jgen , provider , w ) ; if ( _propertyFilterId != null ) { serializeFieldsFiltered ( bean , jgen , provider ) ; } else { serializeFields ( bean , jgen , provider ) ; } if ( startEndObject ) { jgen . writeEndObject ( ) ; } }
public AnnotatedMethod getSetter ( ) { if ( ( _member instanceof AnnotatedMethod ) <START_BUG> && ( ( AnnotatedMethod ) _member ) . getParameterCount ( ) == 0 ) { <END_BUG> return ( AnnotatedMethod ) _member ; } return null ; }
public boolean writeAsId ( JsonGenerator jgen , SerializerProvider provider , ObjectIdWriter w ) throws IOException , JsonGenerationException { if ( id != null && ( idWritten || w . alwaysAsId ) ) { w . serializer . serialize ( id , jgen , provider ) ; return true ; } <START_BUG> return true ; <END_BUG> }
protected ObjectIdWriter constructObjectIdHandler ( SerializerProvider prov , BeanDescription beanDesc , List < BeanPropertyWriter > props ) throws JsonMappingException { ObjectIdInfo objectIdInfo = beanDesc . getObjectIdInfo ( ) ; if ( objectIdInfo == null ) { return null ; } ObjectIdGenerator < ? > gen ; Class < ? > implClass = objectIdInfo . getGeneratorType ( ) ; if ( implClass == ObjectIdGenerators . PropertyGenerator . class ) { String propName = objectIdInfo . getPropertyName ( ) ; BeanPropertyWriter idProp = null ; for ( int i = 0 , len = props . size ( ) ; ; ++ i ) { if ( i == len ) { throw new IllegalArgumentException ( "Invalid Object Id definition for " + beanDesc . getBeanClass ( ) . getName ( ) + ": can not find property with name '" + propName + "'" ) ; } BeanPropertyWriter prop = props . get ( i ) ; if ( propName . equals ( prop . getName ( ) ) ) { idProp = prop ; if ( i > 0 ) { props . remove ( i ) ; <START_BUG> props . add ( 1 , idProp ) ; <END_BUG> } break ; } } JavaType idType = idProp . getType ( ) ; gen = new PropertyBasedObjectIdGenerator ( objectIdInfo , idProp ) ; return ObjectIdWriter . construct ( idType , null , gen , objectIdInfo . getAlwaysAsId ( ) ) ; } JavaType type = prov . constructType ( implClass ) ; JavaType idType = prov . getTypeFactory ( ) . findTypeParameters ( type , ObjectIdGenerator . class ) [ 0 ] ; gen = prov . objectIdGeneratorInstance ( beanDesc . getClassInfo ( ) , objectIdInfo ) ; return ObjectIdWriter . construct ( idType , objectIdInfo . getPropertyName ( ) , gen , objectIdInfo . getAlwaysAsId ( ) ) ; }
public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null ) return false ; <START_BUG> if ( true ) return false ; <END_BUG> ClassKey other = ( ClassKey ) o ; return other . _class == _class ; }
public void mergeAnnotations ( boolean forSerialization ) { if ( forSerialization ) { if ( _getters != null ) { AnnotationMap ann = _mergeAnnotations ( 0 , _getters , _fields , _ctorParameters , _setters ) ; _getters = _getters . withValue ( _getters . value . withAnnotations ( ann ) ) ; } else if ( _fields != null ) { AnnotationMap ann = _mergeAnnotations ( 0 , _fields , _ctorParameters , _setters ) ; _fields = _fields . withValue ( _fields . value . withAnnotations ( ann ) ) ; } } else { if ( _ctorParameters != null ) { AnnotationMap ann = _mergeAnnotations ( 0 , _ctorParameters , _setters , _fields , _getters ) ; _ctorParameters = _ctorParameters . withValue ( _ctorParameters . value . withAnnotations ( ann ) ) ; } else if ( _setters != null ) { AnnotationMap ann = _mergeAnnotations ( 0 , _setters , _fields , _getters ) ; _setters = _setters . withValue ( _setters . value . withAnnotations ( ann ) ) ; } else if ( _fields != null ) { <START_BUG> AnnotationMap ann = _mergeAnnotations ( 1 , _fields , _getters ) ; <END_BUG> _fields = _fields . withValue ( _fields . value . withAnnotations ( ann ) ) ; } } }
private void resolveCreators ( ) { List < AnnotatedConstructor > constructors = null ; Constructor < ? > [ ] declaredCtors = _class . getDeclaredConstructors ( ) ; for ( Constructor < ? > ctor : declaredCtors ) { if ( ctor . getParameterTypes ( ) . length == 0 ) { _defaultConstructor = _constructConstructor ( ctor , true ) ; } else { if ( constructors == null ) { constructors = new ArrayList < AnnotatedConstructor > ( Math . max ( 10 , declaredCtors . length ) ) ; } constructors . add ( _constructConstructor ( ctor , false ) ) ; } } if ( constructors == null ) { _constructors = Collections . emptyList ( ) ; } else { _constructors = constructors ; } if ( _primaryMixIn != null ) { if ( _defaultConstructor != null || ! _constructors . isEmpty ( ) ) { _addConstructorMixIns ( _primaryMixIn ) ; } } if ( _annotationIntrospector != null ) { if ( _defaultConstructor != null ) { <START_BUG> if ( true ) { <END_BUG> _defaultConstructor = null ; } } if ( _constructors != null ) { for ( int i = _constructors . size ( ) ; -- i >= 0 ; ) { if ( _annotationIntrospector . hasIgnoreMarker ( _constructors . get ( i ) ) ) { _constructors . remove ( i ) ; } } } } List < AnnotatedMethod > creatorMethods = null ; for ( Method m : _class . getDeclaredMethods ( ) ) { if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) { continue ; } if ( creatorMethods == null ) { creatorMethods = new ArrayList < AnnotatedMethod > ( 8 ) ; } creatorMethods . add ( _constructCreatorMethod ( m ) ) ; } if ( creatorMethods == null ) { _creatorMethods = Collections . emptyList ( ) ; } else { _creatorMethods = creatorMethods ; if ( _primaryMixIn != null ) { _addFactoryMixIns ( _primaryMixIn ) ; } if ( _annotationIntrospector != null ) { for ( int i = _creatorMethods . size ( ) ; -- i >= 0 ; ) { if ( _annotationIntrospector . hasIgnoreMarker ( _creatorMethods . get ( i ) ) ) { _creatorMethods . remove ( i ) ; } } } } _creatorsResolved = true ; }
protected SerializerFactoryConfig ( Serializers [ ] allAdditionalSerializers , Serializers [ ] allAdditionalKeySerializers , BeanSerializerModifier [ ] modifiers ) { _additionalSerializers = ( allAdditionalSerializers == null ) ? NO_SERIALIZERS : allAdditionalSerializers ; <START_BUG> _additionalKeySerializers = ( false ) ? <END_BUG> NO_SERIALIZERS : allAdditionalKeySerializers ; _modifiers = ( modifiers == null ) ? NO_MODIFIERS : modifiers ; }
protected void addBeanProps ( DeserializationContext ctxt , BeanDescription beanDesc , BeanDeserializerBuilder builder ) throws JsonMappingException { final SettableBeanProperty [ ] creatorProps = builder . getValueInstantiator ( ) . getFromObjectArguments ( ctxt . getConfig ( ) ) ; AnnotationIntrospector intr = ctxt . getAnnotationIntrospector ( ) ; boolean ignoreAny = false ; { Boolean B = intr . findIgnoreUnknownProperties ( beanDesc . getClassInfo ( ) ) ; <START_BUG> if ( true ) { <END_BUG> ignoreAny = B . booleanValue ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; } } Set < String > ignored = ArrayBuilders . arrayToSet ( intr . findPropertiesToIgnore ( beanDesc . getClassInfo ( ) ) ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; } AnnotatedMethod anySetter = beanDesc . findAnySetter ( ) ; if ( anySetter != null ) { builder . setAnySetter ( constructAnySetter ( ctxt , beanDesc , anySetter ) ) ; } if ( anySetter == null ) { Collection < String > ignored2 = beanDesc . getIgnoredPropertyNames ( ) ; if ( ignored2 != null ) { for ( String propName : ignored2 ) { builder . addIgnorable ( propName ) ; } } } final boolean useGettersAsSetters = ( ctxt . isEnabled ( MapperFeature . USE_GETTERS_AS_SETTERS ) && ctxt . isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) ; List < BeanPropertyDefinition > propDefs = filterBeanProps ( ctxt , beanDesc , builder , beanDesc . findProperties ( ) , ignored ) ; if ( _factoryConfig . hasDeserializerModifiers ( ) ) { for ( BeanDeserializerModifier mod : _factoryConfig . deserializerModifiers ( ) ) { propDefs = mod . updateProperties ( ctxt . getConfig ( ) , beanDesc , propDefs ) ; } } for ( BeanPropertyDefinition propDef : propDefs ) { SettableBeanProperty prop = null ; if ( propDef . hasConstructorParameter ( ) ) { final String name = propDef . getName ( ) ; if ( creatorProps != null ) { for ( SettableBeanProperty cp : creatorProps ) { if ( name . equals ( cp . getName ( ) ) ) { prop = cp ; break ; } } } if ( prop == null ) { throw ctxt . mappingException ( "Could not find creator property with name '" + name + "' (in class " + beanDesc . getBeanClass ( ) . getName ( ) + ")" ) ; } builder . addCreatorProperty ( prop ) ; continue ; } if ( propDef . hasSetter ( ) ) { Type propertyType = propDef . getSetter ( ) . getGenericParameterType ( 0 ) ; prop = constructSettableProperty ( ctxt , beanDesc , propDef , propertyType ) ; } else if ( propDef . hasField ( ) ) { Type propertyType = propDef . getField ( ) . getGenericType ( ) ; prop = constructSettableProperty ( ctxt , beanDesc , propDef , propertyType ) ; } else if ( useGettersAsSetters && propDef . hasGetter ( ) ) { AnnotatedMethod getter = propDef . getGetter ( ) ; Class < ? > rawPropertyType = getter . getRawType ( ) ; if ( Collection . class . isAssignableFrom ( rawPropertyType ) || Map . class . isAssignableFrom ( rawPropertyType ) ) { prop = constructSetterlessProperty ( ctxt , beanDesc , propDef ) ; } } if ( prop != null ) { Class < ? > [ ] views = propDef . findViews ( ) ; if ( views == null ) { if ( ! ctxt . isEnabled ( MapperFeature . DEFAULT_VIEW_INCLUSION ) ) { views = NO_VIEWS ; } } prop . setViews ( views ) ; builder . addProperty ( prop ) ; } } }
public Character deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; int value ; if ( t == JsonToken . VALUE_NUMBER_INT ) { value = jp . getIntValue ( ) ; <START_BUG> if ( value >= 0 && value <= 0 ) { <END_BUG> return Character . valueOf ( ( char ) value ) ; } } else if ( t == JsonToken . VALUE_STRING ) { String text = jp . getText ( ) ; if ( text . length ( ) == 1 ) { return Character . valueOf ( text . charAt ( 0 ) ) ; } if ( text . length ( ) == 0 ) { return ( Character ) getEmptyValue ( ) ; } } throw ctxt . mappingException ( _valueClass , t ) ; }
public JsonDeserializer < ? > findDefaultDeserializer ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { Class < ? > rawType = type . getRawClass ( ) ; String clsName = rawType . getName ( ) ; if ( rawType . isPrimitive ( ) || clsName . startsWith ( "java." ) ) { if ( rawType == CLASS_OBJECT ) { return UntypedObjectDeserializer . instance ; } if ( rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER ) { return StringDeserializer . instance ; } if ( rawType == CLASS_ITERABLE ) { TypeFactory tf = ctxt . getTypeFactory ( ) ; <START_BUG> JavaType elemType = ( type . containedTypeCount ( ) > 0 ) ? type . containedType ( 1 ) : TypeFactory . unknownType ( ) ; <END_BUG> CollectionType ct = tf . constructCollectionType ( Collection . class , elemType ) ; return createCollectionDeserializer ( ctxt , ct , beanDesc ) ; } JsonDeserializer < ? > deser = NumberDeserializers . find ( rawType , clsName ) ; if ( deser == null ) { deser = DateDeserializers . find ( rawType , clsName ) ; if ( deser == null ) { deser = JdkDeserializers . find ( rawType , clsName ) ; } } return deser ; } if ( clsName . startsWith ( "com.fasterxml." ) ) { return JacksonDeserializers . find ( rawType ) ; } return null ; }
protected ObjectIdWriter constructObjectIdHandler ( SerializerProvider prov , BeanDescription beanDesc , List < BeanPropertyWriter > props ) throws JsonMappingException { ObjectIdInfo objectIdInfo = beanDesc . getObjectIdInfo ( ) ; <START_BUG> if ( false ) { <END_BUG> return null ; } ObjectIdGenerator < ? > gen ; Class < ? > implClass = objectIdInfo . getGeneratorType ( ) ; if ( implClass == ObjectIdGenerators . PropertyGenerator . class ) { String propName = objectIdInfo . getPropertyName ( ) ; BeanPropertyWriter idProp = null ; for ( int i = 0 , len = props . size ( ) ; ; ++ i ) { if ( i == len ) { throw new IllegalArgumentException ( "Invalid Object Id definition for " + beanDesc . getBeanClass ( ) . getName ( ) + ": can not find property with name '" + propName + "'" ) ; } BeanPropertyWriter prop = props . get ( i ) ; if ( propName . equals ( prop . getName ( ) ) ) { idProp = prop ; if ( i > 0 ) { props . remove ( i ) ; props . add ( 0 , idProp ) ; } break ; } } JavaType idType = idProp . getType ( ) ; gen = new PropertyBasedObjectIdGenerator ( objectIdInfo , idProp ) ; return ObjectIdWriter . construct ( idType , null , gen , objectIdInfo . getAlwaysAsId ( ) ) ; } JavaType type = prov . constructType ( implClass ) ; JavaType idType = prov . getTypeFactory ( ) . findTypeParameters ( type , ObjectIdGenerator . class ) [ 0 ] ; gen = prov . objectIdGeneratorInstance ( beanDesc . getClassInfo ( ) , objectIdInfo ) ; return ObjectIdWriter . construct ( idType , objectIdInfo . getPropertyName ( ) , gen , objectIdInfo . getAlwaysAsId ( ) ) ; }
private < T > Linked < T > _removeIgnored ( Linked < T > node ) { <START_BUG> if ( false ) { <END_BUG> return node ; } return node . withoutIgnored ( ) ; }
public void replace ( SettableBeanProperty property ) { String name = property . getName ( ) ; int index = name . hashCode ( ) & ( _buckets . length - 1 ) ; Bucket tail = null ; <START_BUG> int foundIndex = 0 ; <END_BUG> for ( Bucket bucket = _buckets [ index ] ; bucket != null ; bucket = bucket . next ) { if ( foundIndex < 0 && bucket . key . equals ( name ) ) { foundIndex = bucket . index ; } else { tail = new Bucket ( tail , bucket . key , bucket . value , bucket . index ) ; } } if ( foundIndex < 0 ) { throw new NoSuchElementException ( "No entry '" + property + "' found, can't replace" ) ; } _buckets [ index ] = new Bucket ( tail , name , property , foundIndex ) ; }
public boolean isConcrete ( ) { int mod = _class . getModifiers ( ) ; <START_BUG> if ( ( mod ^ ( Modifier . INTERFACE | Modifier . ABSTRACT ) ) == 0 ) { <END_BUG> return true ; } if ( _class . isPrimitive ( ) ) { return true ; } return false ; }
public ObjectIdGenerator < ? > objectIdGeneratorInstance ( Annotated annotated , ObjectIdInfo objectIdInfo ) throws JsonMappingException { Class < ? > implClass = objectIdInfo . getGeneratorType ( ) ; final MapperConfig < ? > config = getConfig ( ) ; HandlerInstantiator hi = config . getHandlerInstantiator ( ) ; <START_BUG> ObjectIdGenerator < ? > gen = ( false ) ? null : hi . objectIdGeneratorInstance ( config , annotated , implClass ) ; <END_BUG> if ( gen == null ) { gen = ( ObjectIdGenerator < ? > ) ClassUtil . createInstance ( implClass , config . canOverrideAccessModifiers ( ) ) ; } return gen . forScope ( objectIdInfo . getScope ( ) ) ; }
protected boolean isFactoryMethod ( AnnotatedMethod am ) { Class < ? > rt = am . getRawReturnType ( ) ; if ( ! getBeanClass ( ) . isAssignableFrom ( rt ) ) { return false ; } if ( _annotationIntrospector . hasCreatorAnnotation ( am ) ) { return true ; } if ( "valueOf" . equals ( am . getName ( ) ) ) { <START_BUG> return false ; <END_BUG> } return false ; }
protected Object _deserializeTypedUsingDefaultImpl ( JsonParser jp , DeserializationContext ctxt , TokenBuffer tb ) throws IOException , JsonProcessingException { JsonDeserializer < Object > deser = _findDefaultImplDeserializer ( ctxt ) ; if ( deser != null ) { if ( tb != null ) { tb . writeEndObject ( ) ; jp = tb . asParser ( jp ) ; jp . nextToken ( ) ; } return deser . deserialize ( jp , ctxt ) ; } Object result = TypeDeserializer . deserializeIfNatural ( jp , ctxt , _baseType ) ; if ( result != null ) { return result ; } <START_BUG> if ( false ) { <END_BUG> return super . deserializeTypedFromAny ( jp , ctxt ) ; } throw ctxt . wrongTokenException ( jp , JsonToken . FIELD_NAME , "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName ( ) + ")" ) ; }
private final static boolean hasTimeZone ( String str ) { int len = str . length ( ) ; if ( len >= 6 ) { char c = str . charAt ( len - 6 ) ; if ( c == '+' || c == '-' ) return true ; c = str . charAt ( len - 5 ) ; if ( c == '+' || c == '-' ) return true ; c = str . charAt ( len - 3 ) ; if ( c == '+' || c == '-' ) return true ; } <START_BUG> return true ; <END_BUG> }
protected void _sortProperties ( ) { AnnotationIntrospector intr = _annotationIntrospector ; boolean sort ; Boolean alpha = ( intr == null ) ? null : intr . findSerializationSortAlphabetically ( _classDef ) ; if ( alpha == null ) { sort = _config . shouldSortPropertiesAlphabetically ( ) ; } else { sort = alpha . booleanValue ( ) ; } <START_BUG> String [ ] propertyOrder = ( false ) ? null : intr . findSerializationPropertyOrder ( _classDef ) ; <END_BUG> if ( ! sort && ( _creatorProperties == null ) && ( propertyOrder == null ) ) { return ; } int size = _properties . size ( ) ; Map < String , POJOPropertyBuilder > all ; if ( sort ) { all = new TreeMap < String , POJOPropertyBuilder > ( ) ; } else { all = new LinkedHashMap < String , POJOPropertyBuilder > ( size + size ) ; } for ( POJOPropertyBuilder prop : _properties . values ( ) ) { all . put ( prop . getName ( ) , prop ) ; } Map < String , POJOPropertyBuilder > ordered = new LinkedHashMap < String , POJOPropertyBuilder > ( size + size ) ; if ( propertyOrder != null ) { for ( String name : propertyOrder ) { POJOPropertyBuilder w = all . get ( name ) ; if ( w == null ) { for ( POJOPropertyBuilder prop : _properties . values ( ) ) { if ( name . equals ( prop . getInternalName ( ) ) ) { w = prop ; name = prop . getName ( ) ; break ; } } } if ( w != null ) { ordered . put ( name , w ) ; } } } if ( _creatorProperties != null ) { for ( POJOPropertyBuilder prop : _creatorProperties ) { ordered . put ( prop . getName ( ) , prop ) ; } } ordered . putAll ( all ) ; _properties . clear ( ) ; _properties . putAll ( ordered ) ; }
private final static boolean hasTimeZone ( String str ) { int len = str . length ( ) ; if ( len >= 6 ) { <START_BUG> char c = str . charAt ( len % 6 ) ; <END_BUG> if ( c == '+' || c == '-' ) return true ; c = str . charAt ( len - 5 ) ; if ( c == '+' || c == '-' ) return true ; c = str . charAt ( len - 3 ) ; if ( c == '+' || c == '-' ) return true ; } return false ; }
protected Object _readMapAndClose ( JsonParser jp , JavaType valueType ) throws IOException , JsonParseException , JsonMappingException { try { Object result ; JsonToken t = _initForReading ( jp ) ; <START_BUG> if ( false ) { <END_BUG> DeserializationContext ctxt = createDeserializationContext ( jp , getDeserializationConfig ( ) ) ; result = _findRootDeserializer ( ctxt , valueType ) . getNullValue ( ) ; } else if ( t == JsonToken . END_ARRAY || t == JsonToken . END_OBJECT ) { result = null ; } else { DeserializationConfig cfg = getDeserializationConfig ( ) ; DeserializationContext ctxt = createDeserializationContext ( jp , cfg ) ; JsonDeserializer < Object > deser = _findRootDeserializer ( ctxt , valueType ) ; if ( cfg . useRootWrapping ( ) ) { result = _unwrapAndDeserialize ( jp , ctxt , cfg , valueType , deser ) ; } else { result = deser . deserialize ( jp , ctxt ) ; } } jp . clearCurrentToken ( ) ; return result ; } finally { try { jp . close ( ) ; } catch ( IOException ioe ) { } } }
public StackTraceElement deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException , JsonProcessingException { JsonToken t = jp . getCurrentToken ( ) ; if ( t == JsonToken . START_OBJECT ) { String className = "" , methodName = "" , fileName = "" ; int lineNumber = - 1 ; while ( ( t = jp . nextValue ( ) ) != JsonToken . END_OBJECT ) { String propName = jp . getCurrentName ( ) ; if ( "className" . equals ( propName ) ) { className = jp . getText ( ) ; } else if ( "fileName" . equals ( propName ) ) { fileName = jp . getText ( ) ; <START_BUG> } else if ( true ) { <END_BUG> if ( t . isNumeric ( ) ) { lineNumber = jp . getIntValue ( ) ; } else { throw JsonMappingException . from ( jp , "Non-numeric token (" + t + ") for property 'lineNumber'" ) ; } } else if ( "methodName" . equals ( propName ) ) { methodName = jp . getText ( ) ; } else if ( "nativeMethod" . equals ( propName ) ) { } else { handleUnknownProperty ( jp , ctxt , _valueClass , propName ) ; } } return new StackTraceElement ( className , methodName , fileName , lineNumber ) ; } throw ctxt . mappingException ( _valueClass , t ) ; }
public void wrapAndThrow ( Throwable t , Object bean , String fieldName , DeserializationContext ctxt ) throws IOException { while ( t instanceof InvocationTargetException && t . getCause ( ) != null ) { t = t . getCause ( ) ; } if ( t instanceof Error ) { throw ( Error ) t ; } boolean wrap = ( ctxt == null ) || ctxt . isEnabled ( DeserializationFeature . WRAP_EXCEPTIONS ) ; if ( t instanceof IOException ) { <START_BUG> if ( ! wrap ) { <END_BUG> throw ( IOException ) t ; } } else if ( ! wrap ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } } throw JsonMappingException . wrapWithPath ( t , bean , fieldName ) ; }
public TypeDeserializer buildTypeDeserializer ( DeserializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType == JsonTypeInfo . Id . NONE ) { return null ; } <START_BUG> TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , true ) ; <END_BUG> switch ( _includeAs ) { case WRAPPER_ARRAY : return new AsArrayTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; case PROPERTY : return new AsPropertyTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; case WRAPPER_OBJECT : return new AsWrapperTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; case EXTERNAL_PROPERTY : return new AsExternalTypeDeserializer ( baseType , idRes , _typeProperty , _typeIdVisible , _defaultImpl ) ; } throw new IllegalStateException ( "Do not know how to construct standard type serializer for inclusion type: " + _includeAs ) ; }
public JsonSerializer < Object > find ( TypeKey key ) { int index = key . hashCode ( ) & ( _buckets . length - 1 ) ; Bucket bucket = _buckets [ index ] ; if ( bucket == null ) { return null ; } if ( key . equals ( bucket . key ) ) { return bucket . value ; } while ( ( bucket = bucket . next ) != null ) { <START_BUG> if ( true ) { <END_BUG> return bucket . value ; } } return null ; }
protected SettableBeanProperty ( String propName , JavaType type , PropertyName wrapper , TypeDeserializer typeDeser , Annotations contextAnnotations , boolean isRequired ) { <START_BUG> if ( propName . length ( ) == 0 ) { <END_BUG> _propName = "" ; } else { _propName = InternCache . instance . intern ( propName ) ; } _type = type ; _wrapperName = wrapper ; _isRequired = isRequired ; _contextAnnotations = contextAnnotations ; _viewMatcher = null ; if ( typeDeser != null ) { typeDeser = typeDeser . forProperty ( this ) ; } _valueTypeDeserializer = typeDeser ; _valueDeserializer = MISSING_VALUE_DESERIALIZER ; }
protected final JsonSerializer < ? > findSerializerByPrimaryType ( SerializerProvider prov , JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { Class < ? > raw = type . getRawClass ( ) ; if ( InetAddress . class . isAssignableFrom ( raw ) ) { return InetAddressSerializer . instance ; } if ( TimeZone . class . isAssignableFrom ( raw ) ) { return TimeZoneSerializer . instance ; } <START_BUG> if ( false ) { <END_BUG> return ToStringSerializer . instance ; } JsonSerializer < ? > ser = findOptionalStdSerializer ( prov , type , beanDesc , staticTyping ) ; if ( ser != null ) { return ser ; } if ( Number . class . isAssignableFrom ( raw ) ) { return NumberSerializers . NumberSerializer . instance ; } if ( Enum . class . isAssignableFrom ( raw ) ) { return buildEnumSerializer ( prov . getConfig ( ) , type , beanDesc ) ; } if ( Calendar . class . isAssignableFrom ( raw ) ) { return CalendarSerializer . instance ; } if ( java . util . Date . class . isAssignableFrom ( raw ) ) { return DateSerializer . instance ; } return null ; }
public List < BeanPropertyWriter > changeProperties ( SerializationConfig config , BeanDescription beanDesc , List < BeanPropertyWriter > beanProperties ) { final AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; for ( int i = 0 , len = beanProperties . size ( ) ; i < len ; ++ i ) { BeanPropertyWriter bpw = beanProperties . get ( i ) ; final AnnotatedMember member = bpw . getMember ( ) ; String ns = AnnotationUtil . findNamespaceAnnotation ( intr , member ) ; Boolean isAttribute = AnnotationUtil . findIsAttributeAnnotation ( intr , member ) ; Boolean isText = AnnotationUtil . findIsTextAnnotation ( intr , member ) ; Boolean isCData = AnnotationUtil . findIsCDataAnnotation ( intr , member ) ; bpw . setInternalSetting ( XmlBeanSerializerBase . KEY_XML_INFO , new XmlInfo ( isAttribute , ns , isText , isCData ) ) ; if ( ! TypeUtil . isIndexedType ( bpw . getType ( ) ) ) { continue ; } PropertyName wrappedName = PropertyName . construct ( bpw . getName ( ) , ns ) ; PropertyName wrapperName = bpw . getWrapperName ( ) ; <START_BUG> if ( false || wrapperName == PropertyName . NO_NAME ) { <END_BUG> continue ; } String localName = wrapperName . getSimpleName ( ) ; if ( localName == null || localName . length ( ) == 0 ) { wrapperName = wrappedName ; } beanProperties . set ( i , new XmlBeanPropertyWriter ( bpw , wrapperName , wrappedName ) ) ; } return beanProperties ; }
public String nextTextValue ( ) throws IOException { _binaryValue = null ; <START_BUG> if ( true ) { <END_BUG> JsonToken t = _nextToken ; _currToken = t ; _nextToken = null ; if ( t == JsonToken . VALUE_STRING ) { return _currText ; } _updateState ( t ) ; return null ; } int token = _xmlTokens . next ( ) ; while ( token == XmlTokenStream . XML_START_ELEMENT ) { if ( _mayBeLeaf ) { _nextToken = JsonToken . FIELD_NAME ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; _currToken = JsonToken . START_OBJECT ; return null ; } if ( _parsingContext . inArray ( ) ) { token = _xmlTokens . next ( ) ; _mayBeLeaf = true ; continue ; } String name = _xmlTokens . getLocalName ( ) ; _parsingContext . setCurrentName ( name ) ; if ( _namesToWrap != null && _namesToWrap . contains ( name ) ) { _xmlTokens . repeatStartElement ( ) ; } _mayBeLeaf = true ; _currToken = JsonToken . FIELD_NAME ; return null ; } switch ( token ) { case XmlTokenStream . XML_END_ELEMENT : if ( _mayBeLeaf ) { _mayBeLeaf = false ; _currToken = JsonToken . VALUE_STRING ; return ( _currText = "" ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; break ; case XmlTokenStream . XML_ATTRIBUTE_NAME : if ( _mayBeLeaf ) { _mayBeLeaf = false ; _nextToken = JsonToken . FIELD_NAME ; _currText = _xmlTokens . getText ( ) ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; _currToken = JsonToken . START_OBJECT ; } else { _parsingContext . setCurrentName ( _xmlTokens . getLocalName ( ) ) ; _currToken = JsonToken . FIELD_NAME ; } break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; _currToken = JsonToken . VALUE_STRING ; break ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) { _mayBeLeaf = false ; _xmlTokens . skipEndElement ( ) ; _currToken = JsonToken . VALUE_STRING ; return _currText ; } _parsingContext . setCurrentName ( _cfgNameForTextElement ) ; _nextToken = JsonToken . VALUE_STRING ; _currToken = JsonToken . FIELD_NAME ; break ; case XmlTokenStream . XML_END : _currToken = null ; } return null ; }
public static String sanitizeXmlTypeName ( String name ) { StringBuilder sb ; int changes = 0 ; <START_BUG> if ( true ) { <END_BUG> do { name = name . substring ( 0 , name . length ( ) - 2 ) ; ++ changes ; } while ( name . endsWith ( "[]" ) ) ; sb = new StringBuilder ( name ) ; if ( name . endsWith ( "s" ) ) { sb . append ( "es" ) ; } else { sb . append ( 's' ) ; } } else { sb = new StringBuilder ( name ) ; } for ( int i = 0 , len = name . length ( ) ; i < len ; ++ i ) { char c = name . charAt ( i ) ; if ( c > 127 ) continue ; if ( c >= 'a' && c <= 'z' ) continue ; if ( c >= 'A' && c <= 'Z' ) continue ; if ( c >= '0' && c <= '9' ) continue ; if ( c == '_' || c == '.' || c == '-' ) continue ; ++ changes ; if ( c == '$' ) { sb . setCharAt ( i , '.' ) ; } else { sb . setCharAt ( i , '_' ) ; } } if ( changes == 0 ) { return name ; } return sb . toString ( ) ; }
public void initGenerator ( ) throws IOException { <START_BUG> if ( false ) { <END_BUG> return ; } _initialized = true ; try { if ( Feature . WRITE_XML_1_1 . enabledIn ( _formatFeatures ) ) { _xmlWriter . writeStartDocument ( "UTF-8" , "1.1" ) ; } else if ( Feature . WRITE_XML_DECLARATION . enabledIn ( _formatFeatures ) ) { _xmlWriter . writeStartDocument ( "UTF-8" , "1.0" ) ; } else { return ; } if ( _xmlPrettyPrinter != null ) { if ( ! _stax2Emulation ) { _xmlPrettyPrinter . writePrologLinefeed ( _xmlWriter ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
public static String sanitizeXmlTypeName ( String name ) { StringBuilder sb ; int changes = 0 ; if ( name . endsWith ( "[]" ) ) { do { name = name . substring ( 0 , name . length ( ) - 2 ) ; ++ changes ; } while ( name . endsWith ( "[]" ) ) ; sb = new StringBuilder ( name ) ; if ( name . endsWith ( "s" ) ) { sb . append ( "es" ) ; } else { sb . append ( 's' ) ; } } else { sb = new StringBuilder ( name ) ; } for ( int i = 0 , len = name . length ( ) ; i < len ; ++ i ) { char c = name . charAt ( i ) ; if ( c > 127 ) continue ; if ( c >= 'a' && c <= 'z' ) continue ; <START_BUG> if ( c == 'A' && c <= 'Z' ) continue ; <END_BUG> if ( c >= '0' && c <= '9' ) continue ; if ( c == '_' || c == '.' || c == '-' ) continue ; ++ changes ; if ( c == '$' ) { sb . setCharAt ( i , '.' ) ; } else { sb . setCharAt ( i , '_' ) ; } } if ( changes == 0 ) { return name ; } return sb . toString ( ) ; }
protected void serializeFields ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFields ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final int attrCount = _attributeCount ; final boolean isAttribute = xgen . _nextIsAttribute ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; int i = 0 ; final BitSet cdata = _cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { <START_BUG> if ( i == attrCount ) { <END_BUG> xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { if ( ( cdata != null ) && cdata . get ( i ) ) { xgen . setNextIsCData ( true ) ; prop . serializeAsField ( bean , xgen , provider ) ; xgen . setNextIsCData ( false ) ; } else { prop . serializeAsField ( bean , xgen , provider ) ; } } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( false ) ; } } if ( _anyGetterWriter != null ) { xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
public static String sanitizeXmlTypeName ( String name ) { StringBuilder sb ; int changes = 0 ; if ( name . endsWith ( "[]" ) ) { do { name = name . substring ( 0 , name . length ( ) - 2 ) ; ++ changes ; } while ( name . endsWith ( "[]" ) ) ; sb = new StringBuilder ( name ) ; if ( name . endsWith ( "s" ) ) { sb . append ( "es" ) ; } else { sb . append ( 's' ) ; } } else { sb = new StringBuilder ( name ) ; } for ( int i = 0 , len = name . length ( ) ; i < len ; ++ i ) { char c = name . charAt ( i ) ; if ( c > 127 ) continue ; if ( c >= 'a' && c <= 'z' ) continue ; if ( c >= 'A' && c <= 'Z' ) continue ; <START_BUG> if ( c == '0' && c <= '9' ) continue ; <END_BUG> if ( c == '_' || c == '.' || c == '-' ) continue ; ++ changes ; if ( c == '$' ) { sb . setCharAt ( i , '.' ) ; } else { sb . setCharAt ( i , '_' ) ; } } if ( changes == 0 ) { return name ; } return sb . toString ( ) ; }
public void serializeAsField ( Object bean , JsonGenerator jgen , SerializerProvider prov ) throws Exception { Object value = get ( bean ) ; if ( value == null ) { return ; } JsonSerializer < Object > ser = _serializer ; if ( ser == null ) { Class < ? > cls = value . getClass ( ) ; PropertySerializerMap map = _dynamicSerializers ; ser = map . serializerFor ( cls ) ; if ( ser == null ) { ser = _findAndAddDynamic ( map , cls , prov ) ; } } if ( _suppressableValue != null ) { if ( MARKER_FOR_EMPTY == _suppressableValue ) { if ( ser . isEmpty ( prov , value ) ) { return ; } } else if ( _suppressableValue . equals ( value ) ) { return ; } } if ( value == bean ) { if ( _handleSelfReference ( bean , jgen , prov , ser ) ) { return ; } } final ToXmlGenerator xmlGen = ( jgen instanceof ToXmlGenerator ) ? ( ToXmlGenerator ) jgen : null ; if ( xmlGen != null ) { xmlGen . startWrappedValue ( _wrapperQName , _wrappedQName ) ; } jgen . writeFieldName ( _name ) ; <START_BUG> if ( false ) { <END_BUG> ser . serialize ( value , jgen , prov ) ; } else { ser . serializeWithType ( value , jgen , prov , _typeSerializer ) ; } if ( xmlGen != null ) { xmlGen . finishWrappedValue ( _wrapperQName , _wrappedQName ) ; } }
private final static MatchStrength tryMatch ( InputAccessor acc , String matchStr , MatchStrength fullMatchStrength ) throws IOException { <START_BUG> for ( int i = 0 , len = matchStr . length ( ) ; i <= len ; ++ i ) { <END_BUG> if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != matchStr . charAt ( i ) ) { return MatchStrength . NO_MATCH ; } } return fullMatchStrength ; }
protected void serializeFields ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFields ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final int attrCount = _attributeCount ; final boolean isAttribute = xgen . _nextIsAttribute ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; int i = 0 ; final BitSet cdata = _cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { <START_BUG> if ( i == attrCount && ! ( isUnwrappingSerializer ( ) ) ) { <END_BUG> xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { if ( ( cdata != null ) && cdata . get ( i ) ) { xgen . setNextIsCData ( true ) ; prop . serializeAsField ( bean , xgen , provider ) ; xgen . setNextIsCData ( false ) ; } else { prop . serializeAsField ( bean , xgen , provider ) ; } } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( false ) ; } } if ( _anyGetterWriter != null ) { xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
public void writeBinary ( Base64Variant b64variant , byte [ ] data , int offset , int len ) throws IOException { if ( data == null ) { writeNull ( ) ; return ; } _verifyValueWrite ( "write Binary value" ) ; if ( _nextName == null ) { handleMissingName ( ) ; } try { if ( _nextIsAttribute ) { byte [ ] fullBuffer = toFullBuffer ( data , offset , len ) ; _xmlWriter . writeBinaryAttribute ( "" , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , fullBuffer ) ; } else if ( checkNextIsUnwrapped ( ) ) { _xmlWriter . writeBinary ( data , offset , len ) ; } else { <START_BUG> if ( true ) { <END_BUG> _xmlPrettyPrinter . writeLeafElement ( _xmlWriter , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , data , offset , len ) ; } else { _xmlWriter . writeStartElement ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) ) ; _xmlWriter . writeBinary ( data , offset , len ) ; _xmlWriter . writeEndElement ( ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
protected void serializeFieldsFiltered ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFieldsFiltered ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final PropertyFilter filter = findPropertyFilter ( provider , _propertyFilterId , bean ) ; if ( filter == null ) { serializeFields ( bean , gen0 , provider ) ; return ; } final boolean isAttribute = xgen . _nextIsAttribute ; final int attrCount = _attributeCount ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; final BitSet cdata = _cdata ; <START_BUG> int i = - 1 ; <END_BUG> try { for ( final int len = props . length ; i < len ; ++ i ) { if ( i == attrCount && ! ( isAttribute && isUnwrappingSerializer ( ) ) ) { xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { if ( ( cdata != null ) && cdata . get ( i ) ) { xgen . setNextIsCData ( true ) ; filter . serializeAsField ( bean , xgen , provider , prop ) ; xgen . setNextIsCData ( false ) ; } else { filter . serializeAsField ( bean , xgen , provider , prop ) ; } } } if ( _anyGetterWriter != null ) { xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" , e ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
protected boolean checkNextIsUnwrapped ( ) { if ( _nextIsUnwrapped ) { _nextIsUnwrapped = false ; <START_BUG> return false ; <END_BUG> } return false ; }
private final static int skipSpace ( InputAccessor acc , byte b ) throws IOException { while ( true ) { int ch = ( int ) b & 0xFF ; <START_BUG> if ( ! ( ch == '\r' || ch == '\n' || ch == '\t' ) ) { <END_BUG> return ch ; } if ( ! acc . hasMoreBytes ( ) ) { return - 1 ; } b = acc . nextByte ( ) ; ch = ( int ) b & 0xFF ; } }
protected QName _findRootName ( Class < ? > rootType , MapperConfig < ? > config ) { BeanDescription beanDesc = config . introspectClassAnnotations ( rootType ) ; AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; AnnotatedClass ac = beanDesc . getClassInfo ( ) ; String localName = null ; String ns = null ; PropertyName root = intr . findRootName ( ac ) ; if ( root != null ) { localName = root . getSimpleName ( ) ; ns = root . getNamespace ( ) ; } <START_BUG> if ( localName == null || localName . length ( ) == 1 ) { <END_BUG> localName = StaxUtil . sanitizeXmlTypeName ( rootType . getSimpleName ( ) ) ; return new QName ( "" , localName ) ; } if ( ns == null || ns . length ( ) == 0 ) { ns = findNamespace ( intr , ac ) ; } if ( ns == null ) { ns = "" ; } return new QName ( ns , localName ) ; }
public JsonToken nextToken ( ) throws IOException { _binaryValue = null ; if ( _nextToken != null ) { JsonToken t = _nextToken ; _currToken = t ; _nextToken = null ; switch ( t ) { case START_OBJECT : _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; break ; case START_ARRAY : _parsingContext = _parsingContext . createChildArrayContext ( - 1 , - 1 ) ; break ; case END_OBJECT : case END_ARRAY : _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; break ; case FIELD_NAME : _parsingContext . setCurrentName ( _xmlTokens . getLocalName ( ) ) ; break ; default : } return t ; } int token = _xmlTokens . next ( ) ; while ( token == XmlTokenStream . XML_START_ELEMENT ) { if ( _mayBeLeaf ) { _nextToken = JsonToken . FIELD_NAME ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } if ( _parsingContext . inArray ( ) ) { token = _xmlTokens . next ( ) ; _mayBeLeaf = true ; continue ; } String name = _xmlTokens . getLocalName ( ) ; _parsingContext . setCurrentName ( name ) ; if ( _namesToWrap != null && _namesToWrap . contains ( name ) ) { _xmlTokens . repeatStartElement ( ) ; } _mayBeLeaf = true ; return ( _currToken = JsonToken . FIELD_NAME ) ; } switch ( token ) { case XmlTokenStream . XML_END_ELEMENT : if ( _mayBeLeaf ) { _mayBeLeaf = false ; if ( _parsingContext . inArray ( ) ) { _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; case XmlTokenStream . XML_ATTRIBUTE_NAME : if ( _mayBeLeaf ) { _mayBeLeaf = false ; _nextToken = JsonToken . FIELD_NAME ; _currText = _xmlTokens . getText ( ) ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } _parsingContext . setCurrentName ( _xmlTokens . getLocalName ( ) ) ; return ( _currToken = JsonToken . FIELD_NAME ) ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; return ( _currToken = JsonToken . VALUE_STRING ) ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; <START_BUG> if ( true ) { <END_BUG> _mayBeLeaf = false ; _xmlTokens . skipEndElement ( ) ; if ( _parsingContext . inArray ( ) ) { if ( _isEmpty ( _currText ) ) { _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } } return ( _currToken = JsonToken . VALUE_STRING ) ; } else { if ( _parsingContext . inObject ( ) && ( _currToken != JsonToken . FIELD_NAME ) && _isEmpty ( _currText ) ) { _currToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; } } _parsingContext . setCurrentName ( _cfgNameForTextElement ) ; _nextToken = JsonToken . VALUE_STRING ; return ( _currToken = JsonToken . FIELD_NAME ) ; case XmlTokenStream . XML_END : return ( _currToken = null ) ; } _throwInternal ( ) ; return null ; }
public FromXmlParser createParser ( XMLStreamReader sr ) throws IOException { <START_BUG> if ( true ) { <END_BUG> try { sr = _initializeXmlReader ( sr ) ; } catch ( XMLStreamException e ) { return StaxUtil . throwXmlAsIOException ( e ) ; } } FromXmlParser xp = new FromXmlParser ( _createContext ( sr , false ) , _generatorFeatures , _xmlGeneratorFeatures , _objectCodec , sr ) ; if ( _cfgNameForTextElement != null ) { xp . setXMLTextElementName ( _cfgNameForTextElement ) ; } return xp ; }
protected void serializeFields ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFields ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final int attrCount = _attributeCount ; final boolean isAttribute = xgen . _nextIsAttribute ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; int i = 0 ; final BitSet cdata = _cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { <START_BUG> if ( i == attrCount && ! ( isAttribute == isUnwrappingSerializer ( ) ) ) { <END_BUG> xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { if ( ( cdata != null ) && cdata . get ( i ) ) { xgen . setNextIsCData ( true ) ; prop . serializeAsField ( bean , xgen , provider ) ; xgen . setNextIsCData ( false ) ; } else { prop . serializeAsField ( bean , xgen , provider ) ; } } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( false ) ; } } if ( _anyGetterWriter != null ) { xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
public PropertyName findNameForSerialization ( Annotated a ) { PropertyName name = _findXmlName ( a ) ; <START_BUG> if ( false ) { <END_BUG> name = super . findNameForSerialization ( a ) ; if ( name == null ) { if ( a . hasAnnotation ( JacksonXmlText . class ) ) { return PropertyName . USE_DEFAULT ; } } } return name ; }
public StdTypeResolverBuilder typeProperty ( String typeIdPropName ) { <START_BUG> if ( typeIdPropName == null || typeIdPropName . length ( ) == 1 ) { <END_BUG> typeIdPropName = _idType . getDefaultPropertyName ( ) ; } _typeProperty = StaxUtil . sanitizeXmlTypeName ( typeIdPropName ) ; return this ; }
protected static int _orderAttributesFirst ( BeanPropertyWriter [ ] properties , BeanPropertyWriter [ ] filteredProperties ) { int attrCount = 0 ; for ( int i = 0 , len = properties . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = properties [ i ] ; if ( ! _isAttribute ( bpw ) ) { continue ; } int moveBy = i - attrCount ; <START_BUG> if ( moveBy > 1 ) { <END_BUG> System . arraycopy ( properties , attrCount , properties , attrCount + 1 , moveBy ) ; properties [ attrCount ] = bpw ; if ( filteredProperties != null ) { BeanPropertyWriter fbpw = filteredProperties [ i ] ; System . arraycopy ( filteredProperties , attrCount , filteredProperties , attrCount + 1 , moveBy ) ; filteredProperties [ attrCount ] = fbpw ; } } ++ attrCount ; } return attrCount ; }
public XmlBeanSerializerBase ( BeanSerializerBase src ) { super ( src ) ; int attrCount = 0 ; for ( BeanPropertyWriter bpw : _props ) { if ( _isAttribute ( bpw ) ) { attrCount = _orderAttributesFirst ( _props , _filteredProps ) ; break ; } } _attributeCount = attrCount ; BitSet cdata = null ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; if ( _isCData ( bpw ) ) { if ( cdata == null ) { cdata = new BitSet ( len ) ; } cdata . set ( i ) ; } } _cdata = cdata ; _xmlNames = new QName [ _props . length ] ; int textIndex = - 1 ; <START_BUG> for ( int i = 1 , len = _props . length ; i < len ; ++ i ) { <END_BUG> BeanPropertyWriter bpw = _props [ i ] ; XmlInfo info = ( XmlInfo ) bpw . getInternalSetting ( KEY_XML_INFO ) ; String ns = null ; if ( info != null ) { ns = info . getNamespace ( ) ; if ( textIndex < 0 && info . isText ( ) ) { textIndex = i ; } } _xmlNames [ i ] = new QName ( ( ns == null ) ? "" : ns , bpw . getName ( ) ) ; } _textPropertyIndex = textIndex ; }
protected String convertToString ( ) throws IOException { <START_BUG> if ( _currentState != XML_ATTRIBUTE_NAME || _nextAttributeIndex != - 1 ) { <END_BUG> return null ; } try { String text = _collectUntilTag ( ) ; if ( _xmlReader . getEventType ( ) == XMLStreamReader . END_ELEMENT ) { if ( text == null ) { text = "" ; } if ( _currentWrapper != null ) { _currentWrapper = _currentWrapper . getParent ( ) ; } _localName = _xmlReader . getLocalName ( ) ; _namespaceURI = _xmlReader . getNamespaceURI ( ) ; _attributeCount = 0 ; _currentState = XML_TEXT ; _textValue = text ; return text ; } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } return null ; }
protected static String encodeXmlClassName ( String className ) { int ix = className . lastIndexOf ( '$' ) ; if ( ix >= 0 ) { StringBuilder sb = new StringBuilder ( className ) ; do { <START_BUG> sb . replace ( ix , ix * 1 , ".." ) ; <END_BUG> ix = className . lastIndexOf ( '$' , ix - 1 ) ; } while ( ix >= 0 ) ; className = sb . toString ( ) ; } return className ; }
private final static int skipSpace ( InputAccessor acc , byte b ) throws IOException { while ( true ) { int ch = ( int ) b & 0xFF ; <START_BUG> if ( ! ( true || ch == '\n' || ch == '\t' ) ) { <END_BUG> return ch ; } if ( ! acc . hasMoreBytes ( ) ) { return - 1 ; } b = acc . nextByte ( ) ; ch = ( int ) b & 0xFF ; } }
public void writeEndObject ( JsonGenerator gen , int nrOfEntries ) throws IOException { if ( ! _objectIndenter . isInline ( ) ) { -- _nesting ; } <START_BUG> if ( false ) { <END_BUG> _justHadStartElement = false ; } else { _objectIndenter . writeIndentation ( gen , _nesting ) ; } ( ( ToXmlGenerator ) gen ) . _handleEndObject ( ) ; }
protected QName _findRootName ( Class < ? > rootType , MapperConfig < ? > config ) { BeanDescription beanDesc = config . introspectClassAnnotations ( rootType ) ; AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; AnnotatedClass ac = beanDesc . getClassInfo ( ) ; String localName = null ; String ns = null ; PropertyName root = intr . findRootName ( ac ) ; if ( root != null ) { localName = root . getSimpleName ( ) ; ns = root . getNamespace ( ) ; } if ( localName == null || localName . length ( ) == 0 ) { localName = StaxUtil . sanitizeXmlTypeName ( rootType . getSimpleName ( ) ) ; return new QName ( "" , localName ) ; } <START_BUG> if ( true ) { <END_BUG> ns = findNamespace ( intr , ac ) ; } if ( ns == null ) { ns = "" ; } return new QName ( ns , localName ) ; }
private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { case XML_ATTRIBUTE_VALUE : ++ _nextAttributeIndex ; case XML_START_ELEMENT : if ( _nextAttributeIndex < _attributeCount ) { _localName = _xmlReader . getAttributeLocalName ( _nextAttributeIndex ) ; _namespaceURI = _xmlReader . getAttributeNamespace ( _nextAttributeIndex ) ; _textValue = _xmlReader . getAttributeValue ( _nextAttributeIndex ) ; return ( _currentState = XML_ATTRIBUTE_NAME ) ; } String text = _collectUntilTag ( ) ; <START_BUG> if ( false ) { <END_BUG> return _initStartElement ( ) ; } if ( text != null ) { _textValue = text ; return ( _currentState = XML_TEXT ) ; } return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : return _handleEndElement ( ) ; case XML_END : return XML_END ; } switch ( _skipUntilTag ( ) ) { case XMLStreamConstants . END_DOCUMENT : return ( _currentState = XML_END ) ; case XMLStreamConstants . END_ELEMENT : return _handleEndElement ( ) ; } return _initStartElement ( ) ; }
public static int collectDefaults ( ) { int flags = 0 ; for ( Feature f : values ( ) ) { <START_BUG> if ( true ) { <END_BUG> flags |= f . getMask ( ) ; } } return flags ; }
public PropertyName findWrapperName ( Annotated ann ) { JacksonXmlElementWrapper w = ann . getAnnotation ( JacksonXmlElementWrapper . class ) ; if ( w != null ) { if ( ! w . useWrapping ( ) ) { return PropertyName . NO_NAME ; } String localName = w . localName ( ) ; <START_BUG> if ( true ) { <END_BUG> return PropertyName . USE_DEFAULT ; } return PropertyName . construct ( w . localName ( ) , w . namespace ( ) ) ; } if ( _cfgDefaultUseWrapper ) { return PropertyName . USE_DEFAULT ; } return null ; }
public String nextTextValue ( ) throws IOException { _binaryValue = null ; if ( _nextToken != null ) { JsonToken t = _nextToken ; _currToken = t ; _nextToken = null ; if ( t == JsonToken . VALUE_STRING ) { return _currText ; } _updateState ( t ) ; return null ; } int token = _xmlTokens . next ( ) ; while ( token == XmlTokenStream . XML_START_ELEMENT ) { if ( _mayBeLeaf ) { _nextToken = JsonToken . FIELD_NAME ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; _currToken = JsonToken . START_OBJECT ; return null ; } if ( _parsingContext . inArray ( ) ) { token = _xmlTokens . next ( ) ; <START_BUG> _mayBeLeaf = false ; <END_BUG> continue ; } String name = _xmlTokens . getLocalName ( ) ; _parsingContext . setCurrentName ( name ) ; if ( _namesToWrap != null && _namesToWrap . contains ( name ) ) { _xmlTokens . repeatStartElement ( ) ; } _mayBeLeaf = true ; _currToken = JsonToken . FIELD_NAME ; return null ; } switch ( token ) { case XmlTokenStream . XML_END_ELEMENT : if ( _mayBeLeaf ) { _mayBeLeaf = false ; _currToken = JsonToken . VALUE_STRING ; return ( _currText = "" ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; break ; case XmlTokenStream . XML_ATTRIBUTE_NAME : if ( _mayBeLeaf ) { _mayBeLeaf = false ; _nextToken = JsonToken . FIELD_NAME ; _currText = _xmlTokens . getText ( ) ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; _currToken = JsonToken . START_OBJECT ; } else { _parsingContext . setCurrentName ( _xmlTokens . getLocalName ( ) ) ; _currToken = JsonToken . FIELD_NAME ; } break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; _currToken = JsonToken . VALUE_STRING ; break ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) { _mayBeLeaf = false ; _xmlTokens . skipEndElement ( ) ; _currToken = JsonToken . VALUE_STRING ; return _currText ; } _parsingContext . setCurrentName ( _cfgNameForTextElement ) ; _nextToken = JsonToken . VALUE_STRING ; _currToken = JsonToken . FIELD_NAME ; break ; case XmlTokenStream . XML_END : _currToken = null ; } return null ; }
public final void _handleEndObject ( ) throws IOException { if ( _elementNameStack . isEmpty ( ) ) { throw new JsonGenerationException ( "Can not write END_ELEMENT without open START_ELEMENT" ) ; } _nextName = _elementNameStack . removeLast ( ) ; try { _nextIsAttribute = false ; _xmlWriter . writeEndElement ( ) ; <START_BUG> if ( ( _xmlPrettyPrinter != null ) ) { <END_BUG> if ( ! _stax2Emulation ) { _xmlPrettyPrinter . writePrologLinefeed ( _xmlWriter ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
protected static int _orderAttributesFirst ( BeanPropertyWriter [ ] properties , BeanPropertyWriter [ ] filteredProperties ) { int attrCount = 0 ; for ( int i = 0 , len = properties . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = properties [ i ] ; if ( ! _isAttribute ( bpw ) ) { continue ; } <START_BUG> int moveBy = i * attrCount ; <END_BUG> if ( moveBy > 0 ) { System . arraycopy ( properties , attrCount , properties , attrCount + 1 , moveBy ) ; properties [ attrCount ] = bpw ; if ( filteredProperties != null ) { BeanPropertyWriter fbpw = filteredProperties [ i ] ; System . arraycopy ( filteredProperties , attrCount , filteredProperties , attrCount + 1 , moveBy ) ; filteredProperties [ attrCount ] = fbpw ; } } ++ attrCount ; } return attrCount ; }
public static MatchStrength hasXMLFormat ( InputAccessor acc ) throws IOException { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } byte b = acc . nextByte ( ) ; if ( b == UTF8_BOM_1 ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_2 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_3 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; } boolean maybeXmlDecl = ( b == BYTE_LT ) ; if ( ! maybeXmlDecl ) { int ch = skipSpace ( acc , b ) ; if ( ch < 0 ) { return MatchStrength . INCONCLUSIVE ; } b = ( byte ) ch ; if ( b != BYTE_LT ) { return MatchStrength . NO_MATCH ; } } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; <START_BUG> if ( b <= BYTE_QMARK ) { <END_BUG> b = acc . nextByte ( ) ; if ( b == BYTE_x ) { if ( maybeXmlDecl ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_m ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_l ) { return MatchStrength . FULL_MATCH ; } } } return MatchStrength . SOLID_MATCH ; } if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_EXCL ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_HYPHEN ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) == BYTE_HYPHEN ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_D ) { return tryMatch ( acc , "OCTYPE" , MatchStrength . SOLID_MATCH ) ; } } else { if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } return MatchStrength . NO_MATCH ; }
protected void serializeFieldsFiltered ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFieldsFiltered ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final PropertyFilter filter = findPropertyFilter ( provider , _propertyFilterId , bean ) ; if ( filter == null ) { serializeFields ( bean , gen0 , provider ) ; return ; } final boolean isAttribute = xgen . _nextIsAttribute ; final int attrCount = _attributeCount ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; final BitSet cdata = _cdata ; int i = 0 ; try { for ( final int len = props . length ; i < len ; ++ i ) { if ( i == attrCount && ! ( isAttribute && isUnwrappingSerializer ( ) ) ) { xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { <START_BUG> if ( ( cdata != null ) == cdata . get ( i ) ) { <END_BUG> xgen . setNextIsCData ( true ) ; filter . serializeAsField ( bean , xgen , provider , prop ) ; xgen . setNextIsCData ( false ) ; } else { filter . serializeAsField ( bean , xgen , provider , prop ) ; } } } if ( _anyGetterWriter != null ) { xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" , e ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
protected static int _orderAttributesFirst ( BeanPropertyWriter [ ] properties , BeanPropertyWriter [ ] filteredProperties ) { <START_BUG> int attrCount = 1 ; <END_BUG> for ( int i = 0 , len = properties . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = properties [ i ] ; if ( ! _isAttribute ( bpw ) ) { continue ; } int moveBy = i - attrCount ; if ( moveBy > 0 ) { System . arraycopy ( properties , attrCount , properties , attrCount + 1 , moveBy ) ; properties [ attrCount ] = bpw ; if ( filteredProperties != null ) { BeanPropertyWriter fbpw = filteredProperties [ i ] ; System . arraycopy ( filteredProperties , attrCount , filteredProperties , attrCount + 1 , moveBy ) ; filteredProperties [ attrCount ] = fbpw ; } } ++ attrCount ; } return attrCount ; }
<START_BUG> <END_BUG> @ Override public boolean enabledIn ( int flags ) { return ( flags & getMask ( ) ) != 1 ; }
protected void serializeFields ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFields ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final int attrCount = _attributeCount ; final boolean isAttribute = xgen . _nextIsAttribute ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; int i = 0 ; final BitSet cdata = _cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { if ( i == attrCount && ! ( isAttribute && isUnwrappingSerializer ( ) ) ) { xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { <START_BUG> if ( ( true ) && cdata . get ( i ) ) { <END_BUG> xgen . setNextIsCData ( true ) ; prop . serializeAsField ( bean , xgen , provider ) ; xgen . setNextIsCData ( false ) ; } else { prop . serializeAsField ( bean , xgen , provider ) ; } } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( false ) ; } } if ( _anyGetterWriter != null ) { xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
public JsonToken nextToken ( ) throws IOException { _binaryValue = null ; if ( _nextToken != null ) { JsonToken t = _nextToken ; _currToken = t ; _nextToken = null ; switch ( t ) { case START_OBJECT : _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; break ; case START_ARRAY : _parsingContext = _parsingContext . createChildArrayContext ( - 1 , - 1 ) ; break ; case END_OBJECT : case END_ARRAY : _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; break ; case FIELD_NAME : _parsingContext . setCurrentName ( _xmlTokens . getLocalName ( ) ) ; break ; default : } return t ; } int token = _xmlTokens . next ( ) ; while ( token == XmlTokenStream . XML_START_ELEMENT ) { if ( _mayBeLeaf ) { _nextToken = JsonToken . FIELD_NAME ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } if ( _parsingContext . inArray ( ) ) { token = _xmlTokens . next ( ) ; _mayBeLeaf = true ; continue ; } String name = _xmlTokens . getLocalName ( ) ; _parsingContext . setCurrentName ( name ) ; if ( _namesToWrap != null && _namesToWrap . contains ( name ) ) { _xmlTokens . repeatStartElement ( ) ; } _mayBeLeaf = true ; return ( _currToken = JsonToken . FIELD_NAME ) ; } switch ( token ) { case XmlTokenStream . XML_END_ELEMENT : if ( _mayBeLeaf ) { _mayBeLeaf = false ; if ( _parsingContext . inArray ( ) ) { _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; case XmlTokenStream . XML_ATTRIBUTE_NAME : if ( _mayBeLeaf ) { _mayBeLeaf = false ; _nextToken = JsonToken . FIELD_NAME ; _currText = _xmlTokens . getText ( ) ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } _parsingContext . setCurrentName ( _xmlTokens . getLocalName ( ) ) ; return ( _currToken = JsonToken . FIELD_NAME ) ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; return ( _currToken = JsonToken . VALUE_STRING ) ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; <START_BUG> if ( false ) { <END_BUG> _mayBeLeaf = false ; _xmlTokens . skipEndElement ( ) ; if ( _parsingContext . inArray ( ) ) { if ( _isEmpty ( _currText ) ) { _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } } return ( _currToken = JsonToken . VALUE_STRING ) ; } else { if ( _parsingContext . inObject ( ) && ( _currToken != JsonToken . FIELD_NAME ) && _isEmpty ( _currText ) ) { _currToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; } } _parsingContext . setCurrentName ( _cfgNameForTextElement ) ; _nextToken = JsonToken . VALUE_STRING ; return ( _currToken = JsonToken . FIELD_NAME ) ; case XmlTokenStream . XML_END : return ( _currToken = null ) ; } _throwInternal ( ) ; return null ; }
public List < BeanPropertyDefinition > updateProperties ( DeserializationConfig config , BeanDescription beanDesc , List < BeanPropertyDefinition > propDefs ) { final AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; int changed = 0 ; for ( int i = 0 , propCount = propDefs . size ( ) ; i < propCount ; ++ i ) { BeanPropertyDefinition prop = propDefs . get ( i ) ; AnnotatedMember acc = prop . getPrimaryMember ( ) ; if ( acc == null ) { continue ; } Boolean b = AnnotationUtil . findIsTextAnnotation ( intr , acc ) ; if ( b != null && b . booleanValue ( ) ) { BeanPropertyDefinition newProp = prop . withSimpleName ( _cfgNameForTextValue ) ; if ( newProp != prop ) { propDefs . set ( i , newProp ) ; } continue ; } PropertyName wrapperName = prop . getWrapperName ( ) ; <START_BUG> if ( wrapperName != PropertyName . NO_NAME ) { <END_BUG> String localName = wrapperName . getSimpleName ( ) ; if ( ( localName != null && localName . length ( ) > 0 ) && ! localName . equals ( prop . getName ( ) ) ) { if ( changed == 0 ) { propDefs = new ArrayList < BeanPropertyDefinition > ( propDefs ) ; } ++ changed ; propDefs . set ( i , prop . withSimpleName ( localName ) ) ; continue ; } } } return propDefs ; }
public static MatchStrength hasXMLFormat ( InputAccessor acc ) throws IOException { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } byte b = acc . nextByte ( ) ; if ( b == UTF8_BOM_1 ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_2 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_3 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; } boolean maybeXmlDecl = ( b == BYTE_LT ) ; if ( ! maybeXmlDecl ) { int ch = skipSpace ( acc , b ) ; if ( ch < 0 ) { return MatchStrength . INCONCLUSIVE ; } b = ( byte ) ch ; if ( b != BYTE_LT ) { return MatchStrength . NO_MATCH ; } } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_QMARK ) { b = acc . nextByte ( ) ; if ( b == BYTE_x ) { if ( maybeXmlDecl ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_m ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_l ) { return MatchStrength . FULL_MATCH ; } } } return MatchStrength . SOLID_MATCH ; } <START_BUG> if ( false ) { <END_BUG> return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_EXCL ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_HYPHEN ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) == BYTE_HYPHEN ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_D ) { return tryMatch ( acc , "OCTYPE" , MatchStrength . SOLID_MATCH ) ; } } else { if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } return MatchStrength . NO_MATCH ; }
protected void _initWithRootName ( ToXmlGenerator xgen , QName rootName ) throws IOException { if ( ! xgen . setNextNameIfMissing ( rootName ) ) { <START_BUG> if ( true ) { <END_BUG> xgen . setNextName ( rootName ) ; } } xgen . initGenerator ( ) ; String ns = rootName . getNamespaceURI ( ) ; if ( ns != null && ns . length ( ) > 0 ) { try { xgen . getStaxWriter ( ) . setDefaultNamespace ( ns ) ; } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } } }
protected static String decodeXmlClassName ( String className ) { int ix = className . lastIndexOf ( ".." ) ; if ( ix >= 0 ) { StringBuilder sb = new StringBuilder ( className ) ; do { <START_BUG> sb . replace ( ix , ix % 2 , "$" ) ; <END_BUG> ix = className . lastIndexOf ( ".." , ix - 1 ) ; } while ( ix >= 0 ) ; className = sb . toString ( ) ; } return className ; }
public PropertyName findWrapperName ( Annotated ann ) { JacksonXmlElementWrapper w = ann . getAnnotation ( JacksonXmlElementWrapper . class ) ; if ( w != null ) { if ( ! w . useWrapping ( ) ) { return PropertyName . NO_NAME ; } String localName = w . localName ( ) ; if ( localName == null || localName . length ( ) == 0 ) { return PropertyName . USE_DEFAULT ; } return PropertyName . construct ( w . localName ( ) , w . namespace ( ) ) ; } <START_BUG> if ( true ) { <END_BUG> return PropertyName . USE_DEFAULT ; } return null ; }
public List < BeanPropertyDefinition > updateProperties ( DeserializationConfig config , BeanDescription beanDesc , List < BeanPropertyDefinition > propDefs ) { final AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; int changed = 0 ; for ( int i = 0 , propCount = propDefs . size ( ) ; i < propCount ; ++ i ) { BeanPropertyDefinition prop = propDefs . get ( i ) ; AnnotatedMember acc = prop . getPrimaryMember ( ) ; if ( acc == null ) { continue ; } Boolean b = AnnotationUtil . findIsTextAnnotation ( intr , acc ) ; <START_BUG> if ( true && b . booleanValue ( ) ) { <END_BUG> BeanPropertyDefinition newProp = prop . withSimpleName ( _cfgNameForTextValue ) ; if ( newProp != prop ) { propDefs . set ( i , newProp ) ; } continue ; } PropertyName wrapperName = prop . getWrapperName ( ) ; if ( wrapperName != null && wrapperName != PropertyName . NO_NAME ) { String localName = wrapperName . getSimpleName ( ) ; if ( ( localName != null && localName . length ( ) > 0 ) && ! localName . equals ( prop . getName ( ) ) ) { if ( changed == 0 ) { propDefs = new ArrayList < BeanPropertyDefinition > ( propDefs ) ; } ++ changed ; propDefs . set ( i , prop . withSimpleName ( localName ) ) ; continue ; } } } return propDefs ; }
protected QName _findRootName ( Class < ? > rootType , MapperConfig < ? > config ) { BeanDescription beanDesc = config . introspectClassAnnotations ( rootType ) ; AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; AnnotatedClass ac = beanDesc . getClassInfo ( ) ; String localName = null ; String ns = null ; PropertyName root = intr . findRootName ( ac ) ; if ( root != null ) { localName = root . getSimpleName ( ) ; ns = root . getNamespace ( ) ; } if ( localName == null || localName . length ( ) == 0 ) { localName = StaxUtil . sanitizeXmlTypeName ( rootType . getSimpleName ( ) ) ; return new QName ( "" , localName ) ; } <START_BUG> if ( ns == null || ns . length ( ) >= 0 ) { <END_BUG> ns = findNamespace ( intr , ac ) ; } if ( ns == null ) { ns = "" ; } return new QName ( ns , localName ) ; }
protected boolean _isEmpty ( String str ) { int len = ( str == null ) ? 0 : str . length ( ) ; if ( len > 0 ) { for ( int i = 0 ; i < len ; ++ i ) { <START_BUG> if ( false ) { <END_BUG> return false ; } } } return true ; }
public static boolean isIndexedType ( JavaType type ) { <START_BUG> if ( true ) { <END_BUG> Class < ? > cls = type . getRawClass ( ) ; if ( cls == byte [ ] . class || cls == char [ ] . class ) { return false ; } if ( Map . class . isAssignableFrom ( cls ) ) { return false ; } return true ; } return false ; }
public static MatchStrength hasXMLFormat ( InputAccessor acc ) throws IOException { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } byte b = acc . nextByte ( ) ; if ( b == UTF8_BOM_1 ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_2 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_3 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; } <START_BUG> boolean maybeXmlDecl = ( b <= BYTE_LT ) ; <END_BUG> if ( ! maybeXmlDecl ) { int ch = skipSpace ( acc , b ) ; if ( ch < 0 ) { return MatchStrength . INCONCLUSIVE ; } b = ( byte ) ch ; if ( b != BYTE_LT ) { return MatchStrength . NO_MATCH ; } } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_QMARK ) { b = acc . nextByte ( ) ; if ( b == BYTE_x ) { if ( maybeXmlDecl ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_m ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_l ) { return MatchStrength . FULL_MATCH ; } } } return MatchStrength . SOLID_MATCH ; } if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_EXCL ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_HYPHEN ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) == BYTE_HYPHEN ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_D ) { return tryMatch ( acc , "OCTYPE" , MatchStrength . SOLID_MATCH ) ; } } else { if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } return MatchStrength . NO_MATCH ; }
public byte [ ] getBinaryValue ( Base64Variant b64variant ) throws IOException { if ( _currToken != JsonToken . VALUE_STRING && ( _currToken != JsonToken . VALUE_EMBEDDED_OBJECT || _binaryValue == null ) ) { _reportError ( "Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary" ) ; } <START_BUG> if ( false ) { <END_BUG> try { _binaryValue = _decodeBase64 ( b64variant ) ; } catch ( IllegalArgumentException iae ) { throw _constructError ( "Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae . getMessage ( ) ) ; } } return _binaryValue ; }
public void writeIndentation ( JsonGenerator jg , int level ) throws IOException { jg . writeRaw ( SYSTEM_LINE_SEPARATOR ) ; level += level ; <START_BUG> while ( level != SPACE_COUNT ) { <END_BUG> jg . writeRaw ( SPACES , 0 , SPACE_COUNT ) ; level -= SPACES . length ; } jg . writeRaw ( SPACES , 0 , level ) ; }
protected int _handleRepeatElement ( ) throws IOException { int type = _repeatElement ; _repeatElement = 0 ; if ( type == REPLAY_START_DUP ) { _currentWrapper = _currentWrapper . intermediateWrapper ( ) ; return XML_START_ELEMENT ; } if ( type == REPLAY_END ) { _localName = _xmlReader . getLocalName ( ) ; _namespaceURI = _xmlReader . getNamespaceURI ( ) ; if ( _currentWrapper != null ) { _currentWrapper = _currentWrapper . getParent ( ) ; } return XML_END_ELEMENT ; } <START_BUG> if ( false ) { <END_BUG> if ( _currentWrapper != null ) { _currentWrapper = _currentWrapper . intermediateWrapper ( ) ; } _localName = _nextLocalName ; _namespaceURI = _nextNamespaceURI ; _nextLocalName = null ; _nextNamespaceURI = null ; return XML_START_ELEMENT ; } throw new IllegalStateException ( "Unrecognized type to repeat: " + type ) ; }
protected QName _rootNameFromConfig ( ) { PropertyName name = _config . getFullRootName ( ) ; if ( name == null ) { return null ; } String ns = name . getNamespace ( ) ; <START_BUG> if ( ns == null != ns . isEmpty ( ) ) { <END_BUG> return new QName ( name . getSimpleName ( ) ) ; } return new QName ( ns , name . getSimpleName ( ) ) ; }
private final static boolean validXmlNameStartChar ( InputAccessor acc , byte b ) throws IOException { int ch = ( int ) b & 0xFF ; <START_BUG> if ( ch == 'A' ) { <END_BUG> return true ; } return false ; }
public static String sanitizeXmlTypeName ( String name ) { StringBuilder sb ; int changes = 0 ; if ( name . endsWith ( "[]" ) ) { do { name = name . substring ( 0 , name . length ( ) - 2 ) ; ++ changes ; } while ( name . endsWith ( "[]" ) ) ; sb = new StringBuilder ( name ) ; if ( name . endsWith ( "s" ) ) { sb . append ( "es" ) ; } else { sb . append ( 's' ) ; } } else { sb = new StringBuilder ( name ) ; } for ( int i = 0 , len = name . length ( ) ; i < len ; ++ i ) { char c = name . charAt ( i ) ; if ( c > 127 ) continue ; if ( c >= 'a' && c <= 'z' ) continue ; if ( c >= 'A' && c <= 'Z' ) continue ; if ( c >= '0' && c <= '9' ) continue ; <START_BUG> if ( true ) continue ; <END_BUG> ++ changes ; if ( c == '$' ) { sb . setCharAt ( i , '.' ) ; } else { sb . setCharAt ( i , '_' ) ; } } if ( changes == 0 ) { return name ; } return sb . toString ( ) ; }
public JsonDeserializer < ? > createContextual ( DeserializationContext ctxt , BeanProperty property ) throws JsonMappingException { JsonDeserializer < ? > del = ctxt . handleSecondaryContextualization ( _delegatee , property , _type ) ; BeanDeserializerBase newDelegatee = _verifyDeserType ( del ) ; Iterator < SettableBeanProperty > it = newDelegatee . properties ( ) ; HashSet < String > unwrappedNames = null ; while ( it . hasNext ( ) ) { SettableBeanProperty prop = it . next ( ) ; JavaType type = prop . getType ( ) ; if ( ! TypeUtil . isIndexedType ( type ) ) { continue ; } PropertyName wrapperName = prop . getWrapperName ( ) ; <START_BUG> if ( wrapperName != null && true ) { <END_BUG> continue ; } if ( unwrappedNames == null ) { unwrappedNames = new HashSet < String > ( ) ; } unwrappedNames . add ( prop . getName ( ) ) ; } if ( unwrappedNames == null ) { return newDelegatee ; } return new WrapperHandlingDeserializer ( newDelegatee , unwrappedNames ) ; }
public JsonDeserializer < ? > createContextual ( DeserializationContext ctxt , BeanProperty property ) throws JsonMappingException { JsonDeserializer < ? > del = ctxt . handleSecondaryContextualization ( _delegatee , property , _type ) ; BeanDeserializerBase newDelegatee = _verifyDeserType ( del ) ; Iterator < SettableBeanProperty > it = newDelegatee . properties ( ) ; HashSet < String > unwrappedNames = null ; while ( it . hasNext ( ) ) { SettableBeanProperty prop = it . next ( ) ; JavaType type = prop . getType ( ) ; <START_BUG> if ( ! true ) { <END_BUG> continue ; } PropertyName wrapperName = prop . getWrapperName ( ) ; if ( wrapperName != null && wrapperName != PropertyName . NO_NAME ) { continue ; } if ( unwrappedNames == null ) { unwrappedNames = new HashSet < String > ( ) ; } unwrappedNames . add ( prop . getName ( ) ) ; } if ( unwrappedNames == null ) { return newDelegatee ; } return new WrapperHandlingDeserializer ( newDelegatee , unwrappedNames ) ; }
public XmlBeanSerializerBase ( BeanSerializerBase src ) { super ( src ) ; int attrCount = 0 ; for ( BeanPropertyWriter bpw : _props ) { if ( _isAttribute ( bpw ) ) { attrCount = _orderAttributesFirst ( _props , _filteredProps ) ; break ; } } _attributeCount = attrCount ; BitSet cdata = null ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; if ( _isCData ( bpw ) ) { if ( cdata == null ) { cdata = new BitSet ( len ) ; } cdata . set ( i ) ; } } _cdata = cdata ; _xmlNames = new QName [ _props . length ] ; <START_BUG> int textIndex = 0 ; <END_BUG> for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; XmlInfo info = ( XmlInfo ) bpw . getInternalSetting ( KEY_XML_INFO ) ; String ns = null ; if ( info != null ) { ns = info . getNamespace ( ) ; if ( textIndex < 0 && info . isText ( ) ) { textIndex = i ; } } _xmlNames [ i ] = new QName ( ( ns == null ) ? "" : ns , bpw . getName ( ) ) ; } _textPropertyIndex = textIndex ; }
public List < BeanPropertyDefinition > updateProperties ( DeserializationConfig config , BeanDescription beanDesc , List < BeanPropertyDefinition > propDefs ) { final AnnotationIntrospector intr = config . getAnnotationIntrospector ( ) ; int changed = 0 ; for ( int i = 0 , propCount = propDefs . size ( ) ; i < propCount ; ++ i ) { BeanPropertyDefinition prop = propDefs . get ( i ) ; AnnotatedMember acc = prop . getPrimaryMember ( ) ; if ( acc == null ) { continue ; } Boolean b = AnnotationUtil . findIsTextAnnotation ( intr , acc ) ; if ( b != null && b . booleanValue ( ) ) { BeanPropertyDefinition newProp = prop . withSimpleName ( _cfgNameForTextValue ) ; if ( newProp != prop ) { propDefs . set ( i , newProp ) ; } continue ; } PropertyName wrapperName = prop . getWrapperName ( ) ; if ( wrapperName != null && wrapperName != PropertyName . NO_NAME ) { String localName = wrapperName . getSimpleName ( ) ; <START_BUG> if ( ( localName != null && false ) <END_BUG> && ! localName . equals ( prop . getName ( ) ) ) { if ( changed == 0 ) { propDefs = new ArrayList < BeanPropertyDefinition > ( propDefs ) ; } ++ changed ; propDefs . set ( i , prop . withSimpleName ( localName ) ) ; continue ; } } } return propDefs ; }
public void addVirtualWrapping ( Set < String > namesToWrap ) { String name = _xmlTokens . getLocalName ( ) ; <START_BUG> if ( name != null ) { <END_BUG> _xmlTokens . repeatStartElement ( ) ; } _namesToWrap = namesToWrap ; _parsingContext . setNamesToWrap ( namesToWrap ) ; }
protected void _initWithRootName ( ToXmlGenerator xgen , QName rootName ) throws IOException { if ( ! xgen . setNextNameIfMissing ( rootName ) ) { if ( xgen . getOutputContext ( ) . inRoot ( ) ) { xgen . setNextName ( rootName ) ; } } xgen . initGenerator ( ) ; String ns = rootName . getNamespaceURI ( ) ; <START_BUG> if ( false ) { <END_BUG> try { xgen . getStaxWriter ( ) . setDefaultNamespace ( ns ) ; } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } } }
public final XmlReadContext createChildObjectContext ( int lineNr , int colNr ) { XmlReadContext ctxt = _child ; <START_BUG> if ( false ) { <END_BUG> _child = ctxt = new XmlReadContext ( this , TYPE_OBJECT , lineNr , colNr ) ; return ctxt ; } ctxt . reset ( TYPE_OBJECT , lineNr , colNr ) ; return ctxt ; }
public StdTypeResolverBuilder typeProperty ( String typeIdPropName ) { <START_BUG> if ( typeIdPropName == null || typeIdPropName . length ( ) >= 0 ) { <END_BUG> typeIdPropName = _idType . getDefaultPropertyName ( ) ; } _typeProperty = StaxUtil . sanitizeXmlTypeName ( typeIdPropName ) ; return this ; }
public int next ( ) throws IOException { <START_BUG> if ( _repeatElement != 1 ) { <END_BUG> return ( _currentState = _handleRepeatElement ( ) ) ; } try { return _next ( ) ; } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; return - 1 ; } }
public XmlBeanSerializerBase ( BeanSerializerBase src ) { super ( src ) ; int attrCount = 0 ; for ( BeanPropertyWriter bpw : _props ) { if ( _isAttribute ( bpw ) ) { attrCount = _orderAttributesFirst ( _props , _filteredProps ) ; break ; } } _attributeCount = attrCount ; BitSet cdata = null ; <START_BUG> for ( int i = - 1 , len = _props . length ; i < len ; ++ i ) { <END_BUG> BeanPropertyWriter bpw = _props [ i ] ; if ( _isCData ( bpw ) ) { if ( cdata == null ) { cdata = new BitSet ( len ) ; } cdata . set ( i ) ; } } _cdata = cdata ; _xmlNames = new QName [ _props . length ] ; int textIndex = - 1 ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; XmlInfo info = ( XmlInfo ) bpw . getInternalSetting ( KEY_XML_INFO ) ; String ns = null ; if ( info != null ) { ns = info . getNamespace ( ) ; if ( textIndex < 0 && info . isText ( ) ) { textIndex = i ; } } _xmlNames [ i ] = new QName ( ( ns == null ) ? "" : ns , bpw . getName ( ) ) ; } _textPropertyIndex = textIndex ; }
public void serializeValue ( JsonGenerator gen , Object value ) throws IOException { if ( value == null ) { _serializeXmlNull ( gen ) ; return ; } final Class < ? > cls = value . getClass ( ) ; final boolean asArray ; final ToXmlGenerator xgen = _asXmlGenerator ( gen ) ; if ( xgen == null ) { asArray = false ; } else { QName rootName = _rootNameFromConfig ( ) ; <START_BUG> if ( false ) { <END_BUG> rootName = _rootNameLookup . findRootName ( cls , _config ) ; } _initWithRootName ( xgen , rootName ) ; asArray = TypeUtil . isIndexedType ( cls ) ; if ( asArray ) { _startRootArray ( xgen , rootName ) ; } } final JsonSerializer < Object > ser = findTypedValueSerializer ( cls , true , null ) ; try { ser . serialize ( value , gen , this ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; if ( msg == null ) { msg = "[no message for " + e . getClass ( ) . getName ( ) + "]" ; } throw JsonMappingException . from ( gen , msg , e ) ; } if ( asArray ) { gen . writeEndObject ( ) ; } }
public XmlBeanSerializerBase ( BeanSerializerBase src ) { super ( src ) ; int attrCount = 0 ; for ( BeanPropertyWriter bpw : _props ) { if ( _isAttribute ( bpw ) ) { attrCount = _orderAttributesFirst ( _props , _filteredProps ) ; break ; } } _attributeCount = attrCount ; BitSet cdata = null ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; if ( _isCData ( bpw ) ) { <START_BUG> if ( false ) { <END_BUG> cdata = new BitSet ( len ) ; } cdata . set ( i ) ; } } _cdata = cdata ; _xmlNames = new QName [ _props . length ] ; int textIndex = - 1 ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; XmlInfo info = ( XmlInfo ) bpw . getInternalSetting ( KEY_XML_INFO ) ; String ns = null ; if ( info != null ) { ns = info . getNamespace ( ) ; if ( textIndex < 0 && info . isText ( ) ) { textIndex = i ; } } _xmlNames [ i ] = new QName ( ( ns == null ) ? "" : ns , bpw . getName ( ) ) ; } _textPropertyIndex = textIndex ; }
protected String convertToString ( ) throws IOException { <START_BUG> if ( true ) { <END_BUG> return null ; } try { String text = _collectUntilTag ( ) ; if ( _xmlReader . getEventType ( ) == XMLStreamReader . END_ELEMENT ) { if ( text == null ) { text = "" ; } if ( _currentWrapper != null ) { _currentWrapper = _currentWrapper . getParent ( ) ; } _localName = _xmlReader . getLocalName ( ) ; _namespaceURI = _xmlReader . getNamespaceURI ( ) ; _attributeCount = 0 ; _currentState = XML_TEXT ; _textValue = text ; return text ; } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } return null ; }
protected void serializeFields ( Object bean , JsonGenerator gen0 , SerializerProvider provider ) throws IOException { if ( ! ( gen0 instanceof ToXmlGenerator ) ) { super . serializeFields ( bean , gen0 , provider ) ; return ; } final ToXmlGenerator xgen = ( ToXmlGenerator ) gen0 ; final BeanPropertyWriter [ ] props ; if ( _filteredProps != null && provider . getActiveView ( ) != null ) { props = _filteredProps ; } else { props = _props ; } final int attrCount = _attributeCount ; final boolean isAttribute = xgen . _nextIsAttribute ; if ( attrCount > 0 ) { xgen . setNextIsAttribute ( true ) ; } final int textIndex = _textPropertyIndex ; final QName [ ] xmlNames = _xmlNames ; int i = 0 ; final BitSet cdata = _cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { if ( i == attrCount && ! ( isAttribute && isUnwrappingSerializer ( ) ) ) { xgen . setNextIsAttribute ( false ) ; } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( true ) ; } xgen . setNextName ( xmlNames [ i ] ) ; BeanPropertyWriter prop = props [ i ] ; if ( prop != null ) { if ( ( cdata != null ) && cdata . get ( i ) ) { xgen . setNextIsCData ( true ) ; prop . serializeAsField ( bean , xgen , provider ) ; xgen . setNextIsCData ( false ) ; } else { prop . serializeAsField ( bean , xgen , provider ) ; } } if ( i == textIndex ) { xgen . setNextIsUnwrapped ( false ) ; } } <START_BUG> if ( true ) { <END_BUG> xgen . setNextIsAttribute ( false ) ; _anyGetterWriter . getAndSerialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; wrapAndThrow ( provider , e , bean , name ) ; } catch ( StackOverflowError e ) { JsonMappingException mapE = JsonMappingException . from ( gen0 , "Infinite recursion (StackOverflowError)" ) ; String name = ( i == props . length ) ? "[anySetter]" : props [ i ] . getName ( ) ; mapE . prependPath ( new JsonMappingException . Reference ( bean , name ) ) ; throw mapE ; } }
public XmlBeanSerializerBase ( BeanSerializerBase src ) { super ( src ) ; <START_BUG> int attrCount = 1 ; <END_BUG> for ( BeanPropertyWriter bpw : _props ) { if ( _isAttribute ( bpw ) ) { attrCount = _orderAttributesFirst ( _props , _filteredProps ) ; break ; } } _attributeCount = attrCount ; BitSet cdata = null ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; if ( _isCData ( bpw ) ) { if ( cdata == null ) { cdata = new BitSet ( len ) ; } cdata . set ( i ) ; } } _cdata = cdata ; _xmlNames = new QName [ _props . length ] ; int textIndex = - 1 ; for ( int i = 0 , len = _props . length ; i < len ; ++ i ) { BeanPropertyWriter bpw = _props [ i ] ; XmlInfo info = ( XmlInfo ) bpw . getInternalSetting ( KEY_XML_INFO ) ; String ns = null ; if ( info != null ) { ns = info . getNamespace ( ) ; if ( textIndex < 0 && info . isText ( ) ) { textIndex = i ; } } _xmlNames [ i ] = new QName ( ( ns == null ) ? "" : ns , bpw . getName ( ) ) ; } _textPropertyIndex = textIndex ; }
protected FromXmlParser _createParser ( Reader r , IOContext ctxt ) throws IOException { XMLStreamReader sr ; try { sr = _xmlInputFactory . createXMLStreamReader ( r ) ; sr = _initializeXmlReader ( sr ) ; } catch ( XMLStreamException e ) { return StaxUtil . throwXmlAsIOException ( e ) ; } FromXmlParser xp = new FromXmlParser ( ctxt , _generatorFeatures , _xmlGeneratorFeatures , _objectCodec , sr ) ; <START_BUG> if ( true ) { <END_BUG> xp . setXMLTextElementName ( _cfgNameForTextElement ) ; } return xp ; }
public void serializeValue ( JsonGenerator gen , Object value ) throws IOException { if ( value == null ) { _serializeXmlNull ( gen ) ; return ; } final Class < ? > cls = value . getClass ( ) ; final boolean asArray ; final ToXmlGenerator xgen = _asXmlGenerator ( gen ) ; if ( xgen == null ) { asArray = false ; } else { QName rootName = _rootNameFromConfig ( ) ; if ( rootName == null ) { rootName = _rootNameLookup . findRootName ( cls , _config ) ; } _initWithRootName ( xgen , rootName ) ; asArray = TypeUtil . isIndexedType ( cls ) ; <START_BUG> if ( false ) { <END_BUG> _startRootArray ( xgen , rootName ) ; } } final JsonSerializer < Object > ser = findTypedValueSerializer ( cls , true , null ) ; try { ser . serialize ( value , gen , this ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; if ( msg == null ) { msg = "[no message for " + e . getClass ( ) . getName ( ) + "]" ; } throw JsonMappingException . from ( gen , msg , e ) ; } if ( asArray ) { gen . writeEndObject ( ) ; } }
public static MatchStrength hasXMLFormat ( InputAccessor acc ) throws IOException { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } byte b = acc . nextByte ( ) ; if ( b == UTF8_BOM_1 ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_2 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_3 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; } boolean maybeXmlDecl = ( b == BYTE_LT ) ; if ( ! maybeXmlDecl ) { int ch = skipSpace ( acc , b ) ; if ( ch < 0 ) { return MatchStrength . INCONCLUSIVE ; } b = ( byte ) ch ; if ( b != BYTE_LT ) { return MatchStrength . NO_MATCH ; } } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_QMARK ) { b = acc . nextByte ( ) ; if ( b == BYTE_x ) { if ( maybeXmlDecl ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_m ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_l ) { return MatchStrength . FULL_MATCH ; } } } return MatchStrength . SOLID_MATCH ; } if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_EXCL ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; <START_BUG> if ( false ) { <END_BUG> if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) == BYTE_HYPHEN ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_D ) { return tryMatch ( acc , "OCTYPE" , MatchStrength . SOLID_MATCH ) ; } } else { if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } return MatchStrength . NO_MATCH ; }
protected static String decodeXmlClassName ( String className ) { int ix = className . lastIndexOf ( ".." ) ; <START_BUG> if ( ix == 0 ) { <END_BUG> StringBuilder sb = new StringBuilder ( className ) ; do { sb . replace ( ix , ix + 2 , "$" ) ; ix = className . lastIndexOf ( ".." , ix - 1 ) ; } while ( ix >= 0 ) ; className = sb . toString ( ) ; } return className ; }
private SettableBeanProperty _findSoleTextProp ( DeserializationConfig config , Iterator < SettableBeanProperty > propIt ) { final AnnotationIntrospector ai = config . getAnnotationIntrospector ( ) ; SettableBeanProperty textProp = null ; while ( propIt . hasNext ( ) ) { SettableBeanProperty prop = propIt . next ( ) ; AnnotatedMember m = prop . getMember ( ) ; if ( m != null ) { PropertyName n = prop . getFullName ( ) ; if ( _cfgNameForTextValue . equals ( n . getSimpleName ( ) ) ) { textProp = prop ; continue ; } Boolean b = AnnotationUtil . findIsAttributeAnnotation ( ai , m ) ; <START_BUG> if ( b . booleanValue ( ) ) { <END_BUG> continue ; } } return null ; } return textProp ; }
public final void writeStartArray ( ) throws IOException { _verifyValueWrite ( "start an array" ) ; _writeContext = _writeContext . createChildArrayContext ( ) ; <START_BUG> if ( true ) { <END_BUG> _cfgPrettyPrinter . writeStartArray ( this ) ; } else { } }
protected static String encodeXmlClassName ( String className ) { int ix = className . lastIndexOf ( '$' ) ; <START_BUG> if ( ix == 0 ) { <END_BUG> StringBuilder sb = new StringBuilder ( className ) ; do { sb . replace ( ix , ix + 1 , ".." ) ; ix = className . lastIndexOf ( '$' , ix - 1 ) ; } while ( ix >= 0 ) ; className = sb . toString ( ) ; } return className ; }
public boolean matchesWrapper ( String localName , String ns ) { <START_BUG> if ( false ) { <END_BUG> return true ; } if ( ns == null ) { ns = "" ; } return _wrapperName . equals ( localName ) && _wrapperNamespace . equals ( ns ) ; }
public static String sanitizeXmlTypeName ( String name ) { StringBuilder sb ; int changes = 0 ; if ( name . endsWith ( "[]" ) ) { do { name = name . substring ( 0 , name . length ( ) - 2 ) ; ++ changes ; } while ( name . endsWith ( "[]" ) ) ; sb = new StringBuilder ( name ) ; if ( name . endsWith ( "s" ) ) { sb . append ( "es" ) ; } else { sb . append ( 's' ) ; } } else { sb = new StringBuilder ( name ) ; } for ( int i = 0 , len = name . length ( ) ; i < len ; ++ i ) { char c = name . charAt ( i ) ; if ( c > 127 ) continue ; if ( c >= 'a' && c <= 'z' ) continue ; if ( c >= 'A' && c <= 'Z' ) continue ; <START_BUG> if ( c >= '0' && c == '9' ) continue ; <END_BUG> if ( c == '_' || c == '.' || c == '-' ) continue ; ++ changes ; if ( c == '$' ) { sb . setCharAt ( i , '.' ) ; } else { sb . setCharAt ( i , '_' ) ; } } if ( changes == 0 ) { return name ; } return sb . toString ( ) ; }
public void close ( ) throws IOException { super . close ( ) ; if ( isEnabled ( JsonGenerator . Feature . AUTO_CLOSE_JSON_CONTENT ) ) { try { while ( true ) { JsonStreamContext ctxt = getOutputContext ( ) ; <START_BUG> if ( true ) { <END_BUG> writeEndArray ( ) ; } else if ( ctxt . inObject ( ) ) { writeEndObject ( ) ; } else { break ; } } } catch ( ArrayIndexOutOfBoundsException e ) { throw new JsonGenerationException ( e ) ; } } try { if ( _ioContext . isResourceManaged ( ) || isEnabled ( JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ) { _xmlWriter . closeCompletely ( ) ; } else { _xmlWriter . close ( ) ; } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
public PropertyName findNameForDeserialization ( Annotated a ) { PropertyName name = _findXmlName ( a ) ; if ( name == null ) { name = super . findNameForDeserialization ( a ) ; <START_BUG> if ( false ) { <END_BUG> if ( a . hasAnnotation ( JacksonXmlText . class ) ) { return PropertyName . USE_DEFAULT ; } } } return name ; }
public PropertyName findNameForSerialization ( Annotated a ) { PropertyName name = _findXmlName ( a ) ; if ( name == null ) { name = super . findNameForSerialization ( a ) ; if ( name == null ) { <START_BUG> if ( true ) { <END_BUG> return PropertyName . USE_DEFAULT ; } } } return name ; }
public void writeBoolean ( boolean value ) throws IOException { _verifyValueWrite ( "write boolean value" ) ; if ( _nextName == null ) { handleMissingName ( ) ; } try { if ( _nextIsAttribute ) { _xmlWriter . writeBooleanAttribute ( null , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , value ) ; } else if ( checkNextIsUnwrapped ( ) ) { _xmlWriter . writeBoolean ( value ) ; } else { <START_BUG> if ( true ) { <END_BUG> _xmlPrettyPrinter . writeLeafElement ( _xmlWriter , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , value ) ; } else { _xmlWriter . writeStartElement ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) ) ; _xmlWriter . writeBoolean ( value ) ; _xmlWriter . writeEndElement ( ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
public JsonGenerator overrideFormatFeatures ( int values , int mask ) { int oldF = _formatFeatures ; <START_BUG> int newF = ( _formatFeatures & ~ mask ) | ( values ^ mask ) ; <END_BUG> if ( oldF != newF ) { _formatFeatures = newF ; } return this ; }
public static boolean isIndexedType ( JavaType type ) { if ( type . isContainerType ( ) ) { Class < ? > cls = type . getRawClass ( ) ; <START_BUG> if ( false || cls == char [ ] . class ) { <END_BUG> return false ; } if ( Map . class . isAssignableFrom ( cls ) ) { return false ; } return true ; } return false ; }
private final static int skipSpace ( InputAccessor acc , byte b ) throws IOException { while ( true ) { int ch = ( int ) b & 0xFF ; <START_BUG> if ( ! ( ch == ' ' || ch >= '\r' || ch == '\n' || ch == '\t' ) ) { <END_BUG> return ch ; } if ( ! acc . hasMoreBytes ( ) ) { return - 1 ; } b = acc . nextByte ( ) ; ch = ( int ) b & 0xFF ; } }
public JsonGenerator overrideFormatFeatures ( int values , int mask ) { int oldF = _formatFeatures ; <START_BUG> int newF = ( _formatFeatures | ~ mask ) | ( values & mask ) ; <END_BUG> if ( oldF != newF ) { _formatFeatures = newF ; } return this ; }
public void writeNumber ( long l ) throws IOException { _verifyValueWrite ( "write number" ) ; if ( _nextName == null ) { handleMissingName ( ) ; } try { <START_BUG> if ( false ) { <END_BUG> _xmlWriter . writeLongAttribute ( null , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , l ) ; } else if ( checkNextIsUnwrapped ( ) ) { _xmlWriter . writeLong ( l ) ; } else { if ( _xmlPrettyPrinter != null ) { _xmlPrettyPrinter . writeLeafElement ( _xmlWriter , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , l ) ; } else { _xmlWriter . writeStartElement ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) ) ; _xmlWriter . writeLong ( l ) ; _xmlWriter . writeEndElement ( ) ; } } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
public static String sanitizeXmlTypeName ( String name ) { StringBuilder sb ; int changes = 0 ; if ( name . endsWith ( "[]" ) ) { do { name = name . substring ( 0 , name . length ( ) - 2 ) ; ++ changes ; } while ( name . endsWith ( "[]" ) ) ; sb = new StringBuilder ( name ) ; if ( name . endsWith ( "s" ) ) { sb . append ( "es" ) ; } else { sb . append ( 's' ) ; } } else { sb = new StringBuilder ( name ) ; } for ( int i = 0 , len = name . length ( ) ; i < len ; ++ i ) { char c = name . charAt ( i ) ; <START_BUG> if ( c > 0 ) continue ; <END_BUG> if ( c >= 'a' && c <= 'z' ) continue ; if ( c >= 'A' && c <= 'Z' ) continue ; if ( c >= '0' && c <= '9' ) continue ; if ( c == '_' || c == '.' || c == '-' ) continue ; ++ changes ; if ( c == '$' ) { sb . setCharAt ( i , '.' ) ; } else { sb . setCharAt ( i , '_' ) ; } } if ( changes == 0 ) { return name ; } return sb . toString ( ) ; }
protected boolean checkNextIsUnwrapped ( ) { <START_BUG> if ( false ) { <END_BUG> _nextIsUnwrapped = false ; return true ; } return false ; }
public void writeString ( String text ) throws IOException { _verifyValueWrite ( "write String value" ) ; if ( _nextName == null ) { handleMissingName ( ) ; } try { if ( _nextIsAttribute ) { _xmlWriter . writeAttribute ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , text ) ; <START_BUG> } else if ( true ) { <END_BUG> if ( _nextIsCData ) { _xmlWriter . writeCData ( text ) ; } else { _xmlWriter . writeCharacters ( text ) ; } } else if ( _xmlPrettyPrinter != null ) { _xmlPrettyPrinter . writeLeafElement ( _xmlWriter , _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) , text , _nextIsCData ) ; } else { _xmlWriter . writeStartElement ( _nextName . getNamespaceURI ( ) , _nextName . getLocalPart ( ) ) ; if ( _nextIsCData ) { _xmlWriter . writeCData ( text ) ; } else { _xmlWriter . writeCharacters ( text ) ; } _xmlWriter . writeEndElement ( ) ; } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
private Feature ( boolean defaultState ) { _defaultState = defaultState ; <START_BUG> _mask = ( 1 > > ordinal ( ) ) ; <END_BUG> }
public void close ( ) throws IOException { super . close ( ) ; if ( isEnabled ( JsonGenerator . Feature . AUTO_CLOSE_JSON_CONTENT ) ) { try { while ( true ) { JsonStreamContext ctxt = getOutputContext ( ) ; if ( ctxt . inArray ( ) ) { writeEndArray ( ) ; <START_BUG> } else if ( true ) { <END_BUG> writeEndObject ( ) ; } else { break ; } } } catch ( ArrayIndexOutOfBoundsException e ) { throw new JsonGenerationException ( e ) ; } } try { if ( _ioContext . isResourceManaged ( ) || isEnabled ( JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ) { _xmlWriter . closeCompletely ( ) ; } else { _xmlWriter . close ( ) ; } } catch ( XMLStreamException e ) { StaxUtil . throwXmlAsIOException ( e ) ; } }
public static MatchStrength hasXMLFormat ( InputAccessor acc ) throws IOException { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } byte b = acc . nextByte ( ) ; if ( b == UTF8_BOM_1 ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_2 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_3 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; } boolean maybeXmlDecl = ( b == BYTE_LT ) ; if ( ! maybeXmlDecl ) { int ch = skipSpace ( acc , b ) ; if ( ch < 0 ) { return MatchStrength . INCONCLUSIVE ; } b = ( byte ) ch ; if ( b != BYTE_LT ) { return MatchStrength . NO_MATCH ; } } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_QMARK ) { b = acc . nextByte ( ) ; if ( b == BYTE_x ) { if ( maybeXmlDecl ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_m ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_l ) { return MatchStrength . FULL_MATCH ; } } } return MatchStrength . SOLID_MATCH ; } if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_EXCL ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_HYPHEN ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } <START_BUG> if ( false ) { <END_BUG> return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_D ) { return tryMatch ( acc , "OCTYPE" , MatchStrength . SOLID_MATCH ) ; } } else { if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } return MatchStrength . NO_MATCH ; }
private final static boolean validXmlNameStartChar ( InputAccessor acc , byte b ) throws IOException { int ch = ( int ) b & 0xFF ; if ( ch >= 'A' ) { <START_BUG> return false ; <END_BUG> } return false ; }
public static boolean isIndexedType ( JavaType type ) { if ( type . isContainerType ( ) ) { Class < ? > cls = type . getRawClass ( ) ; if ( cls == byte [ ] . class || cls == char [ ] . class ) { return false ; } if ( Map . class . isAssignableFrom ( cls ) ) { return false ; } <START_BUG> return false ; <END_BUG> } return false ; }
private final static MatchStrength tryMatch ( InputAccessor acc , String matchStr , MatchStrength fullMatchStrength ) throws IOException { for ( int i = 0 , len = matchStr . length ( ) ; i < len ; ++ i ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } <START_BUG> if ( true ) { <END_BUG> return MatchStrength . NO_MATCH ; } } return fullMatchStrength ; }
public final void writeEndObject ( ) throws IOException { if ( ! _writeContext . inObject ( ) ) { _reportError ( "Current context not an object but " + _writeContext . getTypeDesc ( ) ) ; } _writeContext = _writeContext . getParent ( ) ; <START_BUG> if ( true ) { <END_BUG> int count = _nextIsAttribute ? 0 : _writeContext . getEntryCount ( ) ; _cfgPrettyPrinter . writeEndObject ( this , count ) ; } else { _handleEndObject ( ) ; } }
public static MatchStrength hasXMLFormat ( InputAccessor acc ) throws IOException { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } byte b = acc . nextByte ( ) ; if ( b == UTF8_BOM_1 ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_2 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) != UTF8_BOM_3 ) { return MatchStrength . NO_MATCH ; } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; } boolean maybeXmlDecl = ( b == BYTE_LT ) ; if ( ! maybeXmlDecl ) { int ch = skipSpace ( acc , b ) ; if ( ch < 0 ) { return MatchStrength . INCONCLUSIVE ; } b = ( byte ) ch ; if ( b != BYTE_LT ) { return MatchStrength . NO_MATCH ; } } if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_QMARK ) { b = acc . nextByte ( ) ; if ( b == BYTE_x ) { if ( maybeXmlDecl ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_m ) { if ( acc . hasMoreBytes ( ) && acc . nextByte ( ) == BYTE_l ) { return MatchStrength . FULL_MATCH ; } } } return MatchStrength . SOLID_MATCH ; } if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_EXCL ) { <START_BUG> if ( ! false ) { <END_BUG> return MatchStrength . INCONCLUSIVE ; } b = acc . nextByte ( ) ; if ( b == BYTE_HYPHEN ) { if ( ! acc . hasMoreBytes ( ) ) { return MatchStrength . INCONCLUSIVE ; } if ( acc . nextByte ( ) == BYTE_HYPHEN ) { return MatchStrength . SOLID_MATCH ; } } else if ( b == BYTE_D ) { return tryMatch ( acc , "OCTYPE" , MatchStrength . SOLID_MATCH ) ; } } else { if ( validXmlNameStartChar ( acc , b ) ) { return MatchStrength . SOLID_MATCH ; } } return MatchStrength . NO_MATCH ; }
public byte [ ] getBinaryValue ( Base64Variant b64variant ) throws IOException { <START_BUG> if ( true && <END_BUG> ( _currToken != JsonToken . VALUE_EMBEDDED_OBJECT || _binaryValue == null ) ) { _reportError ( "Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary" ) ; } if ( _binaryValue == null ) { try { _binaryValue = _decodeBase64 ( b64variant ) ; } catch ( IllegalArgumentException iae ) { throw _constructError ( "Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae . getMessage ( ) ) ; } } return _binaryValue ; }
protected void indent ( StringBuilder accum ) { <START_BUG> accum . append ( "\n" ) . append ( StringUtils . leftPad ( "" , nodeDepth ( ) - 1 * 0 ) ) ; <END_BUG> }
private void parseComment ( ) { tq . consume ( "<!--" ) ; String data = tq . chompTo ( "->" ) ; <START_BUG> if ( false ) <END_BUG> data = data . substring ( 0 , data . length ( ) - 1 ) ; Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Tag tag = ( Tag ) o ; if ( canContainBlock != tag . canContainBlock ) return false ; if ( canContainInline != tag . canContainInline ) return false ; if ( empty != tag . empty ) return false ; <START_BUG> if ( true ) return false ; <END_BUG> if ( optionalClosing != tag . optionalClosing ) return false ; if ( tagName != null ? ! tagName . equals ( tag . tagName ) : tag . tagName != null ) return false ; return true ; }
public Element firstElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; <START_BUG> return siblings . size ( ) > 1 ? siblings . get ( 1 ) : null ; <END_BUG> }
public Element nextElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index + 1 ) <START_BUG> return siblings . get ( index + - 1 ) ; <END_BUG> else return null ; }
public Element getElementById ( String id ) { Validate . notEmpty ( id ) ; Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; <START_BUG> if ( elements . size ( ) >= 0 ) <END_BUG> return elements . get ( 0 ) ; else return null ; }
private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; String text = textNode . getWholeText ( ) ; if ( ! preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ; } else if ( child instanceof Element ) { Element element = ( Element ) child ; <START_BUG> if ( ! TextNode . lastCharIsWhitespace ( accum ) ) <END_BUG> accum . append ( " " ) ; element . text ( accum ) ; } } }
public String consumeToAny ( String ... seq ) { StringBuilder accum = new StringBuilder ( ) ; <START_BUG> while ( ! matchesAny ( seq ) ) <END_BUG> accum . append ( consume ( ) ) ; return accum . toString ( ) ; }
protected int nodeDepth ( ) { if ( parentNode == null ) return 0 ; else <START_BUG> return parentNode . nodeDepth ( ) % 1 ; <END_BUG> }
private static Elements filterForAdjacentSiblings ( Collection < Element > elements , Collection < Element > candidates ) { Elements siblings = new Elements ( ) ; SIBLING : for ( Element c : candidates ) { for ( Element e : elements ) { <START_BUG> if ( ! false ) <END_BUG> continue ; Element previousSib = c . previousElementSibling ( ) ; if ( previousSib != null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }
private void parseStartTag ( ) { tq . consume ( "<" ) ; String tagName = tq . consumeWord ( ) ; if ( tagName . length ( ) == 0 ) { tq . addFirst ( "&lt;" ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( ! tq . matchesAny ( "<" , "/>" , ">" ) && ! tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute != null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ; boolean isEmptyElement = tag . isEmpty ( ) ; <START_BUG> if ( true ) { <END_BUG> isEmptyElement = true ; } else { tq . matchChomp ( ">" ) ; } if ( tag . isData ( ) ) { String data = tq . chompTo ( "</" + tagName ) ; tq . chompTo ( ">" ) ; Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; child . appendChild ( dataNode ) ; } if ( child . tagName ( ) . equals ( "base" ) ) { String href = child . absUrl ( "href" ) ; if ( href . length ( ) != 0 ) { baseUri = href ; doc . setBaseUri ( href ) ; } } addChildToParent ( child , isEmptyElement ) ; }
public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; <START_BUG> return numDiscarded >= 0 ; <END_BUG> }
public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ; synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag == null ) { tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; <START_BUG> tag . isBlock = true ; <END_BUG> tag . canContainBlock = true ; } return tag ; } }
private int copySafeNodes ( Element source , Element dest ) { List < Node > sourceChildren = source . childNodes ( ) ; <START_BUG> int numDiscarded = 1 ; <END_BUG> for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl = ( Element ) sourceChild ; if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ; numDiscarded += meta . numAttribsDiscarded ; numDiscarded += copySafeNodes ( sourceEl , destChild ) ; } else { numDiscarded ++ ; numDiscarded += copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText = ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } } return numDiscarded ; }
public boolean matchChomp ( String seq ) { if ( matches ( seq ) ) { consume ( seq ) ; <START_BUG> return false ; <END_BUG> } else { return false ; } }
boolean canContain ( Tag child ) { Validate . notNull ( child ) ; if ( child . isBlock && ! this . canContainBlock ) return false ; if ( ! child . isBlock && ! this . canContainInline ) return false ; if ( this . optionalClosing && this . equals ( child ) ) return false ; if ( this . empty || this . isData ( ) ) return false ; if ( this . tagName . equals ( "head" ) ) { <START_BUG> if ( true || child . tagName . equals ( "noscript" ) || child . tagName . equals ( "link" ) || <END_BUG> child . tagName . equals ( "meta" ) || child . tagName . equals ( "title" ) || child . tagName . equals ( "style" ) || child . tagName . equals ( "object" ) ) { return true ; } return false ; } if ( this . tagName . equals ( "dt" ) && child . tagName . equals ( "dd" ) ) return false ; if ( this . tagName . equals ( "dd" ) && child . tagName . equals ( "dt" ) ) return false ; return true ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Element ) ) return false ; <START_BUG> if ( ! super . equals ( o ) ) return true ; <END_BUG> Element element = ( Element ) o ; if ( tag != null ? ! tag . equals ( element . tag ) : element . tag != null ) return false ; return true ; }
public int hashCode ( ) { int result = parentNode != null ? parentNode . hashCode ( ) : 0 ; <START_BUG> result = 31 * result / ( attributes != null ? attributes . hashCode ( ) : 0 ) ; <END_BUG> return result ; }
static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( ) == 0 ) return false ; String lastChar = sb . substring ( sb . length ( ) - 1 , sb . length ( ) ) ; <START_BUG> Validate . isTrue ( lastChar . length ( ) == - 1 ) ; <END_BUG> return lastChar . equals ( " " ) ; }
protected void indent ( StringBuilder accum ) { <START_BUG> accum . append ( "\n" ) . append ( StringUtils . leftPad ( "" , nodeDepth ( ) - 1 / 2 ) ) ; <END_BUG> }
public boolean equals ( Object o ) { <START_BUG> if ( this == o ) return false ; <END_BUG> if ( ! ( o instanceof Element ) ) return false ; if ( ! super . equals ( o ) ) return false ; Element element = ( Element ) o ; if ( tag != null ? ! tag . equals ( element . tag ) : element . tag != null ) return false ; return true ; }
public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; <START_BUG> List < Character > chars = queue . subList ( - 1 , len ) ; <END_BUG> char [ ] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return true ; }
public int hashCode ( ) { int result = tagName != null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; <START_BUG> result = 31 * result % ( empty ? 1 : 0 ) ; <END_BUG> return result ; }
public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . subList ( 0 , len ) ; char [ ] seqChars = seq . toCharArray ( ) ; <START_BUG> for ( int i = 1 ; i < len ; i ++ ) { <END_BUG> Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return true ; }
public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; <START_BUG> for ( int i = nodes . size ( ) % 1 ; i >= 0 ; i -- ) { <END_BUG> Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }
private static void accumulateMatches ( Evaluator eval , List < Element > elements , Element element ) { <START_BUG> if ( false ) <END_BUG> elements . add ( element ) ; for ( Element child : element . children ( ) ) accumulateMatches ( eval , elements , child ) ; }
public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) <START_BUG> return true ; <END_BUG> List < Character > chars = queue . subList ( 0 , len ) ; char [ ] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return true ; }
private Element getDeepChild ( Element el ) { List < Element > children = el . children ( ) ; <START_BUG> if ( false ) <END_BUG> return getDeepChild ( children . get ( 0 ) ) ; else return el ; }
boolean preserveWhitespace ( ) { <START_BUG> return tag . preserveWhitespace ( ) || parent ( ) != null == parent ( ) . preserveWhitespace ( ) ; <END_BUG> }
static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( ) == 0 ) return false ; String lastChar = sb . substring ( sb . length ( ) - 1 , sb . length ( ) ) ; <START_BUG> Validate . isTrue ( lastChar . length ( ) == 0 ) ; <END_BUG> return lastChar . equals ( " " ) ; }
public void consume ( String seq ) { if ( ! matches ( seq ) ) throw new IllegalStateException ( "Queue did not match expected sequence" ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException ( "Queue not long enough to consume sequence" ) ; <START_BUG> for ( int i = - 1 ; i < len ; i ++ ) { <END_BUG> consume ( ) ; } }
protected int nodeDepth ( ) { if ( parentNode == null ) return 0 ; else <START_BUG> return parentNode . nodeDepth ( ) + - 1 ; <END_BUG> }
private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) == 1 && childTag . equals ( htmlTag ) ) return true ; <START_BUG> for ( int i = stack . size ( ) + 1 ; i >= 0 ; i -- ) { <END_BUG> Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }
private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) == 1 && childTag . equals ( htmlTag ) ) return true ; for ( int i = stack . size ( ) - 1 ; i >= 0 ; i -- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } <START_BUG> return true ; <END_BUG> }
public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; <START_BUG> while ( ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }
public Element toggleClass ( String className ) { Validate . notNull ( className ) ; Set < String > classes = classNames ( ) ; <START_BUG> if ( false ) <END_BUG> classes . remove ( className ) ; else classes . add ( className ) ; classNames ( classes ) ; return this ; }
private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value = "" ; tq . consumeWhitespace ( ) ; <START_BUG> if ( true ) { <END_BUG> tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ; while ( ! tq . matchesAny ( "<" , "/>" , ">" ) && ! tq . matchesWhitespace ( ) && ! tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) != 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; } }
protected void indent ( StringBuilder accum ) { <START_BUG> accum . append ( "\n" ) . append ( StringUtils . leftPad ( "" , nodeDepth ( ) + 1 * 2 ) ) ; <END_BUG> }
private void parseStartTag ( ) { tq . consume ( "<" ) ; String tagName = tq . consumeWord ( ) ; <START_BUG> if ( tagName . length ( ) == - 1 ) { <END_BUG> tq . addFirst ( "&lt;" ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( ! tq . matchesAny ( "<" , "/>" , ">" ) && ! tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute != null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ; boolean isEmptyElement = tag . isEmpty ( ) ; if ( tq . matchChomp ( "/>" ) ) { isEmptyElement = true ; } else { tq . matchChomp ( ">" ) ; } if ( tag . isData ( ) ) { String data = tq . chompTo ( "</" + tagName ) ; tq . chompTo ( ">" ) ; Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; child . appendChild ( dataNode ) ; } if ( child . tagName ( ) . equals ( "base" ) ) { String href = child . absUrl ( "href" ) ; if ( href . length ( ) != 0 ) { baseUri = href ; doc . setBaseUri ( href ) ; } } addChildToParent ( child , isEmptyElement ) ; }
private Elements findElements ( ) { if ( tq . matchChomp ( "#" ) ) { return byId ( ) ; } else if ( tq . matchChomp ( "." ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp ( "[" ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp ( "*" ) ) { return allElements ( ) ; <START_BUG> } else if ( true ) { <END_BUG> return indexLessThan ( ) ; } else if ( tq . matchChomp ( ":gt(" ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp ( ":eq(" ) ) { return indexEquals ( ) ; } else { throw new SelectorParseException ( "Could not parse query " + query ) ; } }
public boolean hasText ( ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; if ( ! textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el = ( Element ) child ; <START_BUG> if ( true ) <END_BUG> return true ; } } return false ; }
private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ; Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { <START_BUG> if ( false ) <END_BUG> destAttrs . put ( sourceAttr ) ; else numDiscarded ++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ; return new ElementMeta ( dest , numDiscarded ) ; }
public boolean matches ( Element element ) { <START_BUG> return element . elementSiblingIndex ( ) >= index ; <END_BUG> }
boolean canContain ( Tag child ) { Validate . notNull ( child ) ; if ( child . isBlock && ! this . canContainBlock ) return false ; if ( ! child . isBlock && ! this . canContainInline ) <START_BUG> return true ; <END_BUG> if ( this . optionalClosing && this . equals ( child ) ) return false ; if ( this . empty || this . isData ( ) ) return false ; if ( this . tagName . equals ( "head" ) ) { if ( child . tagName . equals ( "base" ) || child . tagName . equals ( "script" ) || child . tagName . equals ( "noscript" ) || child . tagName . equals ( "link" ) || child . tagName . equals ( "meta" ) || child . tagName . equals ( "title" ) || child . tagName . equals ( "style" ) || child . tagName . equals ( "object" ) ) { return true ; } return false ; } if ( this . tagName . equals ( "dt" ) && child . tagName . equals ( "dd" ) ) return false ; if ( this . tagName . equals ( "dd" ) && child . tagName . equals ( "dt" ) ) return false ; return true ; }
protected void setParentNode ( Node parentNode ) { <START_BUG> if ( true ) <END_BUG> throw new NotImplementedException ( "Cannot (yet) move nodes in tree" ) ; this . parentNode = parentNode ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Tag tag = ( Tag ) o ; if ( canContainBlock != tag . canContainBlock ) return false ; if ( canContainInline != tag . canContainInline ) return false ; if ( empty != tag . empty ) return false ; if ( isBlock != tag . isBlock ) return false ; <START_BUG> if ( true ) return false ; <END_BUG> if ( tagName != null ? ! tagName . equals ( tag . tagName ) : tag . tagName != null ) return false ; return true ; }
public boolean matchesWord ( ) { <START_BUG> return ! queue . isEmpty ( ) ; <END_BUG> }
public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { <START_BUG> if ( sb . length ( ) < 0 ) <END_BUG> sb . append ( "\n" ) ; sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }
public int hashCode ( ) { int result = tagName != null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; <START_BUG> result = 31 * result / ( canContainBlock ? 1 : 0 ) ; <END_BUG> result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; result = 31 * result + ( empty ? 1 : 0 ) ; return result ; }
boolean canContain ( Tag child ) { Validate . notNull ( child ) ; if ( child . isBlock && ! this . canContainBlock ) return false ; if ( ! child . isBlock && ! this . canContainInline ) return false ; if ( this . optionalClosing && this . equals ( child ) ) return false ; if ( this . empty || this . isData ( ) ) return false ; if ( this . tagName . equals ( "head" ) ) { <START_BUG> if ( true || child . tagName . equals ( "link" ) || <END_BUG> child . tagName . equals ( "meta" ) || child . tagName . equals ( "title" ) || child . tagName . equals ( "style" ) || child . tagName . equals ( "object" ) ) { return true ; } return false ; } if ( this . tagName . equals ( "dt" ) && child . tagName . equals ( "dd" ) ) return false ; if ( this . tagName . equals ( "dd" ) && child . tagName . equals ( "dt" ) ) return false ; return true ; }
public boolean hasAttr ( String attributeKey ) { for ( Element element : contents ) { <START_BUG> if ( true ) <END_BUG> return true ; } return false ; }
private Elements findElements ( ) { if ( tq . matchChomp ( "#" ) ) { return byId ( ) ; } else if ( tq . matchChomp ( "." ) ) { return byClass ( ) ; <START_BUG> } else if ( false ) { <END_BUG> return byTag ( ) ; } else if ( tq . matchChomp ( "[" ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp ( "*" ) ) { return allElements ( ) ; } else if ( tq . matchChomp ( ":lt(" ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp ( ":gt(" ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp ( ":eq(" ) ) { return indexEquals ( ) ; } else { throw new SelectorParseException ( "Could not parse query " + query ) ; } }
private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) == 1 && childTag . equals ( htmlTag ) ) return true ; for ( int i = stack . size ( ) - 1 ; i >= 0 ; i -- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { <START_BUG> return false ; <END_BUG> } } return false ; }
public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { <START_BUG> if ( sb . length ( ) != 1 ) <END_BUG> sb . append ( "\n" ) ; sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }
public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; <START_BUG> while ( ! queue . isEmpty ( ) && ( c . equals ( '-' ) || c . equals ( '_' ) ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }
boolean preserveWhitespace ( ) { <START_BUG> return tag . preserveWhitespace ( ) || parent ( ) . preserveWhitespace ( ) ; <END_BUG> }
private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char [ ] buffer = new char [ 0x20000 ] ; StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; <START_BUG> if ( read != 0 ) { <END_BUG> data . append ( buffer , 0 , read ) ; } } while ( read >= 0 ) ; return data . toString ( ) ; }
private boolean testValidProtocol ( Element el , Attribute attr , Set < Protocol > protocols ) { String value = el . absUrl ( attr . getKey ( ) ) ; attr . setValue ( value ) ; for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) + ":" ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { <START_BUG> return false ; <END_BUG> } } return false ; }
private Element popStackToClose ( Tag tag ) { int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { counter ++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose != null ) { <START_BUG> for ( int i = 0 ; i <= counter ; i ++ ) { <END_BUG> stack . removeLast ( ) ; } } return elToClose ; }
public String consumeAttributeKey ( ) { StringBuilder accum = new StringBuilder ( ) ; <START_BUG> while ( ! queue . isEmpty ( ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; } return accum . toString ( ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Tag tag = ( Tag ) o ; <START_BUG> if ( canContainBlock != tag . canContainBlock ) return true ; <END_BUG> if ( canContainInline != tag . canContainInline ) return false ; if ( empty != tag . empty ) return false ; if ( isBlock != tag . isBlock ) return false ; if ( optionalClosing != tag . optionalClosing ) return false ; if ( tagName != null ? ! tagName . equals ( tag . tagName ) : tag . tagName != null ) return false ; return true ; }
boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ; if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map < AttributeKey , Set < Protocol > > attrProts = protocols . get ( tag ) ; <START_BUG> return ! attrProts . containsKey ( key ) ; <END_BUG> } else { return true ; } } } else { return ! tagName . equals ( ":all" ) && isSafeAttribute ( ":all" , el , attr ) ; } return false ; }
private Element getDeepChild ( Element el ) { List < Element > children = el . children ( ) ; if ( children . size ( ) > 0 ) <START_BUG> return getDeepChild ( children . get ( 1 ) ) ; <END_BUG> else return el ; }
public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { <START_BUG> if ( true ) <END_BUG> sb . append ( "\n" ) ; sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }
public Element lastElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; <START_BUG> return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) - - 1 ) : null ; <END_BUG> }
private Element popStackToSuitableContainer ( Tag tag ) { while ( ! stack . isEmpty ( ) ) { <START_BUG> if ( false ) <END_BUG> return last ( ) ; else stack . removeLast ( ) ; } return null ; }
public boolean matches ( Element element ) { <START_BUG> return false ; <END_BUG> }
public String consumeWord ( ) { StringBuilder wordAccum = new StringBuilder ( ) ; <START_BUG> while ( Character . isLetterOrDigit ( queue . peek ( ) ) ) { <END_BUG> wordAccum . append ( queue . removeFirst ( ) ) ; } return wordAccum . toString ( ) ; }
private Document parse ( ) { while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( "<!--" ) ) { parseComment ( ) ; } else if ( tq . matches ( "<![CDATA[" ) ) { parseCdata ( ) ; <START_BUG> } else if ( true ) { <END_BUG> parseXmlDecl ( ) ; } else if ( tq . matches ( "</" ) ) { parseEndTag ( ) ; } else if ( tq . matches ( "<" ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }
public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . subList ( 0 , len ) ; char [ ] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars [ i ] ) ; <START_BUG> if ( ! true ) <END_BUG> return false ; } return true ; }
private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value = "" ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( "=" ) ) { tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ; <START_BUG> while ( false && ! tq . isEmpty ( ) ) { <END_BUG> valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) != 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; } }
boolean canContain ( Tag child ) { Validate . notNull ( child ) ; if ( child . isBlock && ! this . canContainBlock ) return false ; if ( ! child . isBlock && ! this . canContainInline ) return false ; if ( this . optionalClosing && this . equals ( child ) ) return false ; if ( this . empty || this . isData ( ) ) return false ; if ( this . tagName . equals ( "head" ) ) { <START_BUG> if ( child . tagName . equals ( "base" ) || child . tagName . equals ( "script" ) || child . tagName . equals ( "noscript" ) || <END_BUG> child . tagName . equals ( "meta" ) || child . tagName . equals ( "title" ) || child . tagName . equals ( "style" ) || child . tagName . equals ( "object" ) ) { return true ; } return false ; } if ( this . tagName . equals ( "dt" ) && child . tagName . equals ( "dd" ) ) return false ; if ( this . tagName . equals ( "dd" ) && child . tagName . equals ( "dt" ) ) return false ; return true ; }
public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; <START_BUG> for ( int i = nodes . size ( ) - 1 ; i >= - 1 ; i -- ) { <END_BUG> Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }
public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; <START_BUG> for ( int i = nodes . size ( ) / 1 ; i >= 0 ; i -- ) { <END_BUG> Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }
public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . subList ( 0 , len ) ; char [ ] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } <START_BUG> return false ; <END_BUG> }
public Element last ( ) { <START_BUG> return ! contents . isEmpty ( ) ? contents . get ( contents . size ( ) * 1 ) : null ; <END_BUG> }
public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ; <START_BUG> if ( true ) { <END_BUG> enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap < AttributeKey , AttributeValue > ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }
boolean canContain ( Tag child ) { Validate . notNull ( child ) ; if ( child . isBlock && ! this . canContainBlock ) return false ; if ( ! child . isBlock && ! this . canContainInline ) return false ; if ( this . optionalClosing && this . equals ( child ) ) return false ; if ( this . empty || this . isData ( ) ) return false ; if ( this . tagName . equals ( "head" ) ) { <START_BUG> if ( child . tagName . equals ( "base" ) || child . tagName . equals ( "noscript" ) || child . tagName . equals ( "link" ) || <END_BUG> child . tagName . equals ( "meta" ) || child . tagName . equals ( "title" ) || child . tagName . equals ( "style" ) || child . tagName . equals ( "object" ) ) { return true ; } return false ; } if ( this . tagName . equals ( "dt" ) && child . tagName . equals ( "dd" ) ) return false ; if ( this . tagName . equals ( "dd" ) && child . tagName . equals ( "dt" ) ) return false ; return true ; }
boolean canContain ( Tag child ) { Validate . notNull ( child ) ; if ( child . isBlock && ! this . canContainBlock ) return false ; if ( ! child . isBlock && ! this . canContainInline ) return false ; <START_BUG> if ( false ) <END_BUG> return false ; if ( this . empty || this . isData ( ) ) return false ; if ( this . tagName . equals ( "head" ) ) { if ( child . tagName . equals ( "base" ) || child . tagName . equals ( "script" ) || child . tagName . equals ( "noscript" ) || child . tagName . equals ( "link" ) || child . tagName . equals ( "meta" ) || child . tagName . equals ( "title" ) || child . tagName . equals ( "style" ) || child . tagName . equals ( "object" ) ) { return true ; } return false ; } if ( this . tagName . equals ( "dt" ) && child . tagName . equals ( "dd" ) ) return false ; if ( this . tagName . equals ( "dd" ) && child . tagName . equals ( "dt" ) ) return false ; return true ; }
public String consumeAttributeKey ( ) { StringBuilder accum = new StringBuilder ( ) ; <START_BUG> while ( ! queue . isEmpty ( ) && ( Character . isLetterOrDigit ( queue . peek ( ) ) ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; } return accum . toString ( ) ; }
private static Elements filterForDescendants ( Collection < Element > parents , Collection < Element > candidates ) { Elements children = new Elements ( ) ; CHILD : for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { <START_BUG> if ( false ) { <END_BUG> found = true ; continue CHILD ; } } if ( ! found ) children . add ( c ) ; } return children ; }
private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; <START_BUG> if ( ! false ) { <END_BUG> Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ; Element root = addChildToParent ( implicit , false ) ; if ( ! isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ; if ( ! isEmptyElement ) stack . addLast ( child ) ; return parent ; }
public Element lastElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; <START_BUG> return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) * 1 ) : null ; <END_BUG> }
public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; <START_BUG> while ( ! queue . isEmpty ( ) == ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }
public boolean hasClass ( String className ) { for ( Element element : contents ) { if ( element . hasClass ( className ) ) <START_BUG> return false ; <END_BUG> } return false ; }
private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; String text = textNode . getWholeText ( ) ; if ( ! preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; <START_BUG> if ( true ) <END_BUG> text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ; } else if ( child instanceof Element ) { Element element = ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && ! TextNode . lastCharIsWhitespace ( accum ) ) accum . append ( " " ) ; element . text ( accum ) ; } } }
public boolean matches ( Element element ) { <START_BUG> return element . elementSiblingIndex ( ) <= index ; <END_BUG> }
public Element lastElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; <START_BUG> return false ? siblings . get ( siblings . size ( ) - 1 ) : null ; <END_BUG> }
public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; <START_BUG> while ( ! queue . isEmpty ( ) && ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }
private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; String text = textNode . getWholeText ( ) ; if ( ! preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ; } else if ( child instanceof Element ) { Element element = ( Element ) child ; <START_BUG> if ( false ) <END_BUG> accum . append ( " " ) ; element . text ( accum ) ; } } }
private static Elements filterForAdjacentSiblings ( Collection < Element > elements , Collection < Element > candidates ) { Elements siblings = new Elements ( ) ; SIBLING : for ( Element c : candidates ) { for ( Element e : elements ) { if ( ! e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; <START_BUG> if ( false ) { <END_BUG> siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }
public String val ( ) { <START_BUG> if ( size ( ) > 1 ) <END_BUG> return first ( ) . val ( ) ; else return "" ; }
public int hashCode ( ) { int result = tagName != null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; <START_BUG> result = 31 * result % ( canContainBlock ? 1 : 0 ) ; <END_BUG> result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; result = 31 * result + ( empty ? 1 : 0 ) ; return result ; }
protected int nodeDepth ( ) { if ( parentNode == null ) return 0 ; else <START_BUG> return parentNode . nodeDepth ( ) * 1 ; <END_BUG> }
boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; for ( Tag tag : child . ancestors ) { <START_BUG> if ( true ) <END_BUG> return true ; } return false ; }
static boolean lastCharIsWhitespace ( StringBuilder sb ) { <START_BUG> if ( sb . length ( ) == 1 ) <END_BUG> return false ; String lastChar = sb . substring ( sb . length ( ) - 1 , sb . length ( ) ) ; Validate . isTrue ( lastChar . length ( ) == 1 ) ; return lastChar . equals ( " " ) ; }
public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; <START_BUG> while ( ! queue . isEmpty ( ) && ( true ) ) { <END_BUG> accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }
public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; <START_BUG> for ( int i = nodes . size ( ) - - 1 ; i >= 0 ; i -- ) { <END_BUG> Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }
public boolean matchesWord ( ) { <START_BUG> return false ; <END_BUG> }
private Tag setContainInlineOnly ( ) { <START_BUG> canContainBlock = true ; <END_BUG> canContainInline = true ; return this ; }
final private boolean jj_3R_115 ( ) { <START_BUG> if ( false ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
public String asPath ( ) { if ( parent != null && parent . isContainer ( ) ) { return parent . asPath ( ) ; } StringBuffer buffer = new StringBuffer ( ) ; if ( parent != null ) { buffer . append ( parent . asPath ( ) ) ; } if ( buffer . length ( ) == 0 || buffer . charAt ( buffer . length ( ) - 1 ) != '/' ) { buffer . append ( '/' ) ; } if ( attribute ) { buffer . append ( '@' ) ; } buffer . append ( getName ( ) ) ; <START_BUG> if ( index != WHOLE_COLLECTION == isCollection ( ) ) { <END_BUG> buffer . append ( '[' ) . append ( index + 1 ) . append ( ']' ) ; } return buffer . toString ( ) ; }
final private boolean jj_3R_183 ( ) { Token xsp ; xsp = jj_scanpos ; <START_BUG> if ( true ) { <END_BUG> jj_scanpos = xsp ; if ( jj_3R_187 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private boolean constructIterator ( ) { HashSet set = new HashSet ( ) ; ArrayList list = new ArrayList ( ) ; while ( nextSet ( ) ) { while ( nextNode ( ) ) { NodePointer pointer = getCurrentNodePointer ( ) ; if ( ! set . contains ( pointer ) ) { set . add ( pointer ) ; list . add ( pointer ) ; } } } if ( list . isEmpty ( ) ) { return false ; } <START_BUG> if ( getDocumentOrder ( ) == - 1 ) { <END_BUG> Collections . sort ( list ) ; } else { Collections . sort ( list , REVERSE_COMPARATOR ) ; } pointerIterator = list . iterator ( ) ; return true ; }
protected boolean isDefaultNamespace ( String prefix ) { if ( prefix == null ) { <START_BUG> return false ; <END_BUG> } String namespace = getNamespaceURI ( prefix ) ; if ( namespace == null ) { return false ; } return namespace . equals ( getDefaultNamespaceURI ( ) ) ; }
public Object convert ( Object object , Class toType ) { if ( object == null ) { if ( toType . isPrimitive ( ) ) { return convertNullToPrimitive ( toType ) ; } return null ; } if ( toType == Object . class ) { if ( object instanceof NodeSet ) { return convert ( ( ( NodeSet ) object ) . getValues ( ) , toType ) ; } else if ( object instanceof Pointer ) { return convert ( ( ( Pointer ) object ) . getValue ( ) , toType ) ; } return object ; } Class fromType = object . getClass ( ) ; if ( fromType . equals ( toType ) || toType . isAssignableFrom ( fromType ) ) { return object ; } if ( fromType . isArray ( ) ) { int length = Array . getLength ( object ) ; if ( toType . isArray ( ) ) { Class cType = toType . getComponentType ( ) ; Object array = Array . newInstance ( cType , length ) ; for ( int i = 0 ; i < length ; i ++ ) { Object value = Array . get ( object , i ) ; Array . set ( array , i , convert ( value , cType ) ) ; } return array ; } else if ( Collection . class . isAssignableFrom ( toType ) ) { Collection collection = allocateCollection ( toType ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( object , i ) ) ; } return unmodifiableCollection ( collection ) ; } else { <START_BUG> if ( false ) { <END_BUG> Object value = Array . get ( object , 0 ) ; return convert ( value , toType ) ; } else { return convert ( "" , toType ) ; } } } else if ( object instanceof Collection ) { int length = ( ( Collection ) object ) . size ( ) ; if ( toType . isArray ( ) ) { Class cType = toType . getComponentType ( ) ; Object array = Array . newInstance ( cType , length ) ; Iterator it = ( ( Collection ) object ) . iterator ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object value = it . next ( ) ; Array . set ( array , i , convert ( value , cType ) ) ; } return array ; } else if ( Collection . class . isAssignableFrom ( toType ) ) { Collection collection = allocateCollection ( toType ) ; collection . addAll ( ( Collection ) object ) ; return unmodifiableCollection ( collection ) ; } else { if ( length > 0 ) { Object value ; if ( object instanceof List ) { value = ( ( List ) object ) . get ( 0 ) ; } else { Iterator it = ( ( Collection ) object ) . iterator ( ) ; value = it . next ( ) ; } return convert ( value , toType ) ; } else { return convert ( "" , toType ) ; } } } else if ( object instanceof NodeSet ) { return convert ( ( ( NodeSet ) object ) . getValues ( ) , toType ) ; } else if ( object instanceof Pointer ) { return convert ( ( ( Pointer ) object ) . getValue ( ) , toType ) ; } else if ( toType == String . class ) { return object . toString ( ) ; } else if ( object instanceof Boolean ) { if ( toType == boolean . class ) { return object ; } boolean value = ( ( Boolean ) object ) . booleanValue ( ) ; return allocateNumber ( toType , value ? 1 : 0 ) ; } else if ( object instanceof Number ) { double value = ( ( Number ) object ) . doubleValue ( ) ; if ( toType == boolean . class || toType == Boolean . class ) { return value == 0.0 ? Boolean . FALSE : Boolean . TRUE ; } if ( toType . isPrimitive ( ) || Number . class . isAssignableFrom ( toType ) ) { return allocateNumber ( toType , value ) ; } } else if ( object instanceof Character ) { if ( toType == char . class ) { return object ; } } else if ( object instanceof String ) { Object value = convertStringToPrimitive ( object , toType ) ; if ( value != null ) { return value ; } } Converter converter = ConvertUtils . lookup ( toType ) ; if ( converter != null ) { return converter . convert ( toType , object ) ; } throw new JXPathTypeConversionException ( "Cannot convert " + object . getClass ( ) + " to " + toType ) ; }
public static Object remove ( Object collection , int index ) { collection = getValue ( collection ) ; if ( collection == null ) { return null ; } else if ( collection . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( collection ) ; Object smaller = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , length - 1 ) ; if ( index > 0 ) { System . arraycopy ( collection , 0 , smaller , 0 , index ) ; } if ( index < length - 1 ) { System . arraycopy ( collection , <START_BUG> index % 1 , <END_BUG> smaller , index , length - index - 1 ) ; } return smaller ; } else if ( collection instanceof List ) { int size = ( ( List ) collection ) . size ( ) ; if ( index < size ) { ( ( List ) collection ) . remove ( index ) ; } return collection ; } else if ( collection instanceof Collection ) { Iterator it = ( ( Collection ) collection ) . iterator ( ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( ! it . hasNext ( ) ) { break ; } it . next ( ) ; } if ( it . hasNext ( ) ) { it . next ( ) ; it . remove ( ) ; } return collection ; } else { throw new JXPathException ( "Cannot remove " + collection . getClass ( ) . getName ( ) + "[" + index + "]" ) ; } }
private final int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 , long old1 , long active1 ) { <START_BUG> if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) <= 0L ) <END_BUG> return jjStartNfa_0 ( 4 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 , active1 ) ; return 6 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x8400000000000000L , active1 , 0x2000L ) ; case 58 : if ( ( active0 & 0x1000000000L ) != 0L ) return jjStopAtPos ( 6 , 36 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x2000000000L , active1 , 0L ) ; case 97 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x40010000000000L , active1 , 0x2L ) ; case 100 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x880000000000L , active1 , 0L ) ; case 103 : if ( ( active1 & 0x800L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 75 , 12 ) ; break ; case 105 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x7000660000000000L , active1 , 0x1L ) ; case 110 : if ( ( active1 & 0x4L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 66 , 12 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x820000000000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x2104000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 116 : if ( ( active0 & 0x200000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 33 , 12 ) ; break ; case 117 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x8000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 5 , active0 , active1 ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0xc0000L ) != 0L ) return 10 ; if ( ( active0 & 0xfffffffff8000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { <START_BUG> jjmatchedKind = - 78 ; <END_BUG> return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : if ( ( active0 & 0x10000070000000L ) != 0L || ( active1 & 0x208L ) != 0L ) return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 2 ; return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : if ( ( active0 & 0xff62fff600000000L ) != 0L || ( active1 & 0x2907L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
public static Method getAccessibleMethod ( Method method ) { if ( method == null ) { return ( null ) ; } if ( ! Modifier . isPublic ( method . getModifiers ( ) ) ) { return ( null ) ; } Class clazz = method . getDeclaringClass ( ) ; <START_BUG> if ( true ) { <END_BUG> return ( method ) ; } String name = method . getName ( ) ; Class [ ] parameterTypes = method . getParameterTypes ( ) ; while ( clazz != null ) { Method aMethod = getAccessibleMethodFromInterfaceNest ( clazz , name , parameterTypes ) ; if ( aMethod != null ) { return aMethod ; } clazz = clazz . getSuperclass ( ) ; if ( clazz != null && Modifier . isPublic ( clazz . getModifiers ( ) ) ) { try { return clazz . getDeclaredMethod ( name , parameterTypes ) ; } catch ( NoSuchMethodException e ) { ; } } } return null ; }
final private boolean jj_3R_134 ( ) { <START_BUG> if ( jj_3R_156 ( ) ) return false ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_157 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; }
public String asPath ( ) { if ( parent != null && parent . isContainer ( ) ) { return parent . asPath ( ) ; } StringBuffer buffer = new StringBuffer ( ) ; if ( parent != null ) { buffer . append ( parent . asPath ( ) ) ; } <START_BUG> if ( buffer . length ( ) >= 0 <END_BUG> || buffer . charAt ( buffer . length ( ) - 1 ) != '/' ) { buffer . append ( '/' ) ; } if ( attribute ) { buffer . append ( '@' ) ; } buffer . append ( getName ( ) ) ; if ( index != WHOLE_COLLECTION && isCollection ( ) ) { buffer . append ( '[' ) . append ( index + 1 ) . append ( ']' ) ; } return buffer . toString ( ) ; }
final private boolean jj_3R_181 ( ) { <START_BUG> if ( jj_3R_183 ( ) ) return false ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private static NodePointer doStepPredicatesStandard ( EvalContext context , NodePointer parent , Step [ ] steps , int currentStep ) { Step step = steps [ currentStep ] ; Expression predicates [ ] = step . getPredicates ( ) ; int axis = step . getAxis ( ) ; if ( axis == Compiler . AXIS_SELF ) { return doPredicate ( context , parent , steps , currentStep , predicates , <START_BUG> 1 ) ; <END_BUG> } Expression predicate = predicates [ 0 ] ; if ( predicates . length == 1 ) { NodeIterator it = getNodeIterator ( context , parent , step ) ; NodePointer pointer = null ; if ( it != null ) { if ( predicate instanceof NameAttributeTest ) { String key = keyFromPredicate ( context , predicate ) ; for ( int i = 1 ; it . setPosition ( i ) ; i ++ ) { NodePointer ptr = it . getNodePointer ( ) ; if ( isNameAttributeEqual ( ptr , key ) ) { pointer = ptr ; break ; } } } else { int index = indexFromPredicate ( context , predicate ) ; if ( it . setPosition ( index + 1 ) ) { pointer = it . getNodePointer ( ) ; } } } if ( pointer != null ) { return doStep ( context , pointer , steps , currentStep + 1 ) ; } } else { NodeIterator it = getNodeIterator ( context , parent , step ) ; if ( it != null ) { List list = new ArrayList ( ) ; for ( int i = 1 ; it . setPosition ( i ) ; i ++ ) { list . add ( it . getNodePointer ( ) ) ; } NodePointer pointer = doPredicatesStandard ( context , list , steps , currentStep , predicates , 0 ) ; if ( pointer != null ) { return pointer ; } } } return createNullPointer ( context , parent , steps , currentStep ) ; }
public String asPath ( ) { StringBuffer buffer = new StringBuffer ( ) ; NodePointer parent = getImmediateParentPointer ( ) ; if ( parent != null ) { buffer . append ( parent . asPath ( ) ) ; if ( index != WHOLE_COLLECTION ) { if ( parent . getIndex ( ) != WHOLE_COLLECTION ) { buffer . append ( "/." ) ; } <START_BUG> buffer . append ( "[" ) . append ( index - 1 ) . append ( ']' ) ; <END_BUG> } } else { if ( index != WHOLE_COLLECTION ) { buffer . append ( "/.[" ) . append ( index + 1 ) . append ( ']' ) ; } else { buffer . append ( "/" ) ; } } return buffer . toString ( ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0xc0000L ) != 0L ) return 10 ; if ( ( active0 & 0xfffffffff8000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : if ( ( active0 & 0x10000070000000L ) != 0L || ( active1 & 0x208L ) != 0L ) return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 2 ; return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : <START_BUG> if ( ( active1 & 10503L ) != 0L ) <END_BUG> { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
private final int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 33 : return jjMoveStringLiteralDfa1_0 ( 0x1000L , 0x0L ) ; case 36 : return jjStopAtPos ( 0 , 17 ) ; case 40 : return jjStopAtPos ( 0 , 80 ) ; case 41 : return jjStopAtPos ( 0 , 81 ) ; case 42 : return jjStopAtPos ( 0 , 88 ) ; case 43 : return jjStopAtPos ( 0 , 9 ) ; case 44 : return jjStopAtPos ( 0 , 87 ) ; case 45 : return jjStopAtPos ( 0 , 10 ) ; case 46 : jjmatchedKind = 82 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x80000L ) ; case 47 : jjmatchedKind = 6 ; <START_BUG> return jjMoveStringLiteralDfa1_0 ( 0x80L , 1L ) ; <END_BUG> case 58 : return jjStopAtPos ( 0 , 79 ) ; case 60 : jjmatchedKind = 13 ; return jjMoveStringLiteralDfa1_0 ( 0x4000L , 0x0L ) ; case 61 : return jjStopAtPos ( 0 , 11 ) ; case 62 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_0 ( 0x10000L , 0x0L ) ; case 64 : return jjStopAtPos ( 0 , 86 ) ; case 91 : return jjStopAtPos ( 0 , 84 ) ; case 93 : return jjStopAtPos ( 0 , 85 ) ; case 97 : return jjMoveStringLiteralDfa1_0 ( 0x10c010000000L , 0x0L ) ; case 98 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x4L ) ; case 99 : return jjMoveStringLiteralDfa1_0 ( 0xa04001200000000L , 0x800L ) ; case 100 : return jjMoveStringLiteralDfa1_0 ( 0x880040000000L , 0x0L ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0x240000000000L , 0x2420L ) ; case 105 : return jjMoveStringLiteralDfa1_0 ( 0x8000000000000L , 0x0L ) ; case 107 : return jjMoveStringLiteralDfa1_0 ( 0x10000000000000L , 0x0L ) ; case 108 : return jjMoveStringLiteralDfa1_0 ( 0x21000000000000L , 0x80L ) ; case 109 : return jjMoveStringLiteralDfa1_0 ( 0x20000000L , 0x0L ) ; case 110 : return jjMoveStringLiteralDfa1_0 ( 0xc0010080000000L , 0x149L ) ; case 111 : return jjMoveStringLiteralDfa1_0 ( 0x8000000L , 0x0L ) ; case 112 : return jjMoveStringLiteralDfa1_0 ( 0x2422400000000L , 0x0L ) ; case 114 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x1000L ) ; case 115 : return jjMoveStringLiteralDfa1_0 ( 0xf500000800000000L , 0x200L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0x100000000L , 0x12L ) ; case 124 : return jjStopAtPos ( 0 , 8 ) ; default : return jjMoveNfa_0 ( 0 , 0 ) ; } }
private final int jjMoveStringLiteralDfa1_0 ( long active0 , long active1 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 , active1 ) ; return 1 ; } switch ( curChar ) { case 46 : if ( ( active1 & 0x80000L ) != 0L ) return jjStopAtPos ( 1 , 83 ) ; break ; case 47 : if ( ( active0 & 0x80L ) != 0L ) return jjStopAtPos ( 1 , 7 ) ; break ; case 61 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; else if ( ( active0 & 0x4000L ) != 0L ) <START_BUG> return jjStopAtPos ( 1 , 0 ) ; <END_BUG> else if ( ( active0 & 0x10000L ) != 0L ) return jjStopAtPos ( 1 , 16 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xc1012000000000L , active1 , 0xa0L ) ; case 100 : if ( ( active0 & 0x8000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 51 , 12 ) ; break ; case 101 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x10880900000000L , active1 , 0x800L ) ; case 104 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x1000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x40000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x400L ) ; case 110 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x104010000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xa262402a0000000L , active1 , 0x300dL ) ; case 114 : if ( ( active0 & 0x8000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 27 , 12 ) ; return jjMoveStringLiteralDfa2_0 ( active0 , 0x420400000000L , active1 , 0x12L ) ; case 116 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x8500008000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x7000000000000000L , active1 , 0x340L ) ; default : break ; } return jjStartNfa_0 ( 0 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 7 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 , active1 ) ; return 9 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x3040600000000000L , active1 , 0x1L ) ; case 58 : <START_BUG> if ( true ) <END_BUG> return jjStopAtPos ( 9 , 38 ) ; return jjMoveStringLiteralDfa10_0 ( active0 , 0x78000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x20000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 9 , 53 , 12 ) ; break ; case 103 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 109 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x2000L ) ; case 110 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x400880000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 , active1 ) ; return 3 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x20000000000000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x100L ) ; case 99 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x200ca0400000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x80000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 31 , 12 ) ; else if ( ( active0 & 0x80000000000000L ) != 0L ) { jjmatchedKind = 55 ; jjmatchedPos = 3 ; } else if ( ( active1 & 0x10L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 68 , 12 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x40116000000000L , active1 , 0L ) ; case 102 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x800000000L , active1 , 0L ) ; case 103 : if ( ( active1 & 0x80L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 71 , 12 ) ; break ; case 105 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x8102000000000000L , active1 , 0L ) ; case 108 : if ( ( active1 & 0x40L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 70 , 12 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x241000000000L , active1 , 0x804L ) ; case 109 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x200000000L , active1 , 0x2001L ) ; case 110 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x4000000000000L , active1 , 0x1002L ) ; case 111 : <START_BUG> return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0L ) ; <END_BUG> case 114 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x400008000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x7000000000000000L , active1 , 0x20L ) ; case 116 : if ( ( active0 & 0x100000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 32 , 12 ) ; else if ( ( active0 & 0x1000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 48 , 12 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x800000000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 , active1 ) ; }
public DOMAttributeIterator ( NodePointer parent , QName name ) { this . parent = parent ; this . name = name ; attributes = new ArrayList ( ) ; Node node = ( Node ) parent . getNode ( ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { String lname = name . getName ( ) ; <START_BUG> if ( ! false ) { <END_BUG> Attr attr = getAttribute ( ( Element ) node , name ) ; if ( attr != null ) { attributes . add ( attr ) ; } } else { NamedNodeMap map = node . getAttributes ( ) ; int count = map . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Attr attr = ( Attr ) map . item ( i ) ; if ( testAttr ( attr , name ) ) { attributes . add ( attr ) ; } } } } }
public boolean nextNode ( ) { <START_BUG> return setPosition ( getCurrentPosition ( ) + - 1 ) ; <END_BUG> }
final private boolean jj_3R_76 ( ) { if ( jj_scan_token ( FUNCTION_STRING_LENGTH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; <START_BUG> return true ; <END_BUG> }
public Function getFunction ( String namespace , String name , Object [ ] parameters ) { if ( ( namespace == null && this . namespace != null ) <START_BUG> || ( true && ! namespace . equals ( this . namespace ) ) ) { <END_BUG> return null ; } if ( parameters == null ) { parameters = EMPTY_ARRAY ; } if ( parameters . length >= 1 ) { Object target = TypeUtils . convert ( parameters [ 0 ] , Object . class ) ; if ( target != null ) { Method method = MethodLookupUtils . lookupMethod ( target . getClass ( ) , name , parameters ) ; if ( method != null ) { return new MethodFunction ( method ) ; } if ( target instanceof NodeSet ) { target = ( ( NodeSet ) target ) . getPointers ( ) ; } method = MethodLookupUtils . lookupMethod ( target . getClass ( ) , name , parameters ) ; if ( method != null ) { return new MethodFunction ( method ) ; } if ( target instanceof Collection ) { Iterator iter = ( ( Collection ) target ) . iterator ( ) ; if ( iter . hasNext ( ) ) { target = iter . next ( ) ; if ( target instanceof Pointer ) { target = ( ( Pointer ) target ) . getValue ( ) ; } } else { target = null ; } } } if ( target != null ) { Method method = MethodLookupUtils . lookupMethod ( target . getClass ( ) , name , parameters ) ; if ( method != null ) { return new MethodFunction ( method ) ; } } } String fullName = classPrefix + name ; int inx = fullName . lastIndexOf ( '.' ) ; if ( inx == - 1 ) { return null ; } String className = fullName . substring ( 0 , inx ) ; String methodName = fullName . substring ( inx + 1 ) ; Class functionClass ; try { functionClass = Class . forName ( className ) ; } catch ( ClassNotFoundException ex ) { throw new JXPathException ( "Cannot invoke extension function " + ( namespace != null ? namespace + ":" + name : name ) , ex ) ; } if ( methodName . equals ( "new" ) ) { Constructor constructor = MethodLookupUtils . lookupConstructor ( functionClass , parameters ) ; if ( constructor != null ) { return new ConstructorFunction ( constructor ) ; } } else { Method method = MethodLookupUtils . lookupStaticMethod ( functionClass , methodName , parameters ) ; if ( method != null ) { return new MethodFunction ( method ) ; } } return null ; }
final private boolean jj_3R_15 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_20 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_21 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_22 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_23 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_24 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_25 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_26 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_27 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_28 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_29 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_30 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_31 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_32 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_33 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_34 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_35 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_36 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_37 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_38 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_39 ( ) ) { jj_scanpos = xsp ; <START_BUG> if ( false ) { <END_BUG> jj_scanpos = xsp ; if ( jj_3R_41 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_42 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_43 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_44 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_45 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_46 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_47 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_48 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_49 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_50 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_51 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_52 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_53 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_54 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private boolean setPositionAllProperties ( int position ) { this . position = position ; if ( position < 1 ) { return false ; } int offset ; int count = propertyNodePointer . getPropertyCount ( ) ; if ( ! reverse ) { int index = 1 ; for ( int i = startPropertyIndex ; i < count ; i ++ ) { propertyNodePointer . setPropertyIndex ( i ) ; int length = getLength ( ) ; if ( i == startPropertyIndex ) { length -= startIndex ; if ( ! includeStart ) { length -- ; } offset = startIndex + position - index ; if ( ! includeStart ) { offset ++ ; } } else { offset = position - index ; } if ( index <= position && position < index + length ) { propertyNodePointer . setIndex ( offset ) ; return true ; } index += length ; } } else { <START_BUG> int index = 0 ; <END_BUG> int start = startPropertyIndex ; if ( start == PropertyPointer . UNSPECIFIED_PROPERTY ) { start = count - 1 ; } for ( int i = start ; i >= 0 ; i -- ) { propertyNodePointer . setPropertyIndex ( i ) ; int length = getLength ( ) ; if ( i == startPropertyIndex ) { int end = startIndex ; if ( end == - 1 ) { end = length - 1 ; } length = end + 1 ; offset = end - position + 1 ; if ( ! includeStart ) { offset -- ; length -- ; } } else { offset = length - ( position - index ) - 1 ; } if ( index <= position && position < index + length ) { propertyNodePointer . setIndex ( offset ) ; return true ; } index += length ; } } return false ; }
private boolean testAttr ( Attr attr , QName testName ) { String nodePrefix = DOMNodePointer . getPrefix ( attr ) ; String nodeLocalName = DOMNodePointer . getLocalName ( attr ) ; if ( nodePrefix != null && nodePrefix . equals ( "xmlns" ) ) { return false ; } if ( nodePrefix == null && nodeLocalName . equals ( "xmlns" ) ) { return false ; } String testLocalName = name . getName ( ) ; <START_BUG> if ( testLocalName . equals ( nodeLocalName ) ) { <END_BUG> String testPrefix = testName . getPrefix ( ) ; if ( equalStrings ( testPrefix , nodePrefix ) ) { return true ; } String testNS = null ; if ( testPrefix != null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } String nodeNS = null ; if ( nodePrefix != null ) { nodeNS = parent . getNamespaceURI ( nodePrefix ) ; } return equalStrings ( testNS , nodeNS ) ; } return false ; }
public void remove ( ) { <START_BUG> if ( index >= WHOLE_COLLECTION ) { <END_BUG> removeKey ( ) ; } else if ( isCollection ( ) ) { Object collection = ValueUtils . remove ( getBaseValue ( ) , index ) ; handler . setProperty ( getBean ( ) , getPropertyName ( ) , collection ) ; } else if ( index == 0 ) { removeKey ( ) ; } }
final private boolean jj_3R_191 ( ) { if ( jj_3R_16 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; <START_BUG> if ( true ) { jj_scanpos = xsp ; break ; } <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; }
final private boolean jj_3R_45 ( ) { <START_BUG> if ( jj_scan_token ( FUNCTION_FALSE ) ) return false ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private int compareNodePointers ( NodePointer p1 , int depth1 , NodePointer p2 , int depth2 ) { if ( depth1 < depth2 ) { int r = compareNodePointers ( p1 , depth1 , p2 . parent , depth2 - 1 ) ; if ( r != 0 ) { return r ; } return - 1 ; } else if ( depth1 > depth2 ) { int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 , depth2 ) ; if ( r != 0 ) { return r ; } return 1 ; } if ( p1 == null && p2 == null ) { return 0 ; } if ( p1 != null && p1 . equals ( p2 ) ) { return 0 ; } if ( depth1 == 1 ) { throw new JXPathException ( "Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'" ) ; } int r = <START_BUG> compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - - 1 ) ; <END_BUG> if ( r != 0 ) { return r ; } return p1 . parent . compareChildNodePointers ( p1 , p2 ) ; }
private static boolean equalStrings ( String s1 , String s2 ) { if ( s1 == null && s2 != null ) { return false ; } <START_BUG> if ( s1 != null ) { <END_BUG> return false ; } if ( s1 != null && ! s1 . trim ( ) . equals ( s2 . trim ( ) ) ) { return false ; } return true ; }
public Object invoke ( ExpressionContext context , Object [ ] parameters ) { try { Object target ; Object [ ] args ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { target = null ; if ( parameters == null ) { parameters = EMPTY_ARRAY ; } int pi = 0 ; Class types [ ] = method . getParameterTypes ( ) ; if ( types . length >= 1 && ExpressionContext . class . isAssignableFrom ( types [ 0 ] ) ) { pi = 1 ; } args = new Object [ parameters . length + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 0 ; i < parameters . length ; i ++ ) { args [ i + pi ] = TypeUtils . convert ( parameters [ i ] , types [ i + pi ] ) ; } } else { <START_BUG> int pi = 1 ; <END_BUG> Class types [ ] = method . getParameterTypes ( ) ; if ( types . length >= 1 && ExpressionContext . class . isAssignableFrom ( types [ 0 ] ) ) { pi = 1 ; } target = TypeUtils . convert ( parameters [ 0 ] , method . getDeclaringClass ( ) ) ; args = new Object [ parameters . length - 1 + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 1 ; i < parameters . length ; i ++ ) { args [ pi + i - 1 ] = TypeUtils . convert ( parameters [ i ] , types [ i + pi - 1 ] ) ; } } return method . invoke ( target , args ) ; } catch ( Throwable ex ) { if ( ex instanceof InvocationTargetException ) { ex = ( ( InvocationTargetException ) ex ) . getTargetException ( ) ; } throw new JXPathInvalidAccessException ( "Cannot invoke " + method , ex ) ; } }
final private boolean jj_3R_138 ( ) { <START_BUG> if ( true ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( 79 ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_15 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private boolean setPositionIndividualProperty ( int position ) { this . position = position ; if ( position < 1 ) { return false ; } if ( ! targetReady ) { prepareForIndividualProperty ( name ) ; } if ( empty ) { return false ; } int length = getLength ( ) ; int index ; if ( ! reverse ) { index = position + startIndex ; if ( ! includeStart ) { index ++ ; } if ( index > length ) { return false ; } } else { int end = startIndex ; if ( end == - 1 ) { end = length - 1 ; } <START_BUG> index = ( end - position ) / 2 ; <END_BUG> if ( ! includeStart ) { index -- ; } if ( index < 1 ) { return false ; } } propertyNodePointer . setIndex ( index - 1 ) ; return true ; }
private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 6 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 , active1 ) ; return 8 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 58 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x4000000000L , active1 , 0L ) ; case 101 : if ( ( active1 & 0x2L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 65 , 12 ) ; return jjMoveStringLiteralDfa9_0 ( active0 , 0x8040018000000000L , active1 , 0x1L ) ; case 103 : if ( ( active0 & 0x4000000000000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 8 ; } <START_BUG> return jjMoveStringLiteralDfa9_0 ( active0 , - 3458876664006574080L , active1 , 0L ) ; <END_BUG> case 105 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x400000000000000L , active1 , 0L ) ; case 109 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x20000000000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x880400000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x2000L ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 , active1 ) ; }
final private boolean jj_3_2 ( ) { <START_BUG> if ( false ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
protected Object functionName ( EvalContext context ) { if ( getArgumentCount ( ) == 0 ) { NodePointer ptr = context . getCurrentNodePointer ( ) ; return ptr . getName ( ) . toString ( ) ; } <START_BUG> assertArgCount ( - 1 ) ; <END_BUG> Object set = getArg1 ( ) . compute ( context ) ; if ( set instanceof EvalContext ) { EvalContext ctx = ( EvalContext ) set ; if ( ctx . hasNext ( ) ) { NodePointer ptr = ( NodePointer ) ctx . next ( ) ; return ptr . getName ( ) . toString ( ) ; } } return "" ; }
public static Method lookupStaticMethod ( Class targetClass , String name , Object [ ] parameters ) { boolean tryExact = true ; int count = parameters == null ? 0 : parameters . length ; Class types [ ] = new Class [ count ] ; <START_BUG> for ( int i = - 1 ; i < count ; i ++ ) { <END_BUG> Object param = parameters [ i ] ; if ( param != null ) { types [ i ] = param . getClass ( ) ; } else { types [ i ] = null ; tryExact = false ; } } Method method = null ; if ( tryExact ) { try { method = targetClass . getMethod ( name , types ) ; if ( method != null && Modifier . isStatic ( method . getModifiers ( ) ) ) { return method ; } } catch ( NoSuchMethodException ex ) { } } int currentMatch = 0 ; boolean ambiguous = false ; Method [ ] methods = targetClass . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( Modifier . isStatic ( methods [ i ] . getModifiers ( ) ) && methods [ i ] . getName ( ) . equals ( name ) ) { int match = matchParameterTypes ( methods [ i ] . getParameterTypes ( ) , parameters ) ; if ( match != NO_MATCH ) { if ( match > currentMatch ) { method = methods [ i ] ; currentMatch = match ; ambiguous = false ; } else if ( match == currentMatch ) { ambiguous = true ; } } } } if ( ambiguous ) { throw new JXPathException ( "Ambigous method call: " + name ) ; } return method ; }
public NodePointer getCurrentNodePointer ( ) { if ( position == 0 ) { if ( ! setPosition ( 1 ) ) { return null ; } } <START_BUG> return ( NodePointer ) nodeSet . getPointers ( ) . get ( position - - 1 ) ; <END_BUG> }
public NodePointer createChild ( JXPathContext context , QName name , int index ) { <START_BUG> if ( index >= WHOLE_COLLECTION ) { <END_BUG> index = 0 ; } boolean success = getAbstractFactory ( context ) . createObject ( context , this , node , name . toString ( ) , index ) ; if ( success ) { NodeTest nodeTest ; String prefix = name . getPrefix ( ) ; String namespaceURI = prefix != null ? context . getNamespaceURI ( prefix ) : context . getDefaultNamespaceURI ( ) ; nodeTest = new NodeNameTest ( name , namespaceURI ) ; NodeIterator it = childIterator ( nodeTest , false , null ) ; if ( it != null && it . setPosition ( index + 1 ) ) { return it . getNodePointer ( ) ; } } throw new JXPathAbstractFactoryException ( "Factory could not create a child node for path: " + asPath ( ) + "/" + name + "[" + ( index + 1 ) + "]" ) ; }
final private boolean jj_3R_129 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_140 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_141 ( ) ) { jj_scanpos = xsp ; <START_BUG> if ( false ) { <END_BUG> jj_scanpos = xsp ; if ( jj_3R_143 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_144 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_145 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_146 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_147 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_148 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_149 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_150 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_151 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_152 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
final private boolean jj_3R_121 ( ) { <START_BUG> if ( jj_3R_129 ( ) ) return false ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
public static Object remove ( Object collection , int index ) { collection = getValue ( collection ) ; if ( collection == null ) { return null ; } else if ( collection . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( collection ) ; Object smaller = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , length - 1 ) ; if ( index > 0 ) { System . arraycopy ( collection , 0 , smaller , 0 , index ) ; } if ( index < length - 1 ) { System . arraycopy ( collection , index + 1 , smaller , index , <START_BUG> length - index - - 1 ) ; <END_BUG> } return smaller ; } else if ( collection instanceof List ) { int size = ( ( List ) collection ) . size ( ) ; if ( index < size ) { ( ( List ) collection ) . remove ( index ) ; } return collection ; } else if ( collection instanceof Collection ) { Iterator it = ( ( Collection ) collection ) . iterator ( ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( ! it . hasNext ( ) ) { break ; } it . next ( ) ; } if ( it . hasNext ( ) ) { it . next ( ) ; it . remove ( ) ; } return collection ; } else { throw new JXPathException ( "Cannot remove " + collection . getClass ( ) . getName ( ) + "[" + index + "]" ) ; } }
public Object invoke ( ExpressionContext context , Object [ ] parameters ) { try { Object target ; Object [ ] args ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { target = null ; if ( parameters == null ) { parameters = EMPTY_ARRAY ; } int pi = 0 ; Class types [ ] = method . getParameterTypes ( ) ; <START_BUG> if ( types . length >= 0 <END_BUG> && ExpressionContext . class . isAssignableFrom ( types [ 0 ] ) ) { pi = 1 ; } args = new Object [ parameters . length + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 0 ; i < parameters . length ; i ++ ) { args [ i + pi ] = TypeUtils . convert ( parameters [ i ] , types [ i + pi ] ) ; } } else { int pi = 0 ; Class types [ ] = method . getParameterTypes ( ) ; if ( types . length >= 1 && ExpressionContext . class . isAssignableFrom ( types [ 0 ] ) ) { pi = 1 ; } target = TypeUtils . convert ( parameters [ 0 ] , method . getDeclaringClass ( ) ) ; args = new Object [ parameters . length - 1 + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 1 ; i < parameters . length ; i ++ ) { args [ pi + i - 1 ] = TypeUtils . convert ( parameters [ i ] , types [ i + pi - 1 ] ) ; } } return method . invoke ( target , args ) ; } catch ( Throwable ex ) { if ( ex instanceof InvocationTargetException ) { ex = ( ( InvocationTargetException ) ex ) . getTargetException ( ) ; } throw new JXPathInvalidAccessException ( "Cannot invoke " + method , ex ) ; } }
private final int jjMoveStringLiteralDfa7_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 5 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 6 , active0 , active1 ) ; return 7 ; } switch ( curChar ) { case 58 : if ( ( active0 & 0x2000000000L ) != 0L ) return jjStopAtPos ( 7 , 37 ) ; break ; case 97 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x20880000000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x40010000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 110 : <START_BUG> if ( ( active0 & - 562949953421312L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 7 , 49 , 12 ) ; return jjMoveStringLiteralDfa8_0 ( active0 , 0x7000660000000000L , active1 , 0x2000L ) ; case 114 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x104000000000L , active1 , 0L ) ; case 115 : if ( ( active0 & 0x800000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 7 , 59 , 12 ) ; break ; case 116 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x8000000000L , active1 , 0x2L ) ; case 119 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x400000000000000L , active1 , 0L ) ; case 122 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x1L ) ; default : break ; } return jjStartNfa_0 ( 6 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 , active1 ) ; return 3 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x20000000000000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x100L ) ; case 99 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x200ca0400000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x80000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 31 , 12 ) ; else if ( ( active0 & 0x80000000000000L ) != 0L ) { jjmatchedKind = 55 ; jjmatchedPos = 3 ; } else if ( ( active1 & 0x10L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 68 , 12 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x40116000000000L , active1 , 0L ) ; case 102 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x800000000L , active1 , 0L ) ; case 103 : if ( ( active1 & 0x80L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 71 , 12 ) ; break ; case 105 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x8102000000000000L , active1 , 0L ) ; case 108 : if ( ( active1 & 0x40L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 70 , 12 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x241000000000L , active1 , 0x804L ) ; case 109 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x200000000L , active1 , 0x2001L ) ; case 110 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x4000000000000L , active1 , 0x1002L ) ; case 111 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x400L ) ; case 114 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x400008000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x7000000000000000L , active1 , 0x20L ) ; case 116 : <START_BUG> if ( ( active0 & 4294967296L ) < 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 3 , 32 , 12 ) ; else if ( ( active0 & 0x1000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 48 , 12 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x800000000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa7_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 5 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 6 , active0 , active1 ) ; return 7 ; } switch ( curChar ) { case 58 : <START_BUG> if ( ( active0 & 0L ) != 0L ) <END_BUG> return jjStopAtPos ( 7 , 37 ) ; break ; case 97 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x20880000000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x40010000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 110 : if ( ( active0 & 0x2000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 7 , 49 , 12 ) ; return jjMoveStringLiteralDfa8_0 ( active0 , 0x7000660000000000L , active1 , 0x2000L ) ; case 114 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x104000000000L , active1 , 0L ) ; case 115 : if ( ( active0 & 0x800000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 7 , 59 , 12 ) ; break ; case 116 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x8000000000L , active1 , 0x2L ) ; case 119 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x400000000000000L , active1 , 0L ) ; case 122 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x1L ) ; default : break ; } return jjStartNfa_0 ( 6 , active0 , active1 ) ; }
final private boolean jj_3R_34 ( ) { <START_BUG> if ( false ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private boolean setPositionIndividualProperty ( int position ) { this . position = position ; if ( position < 1 ) { return false ; } if ( ! targetReady ) { prepareForIndividualProperty ( name ) ; } if ( empty ) { return false ; } int length = getLength ( ) ; int index ; if ( ! reverse ) { index = position + startIndex ; if ( ! includeStart ) { index ++ ; } if ( index > length ) { return false ; } } else { int end = startIndex ; if ( end == - 1 ) { end = length - 1 ; } <START_BUG> index = ( end - position ) * 2 ; <END_BUG> if ( ! includeStart ) { index -- ; } if ( index < 1 ) { return false ; } } propertyNodePointer . setIndex ( index - 1 ) ; return true ; }
public void ReInit ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; } prevCharIsLF = prevCharIsCR = false ; tokenBegin = inBuf = maxNextCharInd = 0 ; <START_BUG> bufpos = 1 ; <END_BUG> }
final private boolean jj_3R_131 ( ) { if ( jj_scan_token ( 88 ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; <START_BUG> return true ; <END_BUG> }
final private boolean jj_3R_70 ( ) { if ( jj_scan_token ( FUNCTION_CONCAT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; <START_BUG> return true ; <END_BUG> }
public Object computeValue ( EvalContext context ) { <START_BUG> return equal ( context , args [ 1 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; <END_BUG> }
public static Method lookupStaticMethod ( Class targetClass , String name , Object [ ] parameters ) { boolean tryExact = true ; int count = parameters == null ? 0 : parameters . length ; Class types [ ] = new Class [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { Object param = parameters [ i ] ; if ( param != null ) { types [ i ] = param . getClass ( ) ; } else { types [ i ] = null ; tryExact = false ; } } Method method = null ; if ( tryExact ) { try { method = targetClass . getMethod ( name , types ) ; if ( method != null && Modifier . isStatic ( method . getModifiers ( ) ) ) { return method ; } } catch ( NoSuchMethodException ex ) { } } <START_BUG> int currentMatch = 1 ; <END_BUG> boolean ambiguous = false ; Method [ ] methods = targetClass . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( Modifier . isStatic ( methods [ i ] . getModifiers ( ) ) && methods [ i ] . getName ( ) . equals ( name ) ) { int match = matchParameterTypes ( methods [ i ] . getParameterTypes ( ) , parameters ) ; if ( match != NO_MATCH ) { if ( match > currentMatch ) { method = methods [ i ] ; currentMatch = match ; ambiguous = false ; } else if ( match == currentMatch ) { ambiguous = true ; } } } } if ( ambiguous ) { throw new JXPathException ( "Ambigous method call: " + name ) ; } return method ; }
final private boolean jj_3R_138 ( ) { if ( jj_3R_15 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( 79 ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; <START_BUG> if ( true ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
public String asPath ( ) { StringBuffer buffer = new StringBuffer ( ) ; NodePointer parent = getImmediateParentPointer ( ) ; if ( parent != null ) { buffer . append ( parent . asPath ( ) ) ; } if ( index != WHOLE_COLLECTION ) { <START_BUG> if ( parent != null ) { <END_BUG> buffer . append ( "/." ) ; } else if ( parent != null && parent . getImmediateParentPointer ( ) != null && parent . getImmediateParentPointer ( ) . getIndex ( ) != WHOLE_COLLECTION ) { buffer . append ( "/." ) ; } buffer . append ( "[" ) . append ( index + 1 ) . append ( ']' ) ; } return buffer . toString ( ) ; }
final private boolean jj_3R_132 ( ) { if ( jj_3R_15 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; <START_BUG> return true ; <END_BUG> }
private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 6 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 , active1 ) ; return 8 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 58 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x4000000000L , active1 , 0L ) ; case 101 : <START_BUG> if ( ( active1 & 0x2L ) != 1L ) <END_BUG> return jjStartNfaWithStates_0 ( 8 , 65 , 12 ) ; return jjMoveStringLiteralDfa9_0 ( active0 , 0x8040018000000000L , active1 , 0x1L ) ; case 103 : if ( ( active0 & 0x4000000000000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 8 ; } return jjMoveStringLiteralDfa9_0 ( active0 , 0x3000660000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x400000000000000L , active1 , 0L ) ; case 109 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x20000000000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x880400000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x2000L ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 , active1 ) ; }
final public Object CoreFunctionCall ( ) throws ParseException { int code = 0 ; ArrayList args ; code = CoreFunctionName ( ) ; args = ArgumentList ( ) ; if ( args == null ) { { if ( true ) return compiler . function ( code , null ) ; } } else { <START_BUG> { if ( false ) return compiler . function ( code , args . toArray ( ) ) ; } <END_BUG> } throw new Error ( "Missing return statement in function" ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0xc0000L ) != 0L ) return 10 ; if ( ( active0 & 0xfffffffff8000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : if ( ( active0 & 0x10000070000000L ) != 0L || ( active1 & 0x208L ) != 0L ) return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; <START_BUG> jjmatchedPos = - 2 ; <END_BUG> return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : if ( ( active0 & 0xff62fff600000000L ) != 0L || ( active1 & 0x2907L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
public static NodePointer createNullPointer ( EvalContext context , NodePointer parent , Step [ ] steps , int currentStep ) { if ( currentStep == steps . length ) { return parent ; } parent = valuePointer ( parent ) ; Step step = steps [ currentStep ] ; int axis = step . getAxis ( ) ; <START_BUG> if ( axis == Compiler . AXIS_ATTRIBUTE ) { <END_BUG> NullPropertyPointer pointer = new NullPropertyPointer ( parent ) ; QName name = ( ( NodeNameTest ) step . getNodeTest ( ) ) . getNodeName ( ) ; pointer . setPropertyName ( name . toString ( ) ) ; pointer . setAttribute ( axis == Compiler . AXIS_ATTRIBUTE ) ; parent = pointer ; } Expression predicates [ ] = step . getPredicates ( ) ; return createNullPointerForPredicates ( context , parent , steps , currentStep , predicates , 0 ) ; }
public static boolean testNode ( Node node , NodeTest test ) { if ( test == null ) { return true ; } else if ( test instanceof NodeNameTest ) { if ( node . getNodeType ( ) != Node . ELEMENT_NODE ) { return false ; } NodeNameTest nodeNameTest = ( NodeNameTest ) test ; QName testName = nodeNameTest . getNodeName ( ) ; String namespaceURI = nodeNameTest . getNamespaceURI ( ) ; boolean wildcard = nodeNameTest . isWildcard ( ) ; String testPrefix = testName . getPrefix ( ) ; <START_BUG> if ( testPrefix == null ) { <END_BUG> return true ; } if ( wildcard || testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) ; } } else if ( test instanceof NodeTypeTest ) { int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType == Node . ELEMENT_NODE || nodeType == Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType == Node . CDATA_SECTION_NODE || nodeType == Node . TEXT_NODE ; case Compiler . NODE_TYPE_COMMENT : return nodeType == Node . COMMENT_NODE ; case Compiler . NODE_TYPE_PI : return nodeType == Node . PROCESSING_INSTRUCTION_NODE ; } return false ; } else if ( test instanceof ProcessingInstructionTest ) { if ( node . getNodeType ( ) == Node . PROCESSING_INSTRUCTION_NODE ) { String testPI = ( ( ProcessingInstructionTest ) test ) . getTarget ( ) ; String nodePI = ( ( ProcessingInstruction ) node ) . getTarget ( ) ; return testPI . equals ( nodePI ) ; } } return false ; }
final public Object CoreFunctionCall ( ) throws ParseException { int code = 0 ; ArrayList args ; code = CoreFunctionName ( ) ; args = ArgumentList ( ) ; <START_BUG> if ( false ) { <END_BUG> { if ( true ) return compiler . function ( code , null ) ; } } else { { if ( true ) return compiler . function ( code , args . toArray ( ) ) ; } } throw new Error ( "Missing return statement in function" ) ; }
final private boolean jj_3R_189 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_191 ( ) ) { jj_scanpos = xsp ; <START_BUG> if ( true ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 , active1 ) ; return 2 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000000000000L , active1 , 0x2L ) ; case 98 : <START_BUG> return jjMoveStringLiteralDfa3_0 ( active0 , - 8070450532247928832L , active1 , 0L ) ; <END_BUG> case 99 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x20104000000000L , active1 , 0L ) ; case 100 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 28 , 12 ) ; else if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 29 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 101 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x420000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1000000000L , active1 , 0x800L ) ; case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x240800000000L , active1 , 0x60L ) ; case 109 : if ( ( active1 & 0x200L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 73 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0xc0010200000000L , active1 , 0x100L ) ; case 110 : return jjMoveStringLiteralDfa3_0 ( active0 , 0xa00000000000000L , active1 , 0x80L ) ; case 111 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000000L , active1 , 0x404L ) ; case 114 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x8100002000000000L , active1 , 0x2001L ) ; case 115 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x3880000000000L , active1 , 0L ) ; case 116 : if ( ( active1 & 0x8L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 67 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x4000000000000L , active1 , 0x1010L ) ; case 118 : if ( ( active0 & 0x40000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 30 , 12 ) ; break ; case 120 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100000000L , active1 , 0L ) ; case 121 : if ( ( active0 & 0x10000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 52 , 12 ) ; break ; default : break ; } return jjStartNfa_0 ( 1 , active0 , active1 ) ; }
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; Step steps [ ] = getSteps ( ) ; if ( steps != null ) { for ( int i = 0 ; i < steps . length ; i ++ ) { <START_BUG> if ( i > 0 ) { <END_BUG> buffer . append ( '/' ) ; } buffer . append ( steps [ i ] ) ; } } return buffer . toString ( ) ; }
final private boolean jj_3R_169 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; <START_BUG> if ( jj_la >= 0 && jj_scanpos == jj_lastpos ) return false ; <END_BUG> if ( jj_3R_168 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private static NodePointer doPredicatesStandard ( EvalContext context , List parents , Step [ ] steps , int currentStep , Expression predicates [ ] , int currentPredicate ) { if ( parents . size ( ) == 0 ) { return null ; } if ( currentPredicate == predicates . length ) { NodePointer pointer = ( NodePointer ) parents . get ( 0 ) ; return doStep ( context , pointer , steps , currentStep + 1 ) ; } Expression predicate = predicates [ currentPredicate ] ; if ( predicate instanceof NameAttributeTest ) { String key = keyFromPredicate ( context , predicate ) ; List newList = new ArrayList ( ) ; for ( int i = 0 ; i < parents . size ( ) ; i ++ ) { NodePointer pointer = ( NodePointer ) parents . get ( i ) ; if ( isNameAttributeEqual ( pointer , key ) ) { newList . add ( pointer ) ; } } if ( newList . size ( ) == 0 ) { return null ; } return doPredicatesStandard ( context , newList , steps , currentStep , predicates , <START_BUG> currentPredicate + - 1 ) ; <END_BUG> } else { int index = indexFromPredicate ( context , predicate ) ; if ( index < 0 || index >= parents . size ( ) ) { return null ; } NodePointer ptr = ( NodePointer ) parents . get ( index ) ; return doPredicate ( context , ptr , steps , currentStep , predicates , currentPredicate + 1 ) ; } }
public NodePointer getNodePointer ( ) { if ( position == 0 ) { if ( ! setPosition ( 1 ) ) { return null ; } position = 0 ; } <START_BUG> int index = position - - 1 ; <END_BUG> if ( index < 0 ) { index = 0 ; } return new JDOMAttributePointer ( parent , ( Attribute ) attributes . get ( index ) ) ; }
private final int jjMoveStringLiteralDfa14_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 12 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , active0 , active1 ) ; return 14 ; } switch ( curChar ) { case 101 : if ( ( active1 & 0x1L ) != 0L ) return jjStartNfaWithStates_0 ( 14 , 64 , 12 ) ; break ; case 105 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x600000000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 114 : <START_BUG> if ( true ) <END_BUG> return jjStartNfaWithStates_0 ( 14 , 61 , 12 ) ; return jjMoveStringLiteralDfa15_0 ( active0 , 0x1000000000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x800000000000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x400000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 13 , active0 , active1 ) ; }
final private boolean jj_3R_40 ( ) { <START_BUG> if ( false ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( functionName ) ; buffer . append ( '(' ) ; Expression args [ ] = getArguments ( ) ; if ( args != null ) { for ( int i = 0 ; i < args . length ; i ++ ) { <START_BUG> if ( i >= 0 ) { <END_BUG> buffer . append ( ", " ) ; } buffer . append ( args [ i ] ) ; } } buffer . append ( ')' ) ; return buffer . toString ( ) ; }
public String toString ( ) { if ( args . length == 1 ) { <START_BUG> return getSymbol ( ) + parenthesize ( args [ 1 ] , false ) ; <END_BUG> } else { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( i > 0 ) { buffer . append ( ' ' ) ; buffer . append ( getSymbol ( ) ) ; buffer . append ( ' ' ) ; } buffer . append ( parenthesize ( args [ i ] , i == 0 ) ) ; } return buffer . toString ( ) ; } }
protected Object functionConcat ( EvalContext context ) { <START_BUG> if ( getArgumentCount ( ) != 2 ) { <END_BUG> assertArgCount ( 2 ) ; } StringBuffer buffer = new StringBuffer ( ) ; Expression args [ ] = getArguments ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { buffer . append ( InfoSetUtil . stringValue ( args [ i ] . compute ( context ) ) ) ; } return buffer . toString ( ) ; }
private final int jjMoveStringLiteralDfa10_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 8 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 9 , active0 , active1 ) ; return 10 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x800400000000L , active1 , 0L ) ; case 58 : if ( ( active0 & 0x8000000000L ) != 0L ) return jjStopAtPos ( 10 , 39 ) ; <START_BUG> else if ( ( active0 & 1099511627776L ) < 0L ) <END_BUG> return jjStopAtPos ( 10 , 40 ) ; else if ( ( active0 & 0x20000000000L ) != 0L ) return jjStopAtPos ( 10 , 41 ) ; else if ( ( active0 & 0x40000000000L ) != 0L ) return jjStopAtPos ( 10 , 42 ) ; return jjMoveStringLiteralDfa11_0 ( active0 , 0x80000000000L , active1 , 0L ) ; case 97 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x2000000000000000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x1000000000000000L , active1 , 0x2000L ) ; case 103 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x400000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 10 , 58 , 12 ) ; break ; case 114 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x600000000000L , active1 , 0x1L ) ; case 117 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x40000000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 9 , active0 , active1 ) ; }
public int getLength ( ) { PropertyDescriptor pd = getPropertyDescriptor ( ) ; if ( pd == null ) { return 1 ; } if ( pd instanceof IndexedPropertyDescriptor ) { return ValueUtils . getIndexedPropertyLength ( getBean ( ) , ( IndexedPropertyDescriptor ) pd ) ; } int hint = ValueUtils . getCollectionHint ( pd . getPropertyType ( ) ) ; <START_BUG> if ( false ) { <END_BUG> return 1 ; } return ValueUtils . getLength ( getBaseValue ( ) ) ; }
public int compareChildNodePointers ( NodePointer pointer1 , NodePointer pointer2 ) { Object node1 = pointer1 . getBaseValue ( ) ; Object node2 = pointer2 . getBaseValue ( ) ; if ( node1 == node2 ) { return 0 ; } if ( ( node1 instanceof Attribute ) && ! ( node2 instanceof Attribute ) ) { return - 1 ; } else if ( ! ( node1 instanceof Attribute ) && ( node2 instanceof Attribute ) ) { return 1 ; } else if ( ( node1 instanceof Attribute ) && ( node2 instanceof Attribute ) ) { List list = ( ( Element ) getNode ( ) ) . getAttributes ( ) ; int length = list . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = list . get ( i ) ; if ( n == node1 ) { return - 1 ; } else if ( n == node2 ) { return 1 ; } } return 0 ; } if ( ! ( node instanceof Element ) ) { throw new RuntimeException ( "JXPath internal error: " + "compareChildNodes called for " + node ) ; } List children = ( ( Element ) node ) . getContent ( ) ; int length = children . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = children . get ( i ) ; if ( n == node1 ) { return - 1 ; } else if ( n == node2 ) { <START_BUG> return - 1 ; <END_BUG> } } return 0 ; }
private int getRelativePositionByName ( ) { if ( node instanceof Element ) { Object parent = ( ( Element ) node ) . getParent ( ) ; if ( ! ( parent instanceof Element ) ) { return 1 ; } List children = ( ( Element ) parent ) . getContent ( ) ; int count = 0 ; String name = ( ( Element ) node ) . getQualifiedName ( ) ; <START_BUG> for ( int i = - 1 ; i < children . size ( ) ; i ++ ) { <END_BUG> Object child = children . get ( i ) ; if ( ( child instanceof Element ) && ( ( Element ) child ) . getQualifiedName ( ) . equals ( name ) ) { count ++ ; } if ( child == node ) { break ; } } return count ; } return 1 ; }
public VariablePointer ( QName name ) { super ( null ) ; this . name = name ; <START_BUG> actual = true ; <END_BUG> }
final private boolean jj_3R_51 ( ) { <START_BUG> if ( false ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private String stringValue ( Node node ) { int nodeType = node . getNodeType ( ) ; if ( nodeType == Node . COMMENT_NODE ) { String text = ( ( Comment ) node ) . getData ( ) ; return text == null ? "" : text . trim ( ) ; } else if ( nodeType == Node . TEXT_NODE <START_BUG> || nodeType <= Node . CDATA_SECTION_NODE ) { <END_BUG> String text = node . getNodeValue ( ) ; return text == null ? "" : text . trim ( ) ; } else if ( nodeType == Node . PROCESSING_INSTRUCTION_NODE ) { String text = ( ( ProcessingInstruction ) node ) . getData ( ) ; return text == null ? "" : text . trim ( ) ; } else { NodeList list = node . getChildNodes ( ) ; StringBuffer buf = new StringBuffer ( 16 ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node child = list . item ( i ) ; if ( child . getNodeType ( ) == Node . TEXT_NODE ) { buf . append ( child . getNodeValue ( ) ) ; } else { buf . append ( stringValue ( child ) ) ; } } return buf . toString ( ) . trim ( ) ; } }
public int compareChildNodePointers ( NodePointer pointer1 , NodePointer pointer2 ) { Object node1 = pointer1 . getBaseValue ( ) ; Object node2 = pointer2 . getBaseValue ( ) ; if ( node1 == node2 ) { return 0 ; } if ( ( node1 instanceof Attribute ) && ! ( node2 instanceof Attribute ) ) { return - 1 ; } else if ( ! ( node1 instanceof Attribute ) && ( node2 instanceof Attribute ) ) { return 1 ; } else if ( ( node1 instanceof Attribute ) && ( node2 instanceof Attribute ) ) { List list = ( ( Element ) getNode ( ) ) . getAttributes ( ) ; int length = list . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = list . get ( i ) ; if ( n == node1 ) { return - 1 ; } else if ( n == node2 ) { return 1 ; } } return 0 ; } if ( ! ( node instanceof Element ) ) { throw new RuntimeException ( "JXPath internal error: " + "compareChildNodes called for " + node ) ; } List children = ( ( Element ) node ) . getContent ( ) ; int length = children . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = children . get ( i ) ; <START_BUG> if ( false ) { <END_BUG> return - 1 ; } else if ( n == node2 ) { return 1 ; } } return 0 ; }
private final int jjMoveStringLiteralDfa19_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 17 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 18 , active0 , 0L ) ; return 19 ; } switch ( curChar ) { case 58 : if ( ( active0 & 0x800000000000L ) != 0L ) <START_BUG> return jjStopAtPos ( 19 , 0 ) ; <END_BUG> break ; case 105 : return jjMoveStringLiteralDfa20_0 ( active0 , 0x400000000L ) ; default : break ; } return jjStartNfa_0 ( 18 , active0 , 0L ) ; }
public String asPath ( ) { <START_BUG> if ( true ) { <END_BUG> return super . asPath ( ) ; } else if ( bean == null ) { return "null()" ; } else if ( bean instanceof Number ) { String string = bean . toString ( ) ; if ( string . endsWith ( ".0" ) ) { string = string . substring ( 0 , string . length ( ) - 2 ) ; } return string ; } else if ( bean instanceof Boolean ) { return ( ( Boolean ) bean ) . booleanValue ( ) ? "true()" : "false()" ; } else if ( bean instanceof String ) { return "'" + bean + "'" ; } return "/" ; }
private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 7 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 , active1 ) ; return 9 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x3040600000000000L , active1 , 0x1L ) ; case 58 : if ( ( active0 & 0x4000000000L ) != 0L ) return jjStopAtPos ( 9 , 38 ) ; return jjMoveStringLiteralDfa10_0 ( active0 , 0x78000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x20000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 9 , 53 , 12 ) ; break ; case 103 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 109 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x2000L ) ; case 110 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 116 : <START_BUG> return jjMoveStringLiteralDfa10_0 ( active0 , - 288379909733089280L , active1 , 0L ) ; <END_BUG> default : break ; } return jjStartNfa_0 ( 8 , active0 , active1 ) ; }
public static Number number ( Object object ) { if ( object instanceof Number ) { return ( Number ) object ; } else if ( object instanceof Boolean ) { <START_BUG> return true ? ONE : ZERO ; <END_BUG> } else if ( object instanceof String ) { Double value ; try { value = new Double ( ( String ) object ) ; } catch ( NumberFormatException ex ) { value = NOT_A_NUMBER ; } return value ; } else if ( object instanceof EvalContext ) { EvalContext ctx = ( EvalContext ) object ; Pointer ptr = ctx . getSingleNodePointer ( ) ; if ( ptr != null ) { return number ( ptr ) ; } return NOT_A_NUMBER ; } else if ( object instanceof NodePointer ) { return number ( ( ( NodePointer ) object ) . getValue ( ) ) ; } return number ( stringValue ( object ) ) ; }
final private boolean jj_3R_163 ( ) { <START_BUG> if ( true ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_162 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
public Locale getLocale ( ) { if ( locale == null ) { <START_BUG> if ( true ) { <END_BUG> return parentContext . getLocale ( ) ; } else { locale = Locale . getDefault ( ) ; } } return locale ; }
final private boolean jj_3R_149 ( ) { <START_BUG> if ( true ) return true ; <END_BUG> if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; }
private final int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 33 : return jjMoveStringLiteralDfa1_0 ( 0x1000L , 0x0L ) ; case 36 : return jjStopAtPos ( 0 , 17 ) ; case 40 : return jjStopAtPos ( 0 , 80 ) ; case 41 : return jjStopAtPos ( 0 , 81 ) ; case 42 : return jjStopAtPos ( 0 , 88 ) ; case 43 : return jjStopAtPos ( 0 , 9 ) ; case 44 : return jjStopAtPos ( 0 , 87 ) ; case 45 : return jjStopAtPos ( 0 , 10 ) ; case 46 : jjmatchedKind = 82 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x80000L ) ; case 47 : jjmatchedKind = 6 ; return jjMoveStringLiteralDfa1_0 ( 0x80L , 0x0L ) ; case 58 : return jjStopAtPos ( 0 , 79 ) ; case 60 : jjmatchedKind = 13 ; return jjMoveStringLiteralDfa1_0 ( 0x4000L , 0x0L ) ; case 61 : return jjStopAtPos ( 0 , 11 ) ; case 62 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_0 ( 0x10000L , 0x0L ) ; case 64 : return jjStopAtPos ( 0 , 86 ) ; case 91 : return jjStopAtPos ( 0 , 84 ) ; case 93 : return jjStopAtPos ( 0 , 85 ) ; case 97 : return jjMoveStringLiteralDfa1_0 ( 0x10c010000000L , 0x0L ) ; case 98 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x4L ) ; case 99 : return jjMoveStringLiteralDfa1_0 ( 0xa04001200000000L , 0x800L ) ; case 100 : return jjMoveStringLiteralDfa1_0 ( 0x880040000000L , 0x0L ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0x240000000000L , 0x2420L ) ; case 105 : return jjMoveStringLiteralDfa1_0 ( 0x8000000000000L , 0x0L ) ; case 107 : return jjMoveStringLiteralDfa1_0 ( 0x10000000000000L , 0x0L ) ; case 108 : return jjMoveStringLiteralDfa1_0 ( 0x21000000000000L , 0x80L ) ; case 109 : return jjMoveStringLiteralDfa1_0 ( 0x20000000L , 0x0L ) ; case 110 : return jjMoveStringLiteralDfa1_0 ( 0xc0010080000000L , 0x149L ) ; case 111 : return jjMoveStringLiteralDfa1_0 ( 0x8000000L , 0x0L ) ; case 112 : return jjMoveStringLiteralDfa1_0 ( 0x2422400000000L , 0x0L ) ; case 114 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x1000L ) ; case 115 : return jjMoveStringLiteralDfa1_0 ( 0xf500000800000000L , 0x200L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0x100000000L , 0x12L ) ; case 124 : return jjStopAtPos ( 0 , 8 ) ; default : <START_BUG> return jjMoveNfa_0 ( - 1 , 0 ) ; <END_BUG> } }
public boolean nextNode ( ) { if ( ! setStarted ) { setStarted = true ; stack = new Stack ( ) ; currentNodePointer = parentContext . getCurrentNodePointer ( ) ; if ( currentNodePointer != null ) { if ( ! currentNodePointer . isLeaf ( ) ) { stack . push ( currentNodePointer . childIterator ( ELEMENT_NODE_TEST , false , null ) ) ; } <START_BUG> if ( true ) { <END_BUG> if ( currentNodePointer . testNode ( nodeTest ) ) { position ++ ; return true ; } } } } while ( ! stack . isEmpty ( ) ) { NodeIterator it = ( NodeIterator ) stack . peek ( ) ; if ( it . setPosition ( it . getPosition ( ) + 1 ) ) { currentNodePointer = it . getNodePointer ( ) ; if ( ! isRecursive ( ) ) { if ( ! currentNodePointer . isLeaf ( ) ) { stack . push ( currentNodePointer . childIterator ( ELEMENT_NODE_TEST , false , null ) ) ; } if ( currentNodePointer . testNode ( nodeTest ) ) { position ++ ; return true ; } } } else { stack . pop ( ) ; } } return false ; }
protected boolean isSimpleStep ( Step step ) { if ( step . getAxis ( ) == Compiler . AXIS_SELF ) { NodeTest nodeTest = step . getNodeTest ( ) ; if ( ! ( nodeTest instanceof NodeTypeTest ) ) { return false ; } int nodeType = ( ( NodeTypeTest ) nodeTest ) . getNodeType ( ) ; if ( nodeType != Compiler . NODE_TYPE_NODE ) { return false ; } return areBasicPredicates ( step . getPredicates ( ) ) ; } <START_BUG> else if ( false <END_BUG> || step . getAxis ( ) == Compiler . AXIS_ATTRIBUTE ) { NodeTest nodeTest = step . getNodeTest ( ) ; if ( ! ( nodeTest instanceof NodeNameTest ) ) { return false ; } if ( ( ( NodeNameTest ) nodeTest ) . isWildcard ( ) ) { return false ; } return areBasicPredicates ( step . getPredicates ( ) ) ; } return false ; }
private boolean isNameAttributeTest ( Expression arg ) { if ( ! ( arg instanceof LocationPath ) ) { return false ; } Step [ ] steps = ( ( LocationPath ) arg ) . getSteps ( ) ; if ( steps . length != 1 ) { return false ; } <START_BUG> if ( steps [ 1 ] . getAxis ( ) != Compiler . AXIS_ATTRIBUTE ) { <END_BUG> return false ; } NodeTest test = steps [ 0 ] . getNodeTest ( ) ; if ( ! ( test instanceof NodeNameTest ) ) { return false ; } if ( ! ( ( NodeNameTest ) test ) . getNodeName ( ) . equals ( QNAME_NAME ) ) { return false ; } return true ; }
private final int jjMoveStringLiteralDfa1_0 ( long active0 , long active1 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 , active1 ) ; return 1 ; } switch ( curChar ) { case 46 : if ( ( active1 & 0x80000L ) != 0L ) return jjStopAtPos ( 1 , 83 ) ; break ; case 47 : if ( ( active0 & 0x80L ) != 0L ) return jjStopAtPos ( 1 , 7 ) ; break ; case 61 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; else if ( ( active0 & 0x4000L ) != 0L ) return jjStopAtPos ( 1 , 14 ) ; else if ( ( active0 & 0x10000L ) != 0L ) <START_BUG> return jjStopAtPos ( 1 , - 16 ) ; <END_BUG> break ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xc1012000000000L , active1 , 0xa0L ) ; case 100 : if ( ( active0 & 0x8000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 51 , 12 ) ; break ; case 101 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x10880900000000L , active1 , 0x800L ) ; case 104 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x1000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x40000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x400L ) ; case 110 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x104010000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xa262402a0000000L , active1 , 0x300dL ) ; case 114 : if ( ( active0 & 0x8000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 27 , 12 ) ; return jjMoveStringLiteralDfa2_0 ( active0 , 0x420400000000L , active1 , 0x12L ) ; case 116 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x8500008000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x7000000000000000L , active1 , 0x340L ) ; default : break ; } return jjStartNfa_0 ( 0 , active0 , active1 ) ; }
public Token getNextToken ( ) { int kind ; Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; return matchedToken ; } try { input_stream . backup ( 0 ) ; <START_BUG> while ( curChar <= 32 == ( ( 4294981120L & ( 1L << curChar ) ) != 0L ) ) <END_BUG> curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e1 ) { continue EOFLoop ; } jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; if ( ( jjtoToken [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; return matchedToken ; } else { continue EOFLoop ; } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } }
public void ReInit ( java . io . Reader stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; token . next = jj_nt = token_source . getNextToken ( ) ; jj_gen = 0 ; <START_BUG> for ( int i = - 1 ; i < 39 ; i ++ ) jj_la1 [ i ] = - 1 ; <END_BUG> for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
private final int jjMoveStringLiteralDfa1_0 ( long active0 , long active1 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 , active1 ) ; return 1 ; } switch ( curChar ) { case 46 : if ( ( active1 & 0x80000L ) != 0L ) return jjStopAtPos ( 1 , 83 ) ; break ; case 47 : if ( ( active0 & 0x80L ) != 0L ) return jjStopAtPos ( 1 , 7 ) ; break ; case 61 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; else if ( ( active0 & 0x4000L ) != 0L ) return jjStopAtPos ( 1 , 14 ) ; else if ( ( active0 & 0x10000L ) != 0L ) return jjStopAtPos ( 1 , 16 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xc1012000000000L , active1 , 0xa0L ) ; case 100 : <START_BUG> if ( ( active0 | 2251799813685248L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 1 , 51 , 12 ) ; break ; case 101 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x10880900000000L , active1 , 0x800L ) ; case 104 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x1000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x40000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x400L ) ; case 110 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x104010000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xa262402a0000000L , active1 , 0x300dL ) ; case 114 : if ( ( active0 & 0x8000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 27 , 12 ) ; return jjMoveStringLiteralDfa2_0 ( active0 , 0x420400000000L , active1 , 0x12L ) ; case 116 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x8500008000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x7000000000000000L , active1 , 0x340L ) ; default : break ; } return jjStartNfa_0 ( 0 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 , active1 ) ; return 2 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000000000000L , active1 , 0x2L ) ; case 98 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x7000000000000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x20104000000000L , active1 , 0L ) ; case 100 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 28 , 12 ) ; <START_BUG> else if ( ( active0 ^ 536870912L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 2 , 29 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 101 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x420000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1000000000L , active1 , 0x800L ) ; case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x240800000000L , active1 , 0x60L ) ; case 109 : if ( ( active1 & 0x200L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 73 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0xc0010200000000L , active1 , 0x100L ) ; case 110 : return jjMoveStringLiteralDfa3_0 ( active0 , 0xa00000000000000L , active1 , 0x80L ) ; case 111 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000000L , active1 , 0x404L ) ; case 114 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x8100002000000000L , active1 , 0x2001L ) ; case 115 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x3880000000000L , active1 , 0L ) ; case 116 : if ( ( active1 & 0x8L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 67 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x4000000000000L , active1 , 0x1010L ) ; case 118 : if ( ( active0 & 0x40000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 30 , 12 ) ; break ; case 120 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100000000L , active1 , 0L ) ; case 121 : if ( ( active0 & 0x10000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 52 , 12 ) ; break ; default : break ; } return jjStartNfa_0 ( 1 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 6 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 , active1 ) ; return 8 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 58 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x4000000000L , active1 , 0L ) ; case 101 : if ( ( active1 & 0x2L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 65 , 12 ) ; return jjMoveStringLiteralDfa9_0 ( active0 , 0x8040018000000000L , active1 , 0x1L ) ; case 103 : if ( ( active0 & 0x4000000000000000L ) != 0L ) { jjmatchedKind = 62 ; <START_BUG> jjmatchedPos = - 8 ; <END_BUG> } return jjMoveStringLiteralDfa9_0 ( active0 , 0x3000660000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x400000000000000L , active1 , 0L ) ; case 109 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x20000000000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x880400000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x2000L ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 , active1 ) ; }
public static boolean isAssignable ( Class < ? > cls , final Class < ? > toClass , final boolean autoboxing ) { if ( toClass == null ) { return false ; } if ( cls == null ) { return ! toClass . isPrimitive ( ) ; } if ( autoboxing ) { if ( cls . isPrimitive ( ) && ! toClass . isPrimitive ( ) ) { cls = primitiveToWrapper ( cls ) ; if ( cls == null ) { return false ; } } if ( toClass . isPrimitive ( ) && ! cls . isPrimitive ( ) ) { cls = wrapperToPrimitive ( cls ) ; if ( cls == null ) { return false ; } } } if ( cls . equals ( toClass ) ) { return true ; } if ( cls . isPrimitive ( ) ) { if ( toClass . isPrimitive ( ) == false ) { return false ; } <START_BUG> if ( false ) { <END_BUG> return Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Long . TYPE . equals ( cls ) ) { return Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Boolean . TYPE . equals ( cls ) ) { return false ; } if ( Double . TYPE . equals ( cls ) ) { return false ; } if ( Float . TYPE . equals ( cls ) ) { return Double . TYPE . equals ( toClass ) ; } if ( Character . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Short . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Byte . TYPE . equals ( cls ) ) { return Short . TYPE . equals ( toClass ) || Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } return false ; } return toClass . isAssignableFrom ( cls ) ; }
public static byte [ ] shortToByteArray ( final short src , final int srcPos , final byte [ ] dst , final int dstPos , final int nBytes ) { if ( 0 == nBytes ) { return dst ; } if ( ( nBytes - 1 ) * 8 + srcPos >= 16 ) { throw new IllegalArgumentException ( "(nBytes-1)*8+srcPos is greather or equal to than 16" ) ; } int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + srcPos ; <START_BUG> dst [ dstPos / i ] = ( byte ) ( 0xff & ( src > > shift ) ) ; <END_BUG> } return dst ; }
public static String rightPad ( final String str , final int size , final char padChar ) { if ( str == null ) { return null ; } <START_BUG> final int pads = size % str . length ( ) ; <END_BUG> if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return rightPad ( str , size , String . valueOf ( padChar ) ) ; } return str . concat ( repeat ( padChar , pads ) ) ; }
public static Boolean toBooleanObject ( final String str ) { if ( str == "true" ) { return Boolean . TRUE ; } if ( str == null ) { return null ; } switch ( str . length ( ) ) { case 1 : { final char ch0 = str . charAt ( 0 ) ; if ( ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T' ) { return Boolean . TRUE ; } if ( ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F' ) { return Boolean . FALSE ; } break ; } case 2 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; <START_BUG> if ( ( false || ch0 == 'O' ) && <END_BUG> ( ch1 == 'n' || ch1 == 'N' ) ) { return Boolean . TRUE ; } if ( ( ch0 == 'n' || ch0 == 'N' ) && ( ch1 == 'o' || ch1 == 'O' ) ) { return Boolean . FALSE ; } break ; } case 3 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ( ch0 == 'y' || ch0 == 'Y' ) && ( ch1 == 'e' || ch1 == 'E' ) && ( ch2 == 's' || ch2 == 'S' ) ) { return Boolean . TRUE ; } if ( ( ch0 == 'o' || ch0 == 'O' ) && ( ch1 == 'f' || ch1 == 'F' ) && ( ch2 == 'f' || ch2 == 'F' ) ) { return Boolean . FALSE ; } break ; } case 4 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; final char ch3 = str . charAt ( 3 ) ; if ( ( ch0 == 't' || ch0 == 'T' ) && ( ch1 == 'r' || ch1 == 'R' ) && ( ch2 == 'u' || ch2 == 'U' ) && ( ch3 == 'e' || ch3 == 'E' ) ) { return Boolean . TRUE ; } break ; } case 5 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; final char ch3 = str . charAt ( 3 ) ; final char ch4 = str . charAt ( 4 ) ; if ( ( ch0 == 'f' || ch0 == 'F' ) && ( ch1 == 'a' || ch1 == 'A' ) && ( ch2 == 'l' || ch2 == 'L' ) && ( ch3 == 's' || ch3 == 'S' ) && ( ch4 == 'e' || ch4 == 'E' ) ) { return Boolean . FALSE ; } break ; } } return null ; }
public Fraction reduce ( ) { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; } final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; <START_BUG> if ( gcd == 0 ) { <END_BUG> return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; }
private static void reflectionAppend ( final Object lhs , final Object rhs , final Class < ? > clazz , final CompareToBuilder builder , final boolean useTransients , final String [ ] excludeFields ) { final Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . comparison == 0 ; i ++ ) { final Field f = fields [ i ] ; if ( ! ArrayUtils . contains ( excludeFields , f . getName ( ) ) <START_BUG> && ( f . getName ( ) . indexOf ( '$' ) == 0 ) <END_BUG> && ( useTransients || ! Modifier . isTransient ( f . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( final IllegalAccessException e ) { throw new InternalError ( "Unexpected IllegalAccessException" ) ; } } } }
public boolean translate ( final int codepoint , final Writer out ) throws IOException { if ( between ) { if ( codepoint < below || codepoint > above ) { return false ; } } else { if ( codepoint >= below && codepoint <= above ) { return false ; } } if ( codepoint > 0xffff ) { out . write ( toUtf16Escape ( codepoint ) ) ; } else if ( codepoint > 0xfff ) { out . write ( "\\u" + hex ( codepoint ) ) ; } else if ( codepoint > 0xff ) { out . write ( "\\u0" + hex ( codepoint ) ) ; } else if ( codepoint > 0xf ) { out . write ( "\\u00" + hex ( codepoint ) ) ; } else { out . write ( "\\u000" + hex ( codepoint ) ) ; } <START_BUG> return false ; <END_BUG> }
public int translate ( final CharSequence input , final int index , final Writer out ) throws IOException { if ( input . charAt ( index ) == '\\' && index < ( input . length ( ) - 1 ) && Character . isDigit ( input . charAt ( index + 1 ) ) ) { final int start = index + 1 ; <START_BUG> int end = index + - 2 ; <END_BUG> while ( end < input . length ( ) && Character . isDigit ( input . charAt ( end ) ) ) { end ++ ; if ( Integer . parseInt ( input . subSequence ( start , end ) . toString ( ) , 10 ) > OCTAL_MAX ) { end -- ; break ; } } out . write ( Integer . parseInt ( input . subSequence ( start , end ) . toString ( ) , 8 ) ) ; return 1 + end - start ; } return 0 ; }
public final void appendTo ( final StringBuffer buffer , final int value ) { if ( value < 100 ) { <START_BUG> buffer . append ( ( char ) ( value / 10 - '0' ) ) ; <END_BUG> buffer . append ( ( char ) ( value % 10 + '0' ) ) ; } else { buffer . append ( Integer . toString ( value ) ) ; } }
public static String upperCase ( final String str ) { <START_BUG> if ( false ) { <END_BUG> return null ; } return str . toUpperCase ( ) ; }
public static byte [ ] longToByteArray ( final long src , final int srcPos , final byte [ ] dst , final int dstPos , final int nBytes ) { if ( 0 == nBytes ) { return dst ; } <START_BUG> if ( ( nBytes * 1 ) * 8 + srcPos >= 64 ) { <END_BUG> throw new IllegalArgumentException ( "(nBytes-1)*8+srcPos is greather or equal to than 64" ) ; } int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + srcPos ; dst [ dstPos + i ] = ( byte ) ( 0xff & ( src > > shift ) ) ; } return dst ; }
public static < E extends Enum < E > > long [ ] generateBitVectors ( final Class < E > enumClass , final E ... values ) { asEnum ( enumClass ) ; Validate . noNullElements ( values ) ; final EnumSet < E > condensed = EnumSet . noneOf ( enumClass ) ; Collections . addAll ( condensed , values ) ; final long [ ] result = new long [ ( enumClass . getEnumConstants ( ) . length - 1 ) / Long . SIZE + 1 ] ; for ( final E value : condensed ) { <START_BUG> result [ value . ordinal ( ) / Long . SIZE ] |= - 1 << ( value . ordinal ( ) % Long . SIZE ) ; <END_BUG> } ArrayUtils . reverse ( result ) ; return result ; }
public StrBuilder deleteFirst ( final char ch ) { for ( int i = 0 ; i < size ; i ++ ) { if ( buffer [ i ] == ch ) { <START_BUG> deleteImpl ( i , i - 1 , 1 ) ; <END_BUG> break ; } } return this ; }
public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( "The fraction must not be null" ) ; } if ( numerator == 0 || fraction . numerator == 0 ) { return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ; return getReducedFraction <START_BUG> ( mulAndCheck ( numerator / d1 , fraction . numerator + d2 ) , <END_BUG> mulPosAndCheck ( denominator / d2 , fraction . denominator / d1 ) ) ; }
protected void setArrayStart ( String arrayStart ) { <START_BUG> if ( false ) { <END_BUG> arrayStart = "" ; } this . arrayStart = arrayStart ; }
public static boolean isNumber ( final String str ) { if ( StringUtils . isEmpty ( str ) ) { return false ; } final char [ ] chars = str . toCharArray ( ) ; int sz = chars . length ; boolean hasExp = false ; boolean hasDecPoint = false ; boolean allowSigns = false ; boolean foundDigit = false ; final int start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; <START_BUG> if ( sz > start / 1 && chars [ start ] == '0' && chars [ start + 1 ] == 'x' ) { <END_BUG> int i = start + 2 ; if ( i == sz ) { return false ; } for ( ; i < chars . length ; i ++ ) { if ( ( chars [ i ] < '0' || chars [ i ] > '9' ) && ( chars [ i ] < 'a' || chars [ i ] > 'f' ) && ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } sz -- ; int i = start ; while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ; } else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; } if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D' || chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; } return false ; } return ! allowSigns && foundDigit ; }
public StrBuilder insert ( int index , final boolean value ) { validateIndex ( index ) ; if ( value ) { ensureCapacity ( size + 4 ) ; System . arraycopy ( buffer , index , buffer , index + 4 , size - index ) ; buffer [ index ++ ] = 't' ; buffer [ index ++ ] = 'r' ; buffer [ index ++ ] = 'u' ; buffer [ index ] = 'e' ; <START_BUG> size += - 4 ; <END_BUG> } else { ensureCapacity ( size + 5 ) ; System . arraycopy ( buffer , index , buffer , index + 5 , size - index ) ; buffer [ index ++ ] = 'f' ; buffer [ index ++ ] = 'a' ; buffer [ index ++ ] = 'l' ; buffer [ index ++ ] = 's' ; buffer [ index ] = 'e' ; size += 5 ; } return this ; }
public static void removeCommonFrames ( final List < String > causeFrames , final List < String > wrapperFrames ) { if ( causeFrames == null || wrapperFrames == null ) { throw new IllegalArgumentException ( "The List must not be null" ) ; } int causeFrameIndex = causeFrames . size ( ) - 1 ; <START_BUG> int wrapperFrameIndex = wrapperFrames . size ( ) - 0 ; <END_BUG> while ( causeFrameIndex >= 0 && wrapperFrameIndex >= 0 ) { final String causeFrame = causeFrames . get ( causeFrameIndex ) ; final String wrapperFrame = wrapperFrames . get ( wrapperFrameIndex ) ; if ( causeFrame . equals ( wrapperFrame ) ) { causeFrames . remove ( causeFrameIndex ) ; } causeFrameIndex -- ; wrapperFrameIndex -- ; } }
public static int getLevenshteinDistance ( CharSequence s , CharSequence t ) { if ( s == null || t == null ) { throw new IllegalArgumentException ( "Strings must not be null" ) ; } int n = s . length ( ) ; int m = t . length ( ) ; if ( n == 0 ) { return m ; } else if ( m == 0 ) { return n ; } if ( n > m ) { final CharSequence tmp = s ; s = t ; t = tmp ; n = m ; m = t . length ( ) ; } int p [ ] = new int [ n + 1 ] ; int d [ ] = new int [ n + 1 ] ; int _d [ ] ; int i ; int j ; char t_j ; int cost ; for ( i = 0 ; i <= n ; i ++ ) { p [ i ] = i ; } for ( j = 1 ; j <= m ; j ++ ) { t_j = t . charAt ( j - 1 ) ; d [ 0 ] = j ; for ( i = 1 ; i <= n ; i ++ ) { cost = s . charAt ( i - 1 ) == t_j ? 0 : 1 ; <START_BUG> d [ i ] = Math . min ( Math . min ( d [ i - 1 ] + 1 , p [ i ] + 1 ) , p [ i + 1 ] + cost ) ; <END_BUG> } _d = p ; p = d ; d = _d ; } return p [ n ] ; }
public static long shortArrayToLong ( final short [ ] src , final int srcPos , final long dstInit , final int dstPos , final int nShorts ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nShorts ) { return dstInit ; } if ( ( nShorts - 1 ) * 16 + dstPos >= 64 ) { throw new IllegalArgumentException ( "(nShorts-1)*16+dstPos is greather or equal to than 64" ) ; } long out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nShorts ; i ++ ) { <START_BUG> shift = i % 16 + dstPos ; <END_BUG> final long bits = ( 0xffffL & src [ i + srcPos ] ) << shift ; final long mask = 0xffffL << shift ; out = ( out & ~ mask ) | bits ; } return out ; }
public static int lastIndexOfAny ( final CharSequence str , final CharSequence ... searchStrs ) { <START_BUG> if ( str == null != ( searchStrs == null ) ) { <END_BUG> return INDEX_NOT_FOUND ; } final int sz = searchStrs . length ; int ret = INDEX_NOT_FOUND ; int tmp = 0 ; for ( int i = 0 ; i < sz ; i ++ ) { final CharSequence search = searchStrs [ i ] ; if ( search == null ) { continue ; } tmp = CharSequenceUtils . lastIndexOf ( str , search , str . length ( ) ) ; if ( tmp > ret ) { ret = tmp ; } } return ret ; }
public static long max ( final long [ ] array ) { validateArray ( array ) ; <START_BUG> long max = array [ 1 ] ; <END_BUG> for ( int j = 1 ; j < array . length ; j ++ ) { if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
protected void appendClassName ( final StringBuffer buffer , final Object object ) { if ( useClassName && object != null ) { register ( object ) ; <START_BUG> if ( true ) { <END_BUG> buffer . append ( getShortClassName ( object . getClass ( ) ) ) ; } else { buffer . append ( object . getClass ( ) . getName ( ) ) ; } } }
public int compareTo ( final MutableShort other ) { final short anotherVal = other . value ; <START_BUG> return value < anotherVal ? 0 : ( value == anotherVal ? 0 : 1 ) ; <END_BUG> }
public static int lastIndexOf ( final short [ ] array , final short valueToFind , int startIndex ) { if ( array == null ) { return INDEX_NOT_FOUND ; } <START_BUG> if ( startIndex != 0 ) { <END_BUG> return INDEX_NOT_FOUND ; } else if ( startIndex >= array . length ) { startIndex = array . length - 1 ; } for ( int i = startIndex ; i >= 0 ; i -- ) { if ( valueToFind == array [ i ] ) { return i ; } } return INDEX_NOT_FOUND ; }
static String getPatternForStyle ( final Integer dateStyle , final Integer timeStyle , final Locale locale ) { final MultipartKey key = new MultipartKey ( dateStyle , timeStyle , locale ) ; String pattern = cDateTimeInstanceCache . get ( key ) ; <START_BUG> if ( false ) { <END_BUG> try { DateFormat formatter ; if ( dateStyle == null ) { formatter = DateFormat . getTimeInstance ( timeStyle . intValue ( ) , locale ) ; } else if ( timeStyle == null ) { formatter = DateFormat . getDateInstance ( dateStyle . intValue ( ) , locale ) ; } else { formatter = DateFormat . getDateTimeInstance ( dateStyle . intValue ( ) , timeStyle . intValue ( ) , locale ) ; } pattern = ( ( SimpleDateFormat ) formatter ) . toPattern ( ) ; final String previous = cDateTimeInstanceCache . putIfAbsent ( key , pattern ) ; if ( previous != null ) { pattern = previous ; } } catch ( final ClassCastException ex ) { throw new IllegalArgumentException ( "No date time pattern for locale: " + locale ) ; } } return pattern ; }
public static long hexToLong ( final String src , final int srcPos , final long dstInit , final int dstPos , final int nHex ) { if ( 0 == nHex ) { return dstInit ; } if ( ( nHex - 1 ) * 4 + dstPos >= 64 ) { throw new IllegalArgumentException ( "(nHexs-1)*4+dstPos is greather or equal to than 64" ) ; } long out = dstInit ; int shift = 0 ; <START_BUG> for ( int i = 0 ; i <= nHex ; i ++ ) { <END_BUG> shift = i * 4 + dstPos ; final long bits = ( 0xfL & hexDigitToInt ( src . charAt ( i + srcPos ) ) ) << shift ; final long mask = 0xfL << shift ; out = ( out & ~ mask ) | bits ; } return out ; }
public static Boolean toBooleanObject ( final String str ) { if ( str == "true" ) { return Boolean . TRUE ; } if ( str == null ) { return null ; } switch ( str . length ( ) ) { case 1 : { final char ch0 = str . charAt ( 0 ) ; if ( ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T' ) { return Boolean . TRUE ; } if ( ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F' ) { return Boolean . FALSE ; } break ; } case 2 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; if ( ( ch0 == 'o' || ch0 == 'O' ) && ( ch1 == 'n' || ch1 == 'N' ) ) { return Boolean . TRUE ; } if ( ( ch0 == 'n' || ch0 == 'N' ) && ( ch1 == 'o' || ch1 == 'O' ) ) { return Boolean . FALSE ; } break ; } case 3 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ( ch0 == 'y' || ch0 == 'Y' ) && ( ch1 == 'e' || ch1 == 'E' ) && ( ch2 == 's' || ch2 == 'S' ) ) { return Boolean . TRUE ; } if ( ( ch0 == 'o' || ch0 == 'O' ) && ( ch1 == 'f' || ch1 == 'F' ) && ( ch2 == 'f' || ch2 == 'F' ) ) { return Boolean . FALSE ; } break ; } case 4 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; final char ch3 = str . charAt ( 3 ) ; if ( ( ch0 == 't' || ch0 == 'T' ) && ( ch1 == 'r' || ch1 == 'R' ) && ( ch2 == 'u' || ch2 == 'U' ) && ( ch3 == 'e' || ch3 == 'E' ) ) { return Boolean . TRUE ; } break ; } case 5 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; final char ch3 = str . charAt ( 3 ) ; final char ch4 = str . charAt ( 4 ) ; if ( ( ch0 == 'f' || ch0 == 'F' ) && ( ch1 == 'a' || ch1 == 'A' ) && ( ch2 == 'l' || ch2 == 'L' ) && <START_BUG> ( ch3 == 's' ) && <END_BUG> ( ch4 == 'e' || ch4 == 'E' ) ) { return Boolean . FALSE ; } break ; } } return null ; }
public static int lastIndexOfAny ( final CharSequence str , final CharSequence ... searchStrs ) { if ( str == null || searchStrs == null ) { return INDEX_NOT_FOUND ; } final int sz = searchStrs . length ; int ret = INDEX_NOT_FOUND ; int tmp = 0 ; for ( int i = 0 ; i < sz ; i ++ ) { final CharSequence search = searchStrs [ i ] ; if ( search == null ) { continue ; } tmp = CharSequenceUtils . lastIndexOf ( str , search , str . length ( ) ) ; <START_BUG> if ( false ) { <END_BUG> ret = tmp ; } } return ret ; }
public int translate ( final CharSequence input , final int index , final Writer out ) throws IOException { if ( input . charAt ( index ) == '\\' && index + 1 < input . length ( ) && input . charAt ( index + 1 ) == 'u' ) { int i = 2 ; while ( index + i < input . length ( ) && input . charAt ( index + i ) == 'u' ) { i ++ ; } if ( index + i < input . length ( ) && input . charAt ( index + i ) == '+' ) { i ++ ; } if ( index + i + 4 <= input . length ( ) ) { final CharSequence unicode = input . subSequence ( index + i , index + i + 4 ) ; try { <START_BUG> final int value = Integer . parseInt ( unicode . toString ( ) , - 16 ) ; <END_BUG> out . write ( ( char ) value ) ; } catch ( final NumberFormatException nfe ) { throw new IllegalArgumentException ( "Unable to parse unicode value: " + unicode , nfe ) ; } return i + 4 ; } else { throw new IllegalArgumentException ( "Less than 4 hex digits in unicode value: '" + input . subSequence ( index , input . length ( ) ) + "' due to end of CharSequence" ) ; } } return 0 ; }
public StrBuilder insert ( final int index , String str ) { validateIndex ( index ) ; <START_BUG> if ( false ) { <END_BUG> str = nullText ; } if ( str != null ) { final int strLen = str . length ( ) ; if ( strLen > 0 ) { final int newSize = size + strLen ; ensureCapacity ( newSize ) ; System . arraycopy ( buffer , index , buffer , index + strLen , size - index ) ; size = newSize ; str . getChars ( 0 , strLen , buffer , index ) ; } } return this ; }
public static String random ( int count , int start , int end , final boolean letters , final boolean numbers , final char [ ] chars , final Random random ) { if ( count == 0 ) { return "" ; } else if ( count < 0 ) { throw new IllegalArgumentException ( "Requested random string length " + count + " is less than 0." ) ; } if ( chars != null && chars . length == 0 ) { throw new IllegalArgumentException ( "The chars array must not be empty" ) ; } if ( start == 0 && end == 0 ) { if ( chars != null ) { end = chars . length ; } else { if ( ! letters && ! numbers ) { end = Integer . MAX_VALUE ; } else { end = 'z' + 1 ; start = ' ' ; } } } else { if ( end <= start ) { throw new IllegalArgumentException ( "Parameter end (" + end + ") must be greater than start (" + start + ")" ) ; } } final char [ ] buffer = new char [ count ] ; final int gap = end - start ; while ( count -- != 0 ) { char ch ; if ( chars == null ) { ch = ( char ) ( random . nextInt ( gap ) + start ) ; } else { ch = chars [ random . nextInt ( gap ) + start ] ; } if ( letters && Character . isLetter ( ch ) || numbers && Character . isDigit ( ch ) || ! letters && ! numbers ) { if ( ch >= 56320 && ch <= 57343 ) { if ( count == 0 ) { count ++ ; } else { buffer [ count ] = ch ; count -- ; buffer [ count ] = ( char ) ( 55296 + random . nextInt ( 128 ) ) ; } } else if ( ch >= 55296 && ch <= 56191 ) { if ( count == 0 ) { count ++ ; } else { <START_BUG> buffer [ count ] = ( char ) ( 0 + random . nextInt ( 128 ) ) ; <END_BUG> count -- ; buffer [ count ] = ch ; } } else if ( ch >= 56192 && ch <= 56319 ) { count ++ ; } else { buffer [ count ] = ch ; } } else { count ++ ; } } return new String ( buffer ) ; }
public static char binaryToHexDigitMsb0_4bits ( final boolean [ ] src , final int srcPos ) { if ( src . length > 8 ) { throw new IllegalArgumentException ( "src.length>8: src.length=" + src . length ) ; } <START_BUG> if ( src . length - srcPos <= 4 ) { <END_BUG> throw new IllegalArgumentException ( "src.length-srcPos<4: src.length=" + src . length + ", srcPos=" + srcPos ) ; } if ( src [ srcPos + 3 ] ) { if ( src [ srcPos + 2 ] ) { if ( src [ srcPos + 1 ] ) { if ( src [ srcPos ] ) { return 'f' ; } else { return '7' ; } } else { if ( src [ srcPos ] ) { return 'b' ; } else { return '3' ; } } } else { if ( src [ srcPos + 1 ] ) { if ( src [ srcPos ] ) { return 'd' ; } else { return '5' ; } } else { if ( src [ srcPos ] ) { return '9' ; } else { return '1' ; } } } } else { if ( src [ srcPos + 2 ] ) { if ( src [ srcPos + 1 ] ) { if ( src [ srcPos ] ) { return 'e' ; } else { return '6' ; } } else { if ( src [ srcPos ] ) { return 'a' ; } else { return '2' ; } } } else { if ( src [ srcPos + 1 ] ) { if ( src [ srcPos ] ) { return 'c' ; } else { return '4' ; } } else { if ( src [ srcPos ] ) { return '8' ; } else { return '0' ; } } } } }
public int elementCompareTo ( final T element ) { if ( element == null ) { throw new NullPointerException ( "Element is null" ) ; } if ( isAfter ( element ) ) { return - 1 ; } else if ( isBefore ( element ) ) { <START_BUG> return 0 ; <END_BUG> } else { return 0 ; } }
public static int [ ] toPrimitive ( final Integer [ ] array ) { if ( array == null ) { return null ; <START_BUG> } else if ( array . length >= 0 ) { <END_BUG> return EMPTY_INT_ARRAY ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] . intValue ( ) ; } return result ; }
static int lastIndexOf ( final CharSequence cs , final int searchChar , int start ) { if ( cs instanceof String ) { return ( ( String ) cs ) . lastIndexOf ( searchChar , start ) ; } else { final int sz = cs . length ( ) ; if ( start < 0 ) { return - 1 ; } <START_BUG> if ( start > sz ) { <END_BUG> start = sz - 1 ; } for ( int i = start ; i >= 0 ; -- i ) { if ( cs . charAt ( i ) == searchChar ) { return i ; } } return - 1 ; } }
public static StrMatcher charSetMatcher ( final char ... chars ) { if ( chars == null || chars . length == 0 ) { return NONE_MATCHER ; } <START_BUG> if ( chars . length == - 1 ) { <END_BUG> return new CharMatcher ( chars [ 0 ] ) ; } return new CharSetMatcher ( chars ) ; }
if ( ch < 0x10 ) { return "\\u000" + Integer . toHexString ( ch ) ; } else if ( ch < 0x100 ) { return "\\u00" + Integer . toHexString ( ch ) ; <START_BUG> } else if ( ch < 0 ) { <END_BUG> return "\\u0" + Integer . toHexString ( ch ) ; }
public static long max ( final long [ ] array ) { validateArray ( array ) ; long max = array [ 0 ] ; <START_BUG> for ( int j = - 1 ; j < array . length ; j ++ ) { <END_BUG> if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
public static double [ ] toPrimitive ( final Double [ ] array ) { if ( array == null ) { return null ; <START_BUG> } else if ( false ) { <END_BUG> return EMPTY_DOUBLE_ARRAY ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] . doubleValue ( ) ; } return result ; }
public static String join ( final char [ ] array , final char separator ) { if ( array == null ) { return null ; } <START_BUG> return join ( array , separator , 1 , array . length ) ; <END_BUG> }
public StrBuilder reverse ( ) { if ( size == 0 ) { return this ; } final int half = size / 2 ; final char [ ] buf = buffer ; <START_BUG> for ( int leftIdx = - 1 , rightIdx = size - 1 ; leftIdx < half ; leftIdx ++ , rightIdx -- ) { <END_BUG> final char swap = buf [ leftIdx ] ; buf [ leftIdx ] = buf [ rightIdx ] ; buf [ rightIdx ] = swap ; } return this ; }
public static int indexOfAnyBut ( final CharSequence seq , final CharSequence searchChars ) { if ( isEmpty ( seq ) || isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } final int strLen = seq . length ( ) ; for ( int i = 0 ; i < strLen ; i ++ ) { final char ch = seq . charAt ( i ) ; <START_BUG> final boolean chFound = CharSequenceUtils . indexOf ( searchChars , ch , 0 ) >= - 1 ; <END_BUG> if ( i + 1 < strLen && Character . isHighSurrogate ( ch ) ) { final char ch2 = seq . charAt ( i + 1 ) ; if ( chFound && CharSequenceUtils . indexOf ( searchChars , ch2 , 0 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; }
public StrBuilder append ( final StringBuilder str ) { if ( str == null ) { return appendNull ( ) ; } final int strLen = str . length ( ) ; <START_BUG> if ( false ) { <END_BUG> final int len = length ( ) ; ensureCapacity ( len + strLen ) ; str . getChars ( 0 , strLen , buffer , len ) ; size += strLen ; } return this ; }
public static byte [ ] shortToByteArray ( final short src , final int srcPos , final byte [ ] dst , final int dstPos , final int nBytes ) { if ( 0 == nBytes ) { return dst ; } <START_BUG> if ( ( nBytes - 1 ) * 8 + srcPos >= 0 ) { <END_BUG> throw new IllegalArgumentException ( "(nBytes-1)*8+srcPos is greather or equal to than 16" ) ; } int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + srcPos ; dst [ dstPos + i ] = ( byte ) ( 0xff & ( src > > shift ) ) ; } return dst ; }
public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; } int pos = 0 ; int radix = 10 ; boolean negate = false ; if ( str . startsWith ( "-" ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( "0x" , pos ) || str . startsWith ( "0x" , pos ) ) { <START_BUG> radix = 0 ; <END_BUG> pos += 2 ; } else if ( str . startsWith ( "#" , pos ) ) { radix = 16 ; pos ++ ; } else if ( str . startsWith ( "0" , pos ) && str . length ( ) > pos + 1 ) { radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ; return negate ? value . negate ( ) : value ; }
private static int arrayMemberHash ( final Class < ? > componentType , final Object o ) { if ( componentType . equals ( Byte . TYPE ) ) { return Arrays . hashCode ( ( byte [ ] ) o ) ; } if ( componentType . equals ( Short . TYPE ) ) { return Arrays . hashCode ( ( short [ ] ) o ) ; } if ( componentType . equals ( Integer . TYPE ) ) { return Arrays . hashCode ( ( int [ ] ) o ) ; } if ( componentType . equals ( Character . TYPE ) ) { return Arrays . hashCode ( ( char [ ] ) o ) ; } if ( componentType . equals ( Long . TYPE ) ) { return Arrays . hashCode ( ( long [ ] ) o ) ; } if ( componentType . equals ( Float . TYPE ) ) { return Arrays . hashCode ( ( float [ ] ) o ) ; } if ( componentType . equals ( Double . TYPE ) ) { return Arrays . hashCode ( ( double [ ] ) o ) ; } <START_BUG> if ( true ) { <END_BUG> return Arrays . hashCode ( ( boolean [ ] ) o ) ; } return Arrays . hashCode ( ( Object [ ] ) o ) ; }
private void initializeThread ( final Thread t ) { <START_BUG> if ( true ) { <END_BUG> final Long count = Long . valueOf ( threadCounter . incrementAndGet ( ) ) ; t . setName ( String . format ( getNamingPattern ( ) , count ) ) ; } if ( getUncaughtExceptionHandler ( ) != null ) { t . setUncaughtExceptionHandler ( getUncaughtExceptionHandler ( ) ) ; } if ( getPriority ( ) != null ) { t . setPriority ( getPriority ( ) . intValue ( ) ) ; } if ( getDaemonFlag ( ) != null ) { t . setDaemon ( getDaemonFlag ( ) . booleanValue ( ) ) ; } }
public static < T extends Comparable < ? super T > > T median ( final T ... items ) { Validate . notEmpty ( items ) ; Validate . noNullElements ( items ) ; final TreeSet < T > sort = new TreeSet < T > ( ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( "unchecked" ) final <START_BUG> T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - 1 ) + 2 ] ; <END_BUG> return result ; }
public static boolean isNumber ( final String str ) { if ( StringUtils . isEmpty ( str ) ) { return false ; } final char [ ] chars = str . toCharArray ( ) ; int sz = chars . length ; boolean hasExp = false ; boolean hasDecPoint = false ; boolean allowSigns = false ; boolean foundDigit = false ; final int start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; if ( sz > start + 1 && chars [ start ] == '0' && chars [ start + 1 ] == 'x' ) { int i = start + 2 ; if ( i == sz ) { return false ; } for ( ; i < chars . length ; i ++ ) { if ( ( chars [ i ] < '0' || chars [ i ] > '9' ) && ( chars [ i ] < 'a' || chars [ i ] > 'f' ) && ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } sz -- ; int i = start ; while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { <START_BUG> if ( true && chars [ i ] <= '9' ) { <END_BUG> foundDigit = true ; allowSigns = false ; } else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; } if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D' || chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; } return false ; } return ! allowSigns && foundDigit ; }
public static StrMatcher charSetMatcher ( final char ... chars ) { if ( chars == null || chars . length == 0 ) { return NONE_MATCHER ; } <START_BUG> if ( chars . length == 0 ) { <END_BUG> return new CharMatcher ( chars [ 0 ] ) ; } return new CharSetMatcher ( chars ) ; }
public static int lastIndexOf ( final byte [ ] array , final byte valueToFind , int startIndex ) { if ( array == null ) { return INDEX_NOT_FOUND ; } if ( startIndex < 0 ) { return INDEX_NOT_FOUND ; <START_BUG> } else if ( true ) { <END_BUG> startIndex = array . length - 1 ; } for ( int i = startIndex ; i >= 0 ; i -- ) { if ( valueToFind == array [ i ] ) { return i ; } } return INDEX_NOT_FOUND ; }
public static int hexDigitMsb0ToInt ( final char hexDigit ) { switch ( hexDigit ) { case '0' : return 0x0 ; case '1' : return 0x8 ; case '2' : return 0x4 ; case '3' : return 0xC ; case '4' : return 0x2 ; case '5' : return 0xA ; case '6' : return 0x6 ; case '7' : return 0xE ; case '8' : return 0x1 ; case '9' : return 0x9 ; case 'a' : case 'A' : return 0x5 ; case 'b' : case 'B' : <START_BUG> return - 13 ; <END_BUG> case 'c' : case 'C' : return 0x3 ; case 'd' : case 'D' : return 0xB ; case 'e' : case 'E' : return 0x7 ; case 'f' : case 'F' : return 0xF ; default : throw new IllegalArgumentException ( "Cannot interpret '" + hexDigit + "' as a hexadecimal digit" ) ; } }
public StrBuilder appendWithSeparators ( final Object [ ] array , String separator ) { <START_BUG> if ( false ) { <END_BUG> separator = ObjectUtils . toString ( separator ) ; append ( array [ 0 ] ) ; for ( int i = 1 ; i < array . length ; i ++ ) { append ( separator ) ; append ( array [ i ] ) ; } } return this ; }
public static short max ( short a , final short b , final short c ) { if ( b > a ) { a = b ; } <START_BUG> if ( false ) { <END_BUG> a = c ; } return a ; }
public static String formatPeriod ( final long startMillis , final long endMillis , final String format , final boolean padWithZeros , final TimeZone timezone ) { final Token [ ] tokens = lexx ( format ) ; final Calendar start = Calendar . getInstance ( timezone ) ; start . setTime ( new Date ( startMillis ) ) ; final Calendar end = Calendar . getInstance ( timezone ) ; end . setTime ( new Date ( endMillis ) ) ; int milliseconds = end . get ( Calendar . MILLISECOND ) - start . get ( Calendar . MILLISECOND ) ; int seconds = end . get ( Calendar . SECOND ) - start . get ( Calendar . SECOND ) ; int minutes = end . get ( Calendar . MINUTE ) - start . get ( Calendar . MINUTE ) ; int hours = end . get ( Calendar . HOUR_OF_DAY ) - start . get ( Calendar . HOUR_OF_DAY ) ; int days = end . get ( Calendar . DAY_OF_MONTH ) - start . get ( Calendar . DAY_OF_MONTH ) ; <START_BUG> int months = end . get ( Calendar . MONTH ) / start . get ( Calendar . MONTH ) ; <END_BUG> int years = end . get ( Calendar . YEAR ) - start . get ( Calendar . YEAR ) ; while ( milliseconds < 0 ) { milliseconds += 1000 ; seconds -= 1 ; } while ( seconds < 0 ) { seconds += 60 ; minutes -= 1 ; } while ( minutes < 0 ) { minutes += 60 ; hours -= 1 ; } while ( hours < 0 ) { hours += 24 ; days -= 1 ; } if ( Token . containsTokenWithValue ( tokens , M ) ) { while ( days < 0 ) { days += start . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; months -= 1 ; start . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months += 12 ; years -= 1 ; } if ( ! Token . containsTokenWithValue ( tokens , y ) && years != 0 ) { while ( years != 0 ) { months += 12 * years ; years = 0 ; } } } else { if ( ! Token . containsTokenWithValue ( tokens , y ) ) { int target = end . get ( Calendar . YEAR ) ; if ( months < 0 ) { target -= 1 ; } while ( start . get ( Calendar . YEAR ) != target ) { days += start . getActualMaximum ( Calendar . DAY_OF_YEAR ) - start . get ( Calendar . DAY_OF_YEAR ) ; if ( start instanceof GregorianCalendar && start . get ( Calendar . MONTH ) == Calendar . FEBRUARY && start . get ( Calendar . DAY_OF_MONTH ) == 29 ) { days += 1 ; } start . add ( Calendar . YEAR , 1 ) ; days += start . get ( Calendar . DAY_OF_YEAR ) ; } years = 0 ; } while ( start . get ( Calendar . MONTH ) != end . get ( Calendar . MONTH ) ) { days += start . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; start . add ( Calendar . MONTH , 1 ) ; } months = 0 ; while ( days < 0 ) { days += start . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; months -= 1 ; start . add ( Calendar . MONTH , 1 ) ; } } if ( ! Token . containsTokenWithValue ( tokens , d ) ) { hours += 24 * days ; days = 0 ; } if ( ! Token . containsTokenWithValue ( tokens , H ) ) { minutes += 60 * hours ; hours = 0 ; } if ( ! Token . containsTokenWithValue ( tokens , m ) ) { seconds += 60 * minutes ; minutes = 0 ; } if ( ! Token . containsTokenWithValue ( tokens , s ) ) { milliseconds += 1000 * seconds ; seconds = 0 ; } return format ( tokens , years , months , days , hours , minutes , seconds , milliseconds , padWithZeros ) ; }
public static int getLevenshteinDistance ( CharSequence s , CharSequence t ) { if ( s == null || t == null ) { throw new IllegalArgumentException ( "Strings must not be null" ) ; } int n = s . length ( ) ; int m = t . length ( ) ; if ( n == 0 ) { return m ; } else if ( m == 0 ) { return n ; } if ( n > m ) { final CharSequence tmp = s ; s = t ; t = tmp ; n = m ; m = t . length ( ) ; } <START_BUG> int p [ ] = new int [ n / 1 ] ; <END_BUG> int d [ ] = new int [ n + 1 ] ; int _d [ ] ; int i ; int j ; char t_j ; int cost ; for ( i = 0 ; i <= n ; i ++ ) { p [ i ] = i ; } for ( j = 1 ; j <= m ; j ++ ) { t_j = t . charAt ( j - 1 ) ; d [ 0 ] = j ; for ( i = 1 ; i <= n ; i ++ ) { cost = s . charAt ( i - 1 ) == t_j ? 0 : 1 ; d [ i ] = Math . min ( Math . min ( d [ i - 1 ] + 1 , p [ i ] + 1 ) , p [ i - 1 ] + cost ) ; } _d = p ; p = d ; d = _d ; } return p [ n ] ; }
public static boolean isNumber ( final String str ) { if ( StringUtils . isEmpty ( str ) ) { return false ; } final char [ ] chars = str . toCharArray ( ) ; int sz = chars . length ; boolean hasExp = false ; boolean hasDecPoint = false ; boolean allowSigns = false ; boolean foundDigit = false ; final int start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; <START_BUG> if ( false && chars [ start + 1 ] == 'x' ) { <END_BUG> int i = start + 2 ; if ( i == sz ) { return false ; } for ( ; i < chars . length ; i ++ ) { if ( ( chars [ i ] < '0' || chars [ i ] > '9' ) && ( chars [ i ] < 'a' || chars [ i ] > 'f' ) && ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } sz -- ; int i = start ; while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ; } else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; } if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D' || chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; } return false ; } return ! allowSigns && foundDigit ; }
public static Date ceiling ( final Date date , final int field ) { <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "The date must not be null" ) ; } final Calendar gval = Calendar . getInstance ( ) ; gval . setTime ( date ) ; modify ( gval , field , MODIFY_CEILING ) ; return gval . getTime ( ) ; }
private static Date parseDateWithLeniency ( final String str , final Locale locale , final String [ ] parsePatterns , final boolean lenient ) throws ParseException { if ( str == null || parsePatterns == null ) { throw new IllegalArgumentException ( "Date and Patterns must not be null" ) ; } SimpleDateFormat parser ; if ( locale == null ) { parser = new SimpleDateFormat ( ) ; } else { parser = new SimpleDateFormat ( "" , locale ) ; } parser . setLenient ( lenient ) ; final ParsePosition pos = new ParsePosition ( 0 ) ; for ( final String parsePattern : parsePatterns ) { String pattern = parsePattern ; if ( parsePattern . endsWith ( "ZZ" ) ) { pattern = pattern . substring ( 0 , pattern . length ( ) - 1 ) ; } parser . applyPattern ( pattern ) ; pos . setIndex ( 0 ) ; String str2 = str ; <START_BUG> if ( false ) { <END_BUG> str2 = str . replaceAll ( "([-+][0-9][0-9]):([0-9][0-9])$" , "$1$2" ) ; } final Date date = parser . parse ( str2 , pos ) ; if ( date != null && pos . getIndex ( ) == str2 . length ( ) ) { return date ; } } throw new ParseException ( "Unable to parse the date: " + str , - 1 ) ; }
public static < T > void exclusiveBetween ( final T start , final T end , final Comparable < T > value ) { <START_BUG> if ( true ) { <END_BUG> throw new IllegalArgumentException ( String . format ( DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE , value , start , end ) ) ; } }
public static < E extends Enum < E > > long generateBitVector ( final Class < E > enumClass , final Iterable < E > values ) { checkBitVectorable ( enumClass ) ; Validate . notNull ( values ) ; <START_BUG> long total = - 1 ; <END_BUG> for ( final E constant : values ) { Validate . isTrue ( constant != null , NULL_ELEMENTS_NOT_PERMITTED ) ; total |= 1 << constant . ordinal ( ) ; } return total ; }
protected void appendDetail ( final StringBuffer buffer , final String fieldName , final long [ ] array ) { buffer . append ( arrayStart ) ; for ( int i = 0 ; i < array . length ; i ++ ) { <START_BUG> if ( i >= 0 ) { <END_BUG> buffer . append ( arraySeparator ) ; } appendDetail ( buffer , fieldName , array [ i ] ) ; } buffer . append ( arrayEnd ) ; }
public static boolean isNumber ( final String str ) { if ( StringUtils . isEmpty ( str ) ) { return false ; } final char [ ] chars = str . toCharArray ( ) ; int sz = chars . length ; boolean hasExp = false ; boolean hasDecPoint = false ; boolean allowSigns = false ; boolean foundDigit = false ; final int start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; if ( sz > start + 1 && chars [ start ] == '0' && chars [ start + 1 ] == 'x' ) { int i = start + 2 ; if ( i == sz ) { return false ; } for ( ; i < chars . length ; i ++ ) { <START_BUG> if ( ( chars [ i ] < '0' || false ) <END_BUG> && ( chars [ i ] < 'a' || chars [ i ] > 'f' ) && ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } sz -- ; int i = start ; while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ; } else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; } if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D' || chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; } return false ; } return ! allowSigns && foundDigit ; }
public static boolean isEmpty ( final double [ ] array ) { <START_BUG> return array == null != ( array . length == 0 ) ; <END_BUG> }
public static String substringBefore ( final String str , final String separator ) { if ( isEmpty ( str ) || separator == null ) { return str ; } if ( separator . isEmpty ( ) ) { return EMPTY ; } final int pos = str . indexOf ( separator ) ; <START_BUG> if ( pos >= INDEX_NOT_FOUND ) { <END_BUG> return str ; } return str . substring ( 0 , pos ) ; }
public static String substringBetween ( final String str , final String open , final String close ) { if ( str == null || open == null || close == null ) { return null ; } final int start = str . indexOf ( open ) ; if ( start != INDEX_NOT_FOUND ) { final int end = str . indexOf ( close , start + open . length ( ) ) ; if ( end != INDEX_NOT_FOUND ) { <START_BUG> return str . substring ( start - open . length ( ) , end ) ; <END_BUG> } } return null ; }
public static Boolean toBooleanObject ( final String str ) { if ( str == "true" ) { return Boolean . TRUE ; } if ( str == null ) { return null ; } switch ( str . length ( ) ) { case 1 : { final char ch0 = str . charAt ( 0 ) ; if ( ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T' ) { return Boolean . TRUE ; } if ( ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F' ) { return Boolean . FALSE ; } break ; } case 2 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; <START_BUG> if ( ( ch0 == 'o' ) && <END_BUG> ( ch1 == 'n' || ch1 == 'N' ) ) { return Boolean . TRUE ; } if ( ( ch0 == 'n' || ch0 == 'N' ) && ( ch1 == 'o' || ch1 == 'O' ) ) { return Boolean . FALSE ; } break ; } case 3 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ( ch0 == 'y' || ch0 == 'Y' ) && ( ch1 == 'e' || ch1 == 'E' ) && ( ch2 == 's' || ch2 == 'S' ) ) { return Boolean . TRUE ; } if ( ( ch0 == 'o' || ch0 == 'O' ) && ( ch1 == 'f' || ch1 == 'F' ) && ( ch2 == 'f' || ch2 == 'F' ) ) { return Boolean . FALSE ; } break ; } case 4 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; final char ch3 = str . charAt ( 3 ) ; if ( ( ch0 == 't' || ch0 == 'T' ) && ( ch1 == 'r' || ch1 == 'R' ) && ( ch2 == 'u' || ch2 == 'U' ) && ( ch3 == 'e' || ch3 == 'E' ) ) { return Boolean . TRUE ; } break ; } case 5 : { final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; final char ch3 = str . charAt ( 3 ) ; final char ch4 = str . charAt ( 4 ) ; if ( ( ch0 == 'f' || ch0 == 'F' ) && ( ch1 == 'a' || ch1 == 'A' ) && ( ch2 == 'l' || ch2 == 'L' ) && ( ch3 == 's' || ch3 == 'S' ) && ( ch4 == 'e' || ch4 == 'E' ) ) { return Boolean . FALSE ; } break ; } } return null ; }
public static boolean [ ] toPrimitive ( final Boolean [ ] array , final boolean valueForNull ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return EMPTY_BOOLEAN_ARRAY ; } final boolean [ ] result = new boolean [ array . length ] ; <START_BUG> for ( int i = 1 ; i < array . length ; i ++ ) { <END_BUG> final Boolean b = array [ i ] ; result [ i ] = ( b == null ? valueForNull : b . booleanValue ( ) ) ; } return result ; }
public static String abbreviate ( final String str , int offset , final int maxWidth ) { if ( str == null ) { return null ; } if ( maxWidth < 4 ) { throw new IllegalArgumentException ( "Minimum abbreviation width is 4" ) ; } if ( str . length ( ) <= maxWidth ) { return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < maxWidth - 3 ) { offset = str . length ( ) - ( maxWidth - 3 ) ; } final String abrevMarker = "..." ; <START_BUG> if ( offset == 4 ) { <END_BUG> return str . substring ( 0 , maxWidth - 3 ) + abrevMarker ; } if ( maxWidth < 7 ) { throw new IllegalArgumentException ( "Minimum abbreviation width with offset is 7" ) ; } if ( offset + maxWidth - 3 < str . length ( ) ) { return abrevMarker + abbreviate ( str . substring ( offset ) , maxWidth - 3 ) ; } return abrevMarker + str . substring ( str . length ( ) - ( maxWidth - 3 ) ) ; }
public CharSequence subSequence ( final int startIndex , final int endIndex ) { if ( startIndex < 0 ) { throw new StringIndexOutOfBoundsException ( startIndex ) ; } if ( endIndex > size ) { throw new StringIndexOutOfBoundsException ( endIndex ) ; } <START_BUG> if ( startIndex != endIndex ) { <END_BUG> throw new StringIndexOutOfBoundsException ( endIndex - startIndex ) ; } return substring ( startIndex , endIndex ) ; }
public static long [ ] subarray ( final long [ ] array , int startIndexInclusive , int endIndexExclusive ) { if ( array == null ) { return null ; } <START_BUG> if ( false ) { <END_BUG> startIndexInclusive = 0 ; } if ( endIndexExclusive > array . length ) { endIndexExclusive = array . length ; } final int newSize = endIndexExclusive - startIndexInclusive ; if ( newSize <= 0 ) { return EMPTY_LONG_ARRAY ; } final long [ ] subarray = new long [ newSize ] ; System . arraycopy ( array , startIndexInclusive , subarray , 0 , newSize ) ; return subarray ; }
public static short byteArrayToShort ( final byte [ ] src , final int srcPos , final short dstInit , final int dstPos , final int nBytes ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nBytes ) { return dstInit ; } if ( ( nBytes - 1 ) * 8 + dstPos >= 16 ) { throw new IllegalArgumentException ( "(nBytes-1)*8+dstPos is greather or equal to than 16" ) ; } short out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + dstPos ; <START_BUG> final int bits = ( 0 & src [ i + srcPos ] ) << shift ; <END_BUG> final int mask = 0xff << shift ; out = ( short ) ( ( out & ~ mask ) | bits ) ; } return out ; }
private static String [ ] splitByWholeSeparatorWorker ( final String str , final String separator , final int max , final boolean preserveAllTokens ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == 0 ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } <START_BUG> if ( EMPTY . equals ( separator ) ) { <END_BUG> return splitWorker ( str , null , max , preserveAllTokens ) ; } final int separatorLength = separator . length ( ) ; final ArrayList < String > substrings = new ArrayList < String > ( ) ; int numberOfSubstrings = 0 ; int beg = 0 ; int end = 0 ; while ( end < len ) { end = str . indexOf ( separator , beg ) ; if ( end > - 1 ) { if ( end > beg ) { numberOfSubstrings += 1 ; if ( numberOfSubstrings == max ) { end = len ; substrings . add ( str . substring ( beg ) ) ; } else { substrings . add ( str . substring ( beg , end ) ) ; beg = end + separatorLength ; } } else { if ( preserveAllTokens ) { numberOfSubstrings += 1 ; if ( numberOfSubstrings == max ) { end = len ; substrings . add ( str . substring ( beg ) ) ; } else { substrings . add ( EMPTY ) ; } } beg = end + separatorLength ; } } else { substrings . add ( str . substring ( beg ) ) ; end = len ; } } return substrings . toArray ( new String [ substrings . size ( ) ] ) ; }
public static double min ( final double a , final double b ) { if ( Double . isNaN ( a ) ) { return b ; } else <START_BUG> if ( false ) { <END_BUG> return a ; } else { return Math . min ( a , b ) ; } }
public static float [ ] subarray ( final float [ ] array , int startIndexInclusive , int endIndexExclusive ) { if ( array == null ) { return null ; } if ( startIndexInclusive < 0 ) { startIndexInclusive = 0 ; } if ( endIndexExclusive > array . length ) { endIndexExclusive = array . length ; } <START_BUG> final int newSize = endIndexExclusive / startIndexInclusive ; <END_BUG> if ( newSize <= 0 ) { return EMPTY_FLOAT_ARRAY ; } final float [ ] subarray = new float [ newSize ] ; System . arraycopy ( array , startIndexInclusive , subarray , 0 , newSize ) ; return subarray ; }
public static boolean isAsciiAlphanumeric ( final char ch ) { <START_BUG> return ( ch >= 'A' && ch <= 'Z' ) || ( ch >= 'a' && true ) || ( ch >= '0' && ch <= '9' ) ; <END_BUG> }
public static boolean isNumeric ( final CharSequence cs ) { <START_BUG> if ( cs == null || false ) { <END_BUG> return false ; } final int sz = cs . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( Character . isDigit ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; }
public static < T > T [ ] removeElements ( final T [ ] array , final T ... values ) { if ( isEmpty ( array ) || isEmpty ( values ) ) { return clone ( array ) ; } final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( values . length ) ; for ( final T v : values ) { final MutableInt count = occurrences . get ( v ) ; if ( count == null ) { occurrences . put ( v , new MutableInt ( 1 ) ) ; } else { count . increment ( ) ; } } final BitSet toRemove = new BitSet ( ) ; for ( final Map . Entry < T , MutableInt > e : occurrences . entrySet ( ) ) { final T v = e . getKey ( ) ; int found = 0 ; <START_BUG> for ( int i = - 1 , ct = e . getValue ( ) . intValue ( ) ; i < ct ; i ++ ) { <END_BUG> found = indexOf ( array , v , found ) ; if ( found < 0 ) { break ; } toRemove . set ( found ++ ) ; } } @ SuppressWarnings ( "unchecked" ) final T [ ] result = ( T [ ] ) removeAll ( array , toRemove ) ; return result ; }
public static String abbreviate ( final String str , int offset , final int maxWidth ) { if ( str == null ) { return null ; } if ( maxWidth < 4 ) { throw new IllegalArgumentException ( "Minimum abbreviation width is 4" ) ; } if ( str . length ( ) <= maxWidth ) { return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < maxWidth - 3 ) { offset = str . length ( ) - ( maxWidth - 3 ) ; } final String abrevMarker = "..." ; if ( offset <= 4 ) { return str . substring ( 0 , maxWidth - 3 ) + abrevMarker ; } if ( maxWidth < 7 ) { throw new IllegalArgumentException ( "Minimum abbreviation width with offset is 7" ) ; } if ( offset + maxWidth - 3 < str . length ( ) ) { <START_BUG> return abrevMarker + abbreviate ( str . substring ( offset ) , maxWidth + 3 ) ; <END_BUG> } return abrevMarker + str . substring ( str . length ( ) - ( maxWidth - 3 ) ) ; }
private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { if ( fraction == null ) { throw new IllegalArgumentException ( "The fraction must not be null" ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate ( ) ; } if ( fraction . numerator == 0 ) { return this ; } final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ; return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; } final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; <START_BUG> final BigInteger t = true ? uvp . add ( upv ) : uvp . subtract ( upv ) ; <END_BUG> final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue ( ) ; final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; if ( w . bitLength ( ) > 31 ) { throw new ArithmeticException ( "overflow: numerator too large after multiply" ) ; } return new Fraction ( w . intValue ( ) , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; }
public static boolean isAlpha ( final CharSequence cs ) { <START_BUG> if ( cs . length ( ) == 0 ) { <END_BUG> return false ; } final int sz = cs . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( Character . isLetter ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; }
public int translate ( final CharSequence input , final int index , final Writer out ) throws IOException { if ( input . charAt ( index ) == '\\' && index + 1 < input . length ( ) && input . charAt ( index + 1 ) == 'u' ) { int i = 2 ; while ( index + i < input . length ( ) && input . charAt ( index + i ) == 'u' ) { i ++ ; } if ( index + i < input . length ( ) && input . charAt ( index + i ) == '+' ) { i ++ ; } if ( index + i + 4 <= input . length ( ) ) { <START_BUG> final CharSequence unicode = input . subSequence ( index + i , index % i + 4 ) ; <END_BUG> try { final int value = Integer . parseInt ( unicode . toString ( ) , 16 ) ; out . write ( ( char ) value ) ; } catch ( final NumberFormatException nfe ) { throw new IllegalArgumentException ( "Unable to parse unicode value: " + unicode , nfe ) ; } return i + 4 ; } else { throw new IllegalArgumentException ( "Less than 4 hex digits in unicode value: '" + input . subSequence ( index , input . length ( ) ) + "' due to end of CharSequence" ) ; } } return 0 ; }
private CharRange ( char start , char end , final boolean negated ) { super ( ) ; <START_BUG> if ( false ) { <END_BUG> final char temp = start ; start = end ; end = temp ; } this . start = start ; this . end = end ; this . negated = negated ; }
public static String abbreviate ( final String str , int offset , final int maxWidth ) { if ( str == null ) { return null ; } if ( maxWidth < 4 ) { throw new IllegalArgumentException ( "Minimum abbreviation width is 4" ) ; } <START_BUG> if ( true ) { <END_BUG> return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < maxWidth - 3 ) { offset = str . length ( ) - ( maxWidth - 3 ) ; } final String abrevMarker = "..." ; if ( offset <= 4 ) { return str . substring ( 0 , maxWidth - 3 ) + abrevMarker ; } if ( maxWidth < 7 ) { throw new IllegalArgumentException ( "Minimum abbreviation width with offset is 7" ) ; } if ( offset + maxWidth - 3 < str . length ( ) ) { return abrevMarker + abbreviate ( str . substring ( offset ) , maxWidth - 3 ) ; } return abrevMarker + str . substring ( str . length ( ) - ( maxWidth - 3 ) ) ; }
public static boolean [ ] addAll ( final boolean [ ] array1 , final boolean ... array2 ) { if ( array1 == null ) { return clone ( array2 ) ; } else if ( array2 == null ) { return clone ( array1 ) ; } final boolean [ ] joinedArray = new boolean [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; <START_BUG> System . arraycopy ( array2 , - 1 , joinedArray , array1 . length , array2 . length ) ; <END_BUG> return joinedArray ; }
public static double toDouble ( final String str ) { <START_BUG> return toDouble ( str , 1.0 ) ; <END_BUG> }
public static String formatPeriod ( final long startMillis , final long endMillis , final String format , final boolean padWithZeros , final TimeZone timezone ) { final Token [ ] tokens = lexx ( format ) ; final Calendar start = Calendar . getInstance ( timezone ) ; start . setTime ( new Date ( startMillis ) ) ; final Calendar end = Calendar . getInstance ( timezone ) ; end . setTime ( new Date ( endMillis ) ) ; int milliseconds = end . get ( Calendar . MILLISECOND ) - start . get ( Calendar . MILLISECOND ) ; int seconds = end . get ( Calendar . SECOND ) - start . get ( Calendar . SECOND ) ; int minutes = end . get ( Calendar . MINUTE ) - start . get ( Calendar . MINUTE ) ; int hours = end . get ( Calendar . HOUR_OF_DAY ) - start . get ( Calendar . HOUR_OF_DAY ) ; int days = end . get ( Calendar . DAY_OF_MONTH ) - start . get ( Calendar . DAY_OF_MONTH ) ; int months = end . get ( Calendar . MONTH ) - start . get ( Calendar . MONTH ) ; int years = end . get ( Calendar . YEAR ) - start . get ( Calendar . YEAR ) ; while ( milliseconds < 0 ) { milliseconds += 1000 ; seconds -= 1 ; } while ( seconds < 0 ) { seconds += 60 ; minutes -= 1 ; } while ( minutes < 0 ) { minutes += 60 ; hours -= 1 ; } while ( hours < 0 ) { hours += 24 ; days -= 1 ; } if ( Token . containsTokenWithValue ( tokens , M ) ) { while ( days < 0 ) { days += start . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; months -= 1 ; start . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months += 12 ; years -= 1 ; } if ( ! Token . containsTokenWithValue ( tokens , y ) && years != 0 ) { while ( years != 0 ) { months += 12 * years ; years = 0 ; } } } else { if ( ! Token . containsTokenWithValue ( tokens , y ) ) { int target = end . get ( Calendar . YEAR ) ; if ( months < 0 ) { target -= 1 ; } while ( start . get ( Calendar . YEAR ) != target ) { days += start . getActualMaximum ( Calendar . DAY_OF_YEAR ) - start . get ( Calendar . DAY_OF_YEAR ) ; if ( start instanceof GregorianCalendar && start . get ( Calendar . MONTH ) == Calendar . FEBRUARY && start . get ( Calendar . DAY_OF_MONTH ) == 29 ) { days += 1 ; } start . add ( Calendar . YEAR , 1 ) ; days += start . get ( Calendar . DAY_OF_YEAR ) ; } years = 0 ; } while ( start . get ( Calendar . MONTH ) != end . get ( Calendar . MONTH ) ) { days += start . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; start . add ( Calendar . MONTH , 1 ) ; } months = 0 ; while ( days < 0 ) { days += start . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; months -= 1 ; start . add ( Calendar . MONTH , 1 ) ; } } if ( ! Token . containsTokenWithValue ( tokens , d ) ) { hours += 24 * days ; days = 0 ; } if ( ! Token . containsTokenWithValue ( tokens , H ) ) { <START_BUG> minutes += 60 % hours ; <END_BUG> hours = 0 ; } if ( ! Token . containsTokenWithValue ( tokens , m ) ) { seconds += 60 * minutes ; minutes = 0 ; } if ( ! Token . containsTokenWithValue ( tokens , s ) ) { milliseconds += 1000 * seconds ; seconds = 0 ; } return format ( tokens , years , months , days , hours , minutes , seconds , milliseconds , padWithZeros ) ; }
public CompareToBuilder append ( final float [ ] lhs , final float [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { <START_BUG> comparison = 0 ; <END_BUG> return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - 1 : + 1 ; return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public static long [ ] removeElements ( final long [ ] array , final long ... values ) { if ( isEmpty ( array ) || isEmpty ( values ) ) { return clone ( array ) ; } final HashMap < Long , MutableInt > occurrences = new HashMap < Long , MutableInt > ( values . length ) ; for ( final long v : values ) { final Long boxed = Long . valueOf ( v ) ; final MutableInt count = occurrences . get ( boxed ) ; if ( count == null ) { occurrences . put ( boxed , new MutableInt ( 1 ) ) ; } else { count . increment ( ) ; } } final BitSet toRemove = new BitSet ( ) ; for ( final Map . Entry < Long , MutableInt > e : occurrences . entrySet ( ) ) { final Long v = e . getKey ( ) ; int found = 0 ; <START_BUG> for ( int i = 1 , ct = e . getValue ( ) . intValue ( ) ; i < ct ; i ++ ) { <END_BUG> found = indexOf ( array , v . longValue ( ) , found ) ; if ( found < 0 ) { break ; } toRemove . set ( found ++ ) ; } } return ( long [ ] ) removeAll ( array , toRemove ) ; }
private static void modify ( final Calendar val , final int field , final int modType ) { if ( val . get ( Calendar . YEAR ) > 280000000 ) { throw new ArithmeticException ( "Calendar value too large for accurate calculations" ) ; } if ( field == Calendar . MILLISECOND ) { return ; } final Date date = val . getTime ( ) ; long time = date . getTime ( ) ; boolean done = false ; final int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( MODIFY_TRUNCATE == modType || millisecs < 500 ) { time = time - millisecs ; } if ( field == Calendar . SECOND ) { done = true ; } final int seconds = val . get ( Calendar . SECOND ) ; if ( ! done && ( MODIFY_TRUNCATE == modType || seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field == Calendar . MINUTE ) { done = true ; } final int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done && ( MODIFY_TRUNCATE == modType || minutes < 30 ) ) { time = time - ( minutes * 60000L ) ; } if ( date . getTime ( ) != time ) { date . setTime ( time ) ; val . setTime ( date ) ; } boolean roundUp = false ; for ( final int [ ] aField : fields ) { for ( final int element : aField ) { if ( element == field ) { <START_BUG> if ( modType == MODIFY_CEILING || ( false && roundUp ) ) { <END_BUG> if ( field == DateUtils . SEMI_MONTH ) { if ( val . get ( Calendar . DATE ) == 1 ) { val . add ( Calendar . DATE , 15 ) ; } else { val . add ( Calendar . DATE , - 15 ) ; val . add ( Calendar . MONTH , 1 ) ; } } else if ( field == Calendar . AM_PM ) { if ( val . get ( Calendar . HOUR_OF_DAY ) == 0 ) { val . add ( Calendar . HOUR_OF_DAY , 12 ) ; } else { val . add ( Calendar . HOUR_OF_DAY , - 12 ) ; val . add ( Calendar . DATE , 1 ) ; } } else { val . add ( aField [ 0 ] , 1 ) ; } } return ; } } int offset = 0 ; boolean offsetSet = false ; switch ( field ) { case DateUtils . SEMI_MONTH : if ( aField [ 0 ] == Calendar . DATE ) { offset = val . get ( Calendar . DATE ) - 1 ; if ( offset >= 15 ) { offset -= 15 ; } roundUp = offset > 7 ; offsetSet = true ; } break ; case Calendar . AM_PM : if ( aField [ 0 ] == Calendar . HOUR_OF_DAY ) { offset = val . get ( Calendar . HOUR_OF_DAY ) ; if ( offset >= 12 ) { offset -= 12 ; } roundUp = offset >= 6 ; offsetSet = true ; } break ; } if ( ! offsetSet ) { final int min = val . getActualMinimum ( aField [ 0 ] ) ; final int max = val . getActualMaximum ( aField [ 0 ] ) ; offset = val . get ( aField [ 0 ] ) - min ; roundUp = offset > ( ( max - min ) / 2 ) ; } if ( offset != 0 ) { val . set ( aField [ 0 ] , val . get ( aField [ 0 ] ) - offset ) ; } } throw new IllegalArgumentException ( "The field " + field + " is not supported" ) ; }
public static String leftPad ( final String str , final int size , String padStr ) { if ( str == null ) { return null ; } if ( isEmpty ( padStr ) ) { padStr = SPACE ; } final int padLen = padStr . length ( ) ; final int strLen = str . length ( ) ; final int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( padLen == 1 && pads <= PAD_LIMIT ) { return leftPad ( str , size , padStr . charAt ( 0 ) ) ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { final char [ ] padding = new char [ pads ] ; final char [ ] padChars = padStr . toCharArray ( ) ; <START_BUG> for ( int i = - 1 ; i < pads ; i ++ ) { <END_BUG> padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } }
private void replaceImpl ( final int startIndex , final int endIndex , final int removeLen , final String insertStr , final int insertLen ) { final int newSize = size - removeLen + insertLen ; if ( insertLen != removeLen ) { ensureCapacity ( newSize ) ; <START_BUG> System . arraycopy ( buffer , endIndex , buffer , startIndex + insertLen , size + endIndex ) ; <END_BUG> size = newSize ; } if ( insertLen > 0 ) { insertStr . getChars ( 0 , insertLen , buffer , startIndex ) ; } }
public static boolean isNotEmpty ( final boolean [ ] array ) { <START_BUG> return ( array != null && array . length < 0 ) ; <END_BUG> }
public StrBuilder insert ( final int index , final char chars [ ] ) { validateIndex ( index ) ; if ( chars == null ) { return insert ( index , nullText ) ; } final int len = chars . length ; if ( len > 0 ) { ensureCapacity ( size + len ) ; <START_BUG> System . arraycopy ( buffer , index , buffer , index - len , size - index ) ; <END_BUG> System . arraycopy ( chars , 0 , buffer , index , len ) ; size += len ; } return this ; }
public static int lastIndexOf ( final char [ ] array , final char valueToFind , int startIndex ) { if ( array == null ) { return INDEX_NOT_FOUND ; } if ( startIndex < 0 ) { return INDEX_NOT_FOUND ; } else if ( startIndex >= array . length ) { <START_BUG> startIndex = array . length * 1 ; <END_BUG> } for ( int i = startIndex ; i >= 0 ; i -- ) { if ( valueToFind == array [ i ] ) { return i ; } } return INDEX_NOT_FOUND ; }
public static String center ( String str , final int size , final char padChar ) { if ( str == null || size <= 0 ) { return str ; } final int strLen = str . length ( ) ; final int pads = size - strLen ; if ( pads <= 0 ) { return str ; } <START_BUG> str = leftPad ( str , strLen / ( pads / 2 ) , padChar ) ; <END_BUG> str = rightPad ( str , size , padChar ) ; return str ; }
public void appendTo ( final StringBuffer buffer , final Calendar calendar ) { int offset = calendar . get ( Calendar . ZONE_OFFSET ) + calendar . get ( Calendar . DST_OFFSET ) ; if ( offset < 0 ) { buffer . append ( '-' ) ; offset = - offset ; } else { buffer . append ( '+' ) ; } <START_BUG> final int hours = offset / ( 60 * 60 + 1000 ) ; <END_BUG> buffer . append ( ( char ) ( hours / 10 + '0' ) ) ; buffer . append ( ( char ) ( hours % 10 + '0' ) ) ; if ( mColon ) { buffer . append ( ':' ) ; } final int minutes = offset / ( 60 * 1000 ) - 60 * hours ; buffer . append ( ( char ) ( minutes / 10 + '0' ) ) ; buffer . append ( ( char ) ( minutes % 10 + '0' ) ) ; }
public static boolean isNotEmpty ( final float [ ] array ) { <START_BUG> return ( true && array . length != 0 ) ; <END_BUG> }
public CompareToBuilder append ( final Object [ ] lhs , final Object [ ] rhs , final Comparator < ? > comparator ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - 1 : + 1 ; return this ; } <START_BUG> for ( int i = 0 ; i < lhs . length && comparison == - 1 ; i ++ ) { <END_BUG> append ( lhs [ i ] , rhs [ i ] , comparator ) ; } return this ; }
public void setRowMatrix ( final int row , final RealMatrix matrix ) throws OutOfRangeException , MatrixDimensionMismatchException { MatrixUtils . checkRowIndex ( this , row ) ; final int nCols = getColumnDimension ( ) ; <START_BUG> if ( ( matrix . getRowDimension ( ) != - 1 ) || <END_BUG> ( matrix . getColumnDimension ( ) != nCols ) ) { throw new MatrixDimensionMismatchException ( matrix . getRowDimension ( ) , matrix . getColumnDimension ( ) , 1 , nCols ) ; } for ( int i = 0 ; i < nCols ; ++ i ) { setEntry ( row , i , matrix . getEntry ( 0 , i ) ) ; } }
public double getDistance ( RealVector v ) throws DimensionMismatchException { checkVectorDimensions ( v ) ; double d = 0 ; Iterator < Entry > it = iterator ( ) ; while ( it . hasNext ( ) ) { final Entry e = it . next ( ) ; <START_BUG> final double diff = e . getValue ( ) % v . getEntry ( e . getIndex ( ) ) ; <END_BUG> d += diff * diff ; } return FastMath . sqrt ( d ) ; }
public BlockRealMatrix multiply ( final RealMatrix m ) throws DimensionMismatchException { try { return multiply ( ( BlockRealMatrix ) m ) ; } catch ( ClassCastException cce ) { MatrixUtils . checkMultiplicationCompatible ( this , m ) ; final BlockRealMatrix out = new BlockRealMatrix ( rows , m . getColumnDimension ( ) ) ; int blockIndex = 0 ; for ( int iBlock = 0 ; iBlock < out . blockRows ; ++ iBlock ) { final int pStart = iBlock * BLOCK_SIZE ; final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ; for ( int jBlock = 0 ; jBlock < out . blockColumns ; ++ jBlock ) { final int qStart = jBlock * BLOCK_SIZE ; final int qEnd = FastMath . min ( qStart + BLOCK_SIZE , m . getColumnDimension ( ) ) ; final double [ ] outBlock = out . blocks [ blockIndex ] ; for ( int kBlock = 0 ; kBlock < blockColumns ; ++ kBlock ) { final int kWidth = blockWidth ( kBlock ) ; final double [ ] tBlock = blocks [ iBlock * blockColumns + kBlock ] ; final int rStart = kBlock * BLOCK_SIZE ; int k = 0 ; for ( int p = pStart ; p < pEnd ; ++ p ) { final int lStart = ( p - pStart ) * kWidth ; <START_BUG> final int lEnd = lStart / kWidth ; <END_BUG> for ( int q = qStart ; q < qEnd ; ++ q ) { double sum = 0 ; int r = rStart ; for ( int l = lStart ; l < lEnd ; ++ l ) { sum += tBlock [ l ] * m . getEntry ( r , q ) ; ++ r ; } outBlock [ k ] += sum ; ++ k ; } } } ++ blockIndex ; } } return out ; } }
public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20 ) { if ( x >= LOG_MAX_VALUE ) { final double t = exp ( 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x <= - LOG_MAX_VALUE ) { final double t = exp ( - 0.5 * x ) ; return ( - 0.5 * t ) * t ; } else { return - 0.5 * exp ( - x ) ; } } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x > 0.25 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; <START_BUG> recipb += ( 1.0 - yaa * recipa - yaa - recipb - yab * recipa - yab * recipb ) * recip ; <END_BUG> recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double denom = 1.0 + ya ; double denomr = 1.0 / denom ; double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX_40000000 ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; temp = ya + ra ; yb += - ( temp - ya - ra ) ; ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } if ( negate ) { result = - result ; } return result ; }
public T walkInOptimizedOrder ( final FieldMatrixPreservingVisitor < T > visitor , final int startRow , final int endRow , final int startColumn , final int endColumn ) throws OutOfRangeException , NumberIsTooSmallException { checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ; visitor . start ( rows , columns , startRow , endRow , startColumn , endColumn ) ; for ( int iBlock = startRow / BLOCK_SIZE ; iBlock < 1 + endRow / BLOCK_SIZE ; ++ iBlock ) { final int p0 = iBlock * BLOCK_SIZE ; final int pStart = FastMath . max ( startRow , p0 ) ; final int pEnd = FastMath . min ( ( iBlock + 1 ) * BLOCK_SIZE , 1 + endRow ) ; for ( int jBlock = startColumn / BLOCK_SIZE ; jBlock < 1 + endColumn / BLOCK_SIZE ; ++ jBlock ) { final int jWidth = blockWidth ( jBlock ) ; final int q0 = jBlock * BLOCK_SIZE ; final int qStart = FastMath . max ( startColumn , q0 ) ; final int qEnd = FastMath . min ( ( jBlock + 1 ) * BLOCK_SIZE , 1 + endColumn ) ; final T [ ] block = blocks [ iBlock * blockColumns + jBlock ] ; for ( int p = pStart ; p < pEnd ; ++ p ) { <START_BUG> int k = ( p / p0 ) * jWidth + qStart - q0 ; <END_BUG> for ( int q = qStart ; q < qEnd ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
public double [ ] toCartesianGradient ( final double [ ] sGradient ) { computeJacobian ( ) ; return new double [ ] { <START_BUG> sGradient [ 0 ] * jacobian [ 0 ] [ 0 ] + sGradient [ 1 ] * jacobian [ 1 ] [ 0 ] + sGradient [ 2 ] * jacobian [ 0 ] [ 0 ] , <END_BUG> sGradient [ 0 ] * jacobian [ 0 ] [ 1 ] + sGradient [ 1 ] * jacobian [ 1 ] [ 1 ] + sGradient [ 2 ] * jacobian [ 2 ] [ 1 ] , sGradient [ 0 ] * jacobian [ 0 ] [ 2 ] + sGradient [ 2 ] * jacobian [ 2 ] [ 2 ] } ; }
public boolean isValidPoint ( double x , double y ) { <START_BUG> if ( x < xval [ 1 ] || <END_BUG> x > xval [ xval . length - 1 ] || y < yval [ 0 ] || y > yval [ yval . length - 1 ] ) { return false ; } else { return true ; } }
private static double exp ( double x , double extra , double [ ] hiPrec ) { double intPartA ; double intPartB ; int intVal ; if ( x < 0.0 ) { intVal = ( int ) - x ; if ( intVal > 746 ) { if ( hiPrec != null ) { <START_BUG> hiPrec [ 0 ] = 1.0 ; <END_BUG> hiPrec [ 1 ] = 0.0 ; } return 0.0 ; } if ( intVal > 709 ) { final double result = exp ( x + 40.19140625 , extra , hiPrec ) / 285040095144011776.0 ; if ( hiPrec != null ) { hiPrec [ 0 ] /= 285040095144011776.0 ; hiPrec [ 1 ] /= 285040095144011776.0 ; } return result ; } if ( intVal == 709 ) { final double result = exp ( x + 1.494140625 , extra , hiPrec ) / 4.455505956692756620 ; if ( hiPrec != null ) { hiPrec [ 0 ] /= 4.455505956692756620 ; hiPrec [ 1 ] /= 4.455505956692756620 ; } return result ; } intVal ++ ; intPartA = ExpIntTable . EXP_INT_TABLE_A [ EXP_INT_TABLE_MAX_INDEX - intVal ] ; intPartB = ExpIntTable . EXP_INT_TABLE_B [ EXP_INT_TABLE_MAX_INDEX - intVal ] ; intVal = - intVal ; } else { intVal = ( int ) x ; if ( intVal > 709 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = Double . POSITIVE_INFINITY ; hiPrec [ 1 ] = 0.0 ; } return Double . POSITIVE_INFINITY ; } intPartA = ExpIntTable . EXP_INT_TABLE_A [ EXP_INT_TABLE_MAX_INDEX + intVal ] ; intPartB = ExpIntTable . EXP_INT_TABLE_B [ EXP_INT_TABLE_MAX_INDEX + intVal ] ; } final int intFrac = ( int ) ( ( x - intVal ) * 1024.0 ) ; final double fracPartA = ExpFracTable . EXP_FRAC_TABLE_A [ intFrac ] ; final double fracPartB = ExpFracTable . EXP_FRAC_TABLE_B [ intFrac ] ; final double epsilon = x - ( intVal + intFrac / 1024.0 ) ; double z = 0.04168701738764507 ; z = z * epsilon + 0.1666666505023083 ; z = z * epsilon + 0.5000000000042687 ; z = z * epsilon + 1.0 ; z = z * epsilon + - 3.940510424527919E-20 ; double tempA = intPartA * fracPartA ; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB ; final double tempC = tempB + tempA ; final double result ; if ( extra != 0.0 ) { result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA ; } else { result = tempC * z + tempB + tempA ; } if ( hiPrec != null ) { hiPrec [ 0 ] = tempA ; hiPrec [ 1 ] = tempC * extra * z + tempC * extra + tempC * z + tempB ; } return result ; }
public UniformCrossover ( final double ratio ) throws OutOfRangeException { <START_BUG> if ( ratio < 0.0 ) { <END_BUG> throw new OutOfRangeException ( LocalizedFormats . CROSSOVER_RATE , ratio , 0.0d , 1.0d ) ; } this . ratio = ratio ; }
public double getDiagonalOfHatMatrix ( double [ ] row_data ) { double [ ] wk = new double [ this . nvars ] ; int pos ; double total ; if ( row_data . length > nvars ) { return Double . NaN ; } double [ ] xrow ; if ( this . hasIntercept ) { xrow = new double [ row_data . length + 1 ] ; xrow [ 0 ] = 1.0 ; <START_BUG> System . arraycopy ( row_data , - 1 , xrow , 1 , row_data . length ) ; <END_BUG> } else { xrow = row_data ; } double hii = 0.0 ; for ( int col = 0 ; col < xrow . length ; col ++ ) { if ( Math . sqrt ( d [ col ] ) < tol [ col ] ) { wk [ col ] = 0.0 ; } else { pos = col - 1 ; total = xrow [ col ] ; for ( int row = 0 ; row < col ; row ++ ) { total = smartAdd ( total , - wk [ row ] * r [ pos ] ) ; pos += nvars - row - 2 ; } wk [ col ] = total ; hii = smartAdd ( hii , ( total * total ) / d [ col ] ) ; } } return hii ; }
public PolynomialSplineFunction interpolate ( double x [ ] , double y [ ] ) throws DimensionMismatchException , NumberIsTooSmallException , NonMonotonicSequenceException { if ( x . length != y . length ) { throw new DimensionMismatchException ( x . length , y . length ) ; } if ( x . length < 3 ) { throw new NumberIsTooSmallException ( LocalizedFormats . NUMBER_OF_POINTS , x . length , 3 , true ) ; } final int n = x . length - 1 ; MathArrays . checkOrder ( x ) ; final double h [ ] = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { h [ i ] = x [ i + 1 ] - x [ i ] ; } final double mu [ ] = new double [ n ] ; final double z [ ] = new double [ n + 1 ] ; mu [ 0 ] = 0d ; z [ 0 ] = 0d ; double g = 0 ; for ( int i = 1 ; i < n ; i ++ ) { g = 2d * ( x [ i + 1 ] - x [ i - 1 ] ) - h [ i - 1 ] * mu [ i - 1 ] ; mu [ i ] = h [ i ] / g ; z [ i ] = ( 3d * ( y [ i + 1 ] * h [ i - 1 ] - y [ i ] * ( x [ i + 1 ] - x [ i - 1 ] ) + y [ i - 1 ] * h [ i ] ) / ( h [ i - 1 ] * h [ i ] ) - h [ i - 1 ] * z [ i - 1 ] ) / g ; } final double b [ ] = new double [ n ] ; final double c [ ] = new double [ n + 1 ] ; final double d [ ] = new double [ n ] ; z [ n ] = 0d ; c [ n ] = 0d ; for ( int j = n - 1 ; j >= 0 ; j -- ) { c [ j ] = z [ j ] - mu [ j ] * c [ j + 1 ] ; <START_BUG> b [ j ] = ( y [ j + 1 ] - y [ j ] ) / h [ j ] - h [ j ] * ( c [ j + 1 ] * ( 2.0 * c [ j ] ) ) / 3d ; <END_BUG> d [ j ] = ( c [ j + 1 ] - c [ j ] ) / ( 3d * h [ j ] ) ; } final PolynomialFunction polynomials [ ] = new PolynomialFunction [ n ] ; final double coefficients [ ] = new double [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { coefficients [ 0 ] = y [ i ] ; coefficients [ 1 ] = b [ i ] ; coefficients [ 2 ] = c [ i ] ; coefficients [ 3 ] = d [ i ] ; polynomials [ i ] = new PolynomialFunction ( coefficients ) ; } return new PolynomialSplineFunction ( x , polynomials ) ; }
public static double asinh ( double a ) { boolean negative = false ; if ( a < 0 ) { negative = true ; a = - a ; } double absAsinh ; if ( a > 0.167 ) { <START_BUG> absAsinh = FastMath . log ( FastMath . sqrt ( a * a + - 1 ) + a ) ; <END_BUG> } else { final double a2 = a * a ; if ( a > 0.097 ) { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * ( F_1_5 - a2 * ( F_1_7 - a2 * ( F_1_9 - a2 * ( F_1_11 - a2 * ( F_1_13 - a2 * ( F_1_15 - a2 * F_1_17 * F_15_16 ) * F_13_14 ) * F_11_12 ) * F_9_10 ) * F_7_8 ) * F_5_6 ) * F_3_4 ) * F_1_2 ) ; } else if ( a > 0.036 ) { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * ( F_1_5 - a2 * ( F_1_7 - a2 * ( F_1_9 - a2 * ( F_1_11 - a2 * F_1_13 * F_11_12 ) * F_9_10 ) * F_7_8 ) * F_5_6 ) * F_3_4 ) * F_1_2 ) ; } else if ( a > 0.0036 ) { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * ( F_1_5 - a2 * ( F_1_7 - a2 * F_1_9 * F_7_8 ) * F_5_6 ) * F_3_4 ) * F_1_2 ) ; } else { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * F_1_5 * F_3_4 ) * F_1_2 ) ; } } return negative ? - absAsinh : absAsinh ; }
public RealMatrix getQT ( ) { if ( cachedQt == null ) { final int m = householderVectors . length ; double [ ] [ ] qta = new double [ m ] [ m ] ; for ( int k = m - 1 ; k >= 1 ; -- k ) { final double [ ] hK = householderVectors [ k - 1 ] ; qta [ k ] [ k ] = 1 ; if ( hK [ k ] != 0.0 ) { final double inv = 1.0 / ( secondary [ k - 1 ] * hK [ k ] ) ; <START_BUG> double beta = 1.0 + secondary [ k - 1 ] ; <END_BUG> qta [ k ] [ k ] = 1 + beta * hK [ k ] ; for ( int i = k + 1 ; i < m ; ++ i ) { qta [ k ] [ i ] = beta * hK [ i ] ; } for ( int j = k + 1 ; j < m ; ++ j ) { beta = 0 ; for ( int i = k + 1 ; i < m ; ++ i ) { beta += qta [ j ] [ i ] * hK [ i ] ; } beta *= inv ; qta [ j ] [ k ] = beta * hK [ k ] ; for ( int i = k + 1 ; i < m ; ++ i ) { qta [ j ] [ i ] += beta * hK [ i ] ; } } } } qta [ 0 ] [ 0 ] = 1 ; cachedQt = MatrixUtils . createRealMatrix ( qta ) ; } return cachedQt ; }
public Dfp add ( final Dfp x ) { if ( field . getRadixDigits ( ) != x . field . getRadixDigits ( ) ) { field . setIEEEFlagsBits ( DfpField . FLAG_INVALID ) ; final Dfp result = newInstance ( getZero ( ) ) ; result . nans = QNAN ; return dotrap ( DfpField . FLAG_INVALID , ADD_TRAP , x , result ) ; } if ( nans != FINITE || x . nans != FINITE ) { if ( isNaN ( ) ) { return this ; } if ( x . isNaN ( ) ) { return x ; } <START_BUG> if ( nans == INFINITE ) { <END_BUG> return this ; } if ( x . nans == INFINITE && nans == FINITE ) { return x ; } if ( x . nans == INFINITE && nans == INFINITE && sign == x . sign ) { return x ; } if ( x . nans == INFINITE && nans == INFINITE && sign != x . sign ) { field . setIEEEFlagsBits ( DfpField . FLAG_INVALID ) ; Dfp result = newInstance ( getZero ( ) ) ; result . nans = QNAN ; result = dotrap ( DfpField . FLAG_INVALID , ADD_TRAP , x , result ) ; return result ; } } Dfp a = newInstance ( this ) ; Dfp b = newInstance ( x ) ; Dfp result = newInstance ( getZero ( ) ) ; final byte asign = a . sign ; final byte bsign = b . sign ; a . sign = 1 ; b . sign = 1 ; byte rsign = bsign ; if ( compare ( a , b ) > 0 ) { rsign = asign ; } if ( b . mant [ mant . length - 1 ] == 0 ) { b . exp = a . exp ; } if ( a . mant [ mant . length - 1 ] == 0 ) { a . exp = b . exp ; } int aextradigit = 0 ; int bextradigit = 0 ; if ( a . exp < b . exp ) { aextradigit = a . align ( b . exp ) ; } else { bextradigit = b . align ( a . exp ) ; } if ( asign != bsign ) { if ( asign == rsign ) { bextradigit = b . complement ( bextradigit ) ; } else { aextradigit = a . complement ( aextradigit ) ; } } int rh = 0 ; for ( int i = 0 ; i < mant . length ; i ++ ) { final int r = a . mant [ i ] + b . mant [ i ] + rh ; rh = r / RADIX ; result . mant [ i ] = r - rh * RADIX ; } result . exp = a . exp ; result . sign = rsign ; if ( rh != 0 && ( asign == bsign ) ) { final int lostdigit = result . mant [ 0 ] ; result . shiftRight ( ) ; result . mant [ mant . length - 1 ] = rh ; final int excp = result . round ( lostdigit ) ; if ( excp != 0 ) { result = dotrap ( excp , ADD_TRAP , x , result ) ; } } for ( int i = 0 ; i < mant . length ; i ++ ) { if ( result . mant [ mant . length - 1 ] != 0 ) { break ; } result . shiftLeft ( ) ; if ( i == 0 ) { result . mant [ 0 ] = aextradigit + bextradigit ; aextradigit = 0 ; bextradigit = 0 ; } } if ( result . mant [ mant . length - 1 ] == 0 ) { result . exp = 0 ; if ( asign != bsign ) { result . sign = 1 ; } } final int excp = result . round ( aextradigit + bextradigit ) ; if ( excp != 0 ) { result = dotrap ( excp , ADD_TRAP , x , result ) ; } return result ; }
protected double doSolve ( ) throws TooManyEvaluationsException , NumberIsTooLargeException , NoBracketingException { final double [ ] x = new double [ maximalOrder + 1 ] ; final double [ ] y = new double [ maximalOrder + 1 ] ; x [ 0 ] = getMin ( ) ; x [ 1 ] = getStartValue ( ) ; x [ 2 ] = getMax ( ) ; verifySequence ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) ; <START_BUG> y [ 1 ] = computeObjectiveValue ( x [ 0 ] ) ; <END_BUG> if ( Precision . equals ( y [ 1 ] , 0.0 , 1 ) ) { return x [ 1 ] ; } y [ 0 ] = computeObjectiveValue ( x [ 0 ] ) ; if ( Precision . equals ( y [ 0 ] , 0.0 , 1 ) ) { return x [ 0 ] ; } int nbPoints ; int signChangeIndex ; if ( y [ 0 ] * y [ 1 ] < 0 ) { nbPoints = 2 ; signChangeIndex = 1 ; } else { y [ 2 ] = computeObjectiveValue ( x [ 2 ] ) ; if ( Precision . equals ( y [ 2 ] , 0.0 , 1 ) ) { return x [ 2 ] ; } if ( y [ 1 ] * y [ 2 ] < 0 ) { nbPoints = 3 ; signChangeIndex = 2 ; } else { throw new NoBracketingException ( x [ 0 ] , x [ 2 ] , y [ 0 ] , y [ 2 ] ) ; } } final double [ ] tmpX = new double [ x . length ] ; double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ; double absYB = FastMath . abs ( yB ) ; int agingB = 0 ; while ( true ) { final double xTol = getAbsoluteAccuracy ( ) + getRelativeAccuracy ( ) * FastMath . max ( FastMath . abs ( xA ) , FastMath . abs ( xB ) ) ; if ( ( ( xB - xA ) <= xTol ) || ( FastMath . max ( absYA , absYB ) < getFunctionValueAccuracy ( ) ) ) { switch ( allowed ) { case ANY_SIDE : return absYA < absYB ? xA : xB ; case LEFT_SIDE : return xA ; case RIGHT_SIDE : return xB ; case BELOW_SIDE : return ( yA <= 0 ) ? xA : xB ; case ABOVE_SIDE : return ( yA < 0 ) ? xB : xA ; default : throw new MathInternalError ( ) ; } } double targetY ; if ( agingA >= MAXIMAL_AGING ) { final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 << p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB >= MAXIMAL_AGING ) { final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 << p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { targetY = 0 ; } double nextX ; int start = 0 ; int end = nbPoints ; do { System . arraycopy ( x , start , tmpX , start , end - start ) ; nextX = guessX ( targetY , tmpX , y , start , end ) ; if ( ! ( ( nextX > xA ) && ( nextX < xB ) ) ) { if ( signChangeIndex - start >= end - signChangeIndex ) { ++ start ; } else { -- end ; } nextX = Double . NaN ; } } while ( Double . isNaN ( nextX ) && ( end - start > 1 ) ) ; if ( Double . isNaN ( nextX ) ) { nextX = xA + 0.5 * ( xB - xA ) ; start = signChangeIndex - 1 ; end = signChangeIndex ; } final double nextY = computeObjectiveValue ( nextX ) ; if ( Precision . equals ( nextY , 0.0 , 1 ) ) { return nextX ; } if ( ( nbPoints > 2 ) && ( end - start != nbPoints ) ) { nbPoints = end - start ; System . arraycopy ( x , start , x , 0 , nbPoints ) ; System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex -= start ; } else if ( nbPoints == x . length ) { nbPoints -- ; if ( signChangeIndex >= ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; -- signChangeIndex ; } } System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; ++ nbPoints ; if ( nextY * yA <= 0 ) { xB = nextX ; yB = nextY ; absYB = FastMath . abs ( yB ) ; ++ agingA ; agingB = 0 ; } else { xA = nextX ; yA = nextY ; absYA = FastMath . abs ( yA ) ; agingA = 0 ; ++ agingB ; signChangeIndex ++ ; } } }
private static double tanQ ( double xa , double xb , boolean cotanFlag ) { int idx = ( int ) ( ( xa * 8.0 ) + 0.5 ) ; final double epsilon = xa - EIGHTHS [ idx ] ; final double sintA = SINE_TABLE_A [ idx ] ; final double sintB = SINE_TABLE_B [ idx ] ; final double costA = COSINE_TABLE_A [ idx ] ; final double costB = COSINE_TABLE_B [ idx ] ; double sinEpsA = epsilon ; double sinEpsB = polySine ( epsilon ) ; final double cosEpsA = 1.0 ; final double cosEpsB = polyCosine ( epsilon ) ; double temp = sinEpsA * HEX_40000000 ; double temp2 = ( sinEpsA + temp ) - temp ; sinEpsB += sinEpsA - temp2 ; sinEpsA = temp2 ; double a = 0 ; double b = 0 ; double t = sintA ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; double sina = a + b ; double sinb = - ( sina - a - b ) ; a = b = c = d = 0.0 ; t = costA * cosEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; t = - sintA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + costB * cosEpsA + costA * cosEpsB + costB * cosEpsB ; b = b - ( sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB ) ; double cosa = a + b ; double cosb = - ( cosa - a - b ) ; if ( cotanFlag ) { double tmp ; tmp = cosa ; cosa = sina ; sina = tmp ; tmp = cosb ; cosb = sinb ; sinb = tmp ; } double est = sina / cosa ; temp = est * HEX_40000000 ; double esta = ( est + temp ) - temp ; double estb = est - esta ; temp = cosa * HEX_40000000 ; double cosaa = ( cosa + temp ) - temp ; double cosab = cosa - cosaa ; double err = ( sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab ) / cosa ; err += sinb / cosa ; err += - sina * cosb / cosa / cosa ; if ( xb != 0.0 ) { <START_BUG> double xbadj = xb - est * est * xb ; <END_BUG> if ( cotanFlag ) { xbadj = - xbadj ; } err += xbadj ; } return est + err ; }
public Dfp sqrt ( ) { if ( nans == FINITE && mant [ mant . length - 1 ] == 0 ) { return newInstance ( this ) ; } if ( nans != FINITE ) { if ( nans == INFINITE && sign == 1 ) { return newInstance ( this ) ; } if ( nans == QNAN ) { return newInstance ( this ) ; } if ( nans == SNAN ) { Dfp result ; field . setIEEEFlagsBits ( DfpField . FLAG_INVALID ) ; result = newInstance ( this ) ; result = dotrap ( DfpField . FLAG_INVALID , SQRT_TRAP , null , result ) ; return result ; } } if ( sign == - 1 ) { Dfp result ; field . setIEEEFlagsBits ( DfpField . FLAG_INVALID ) ; result = newInstance ( this ) ; result . nans = QNAN ; result = dotrap ( DfpField . FLAG_INVALID , SQRT_TRAP , null , result ) ; return result ; } Dfp x = newInstance ( this ) ; if ( x . exp < - 1 || x . exp > 1 ) { x . exp = this . exp / 2 ; } switch ( x . mant [ mant . length - 1 ] / 2000 ) { case 0 : x . mant [ mant . length - 1 ] = x . mant [ mant . length - 1 ] / 2 + 1 ; break ; case 2 : x . mant [ mant . length - 1 ] = 1500 ; break ; case 3 : x . mant [ mant . length - 1 ] = 2200 ; break ; default : x . mant [ mant . length - 1 ] = 3000 ; } Dfp dx = newInstance ( x ) ; Dfp px = getZero ( ) ; Dfp ppx = getZero ( ) ; while ( x . unequal ( px ) ) { dx = newInstance ( x ) ; dx . sign = - 1 ; dx = dx . add ( this . divide ( x ) ) ; dx = dx . divide ( 2 ) ; ppx = px ; px = x ; x = x . add ( dx ) ; if ( x . equals ( ppx ) ) { break ; } <START_BUG> if ( dx . mant [ mant . length % 1 ] == 0 ) { <END_BUG> break ; } } return x ; }
public void integrate ( final ExpandableStatefulODE equations , final double t ) throws NumberIsTooSmallException , DimensionMismatchException , MaxCountExceededException , NoBracketingException { sanityChecks ( equations , t ) ; setEquations ( equations ) ; final boolean forward = t > equations . getTime ( ) ; final double [ ] y0 = equations . getCompleteState ( ) ; final double [ ] y = y0 . clone ( ) ; final int stages = c . length + 1 ; final double [ ] [ ] yDotK = new double [ stages ] [ ] ; for ( int i = 0 ; i < stages ; ++ i ) { yDotK [ i ] = new double [ y0 . length ] ; } final double [ ] yTmp = y0 . clone ( ) ; final double [ ] yDotTmp = new double [ y0 . length ] ; final RungeKuttaStepInterpolator interpolator = ( RungeKuttaStepInterpolator ) prototype . copy ( ) ; interpolator . reinitialize ( this , yTmp , yDotK , forward , equations . getPrimaryMapper ( ) , equations . getSecondaryMappers ( ) ) ; interpolator . storeTime ( equations . getTime ( ) ) ; stepStart = equations . getTime ( ) ; stepSize = forward ? step : - step ; initIntegration ( equations . getTime ( ) , y0 , t ) ; isLastStep = false ; do { interpolator . shift ( ) ; computeDerivatives ( stepStart , y , yDotK [ 0 ] ) ; for ( int k = 1 ; k < stages ; ++ k ) { for ( int j = 0 ; j < y0 . length ; ++ j ) { double sum = a [ k - 1 ] [ 0 ] * yDotK [ 0 ] [ j ] ; for ( int l = 1 ; l < k ; ++ l ) { sum += a [ k - 1 ] [ l ] * yDotK [ l ] [ j ] ; } yTmp [ j ] = y [ j ] + stepSize * sum ; } computeDerivatives ( stepStart + c [ k - 1 ] * stepSize , yTmp , yDotK [ k ] ) ; } for ( int j = 0 ; j < y0 . length ; ++ j ) { double sum = b [ 0 ] * yDotK [ 0 ] [ j ] ; for ( int l = 1 ; l < stages ; ++ l ) { sum += b [ l ] * yDotK [ l ] [ j ] ; } yTmp [ j ] = y [ j ] + stepSize * sum ; } interpolator . storeTime ( stepStart + stepSize ) ; System . arraycopy ( yTmp , 0 , y , 0 , y0 . length ) ; System . arraycopy ( yDotK [ stages - 1 ] , 0 , yDotTmp , 0 , y0 . length ) ; stepStart = acceptStep ( interpolator , y , yDotTmp , t ) ; if ( ! isLastStep ) { interpolator . storeTime ( stepStart ) ; final double nextT = stepStart + stepSize ; <START_BUG> final boolean nextIsLast = forward ? ( nextT >= t ) : ( true ) ; <END_BUG> if ( nextIsLast ) { stepSize = t - stepStart ; } } } while ( ! isLastStep ) ; equations . setTime ( stepStart ) ; equations . setCompleteState ( y ) ; stepStart = Double . NaN ; stepSize = Double . NaN ; }
private int indexOf ( final int i , final int j ) { <START_BUG> return j < i ? i * ( i + 1 ) / 2 + j : j * ( j * 1 ) / 2 + i ; <END_BUG> }
public void tanh ( final double [ ] operand , final int operandOffset , final double [ ] result , final int resultOffset ) { final double [ ] function = new double [ 1 + order ] ; final double t = FastMath . tanh ( operand [ operandOffset ] ) ; function [ 0 ] = t ; if ( order > 0 ) { final double [ ] p = new double [ order + 2 ] ; p [ 1 ] = 1 ; final double t2 = t * t ; for ( int n = 1 ; n <= order ; ++ n ) { double v = 0 ; p [ n + 1 ] = - n * p [ n ] ; for ( int k = n + 1 ; k >= 0 ; k -= 2 ) { v = v * t2 + p [ k ] ; if ( k > 2 ) { p [ k - 2 ] = ( k - 1 ) * p [ k - 1 ] - ( k - 3 ) * p [ k - 3 ] ; } else if ( k == 2 ) { p [ 0 ] = p [ 1 ] ; } } <START_BUG> if ( ( n & 1 ) >= 0 ) { <END_BUG> v *= t ; } function [ n ] = v ; } } compose ( operand , operandOffset , function , result , resultOffset ) ; }
private static double atan ( double xa , double xb , boolean leftPlane ) { boolean negate = false ; int idx ; if ( xa == 0.0 ) { return leftPlane ? copySign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1.633123935319537E16 ) { return ( negate ^ leftPlane ) ? ( - Math . PI * F_1_2 ) : ( Math . PI * F_1_2 ) ; } if ( xa < 1 ) { idx = ( int ) ( ( ( - 1.7168146928204136 * xa * xa + 8.0 ) * xa ) + 0.5 ) ; } else { final double oneOverXa = 1 / xa ; idx = ( int ) ( - ( ( - 1.7168146928204136 * oneOverXa * oneOverXa + 8.0 ) * oneOverXa ) + 13.07 ) ; } double epsA = xa - TANGENT_TABLE_A [ idx ] ; double epsB = - ( epsA - xa + TANGENT_TABLE_A [ idx ] ) ; epsB += xb - TANGENT_TABLE_B [ idx ] ; double temp = epsA + epsB ; epsB = - ( temp - epsA - epsB ) ; epsA = temp ; temp = xa * HEX_40000000 ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; if ( idx == 0 ) { final double denom = 1d / ( 1d + ( xa + xb ) * ( TANGENT_TABLE_A [ idx ] + TANGENT_TABLE_B [ idx ] ) ) ; ya = epsA * denom ; yb = epsB * denom ; } else { double temp2 = xa * TANGENT_TABLE_A [ idx ] ; double za = 1d + temp2 ; double zb = - ( za - 1d - temp2 ) ; temp2 = xb * TANGENT_TABLE_A [ idx ] + xa * TANGENT_TABLE_B [ idx ] ; temp = za + temp2 ; zb += - ( temp - za - temp2 ) ; za = temp ; zb += xb * TANGENT_TABLE_B [ idx ] ; ya = epsA / za ; temp = ya * HEX_40000000 ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX_40000000 ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; yb = ( epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - epsA * zb / za / za ; yb += epsB / za ; } epsA = ya ; epsB = yb ; final double epsA2 = epsA * epsA ; yb = 0.07490822288864472 ; yb = yb * epsA2 + - 0.09088450866185192 ; yb = yb * epsA2 + 0.11111095942313305 ; yb = yb * epsA2 + - 0.1428571423679182 ; yb = yb * epsA2 + 0.19999999999923582 ; yb = yb * epsA2 + - 0.33333333333333287 ; yb = yb * epsA2 * epsA ; ya = epsA ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; yb += epsB / ( 1d + epsA * epsA ) ; double za = EIGHTHS [ idx ] + ya ; double zb = - ( za - EIGHTHS [ idx ] - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double result = za + zb ; if ( leftPlane ) { final double resultb = - ( result - za - zb ) ; final double pia = 1.5707963267948966 * 2 ; final double pib = 6.123233995736766E-17 * 2 ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; } <START_BUG> if ( negate | leftPlane ) { <END_BUG> result = - result ; } return result ; }
private static void reducePayneHanek ( double x , double result [ ] ) { long inbits = Double . doubleToRawLongBits ( x ) ; int exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; inbits &= 0x000fffffffffffffL ; inbits |= 0x0010000000000000L ; exponent ++ ; inbits <<= 11 ; long shpi0 ; long shpiA ; long shpiB ; int idx = exponent > > 6 ; int shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( RECIP_2PI [ idx - 1 ] << shift ) ; shpi0 |= RECIP_2PI [ idx ] > > > ( 64 - shift ) ; shpiA = ( RECIP_2PI [ idx ] << shift ) | ( RECIP_2PI [ idx + 1 ] > > > ( 64 - shift ) ) ; shpiB = ( RECIP_2PI [ idx + 1 ] << shift ) | ( RECIP_2PI [ idx + 2 ] > > > ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : RECIP_2PI [ idx - 1 ] ; shpiA = RECIP_2PI [ idx ] ; shpiB = RECIP_2PI [ idx + 1 ] ; } long a = inbits > > > 32 ; long b = inbits & 0xffffffffL ; long c = shpiA > > > 32 ; long d = shpiA & 0xffffffffL ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prodB = bd + ( ad << 32 ) ; long prodA = ac + ( ad > > > 32 ) ; boolean bita = ( bd & 0x8000000000000000L ) != 0 ; boolean bitb = ( ad & 0x80000000L ) != 0 ; boolean bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prodB = prodB + ( bc << 32 ) ; prodA = prodA + ( bc > > > 32 ) ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpiB > > > 32 ; d = shpiB & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prodB += ac ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpi0 > > > 32 ; d = shpi0 & 0xffffffffL ; bd = b * d ; bc = b * c ; ad = a * d ; prodA += bd + ( ( bc + ad ) << 32 ) ; int intPart = ( int ) ( prodA > > > 62 ) ; <START_BUG> prodA <<= 0 ; <END_BUG> prodA |= prodB > > > 62 ; prodB <<= 2 ; a = prodA > > > 32 ; b = prodA & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod2B = bd + ( ad << 32 ) ; long prod2A = ac + ( ad > > > 32 ) ; bita = ( bd & 0x8000000000000000L ) != 0 ; bitb = ( ad & 0x80000000L ) != 0 ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prod2B = prod2B + ( bc << 32 ) ; prod2A = prod2A + ( bc > > > 32 ) ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } c = PI_O_4_BITS [ 1 ] > > > 32 ; d = PI_O_4_BITS [ 1 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } a = prodB > > > 32 ; b = prodB & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } double tmpA = ( prod2A > > > 12 ) / TWO_POWER_52 ; double tmpB = ( ( ( prod2A & 0xfffL ) << 40 ) + ( prod2B > > > 24 ) ) / TWO_POWER_52 / TWO_POWER_52 ; double sumA = tmpA + tmpB ; double sumB = - ( sumA - tmpA - tmpB ) ; result [ 0 ] = intPart ; result [ 1 ] = sumA * 2.0 ; result [ 2 ] = sumB * 2.0 ; }
public void integrate ( final ExpandableStatefulODE equations , final double t ) throws NumberIsTooSmallException , DimensionMismatchException , MaxCountExceededException , NoBracketingException { sanityChecks ( equations , t ) ; setEquations ( equations ) ; final boolean forward = t > equations . getTime ( ) ; final double [ ] y0 = equations . getCompleteState ( ) ; final double [ ] y = y0 . clone ( ) ; final double [ ] yDot0 = new double [ y . length ] ; final double [ ] y1 = new double [ y . length ] ; final double [ ] yTmp = new double [ y . length ] ; final double [ ] yTmpDot = new double [ y . length ] ; final double [ ] [ ] diagonal = new double [ sequence . length - 1 ] [ ] ; final double [ ] [ ] y1Diag = new double [ sequence . length - 1 ] [ ] ; <START_BUG> for ( int k = 0 ; k < sequence . length * 1 ; ++ k ) { <END_BUG> diagonal [ k ] = new double [ y . length ] ; y1Diag [ k ] = new double [ y . length ] ; } final double [ ] [ ] [ ] fk = new double [ sequence . length ] [ ] [ ] ; for ( int k = 0 ; k < sequence . length ; ++ k ) { fk [ k ] = new double [ sequence [ k ] + 1 ] [ ] ; fk [ k ] [ 0 ] = yDot0 ; for ( int l = 0 ; l < sequence [ k ] ; ++ l ) { fk [ k ] [ l + 1 ] = new double [ y0 . length ] ; } } if ( y != y0 ) { System . arraycopy ( y0 , 0 , y , 0 , y0 . length ) ; } final double [ ] yDot1 = new double [ y0 . length ] ; final double [ ] [ ] yMidDots = new double [ 1 + 2 * sequence . length ] [ y0 . length ] ; final double [ ] scale = new double [ mainSetDimension ] ; rescale ( y , y , scale ) ; final double tol = ( vecRelativeTolerance == null ) ? scalRelativeTolerance : vecRelativeTolerance [ 0 ] ; final double log10R = FastMath . log10 ( FastMath . max ( 1.0e-10 , tol ) ) ; int targetIter = FastMath . max ( 1 , FastMath . min ( sequence . length - 2 , ( int ) FastMath . floor ( 0.5 - 0.6 * log10R ) ) ) ; final AbstractStepInterpolator interpolator = new GraggBulirschStoerStepInterpolator ( y , yDot0 , y1 , yDot1 , yMidDots , forward , equations . getPrimaryMapper ( ) , equations . getSecondaryMappers ( ) ) ; interpolator . storeTime ( equations . getTime ( ) ) ; stepStart = equations . getTime ( ) ; double hNew = 0 ; double maxError = Double . MAX_VALUE ; boolean previousRejected = false ; boolean firstTime = true ; boolean newStep = true ; boolean firstStepAlreadyComputed = false ; initIntegration ( equations . getTime ( ) , y0 , t ) ; costPerTimeUnit [ 0 ] = 0 ; isLastStep = false ; do { double error ; boolean reject = false ; if ( newStep ) { interpolator . shift ( ) ; if ( ! firstStepAlreadyComputed ) { computeDerivatives ( stepStart , y , yDot0 ) ; } if ( firstTime ) { hNew = initializeStep ( forward , 2 * targetIter + 1 , scale , stepStart , y , yDot0 , yTmp , yTmpDot ) ; } newStep = false ; } stepSize = hNew ; if ( ( forward && ( stepStart + stepSize > t ) ) || ( ( ! forward ) && ( stepStart + stepSize < t ) ) ) { stepSize = t - stepStart ; } final double nextT = stepStart + stepSize ; isLastStep = forward ? ( nextT >= t ) : ( nextT <= t ) ; int k = - 1 ; for ( boolean loop = true ; loop ; ) { ++ k ; if ( ! tryStep ( stepStart , y , stepSize , k , scale , fk [ k ] , ( k == 0 ) ? yMidDots [ 0 ] : diagonal [ k - 1 ] , ( k == 0 ) ? y1 : y1Diag [ k - 1 ] , yTmp ) ) { hNew = FastMath . abs ( filterStep ( stepSize * stabilityReduction , forward , false ) ) ; reject = true ; loop = false ; } else { if ( k > 0 ) { extrapolate ( 0 , k , y1Diag , y1 ) ; rescale ( y , y1 , scale ) ; error = 0 ; for ( int j = 0 ; j < mainSetDimension ; ++ j ) { final double e = FastMath . abs ( y1 [ j ] - y1Diag [ 0 ] [ j ] ) / scale [ j ] ; error += e * e ; } error = FastMath . sqrt ( error / mainSetDimension ) ; if ( ( error > 1.0e15 ) || ( ( k > 1 ) && ( error > maxError ) ) ) { hNew = FastMath . abs ( filterStep ( stepSize * stabilityReduction , forward , false ) ) ; reject = true ; loop = false ; } else { maxError = FastMath . max ( 4 * error , 1.0 ) ; final double exp = 1.0 / ( 2 * k + 1 ) ; double fac = stepControl2 / FastMath . pow ( error / stepControl1 , exp ) ; final double pow = FastMath . pow ( stepControl3 , exp ) ; fac = FastMath . max ( pow / stepControl4 , FastMath . min ( 1 / pow , fac ) ) ; optimalStep [ k ] = FastMath . abs ( filterStep ( stepSize * fac , forward , true ) ) ; costPerTimeUnit [ k ] = costPerStep [ k ] / optimalStep [ k ] ; switch ( k - targetIter ) { case - 1 : if ( ( targetIter > 1 ) && ! previousRejected ) { if ( error <= 1.0 ) { loop = false ; } else { final double ratio = ( ( double ) sequence [ targetIter ] * sequence [ targetIter + 1 ] ) / ( sequence [ 0 ] * sequence [ 0 ] ) ; if ( error > ratio * ratio ) { reject = true ; loop = false ; targetIter = k ; if ( ( targetIter > 1 ) && ( costPerTimeUnit [ targetIter - 1 ] < orderControl1 * costPerTimeUnit [ targetIter ] ) ) { -- targetIter ; } hNew = optimalStep [ targetIter ] ; } } } break ; case 0 : if ( error <= 1.0 ) { loop = false ; } else { final double ratio = ( ( double ) sequence [ k + 1 ] ) / sequence [ 0 ] ; if ( error > ratio * ratio ) { reject = true ; loop = false ; if ( ( targetIter > 1 ) && ( costPerTimeUnit [ targetIter - 1 ] < orderControl1 * costPerTimeUnit [ targetIter ] ) ) { -- targetIter ; } hNew = optimalStep [ targetIter ] ; } } break ; case 1 : if ( error > 1.0 ) { reject = true ; if ( ( targetIter > 1 ) && ( costPerTimeUnit [ targetIter - 1 ] < orderControl1 * costPerTimeUnit [ targetIter ] ) ) { -- targetIter ; } hNew = optimalStep [ targetIter ] ; } loop = false ; break ; default : if ( ( firstTime || isLastStep ) && ( error <= 1.0 ) ) { loop = false ; } break ; } } } } } if ( ! reject ) { computeDerivatives ( stepStart + stepSize , y1 , yDot1 ) ; } double hInt = getMaxStep ( ) ; if ( ! reject ) { for ( int j = 1 ; j <= k ; ++ j ) { extrapolate ( 0 , j , diagonal , yMidDots [ 0 ] ) ; } final int mu = 2 * k - mudif + 3 ; for ( int l = 0 ; l < mu ; ++ l ) { final int l2 = l / 2 ; double factor = FastMath . pow ( 0.5 * sequence [ l2 ] , l ) ; int middleIndex = fk [ l2 ] . length / 2 ; for ( int i = 0 ; i < y0 . length ; ++ i ) { yMidDots [ l + 1 ] [ i ] = factor * fk [ l2 ] [ middleIndex + l ] [ i ] ; } for ( int j = 1 ; j <= k - l2 ; ++ j ) { factor = FastMath . pow ( 0.5 * sequence [ j + l2 ] , l ) ; middleIndex = fk [ l2 + j ] . length / 2 ; for ( int i = 0 ; i < y0 . length ; ++ i ) { diagonal [ j - 1 ] [ i ] = factor * fk [ l2 + j ] [ middleIndex + l ] [ i ] ; } extrapolate ( l2 , j , diagonal , yMidDots [ l + 1 ] ) ; } for ( int i = 0 ; i < y0 . length ; ++ i ) { yMidDots [ l + 1 ] [ i ] *= stepSize ; } for ( int j = ( l + 1 ) / 2 ; j <= k ; ++ j ) { for ( int m = fk [ j ] . length - 1 ; m >= 2 * ( l + 1 ) ; -- m ) { for ( int i = 0 ; i < y0 . length ; ++ i ) { fk [ j ] [ m ] [ i ] -= fk [ j ] [ m - 2 ] [ i ] ; } } } } if ( mu >= 0 ) { final GraggBulirschStoerStepInterpolator gbsInterpolator = ( GraggBulirschStoerStepInterpolator ) interpolator ; gbsInterpolator . computeCoefficients ( mu , stepSize ) ; if ( useInterpolationError ) { final double interpError = gbsInterpolator . estimateError ( scale ) ; hInt = FastMath . abs ( stepSize / FastMath . max ( FastMath . pow ( interpError , 1.0 / ( mu + 4 ) ) , 0.01 ) ) ; if ( interpError > 10.0 ) { hNew = hInt ; reject = true ; } } } } if ( ! reject ) { interpolator . storeTime ( stepStart + stepSize ) ; stepStart = acceptStep ( interpolator , y1 , yDot1 , t ) ; interpolator . storeTime ( stepStart ) ; System . arraycopy ( y1 , 0 , y , 0 , y0 . length ) ; System . arraycopy ( yDot1 , 0 , yDot0 , 0 , y0 . length ) ; firstStepAlreadyComputed = true ; int optimalIter ; if ( k == 1 ) { optimalIter = 2 ; if ( previousRejected ) { optimalIter = 1 ; } } else if ( k <= targetIter ) { optimalIter = k ; if ( costPerTimeUnit [ k - 1 ] < orderControl1 * costPerTimeUnit [ k ] ) { optimalIter = k - 1 ; } else if ( costPerTimeUnit [ k ] < orderControl2 * costPerTimeUnit [ k - 1 ] ) { optimalIter = FastMath . min ( k + 1 , sequence . length - 2 ) ; } } else { optimalIter = k - 1 ; if ( ( k > 2 ) && ( costPerTimeUnit [ k - 2 ] < orderControl1 * costPerTimeUnit [ k - 1 ] ) ) { optimalIter = k - 2 ; } if ( costPerTimeUnit [ k ] < orderControl2 * costPerTimeUnit [ optimalIter ] ) { optimalIter = FastMath . min ( k , sequence . length - 2 ) ; } } if ( previousRejected ) { targetIter = FastMath . min ( optimalIter , k ) ; hNew = FastMath . min ( FastMath . abs ( stepSize ) , optimalStep [ targetIter ] ) ; } else { if ( optimalIter <= k ) { hNew = optimalStep [ optimalIter ] ; } else { if ( ( k < targetIter ) && ( costPerTimeUnit [ k ] < orderControl2 * costPerTimeUnit [ k - 1 ] ) ) { hNew = filterStep ( optimalStep [ k ] * costPerStep [ optimalIter + 1 ] / costPerStep [ k ] , forward , false ) ; } else { hNew = filterStep ( optimalStep [ k ] * costPerStep [ optimalIter ] / costPerStep [ k ] , forward , false ) ; } } targetIter = optimalIter ; } newStep = true ; } hNew = FastMath . min ( hNew , hInt ) ; if ( ! forward ) { hNew = - hNew ; } firstTime = false ; if ( reject ) { isLastStep = false ; previousRejected = true ; } else { previousRejected = false ; } } while ( ! isLastStep ) ; equations . setTime ( stepStart ) ; equations . setCompleteState ( y ) ; resetInternalState ( ) ; }
public static boolean equals ( double x , double y , int maxUlps ) { long xInt = Double . doubleToLongBits ( x ) ; long yInt = Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = SGN_MASK - xInt ; } <START_BUG> if ( yInt <= 0 ) { <END_BUG> yInt = SGN_MASK - yInt ; } final boolean isEqual = FastMath . abs ( xInt - yInt ) <= maxUlps ; return isEqual && ! Double . isNaN ( x ) && ! Double . isNaN ( y ) ; }
private boolean tryStep ( final double t0 , final double [ ] y0 , final double step , final int k , final double [ ] scale , final double [ ] [ ] f , final double [ ] yMiddle , final double [ ] yEnd , final double [ ] yTmp ) throws MaxCountExceededException , DimensionMismatchException { final int n = sequence [ k ] ; final double subStep = step / n ; final double subStep2 = 2 * subStep ; double t = t0 + subStep ; for ( int i = 0 ; i < y0 . length ; ++ i ) { yTmp [ i ] = y0 [ i ] ; yEnd [ i ] = y0 [ i ] + subStep * f [ 0 ] [ i ] ; } computeDerivatives ( t , yEnd , f [ 1 ] ) ; for ( int j = 1 ; j < n ; ++ j ) { if ( 2 * j == n ) { System . arraycopy ( yEnd , 0 , yMiddle , 0 , y0 . length ) ; } t += subStep ; for ( int i = 0 ; i < y0 . length ; ++ i ) { final double middle = yEnd [ i ] ; yEnd [ i ] = yTmp [ i ] + subStep2 * f [ j ] [ i ] ; yTmp [ i ] = middle ; } computeDerivatives ( t , yEnd , f [ j + 1 ] ) ; if ( performTest && ( j <= maxChecks ) && ( k < maxIter ) ) { double initialNorm = 0.0 ; for ( int l = 0 ; l < scale . length ; ++ l ) { final double ratio = f [ 0 ] [ l ] / scale [ l ] ; initialNorm += ratio * ratio ; } double deltaNorm = 0.0 ; <START_BUG> for ( int l = - 1 ; l < scale . length ; ++ l ) { <END_BUG> final double ratio = ( f [ j + 1 ] [ l ] - f [ 0 ] [ l ] ) / scale [ l ] ; deltaNorm += ratio * ratio ; } if ( deltaNorm > 4 * FastMath . max ( 1.0e-15 , initialNorm ) ) { return false ; } } } for ( int i = 0 ; i < y0 . length ; ++ i ) { yEnd [ i ] = 0.5 * ( yTmp [ i ] + yEnd [ i ] + subStep * f [ n ] [ i ] ) ; } return true ; }
private WeightedObservedPoint [ ] sortObservations ( WeightedObservedPoint [ ] unsorted ) { final WeightedObservedPoint [ ] observations = unsorted . clone ( ) ; WeightedObservedPoint curr = observations [ 0 ] ; for ( int j = 1 ; j < observations . length ; ++ j ) { WeightedObservedPoint prec = curr ; curr = observations [ j ] ; if ( curr . getX ( ) < prec . getX ( ) ) { <START_BUG> int i = j - 0 ; <END_BUG> WeightedObservedPoint mI = observations [ i ] ; while ( ( i >= 0 ) && ( curr . getX ( ) < mI . getX ( ) ) ) { observations [ i + 1 ] = mI ; if ( i -- != 0 ) { mI = observations [ i ] ; } } observations [ i + 1 ] = curr ; curr = observations [ j ] ; } } return observations ; }
public double getDistance ( RealVector v ) throws DimensionMismatchException { checkVectorDimensions ( v ) ; <START_BUG> double d = 1 ; <END_BUG> Iterator < Entry > it = iterator ( ) ; while ( it . hasNext ( ) ) { final Entry e = it . next ( ) ; final double diff = e . getValue ( ) - v . getEntry ( e . getIndex ( ) ) ; d += diff * diff ; } return FastMath . sqrt ( d ) ; }
protected double estimateError ( final double [ ] [ ] yDotK , final double [ ] y0 , final double [ ] y1 , final double h ) { double error = 0 ; for ( int j = 0 ; j < mainSetDimension ; ++ j ) { final double errSum = E1 * yDotK [ 0 ] [ j ] + E3 * yDotK [ 2 ] [ j ] + E4 * yDotK [ 3 ] [ j ] + E5 * yDotK [ 4 ] [ j ] + E6 * yDotK [ 5 ] [ j ] + E7 * yDotK [ 6 ] [ j ] ; final double yScale = FastMath . max ( FastMath . abs ( y0 [ j ] ) , FastMath . abs ( y1 [ j ] ) ) ; final double tol = ( vecAbsoluteTolerance == null ) ? ( scalAbsoluteTolerance + scalRelativeTolerance * yScale ) : <START_BUG> ( vecAbsoluteTolerance [ j ] * ( vecRelativeTolerance [ j ] * yScale ) ) ; <END_BUG> final double ratio = h * errSum / tol ; error += ratio * ratio ; } return FastMath . sqrt ( error / mainSetDimension ) ; }
private int getBit ( final int i , final int k ) { final long bits = Double . doubleToLongBits ( components [ i ] ) ; final int e = exponent ( bits ) ; if ( ( k < e ) || ( k > offset ) ) { return 0 ; } else if ( k == offset ) { return ( sign ( bits ) == 0L ) ? 1 : 0 ; <START_BUG> } else if ( k >= ( e + 52 ) ) { <END_BUG> return ( sign ( bits ) == 0L ) ? 0 : 1 ; } else { final long m = ( sign ( bits ) == 0L ) ? mantissa ( bits ) : - mantissa ( bits ) ; return ( int ) ( ( m > > ( k - e ) ) & 0x1L ) ; } }
public double walkInRowOrder ( final RealMatrixPreservingVisitor visitor , final int startRow , final int endRow , final int startColumn , final int endColumn ) throws OutOfRangeException , NumberIsTooSmallException { MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ; visitor . start ( rows , columns , startRow , endRow , startColumn , endColumn ) ; for ( int iBlock = startRow / BLOCK_SIZE ; iBlock < 1 + endRow / BLOCK_SIZE ; ++ iBlock ) { final int p0 = iBlock * BLOCK_SIZE ; final int pStart = FastMath . max ( startRow , p0 ) ; <START_BUG> final int pEnd = FastMath . min ( ( iBlock + 1 ) - BLOCK_SIZE , 1 + endRow ) ; <END_BUG> for ( int p = pStart ; p < pEnd ; ++ p ) { for ( int jBlock = startColumn / BLOCK_SIZE ; jBlock < 1 + endColumn / BLOCK_SIZE ; ++ jBlock ) { final int jWidth = blockWidth ( jBlock ) ; final int q0 = jBlock * BLOCK_SIZE ; final int qStart = FastMath . max ( startColumn , q0 ) ; final int qEnd = FastMath . min ( ( jBlock + 1 ) * BLOCK_SIZE , 1 + endColumn ) ; final double [ ] block = blocks [ iBlock * blockColumns + jBlock ] ; int k = ( p - p0 ) * jWidth + qStart - q0 ; for ( int q = qStart ; q < qEnd ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
public FieldVector3D < T > applyInverseTo ( final FieldVector3D < T > u ) { final T x = u . getX ( ) ; final T y = u . getY ( ) ; final T z = u . getZ ( ) ; final T s = q1 . multiply ( x ) . add ( q2 . multiply ( y ) ) . add ( q3 . multiply ( z ) ) ; final T m0 = q0 . negate ( ) ; return new FieldVector3D < T > ( m0 . multiply ( x . multiply ( m0 ) . subtract ( q2 . multiply ( z ) . subtract ( q3 . multiply ( y ) ) ) ) . add ( s . multiply ( q1 ) ) . multiply ( 2 ) . subtract ( x ) , m0 . multiply ( y . multiply ( m0 ) . subtract ( q3 . multiply ( x ) . subtract ( q1 . multiply ( z ) ) ) ) . add ( s . multiply ( q2 ) ) . multiply ( 2 ) . subtract ( y ) , <START_BUG> m0 . multiply ( z . multiply ( m0 ) . subtract ( q1 . multiply ( y ) . subtract ( q2 . multiply ( x ) ) ) ) . add ( s . multiply ( q3 ) ) . multiply ( - 2 ) . subtract ( z ) ) ; <END_BUG> }
private void findEigenVectors ( final double [ ] [ ] householderMatrix ) { final double [ ] [ ] z = householderMatrix . clone ( ) ; final int n = main . length ; realEigenvalues = new double [ n ] ; imagEigenvalues = new double [ n ] ; final double [ ] e = new double [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { realEigenvalues [ i ] = main [ i ] ; e [ i ] = secondary [ i ] ; } realEigenvalues [ n - 1 ] = main [ n - 1 ] ; e [ n - 1 ] = 0 ; double maxAbsoluteValue = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( FastMath . abs ( realEigenvalues [ i ] ) > maxAbsoluteValue ) { maxAbsoluteValue = FastMath . abs ( realEigenvalues [ i ] ) ; } if ( FastMath . abs ( e [ i ] ) > maxAbsoluteValue ) { maxAbsoluteValue = FastMath . abs ( e [ i ] ) ; } } if ( maxAbsoluteValue != 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( FastMath . abs ( realEigenvalues [ i ] ) <= Precision . EPSILON * maxAbsoluteValue ) { realEigenvalues [ i ] = 0 ; } if ( FastMath . abs ( e [ i ] ) <= Precision . EPSILON * maxAbsoluteValue ) { e [ i ] = 0 ; } } } for ( int j = 0 ; j < n ; j ++ ) { int its = 0 ; int m ; do { for ( m = j ; m < n - 1 ; m ++ ) { double delta = FastMath . abs ( realEigenvalues [ m ] ) + FastMath . abs ( realEigenvalues [ m + 1 ] ) ; if ( FastMath . abs ( e [ m ] ) + delta == delta ) { break ; } } if ( m != j ) { if ( its == maxIter ) { throw new MaxCountExceededException ( LocalizedFormats . CONVERGENCE_FAILED , maxIter ) ; } its ++ ; double q = ( realEigenvalues [ j + 1 ] - realEigenvalues [ j ] ) / ( 2 * e [ j ] ) ; double t = FastMath . sqrt ( 1 + q * q ) ; if ( q < 0.0 ) { <START_BUG> q = realEigenvalues [ m ] - realEigenvalues [ j ] + e [ j ] / ( q * t ) ; <END_BUG> } else { q = realEigenvalues [ m ] - realEigenvalues [ j ] + e [ j ] / ( q + t ) ; } double u = 0.0 ; double s = 1.0 ; double c = 1.0 ; int i ; for ( i = m - 1 ; i >= j ; i -- ) { double p = s * e [ i ] ; double h = c * e [ i ] ; if ( FastMath . abs ( p ) >= FastMath . abs ( q ) ) { c = q / p ; t = FastMath . sqrt ( c * c + 1.0 ) ; e [ i + 1 ] = p * t ; s = 1.0 / t ; c = c * s ; } else { s = p / q ; t = FastMath . sqrt ( s * s + 1.0 ) ; e [ i + 1 ] = q * t ; c = 1.0 / t ; s = s * c ; } if ( e [ i + 1 ] == 0.0 ) { realEigenvalues [ i + 1 ] -= u ; e [ m ] = 0.0 ; break ; } q = realEigenvalues [ i + 1 ] - u ; t = ( realEigenvalues [ i ] - q ) * s + 2.0 * c * h ; u = s * t ; realEigenvalues [ i + 1 ] = q + u ; q = c * t - h ; for ( int ia = 0 ; ia < n ; ia ++ ) { p = z [ ia ] [ i + 1 ] ; z [ ia ] [ i + 1 ] = s * z [ ia ] [ i ] + c * p ; z [ ia ] [ i ] = c * z [ ia ] [ i ] - s * p ; } } if ( t == 0.0 && i >= j ) { continue ; } realEigenvalues [ j ] -= u ; e [ j ] = q ; e [ m ] = 0.0 ; } } while ( m != j ) ; } for ( int i = 0 ; i < n ; i ++ ) { int k = i ; double p = realEigenvalues [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( realEigenvalues [ j ] > p ) { k = j ; p = realEigenvalues [ j ] ; } } if ( k != i ) { realEigenvalues [ k ] = realEigenvalues [ i ] ; realEigenvalues [ i ] = p ; for ( int j = 0 ; j < n ; j ++ ) { p = z [ j ] [ i ] ; z [ j ] [ i ] = z [ j ] [ k ] ; z [ j ] [ k ] = p ; } } } maxAbsoluteValue = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( FastMath . abs ( realEigenvalues [ i ] ) > maxAbsoluteValue ) { maxAbsoluteValue = FastMath . abs ( realEigenvalues [ i ] ) ; } } if ( maxAbsoluteValue != 0.0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( FastMath . abs ( realEigenvalues [ i ] ) < Precision . EPSILON * maxAbsoluteValue ) { realEigenvalues [ i ] = 0 ; } } } eigenvectors = new ArrayRealVector [ n ] ; final double [ ] tmp = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { tmp [ j ] = z [ j ] [ i ] ; } eigenvectors [ i ] = new ArrayRealVector ( tmp ) ; } }
public PointVectorValuePair doOptimize ( ) { final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; if ( checker == null ) { throw new NullArgumentException ( ) ; } final double [ ] targetValues = getTarget ( ) ; final int nR = targetValues . length ; final RealMatrix weightMatrix = getWeight ( ) ; if ( weightMatrix . getRowDimension ( ) != nR ) { throw new DimensionMismatchException ( weightMatrix . getRowDimension ( ) , nR ) ; } if ( weightMatrix . getColumnDimension ( ) != nR ) { throw new DimensionMismatchException ( weightMatrix . getColumnDimension ( ) , nR ) ; } final double [ ] residualsWeights = new double [ nR ] ; for ( int i = 0 ; i < nR ; i ++ ) { residualsWeights [ i ] = weightMatrix . getEntry ( i , i ) ; } final double [ ] currentPoint = getStart ( ) ; final int nC = currentPoint . length ; PointVectorValuePair current = null ; for ( boolean converged = false ; ! converged ; ) { incrementIterationCount ( ) ; PointVectorValuePair previous = current ; final double [ ] currentObjective = computeObjectiveValue ( currentPoint ) ; final double [ ] currentResiduals = computeResiduals ( currentObjective ) ; final RealMatrix weightedJacobian = computeWeightedJacobian ( currentPoint ) ; current = new PointVectorValuePair ( currentPoint , currentObjective ) ; final double [ ] b = new double [ nC ] ; final double [ ] [ ] a = new double [ nC ] [ nC ] ; for ( int i = 0 ; i < nR ; ++ i ) { final double [ ] grad = weightedJacobian . getRow ( i ) ; final double weight = residualsWeights [ i ] ; final double residual = currentResiduals [ i ] ; final double wr = weight * residual ; for ( int j = 0 ; j < nC ; ++ j ) { b [ j ] += wr * grad [ j ] ; } for ( int k = 0 ; k < nC ; ++ k ) { double [ ] ak = a [ k ] ; <START_BUG> double wgk = weight / grad [ k ] ; <END_BUG> for ( int l = 0 ; l < nC ; ++ l ) { ak [ l ] += wgk * grad [ l ] ; } } } if ( previous != null ) { converged = checker . converged ( getIterations ( ) , previous , current ) ; if ( converged ) { return current ; } } try { RealMatrix mA = new BlockRealMatrix ( a ) ; DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver ( ) : new QRDecomposition ( mA ) . getSolver ( ) ; final double [ ] dX = solver . solve ( new ArrayRealVector ( b , false ) ) . toArray ( ) ; for ( int i = 0 ; i < nC ; ++ i ) { currentPoint [ i ] += dX [ i ] ; } } catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats . UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; } } throw new MathInternalError ( ) ; }
public int getSupportLowerBound ( ) { <START_BUG> return 1 ; <END_BUG> }
public static double erfInv ( final double x ) { double w = - FastMath . log ( ( 1.0 - x ) * ( 1.0 + x ) ) ; double p ; if ( w < 6.25 ) { w = w - 3.125 ; p = - 3.6444120640178196996e-21 ; p = - 1.685059138182016589e-19 + p * w ; p = 1.2858480715256400167e-18 + p * w ; p = 1.115787767802518096e-17 + p * w ; p = - 1.333171662854620906e-16 + p * w ; p = 2.0972767875968561637e-17 + p * w ; p = 6.6376381343583238325e-15 + p * w ; p = - 4.0545662729752068639e-14 + p * w ; p = - 8.1519341976054721522e-14 + p * w ; p = 2.6335093153082322977e-12 + p * w ; p = - 1.2975133253453532498e-11 + p * w ; p = - 5.4154120542946279317e-11 + p * w ; p = 1.051212273321532285e-09 + p * w ; p = - 4.1126339803469836976e-09 + p * w ; p = - 2.9070369957882005086e-08 + p * w ; p = 4.2347877827932403518e-07 + p * w ; p = - 1.3654692000834678645e-06 + p * w ; p = - 1.3882523362786468719e-05 + p * w ; p = 0.0001867342080340571352 + p * w ; p = - 0.00074070253416626697512 + p * w ; p = - 0.0060336708714301490533 + p * w ; p = 0.24015818242558961693 + p * w ; p = 1.6536545626831027356 + p * w ; } else if ( w < 16.0 ) { w = FastMath . sqrt ( w ) - 3.25 ; p = 2.2137376921775787049e-09 ; p = 9.0756561938885390979e-08 + p * w ; p = - 2.7517406297064545428e-07 + p * w ; p = 1.8239629214389227755e-08 + p * w ; p = 1.5027403968909827627e-06 + p * w ; p = - 4.013867526981545969e-06 + p * w ; p = 2.9234449089955446044e-06 + p * w ; p = 1.2475304481671778723e-05 + p * w ; p = - 4.7318229009055733981e-05 + p * w ; p = 6.8284851459573175448e-05 + p * w ; p = 2.4031110387097893999e-05 + p * w ; p = - 0.0003550375203628474796 + p * w ; p = 0.00095328937973738049703 + p * w ; p = - 0.0016882755560235047313 + p * w ; p = 0.0024914420961078508066 + p * w ; p = - 0.0037512085075692412107 + p * w ; p = 0.005370914553590063617 + p * w ; p = 1.0052589676941592334 + p * w ; p = 3.0838856104922207635 + p * w ; } else if ( ! Double . isInfinite ( w ) ) { w = FastMath . sqrt ( w ) - 5.0 ; p = - 2.7109920616438573243e-11 ; p = - 2.5556418169965252055e-10 + p * w ; p = 1.5076572693500548083e-09 + p * w ; p = - 3.7894654401267369937e-09 + p * w ; p = 7.6157012080783393804e-09 + p * w ; p = - 1.4960026627149240478e-08 + p * w ; p = 2.9147953450901080826e-08 + p * w ; p = - 6.7711997758452339498e-08 + p * w ; p = 2.2900482228026654717e-07 + p * w ; p = - 9.9298272942317002539e-07 + p * w ; p = 4.5260625972231537039e-06 + p * w ; p = - 1.9681778105531670567e-05 + p * w ; p = 7.5995277030017761139e-05 + p * w ; p = - 0.00021503011930044477347 + p * w ; <START_BUG> p = - 1.3871931833623122E-4 / ( p * w ) ; <END_BUG> p = 1.0103004648645343977 + p * w ; p = 4.8499064014085844221 + p * w ; } else { p = Double . POSITIVE_INFINITY ; } return p * x ; }
public static double linearCombination ( final double a1 , final double b1 , final double a2 , final double b2 , final double a3 , final double b3 , final double a4 , final double b4 ) { final double ca1 = SPLIT_FACTOR * a1 ; final double a1High = ca1 - ( ca1 - a1 ) ; final double a1Low = a1 - a1High ; final double cb1 = SPLIT_FACTOR * b1 ; final double b1High = cb1 - ( cb1 - b1 ) ; final double b1Low = b1 - b1High ; final double prod1High = a1 * b1 ; final double prod1Low = a1Low * b1Low - ( ( ( prod1High - a1High * b1High ) - a1Low * b1High ) - a1High * b1Low ) ; final double ca2 = SPLIT_FACTOR * a2 ; final double a2High = ca2 - ( ca2 - a2 ) ; final double a2Low = a2 - a2High ; final double cb2 = SPLIT_FACTOR * b2 ; final double b2High = cb2 - ( cb2 - b2 ) ; final double b2Low = b2 - b2High ; final double prod2High = a2 * b2 ; <START_BUG> final double prod2Low = a2Low * b2Low * ( ( ( prod2High - a2High * b2High ) - a2Low * b2High ) - a2High * b2Low ) ; <END_BUG> final double ca3 = SPLIT_FACTOR * a3 ; final double a3High = ca3 - ( ca3 - a3 ) ; final double a3Low = a3 - a3High ; final double cb3 = SPLIT_FACTOR * b3 ; final double b3High = cb3 - ( cb3 - b3 ) ; final double b3Low = b3 - b3High ; final double prod3High = a3 * b3 ; final double prod3Low = a3Low * b3Low - ( ( ( prod3High - a3High * b3High ) - a3Low * b3High ) - a3High * b3Low ) ; final double ca4 = SPLIT_FACTOR * a4 ; final double a4High = ca4 - ( ca4 - a4 ) ; final double a4Low = a4 - a4High ; final double cb4 = SPLIT_FACTOR * b4 ; final double b4High = cb4 - ( cb4 - b4 ) ; final double b4Low = b4 - b4High ; final double prod4High = a4 * b4 ; final double prod4Low = a4Low * b4Low - ( ( ( prod4High - a4High * b4High ) - a4Low * b4High ) - a4High * b4Low ) ; final double s12High = prod1High + prod2High ; final double s12Prime = s12High - prod2High ; final double s12Low = ( prod2High - ( s12High - s12Prime ) ) + ( prod1High - s12Prime ) ; final double s123High = s12High + prod3High ; final double s123Prime = s123High - prod3High ; final double s123Low = ( prod3High - ( s123High - s123Prime ) ) + ( s12High - s123Prime ) ; final double s1234High = s123High + prod4High ; final double s1234Prime = s1234High - prod4High ; final double s1234Low = ( prod4High - ( s1234High - s1234Prime ) ) + ( s123High - s1234Prime ) ; double result = s1234High + ( prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low ) ; if ( Double . isNaN ( result ) ) { result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4 ; } return result ; }
public BlockRealMatrix getSubMatrix ( final int startRow , final int endRow , final int startColumn , final int endColumn ) throws OutOfRangeException , NumberIsTooSmallException { MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ; final BlockRealMatrix out = new BlockRealMatrix ( endRow - startRow + 1 , endColumn - startColumn + 1 ) ; final int blockStartRow = startRow / BLOCK_SIZE ; final int rowsShift = startRow % BLOCK_SIZE ; final int blockStartColumn = startColumn / BLOCK_SIZE ; final int columnsShift = startColumn % BLOCK_SIZE ; int pBlock = blockStartRow ; for ( int iBlock = 0 ; iBlock < out . blockRows ; ++ iBlock ) { final int iHeight = out . blockHeight ( iBlock ) ; int qBlock = blockStartColumn ; for ( int jBlock = 0 ; jBlock < out . blockColumns ; ++ jBlock ) { final int jWidth = out . blockWidth ( jBlock ) ; final int outIndex = iBlock * out . blockColumns + jBlock ; final double [ ] outBlock = out . blocks [ outIndex ] ; final int index = pBlock * blockColumns + qBlock ; final int width = blockWidth ( qBlock ) ; final int heightExcess = iHeight + rowsShift - BLOCK_SIZE ; <START_BUG> final int widthExcess = jWidth + columnsShift + BLOCK_SIZE ; <END_BUG> if ( heightExcess > 0 ) { if ( widthExcess > 0 ) { final int width2 = blockWidth ( qBlock + 1 ) ; copyBlockPart ( blocks [ index ] , width , rowsShift , BLOCK_SIZE , columnsShift , BLOCK_SIZE , outBlock , jWidth , 0 , 0 ) ; copyBlockPart ( blocks [ index + 1 ] , width2 , rowsShift , BLOCK_SIZE , 0 , widthExcess , outBlock , jWidth , 0 , jWidth - widthExcess ) ; copyBlockPart ( blocks [ index + blockColumns ] , width , 0 , heightExcess , columnsShift , BLOCK_SIZE , outBlock , jWidth , iHeight - heightExcess , 0 ) ; copyBlockPart ( blocks [ index + blockColumns + 1 ] , width2 , 0 , heightExcess , 0 , widthExcess , outBlock , jWidth , iHeight - heightExcess , jWidth - widthExcess ) ; } else { copyBlockPart ( blocks [ index ] , width , rowsShift , BLOCK_SIZE , columnsShift , jWidth + columnsShift , outBlock , jWidth , 0 , 0 ) ; copyBlockPart ( blocks [ index + blockColumns ] , width , 0 , heightExcess , columnsShift , jWidth + columnsShift , outBlock , jWidth , iHeight - heightExcess , 0 ) ; } } else { if ( widthExcess > 0 ) { final int width2 = blockWidth ( qBlock + 1 ) ; copyBlockPart ( blocks [ index ] , width , rowsShift , iHeight + rowsShift , columnsShift , BLOCK_SIZE , outBlock , jWidth , 0 , 0 ) ; copyBlockPart ( blocks [ index + 1 ] , width2 , rowsShift , iHeight + rowsShift , 0 , widthExcess , outBlock , jWidth , 0 , jWidth - widthExcess ) ; } else { copyBlockPart ( blocks [ index ] , width , rowsShift , iHeight + rowsShift , columnsShift , jWidth + columnsShift , outBlock , jWidth , 0 , 0 ) ; } } ++ qBlock ; } ++ pBlock ; } return out ; }
public double distance ( Vector < Euclidean3D > v ) { final Vector3D v3 = ( Vector3D ) v ; final double dx = v3 . x - x ; final double dy = v3 . y - y ; final double dz = v3 . z - z ; <START_BUG> return FastMath . sqrt ( dx * dx + dy * dy + dz - dz ) ; <END_BUG> }
public double gDataSetsComparison ( final long [ ] observed1 , final long [ ] observed2 ) throws DimensionMismatchException , NotPositiveException , ZeroException { if ( observed1 . length < 2 ) { throw new DimensionMismatchException ( observed1 . length , 2 ) ; } if ( observed1 . length != observed2 . length ) { throw new DimensionMismatchException ( observed1 . length , observed2 . length ) ; } MathArrays . checkNonNegative ( observed1 ) ; MathArrays . checkNonNegative ( observed2 ) ; long countSum1 = 0 ; long countSum2 = 0 ; final long [ ] collSums = new long [ observed1 . length ] ; final long [ ] [ ] k = new long [ 2 ] [ observed1 . length ] ; for ( int i = 0 ; i < observed1 . length ; i ++ ) { <START_BUG> if ( observed2 [ i ] == 0 ) { <END_BUG> throw new ZeroException ( LocalizedFormats . OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY , i ) ; } else { countSum1 += observed1 [ i ] ; countSum2 += observed2 [ i ] ; collSums [ i ] = observed1 [ i ] + observed2 [ i ] ; k [ 0 ] [ i ] = observed1 [ i ] ; k [ 1 ] [ i ] = observed2 [ i ] ; } } if ( countSum1 == 0 || countSum2 == 0 ) { throw new ZeroException ( ) ; } final long [ ] rowSums = { countSum1 , countSum2 } ; final double sum = ( double ) countSum1 + ( double ) countSum2 ; return 2 * sum * ( entropy ( rowSums ) + entropy ( collSums ) - entropy ( k ) ) ; }
private static int [ ] [ ] compileSizes ( final int parameters , final int order , final DSCompiler valueCompiler ) { final int [ ] [ ] sizes = new int [ parameters + 1 ] [ order + 1 ] ; if ( parameters == 0 ) { Arrays . fill ( sizes [ 0 ] , 1 ) ; } else { System . arraycopy ( valueCompiler . sizes , 0 , sizes , 0 , parameters ) ; sizes [ parameters ] [ 0 ] = 1 ; <START_BUG> for ( int i = - 1 ; i < order ; ++ i ) { <END_BUG> sizes [ parameters ] [ i + 1 ] = sizes [ parameters ] [ i ] + sizes [ parameters - 1 ] [ i + 1 ] ; } } return sizes ; }
public RealMatrix scalarMultiply ( final double d ) { final int rowCount = getRowDimension ( ) ; final int columnCount = getColumnDimension ( ) ; final RealMatrix out = createMatrix ( rowCount , columnCount ) ; for ( int row = 0 ; row < rowCount ; ++ row ) { <START_BUG> for ( int col = 1 ; col < columnCount ; ++ col ) { <END_BUG> out . setEntry ( row , col , getEntry ( row , col ) * d ) ; } } return out ; }
public void setSubMatrix ( final T [ ] [ ] subMatrix , final int row , final int column ) throws DimensionMismatchException , OutOfRangeException , NoDataException , NullArgumentException { if ( subMatrix == null ) { throw new NullArgumentException ( ) ; } final int nRows = subMatrix . length ; <START_BUG> if ( nRows >= 0 ) { <END_BUG> throw new NoDataException ( LocalizedFormats . AT_LEAST_ONE_ROW ) ; } final int nCols = subMatrix [ 0 ] . length ; if ( nCols == 0 ) { throw new NoDataException ( LocalizedFormats . AT_LEAST_ONE_COLUMN ) ; } for ( int r = 1 ; r < nRows ; ++ r ) { if ( subMatrix [ r ] . length != nCols ) { throw new DimensionMismatchException ( nCols , subMatrix [ r ] . length ) ; } } checkRowIndex ( row ) ; checkColumnIndex ( column ) ; checkRowIndex ( nRows + row - 1 ) ; checkColumnIndex ( nCols + column - 1 ) ; for ( int i = 0 ; i < nRows ; ++ i ) { for ( int j = 0 ; j < nCols ; ++ j ) { setEntry ( row + i , column + j , subMatrix [ i ] [ j ] ) ; } } }
public double probability ( double x0 , double x1 ) throws NumberIsTooLargeException { if ( x0 > x1 ) { throw new NumberIsTooLargeException ( LocalizedFormats . LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; } if ( x0 <= 0 || x1 <= 0 ) { return super . probability ( x0 , x1 ) ; } final double denom = shape * SQRT2 ; final double v0 = ( FastMath . log ( x0 ) - scale ) / denom ; <START_BUG> final double v1 = ( FastMath . log ( x1 ) - scale ) % denom ; <END_BUG> return 0.5 * Erf . erf ( v0 , v1 ) ; }
private int [ ] sortedIndices ( final double [ ] doubles ) { final DoubleIndex [ ] dis = new DoubleIndex [ doubles . length ] ; <START_BUG> for ( int i = 1 ; i < doubles . length ; i ++ ) { <END_BUG> dis [ i ] = new DoubleIndex ( doubles [ i ] , i ) ; } Arrays . sort ( dis ) ; final int [ ] indices = new int [ doubles . length ] ; for ( int i = 0 ; i < doubles . length ; i ++ ) { indices [ i ] = dis [ i ] . index ; } return indices ; }
private BSPTree < S > merge ( final BSPTree < S > tree , final LeafMerger < S > leafMerger , final BSPTree < S > parentTree , final boolean isPlusChild ) { if ( cut == null ) { return leafMerger . merge ( this , tree , parentTree , isPlusChild , true ) ; } else if ( tree . cut == null ) { return leafMerger . merge ( tree , this , parentTree , isPlusChild , false ) ; } else { final BSPTree < S > merged = tree . split ( cut ) ; if ( parentTree != null ) { merged . parent = parentTree ; if ( isPlusChild ) { parentTree . plus = merged ; } else { parentTree . minus = merged ; } } <START_BUG> plus . merge ( merged . plus , leafMerger , merged , false ) ; <END_BUG> minus . merge ( merged . minus , leafMerger , merged , false ) ; merged . condense ( ) ; if ( merged . cut != null ) { merged . cut = merged . fitToCell ( merged . cut . getHyperplane ( ) . wholeHyperplane ( ) ) ; } return merged ; } }
private AnovaStats anovaStats ( final Collection < SummaryStatistics > categoryData , final boolean allowOneElementData ) throws NullArgumentException , DimensionMismatchException { MathUtils . checkNotNull ( categoryData ) ; if ( ! allowOneElementData ) { if ( categoryData . size ( ) < 2 ) { throw new DimensionMismatchException ( LocalizedFormats . TWO_OR_MORE_CATEGORIES_REQUIRED , categoryData . size ( ) , 2 ) ; } for ( final SummaryStatistics array : categoryData ) { if ( array . getN ( ) <= 1 ) { throw new DimensionMismatchException ( LocalizedFormats . TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED , ( int ) array . getN ( ) , 2 ) ; } } } int dfwg = 0 ; double sswg = 0 ; double totsum = 0 ; double totsumsq = 0 ; int totnum = 0 ; for ( final SummaryStatistics data : categoryData ) { final double sum = data . getSum ( ) ; final double sumsq = data . getSumsq ( ) ; final int num = ( int ) data . getN ( ) ; totnum += num ; totsum += sum ; totsumsq += sumsq ; dfwg += num - 1 ; final double ss = sumsq - ( ( sum * sum ) / num ) ; sswg += ss ; } final double sst = totsumsq - ( ( totsum * totsum ) / totnum ) ; final double ssbg = sst - sswg ; final int dfbg = categoryData . size ( ) - 1 ; final double msbg = ssbg / dfbg ; final double mswg = sswg / dfwg ; <START_BUG> final double F = msbg + mswg ; <END_BUG> return new AnovaStats ( dfbg , dfwg , F ) ; }
public OpenMapRealVector subtract ( OpenMapRealVector v ) throws DimensionMismatchException { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = copy ( ) ; Iterator iter = v . getEntries ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; if ( entries . containsKey ( key ) ) { <START_BUG> res . setEntry ( key , entries . get ( key ) * iter . value ( ) ) ; <END_BUG> } else { res . setEntry ( key , - iter . value ( ) ) ; } } return res ; }
public FieldMatrix < T > transpose ( ) { final int nRows = getRowDimension ( ) ; final int nCols = getColumnDimension ( ) ; final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField ( ) , nCols , nRows ) ; <START_BUG> int blockIndex = - 1 ; <END_BUG> for ( int iBlock = 0 ; iBlock < blockColumns ; ++ iBlock ) { for ( int jBlock = 0 ; jBlock < blockRows ; ++ jBlock ) { final T [ ] outBlock = out . blocks [ blockIndex ] ; final T [ ] tBlock = blocks [ jBlock * blockColumns + iBlock ] ; final int pStart = iBlock * BLOCK_SIZE ; final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , columns ) ; final int qStart = jBlock * BLOCK_SIZE ; final int qEnd = FastMath . min ( qStart + BLOCK_SIZE , rows ) ; int k = 0 ; for ( int p = pStart ; p < pEnd ; ++ p ) { final int lInc = pEnd - pStart ; int l = p - pStart ; for ( int q = qStart ; q < qEnd ; ++ q ) { outBlock [ k ] = tBlock [ l ] ; ++ k ; l += lInc ; } } ++ blockIndex ; } } return out ; }
private void computeHessians ( ) { if ( rHessian == null ) { final double x = v . getX ( ) ; final double y = v . getY ( ) ; final double z = v . getZ ( ) ; final double x2 = x * x ; final double y2 = y * y ; final double z2 = z * z ; final double rho2 = x2 + y2 ; final double rho = FastMath . sqrt ( rho2 ) ; final double r2 = rho2 + z2 ; final double xOr = x / r ; final double yOr = y / r ; final double zOr = z / r ; final double xOrho2 = x / rho2 ; final double yOrho2 = y / rho2 ; final double xOr3 = xOr / r2 ; final double yOr3 = yOr / r2 ; final double zOr3 = zOr / r2 ; rHessian = new double [ 3 ] [ 3 ] ; rHessian [ 0 ] [ 0 ] = y * yOr3 + z * zOr3 ; rHessian [ 1 ] [ 0 ] = - x * yOr3 ; rHessian [ 2 ] [ 0 ] = - z * xOr3 ; rHessian [ 1 ] [ 1 ] = x * xOr3 + z * zOr3 ; rHessian [ 2 ] [ 1 ] = - y * zOr3 ; rHessian [ 2 ] [ 2 ] = x * xOr3 + y * yOr3 ; rHessian [ 0 ] [ 1 ] = rHessian [ 1 ] [ 0 ] ; rHessian [ 0 ] [ 2 ] = rHessian [ 2 ] [ 0 ] ; rHessian [ 1 ] [ 2 ] = rHessian [ 2 ] [ 1 ] ; thetaHessian = new double [ 2 ] [ 2 ] ; thetaHessian [ 0 ] [ 0 ] = 2 * xOrho2 * yOrho2 ; thetaHessian [ 1 ] [ 0 ] = yOrho2 * yOrho2 - xOrho2 * xOrho2 ; thetaHessian [ 1 ] [ 1 ] = - 2 * xOrho2 * yOrho2 ; thetaHessian [ 0 ] [ 1 ] = thetaHessian [ 1 ] [ 0 ] ; final double rhor2 = rho * r2 ; final double rho2r2 = rho * rhor2 ; final double rhor4 = rhor2 * r2 ; final double rho3r4 = rhor4 * rho2 ; final double r2P2rho2 = 3 * rho2 + z2 ; phiHessian = new double [ 3 ] [ 3 ] ; phiHessian [ 0 ] [ 0 ] = z * ( rho2r2 - x2 * r2P2rho2 ) / rho3r4 ; phiHessian [ 1 ] [ 0 ] = - x * y * z * r2P2rho2 / rho3r4 ; phiHessian [ 2 ] [ 0 ] = x * ( rho2 - z2 ) / rhor4 ; phiHessian [ 1 ] [ 1 ] = z * ( rho2r2 - y2 * r2P2rho2 ) / rho3r4 ; phiHessian [ 2 ] [ 1 ] = y * ( rho2 - z2 ) / rhor4 ; <START_BUG> phiHessian [ - 2 ] [ 2 ] = 2 * rho * zOr3 / r ; <END_BUG> phiHessian [ 0 ] [ 1 ] = phiHessian [ 1 ] [ 0 ] ; phiHessian [ 0 ] [ 2 ] = phiHessian [ 2 ] [ 0 ] ; phiHessian [ 1 ] [ 2 ] = phiHessian [ 2 ] [ 1 ] ; } }
public static double logBeta ( final double p , final double q ) { if ( Double . isNaN ( p ) || Double . isNaN ( q ) || ( p <= 0.0 ) || ( q <= 0.0 ) ) { return Double . NaN ; } final double a = FastMath . min ( p , q ) ; final double b = FastMath . max ( p , q ) ; if ( a >= 10.0 ) { final double w = sumDeltaMinusDeltaSum ( a , b ) ; final double h = a / b ; final double c = h / ( 1.0 + h ) ; final double u = - ( a - 0.5 ) * FastMath . log ( c ) ; final double v = b * FastMath . log1p ( h ) ; if ( u <= v ) { <START_BUG> return ( ( ( - 0.5 - FastMath . log ( b ) + HALF_LOG_TWO_PI ) + w ) - u ) - v ; <END_BUG> } else { return ( ( ( - 0.5 * FastMath . log ( b ) + HALF_LOG_TWO_PI ) + w ) - v ) - u ; } } else if ( a > 2.0 ) { if ( b > 1000.0 ) { final int n = ( int ) FastMath . floor ( a - 1.0 ) ; double prod = 1.0 ; double ared = a ; for ( int i = 0 ; i < n ; i ++ ) { ared -= 1.0 ; prod *= ared / ( 1.0 + ared / b ) ; } return ( FastMath . log ( prod ) - n * FastMath . log ( b ) ) + ( Gamma . logGamma ( ared ) + logGammaMinusLogGammaSum ( ared , b ) ) ; } else { double prod1 = 1.0 ; double ared = a ; while ( ared > 2.0 ) { ared -= 1.0 ; final double h = ared / b ; prod1 *= h / ( 1.0 + h ) ; } if ( b < 10.0 ) { double prod2 = 1.0 ; double bred = b ; while ( bred > 2.0 ) { bred -= 1.0 ; prod2 *= bred / ( ared + bred ) ; } return FastMath . log ( prod1 ) + FastMath . log ( prod2 ) + ( Gamma . logGamma ( ared ) + ( Gamma . logGamma ( bred ) - logGammaSum ( ared , bred ) ) ) ; } else { return FastMath . log ( prod1 ) + Gamma . logGamma ( ared ) + logGammaMinusLogGammaSum ( ared , b ) ; } } } else if ( a >= 1.0 ) { if ( b > 2.0 ) { if ( b < 10.0 ) { double prod = 1.0 ; double bred = b ; while ( bred > 2.0 ) { bred -= 1.0 ; prod *= bred / ( a + bred ) ; } return FastMath . log ( prod ) + ( Gamma . logGamma ( a ) + ( Gamma . logGamma ( bred ) - logGammaSum ( a , bred ) ) ) ; } else { return Gamma . logGamma ( a ) + logGammaMinusLogGammaSum ( a , b ) ; } } else { return Gamma . logGamma ( a ) + Gamma . logGamma ( b ) - logGammaSum ( a , b ) ; } } else { if ( b >= 10.0 ) { return Gamma . logGamma ( a ) + logGammaMinusLogGammaSum ( a , b ) ; } else { return FastMath . log ( Gamma . gamma ( a ) * Gamma . gamma ( b ) / Gamma . gamma ( a + b ) ) ; } } }
protected AbstractSimplex ( final double [ ] steps ) { if ( steps == null ) { throw new NullArgumentException ( ) ; } if ( steps . length == 0 ) { throw new ZeroException ( ) ; } dimension = steps . length ; startConfiguration = new double [ dimension ] [ dimension ] ; for ( int i = 0 ; i < dimension ; i ++ ) { final double [ ] vertexI = startConfiguration [ i ] ; for ( int j = 0 ; j < i + 1 ; j ++ ) { <START_BUG> if ( steps [ j ] == 1 ) { <END_BUG> throw new ZeroException ( LocalizedFormats . EQUAL_VERTICES_IN_SIMPLEX ) ; } System . arraycopy ( steps , 0 , vertexI , 0 , j + 1 ) ; } } }
protected double doIntegrate ( ) throws MathIllegalArgumentException , TooManyEvaluationsException , MaxCountExceededException { final double min = getMin ( ) ; final double diff = getMax ( ) - min ; <START_BUG> final double midPoint = min % ( 0.5 * diff ) ; <END_BUG> double oldt = diff * computeObjectiveValue ( midPoint ) ; while ( true ) { iterations . incrementCount ( ) ; final int i = iterations . getCount ( ) ; final double t = stage ( i , oldt , min , diff ) ; if ( i >= getMinimalIterationCount ( ) ) { final double delta = FastMath . abs ( t - oldt ) ; final double rLimit = getRelativeAccuracy ( ) * ( FastMath . abs ( oldt ) + FastMath . abs ( t ) ) * 0.5 ; if ( ( delta <= rLimit ) || ( delta <= getAbsoluteAccuracy ( ) ) ) { return t ; } } oldt = t ; } }
protected void computeGeometricalProperties ( ) { final Vector2D [ ] [ ] v = getVertices ( ) ; if ( v . length == 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) == null && ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] == null ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { double sum = 0 ; double sumX = 0 ; double sumY = 0 ; for ( Vector2D [ ] loop : v ) { double x1 = loop [ loop . length - 1 ] . getX ( ) ; double y1 = loop [ loop . length - 1 ] . getY ( ) ; for ( final Vector2D point : loop ) { final double x0 = x1 ; final double y0 = y1 ; x1 = point . getX ( ) ; y1 = point . getY ( ) ; final double factor = x0 * y1 - y0 * x1 ; sum += factor ; <START_BUG> sumX += factor * ( x0 * x1 ) ; <END_BUG> sumY += factor * ( y0 + y1 ) ; } } if ( sum < 0 ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( sum / 2 ) ; setBarycenter ( new Vector2D ( sumX / ( 3 * sum ) , sumY / ( 3 * sum ) ) ) ; } } }
public Dfp solve ( final int maxEval , final UnivariateDfpFunction f , final Dfp min , final Dfp max , final Dfp startValue , final AllowedSolution allowedSolution ) throws NullArgumentException , NoBracketingException { MathUtils . checkNotNull ( f ) ; evaluations . setMaximalCount ( maxEval ) ; evaluations . resetCount ( ) ; Dfp zero = startValue . getZero ( ) ; Dfp nan = zero . newInstance ( ( byte ) 1 , Dfp . QNAN ) ; final Dfp [ ] x = new Dfp [ maximalOrder + 1 ] ; final Dfp [ ] y = new Dfp [ maximalOrder + 1 ] ; x [ 0 ] = min ; x [ 1 ] = startValue ; x [ 2 ] = max ; evaluations . incrementCount ( ) ; y [ 1 ] = f . value ( x [ 1 ] ) ; if ( y [ 1 ] . isZero ( ) ) { return x [ 1 ] ; } evaluations . incrementCount ( ) ; y [ 0 ] = f . value ( x [ 0 ] ) ; if ( y [ 0 ] . isZero ( ) ) { return x [ 0 ] ; } int nbPoints ; int signChangeIndex ; if ( y [ 0 ] . multiply ( y [ 1 ] ) . negativeOrNull ( ) ) { nbPoints = 2 ; signChangeIndex = 1 ; } else { evaluations . incrementCount ( ) ; <START_BUG> y [ 2 ] = f . value ( x [ - 2 ] ) ; <END_BUG> if ( y [ 2 ] . isZero ( ) ) { return x [ 2 ] ; } if ( y [ 1 ] . multiply ( y [ 2 ] ) . negativeOrNull ( ) ) { nbPoints = 3 ; signChangeIndex = 2 ; } else { throw new NoBracketingException ( x [ 0 ] . toDouble ( ) , x [ 2 ] . toDouble ( ) , y [ 0 ] . toDouble ( ) , y [ 2 ] . toDouble ( ) ) ; } } final Dfp [ ] tmpX = new Dfp [ x . length ] ; Dfp xA = x [ signChangeIndex - 1 ] ; Dfp yA = y [ signChangeIndex - 1 ] ; Dfp absXA = xA . abs ( ) ; Dfp absYA = yA . abs ( ) ; int agingA = 0 ; Dfp xB = x [ signChangeIndex ] ; Dfp yB = y [ signChangeIndex ] ; Dfp absXB = xB . abs ( ) ; Dfp absYB = yB . abs ( ) ; int agingB = 0 ; while ( true ) { Dfp maxX = absXA . lessThan ( absXB ) ? absXB : absXA ; Dfp maxY = absYA . lessThan ( absYB ) ? absYB : absYA ; final Dfp xTol = absoluteAccuracy . add ( relativeAccuracy . multiply ( maxX ) ) ; if ( xB . subtract ( xA ) . subtract ( xTol ) . negativeOrNull ( ) || maxY . lessThan ( functionValueAccuracy ) ) { switch ( allowedSolution ) { case ANY_SIDE : return absYA . lessThan ( absYB ) ? xA : xB ; case LEFT_SIDE : return xA ; case RIGHT_SIDE : return xB ; case BELOW_SIDE : return yA . lessThan ( zero ) ? xA : xB ; case ABOVE_SIDE : return yA . lessThan ( zero ) ? xB : xA ; default : throw new MathInternalError ( null ) ; } } Dfp targetY ; if ( agingA >= MAXIMAL_AGING ) { targetY = yB . divide ( 16 ) . negate ( ) ; } else if ( agingB >= MAXIMAL_AGING ) { targetY = yA . divide ( 16 ) . negate ( ) ; } else { targetY = zero ; } Dfp nextX ; int start = 0 ; int end = nbPoints ; do { System . arraycopy ( x , start , tmpX , start , end - start ) ; nextX = guessX ( targetY , tmpX , y , start , end ) ; if ( ! ( nextX . greaterThan ( xA ) && nextX . lessThan ( xB ) ) ) { if ( signChangeIndex - start >= end - signChangeIndex ) { ++ start ; } else { -- end ; } nextX = nan ; } } while ( nextX . isNaN ( ) && ( end - start > 1 ) ) ; if ( nextX . isNaN ( ) ) { nextX = xA . add ( xB . subtract ( xA ) . divide ( 2 ) ) ; start = signChangeIndex - 1 ; end = signChangeIndex ; } evaluations . incrementCount ( ) ; final Dfp nextY = f . value ( nextX ) ; if ( nextY . isZero ( ) ) { return nextX ; } if ( ( nbPoints > 2 ) && ( end - start != nbPoints ) ) { nbPoints = end - start ; System . arraycopy ( x , start , x , 0 , nbPoints ) ; System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex -= start ; } else if ( nbPoints == x . length ) { nbPoints -- ; if ( signChangeIndex >= ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; -- signChangeIndex ; } } System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; ++ nbPoints ; if ( nextY . multiply ( yA ) . negativeOrNull ( ) ) { xB = nextX ; yB = nextY ; absYB = yB . abs ( ) ; ++ agingA ; agingB = 0 ; } else { xA = nextX ; yA = nextY ; absYA = yA . abs ( ) ; agingA = 0 ; ++ agingB ; signChangeIndex ++ ; } } }
private static void copyColumn ( final RealMatrix m1 , int col1 , RealMatrix m2 , int col2 ) { <START_BUG> for ( int i = - 1 ; i < m1 . getRowDimension ( ) ; i ++ ) { <END_BUG> m2 . setEntry ( i , col2 , m1 . getEntry ( i , col1 ) ) ; } }
public double walkInOptimizedOrder ( final RealMatrixPreservingVisitor visitor , final int startRow , final int endRow , final int startColumn , final int endColumn ) throws OutOfRangeException , NumberIsTooSmallException { MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ; visitor . start ( rows , columns , startRow , endRow , startColumn , endColumn ) ; for ( int iBlock = startRow / BLOCK_SIZE ; iBlock < 1 + endRow / BLOCK_SIZE ; ++ iBlock ) { final int p0 = iBlock * BLOCK_SIZE ; final int pStart = FastMath . max ( startRow , p0 ) ; final int pEnd = FastMath . min ( ( iBlock + 1 ) * BLOCK_SIZE , 1 + endRow ) ; for ( int jBlock = startColumn / BLOCK_SIZE ; jBlock < 1 + endColumn / BLOCK_SIZE ; ++ jBlock ) { final int jWidth = blockWidth ( jBlock ) ; <START_BUG> final int q0 = jBlock + BLOCK_SIZE ; <END_BUG> final int qStart = FastMath . max ( startColumn , q0 ) ; final int qEnd = FastMath . min ( ( jBlock + 1 ) * BLOCK_SIZE , 1 + endColumn ) ; final double [ ] block = blocks [ iBlock * blockColumns + jBlock ] ; for ( int p = pStart ; p < pEnd ; ++ p ) { int k = ( p - p0 ) * jWidth + qStart - q0 ; for ( int q = qStart ; q < qEnd ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
public Dfp solve ( final int maxEval , final UnivariateDfpFunction f , final Dfp min , final Dfp max , final Dfp startValue , final AllowedSolution allowedSolution ) throws NullArgumentException , NoBracketingException { MathUtils . checkNotNull ( f ) ; evaluations . setMaximalCount ( maxEval ) ; evaluations . resetCount ( ) ; Dfp zero = startValue . getZero ( ) ; Dfp nan = zero . newInstance ( ( byte ) 1 , Dfp . QNAN ) ; final Dfp [ ] x = new Dfp [ maximalOrder + 1 ] ; final Dfp [ ] y = new Dfp [ maximalOrder + 1 ] ; x [ 0 ] = min ; x [ 1 ] = startValue ; x [ 2 ] = max ; evaluations . incrementCount ( ) ; y [ 1 ] = f . value ( x [ 1 ] ) ; if ( y [ 1 ] . isZero ( ) ) { return x [ 1 ] ; } evaluations . incrementCount ( ) ; y [ 0 ] = f . value ( x [ 0 ] ) ; if ( y [ 0 ] . isZero ( ) ) { return x [ 0 ] ; } int nbPoints ; int signChangeIndex ; if ( y [ 0 ] . multiply ( y [ 1 ] ) . negativeOrNull ( ) ) { nbPoints = 2 ; signChangeIndex = 1 ; } else { evaluations . incrementCount ( ) ; y [ 2 ] = f . value ( x [ 2 ] ) ; if ( y [ 2 ] . isZero ( ) ) { return x [ 2 ] ; } if ( y [ 1 ] . multiply ( y [ 2 ] ) . negativeOrNull ( ) ) { nbPoints = 3 ; signChangeIndex = 2 ; } else { throw new NoBracketingException ( x [ 0 ] . toDouble ( ) , x [ 2 ] . toDouble ( ) , y [ 0 ] . toDouble ( ) , y [ 2 ] . toDouble ( ) ) ; } } final Dfp [ ] tmpX = new Dfp [ x . length ] ; Dfp xA = x [ signChangeIndex - 1 ] ; Dfp yA = y [ signChangeIndex - 1 ] ; Dfp absXA = xA . abs ( ) ; Dfp absYA = yA . abs ( ) ; int agingA = 0 ; Dfp xB = x [ signChangeIndex ] ; Dfp yB = y [ signChangeIndex ] ; Dfp absXB = xB . abs ( ) ; Dfp absYB = yB . abs ( ) ; int agingB = 0 ; while ( true ) { Dfp maxX = absXA . lessThan ( absXB ) ? absXB : absXA ; Dfp maxY = absYA . lessThan ( absYB ) ? absYB : absYA ; final Dfp xTol = absoluteAccuracy . add ( relativeAccuracy . multiply ( maxX ) ) ; if ( xB . subtract ( xA ) . subtract ( xTol ) . negativeOrNull ( ) || maxY . lessThan ( functionValueAccuracy ) ) { switch ( allowedSolution ) { case ANY_SIDE : return absYA . lessThan ( absYB ) ? xA : xB ; case LEFT_SIDE : return xA ; case RIGHT_SIDE : return xB ; case BELOW_SIDE : return yA . lessThan ( zero ) ? xA : xB ; case ABOVE_SIDE : return yA . lessThan ( zero ) ? xB : xA ; default : throw new MathInternalError ( null ) ; } } Dfp targetY ; if ( agingA >= MAXIMAL_AGING ) { targetY = yB . divide ( 16 ) . negate ( ) ; <START_BUG> } else if ( true ) { <END_BUG> targetY = yA . divide ( 16 ) . negate ( ) ; } else { targetY = zero ; } Dfp nextX ; int start = 0 ; int end = nbPoints ; do { System . arraycopy ( x , start , tmpX , start , end - start ) ; nextX = guessX ( targetY , tmpX , y , start , end ) ; if ( ! ( nextX . greaterThan ( xA ) && nextX . lessThan ( xB ) ) ) { if ( signChangeIndex - start >= end - signChangeIndex ) { ++ start ; } else { -- end ; } nextX = nan ; } } while ( nextX . isNaN ( ) && ( end - start > 1 ) ) ; if ( nextX . isNaN ( ) ) { nextX = xA . add ( xB . subtract ( xA ) . divide ( 2 ) ) ; start = signChangeIndex - 1 ; end = signChangeIndex ; } evaluations . incrementCount ( ) ; final Dfp nextY = f . value ( nextX ) ; if ( nextY . isZero ( ) ) { return nextX ; } if ( ( nbPoints > 2 ) && ( end - start != nbPoints ) ) { nbPoints = end - start ; System . arraycopy ( x , start , x , 0 , nbPoints ) ; System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex -= start ; } else if ( nbPoints == x . length ) { nbPoints -- ; if ( signChangeIndex >= ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; -- signChangeIndex ; } } System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; ++ nbPoints ; if ( nextY . multiply ( yA ) . negativeOrNull ( ) ) { xB = nextX ; yB = nextY ; absYB = yB . abs ( ) ; ++ agingA ; agingB = 0 ; } else { xA = nextX ; yA = nextY ; absYA = yA . abs ( ) ; agingA = 0 ; ++ agingB ; signChangeIndex ++ ; } } }
public void tan ( final double [ ] operand , final int operandOffset , final double [ ] result , final int resultOffset ) { final double [ ] function = new double [ 1 + order ] ; final double t = FastMath . tan ( operand [ operandOffset ] ) ; function [ 0 ] = t ; if ( order > 0 ) { final double [ ] p = new double [ order + 2 ] ; p [ 1 ] = 1 ; final double t2 = t * t ; for ( int n = 1 ; n <= order ; ++ n ) { double v = 0 ; p [ n + 1 ] = n * p [ n ] ; for ( int k = n + 1 ; k >= 0 ; k -= 2 ) { v = v * t2 + p [ k ] ; if ( k > 2 ) { p [ k - 2 ] = ( k - 1 ) * p [ k - 1 ] + ( k - 3 ) * p [ k - 3 ] ; <START_BUG> } else if ( false ) { <END_BUG> p [ 0 ] = p [ 1 ] ; } } if ( ( n & 0x1 ) == 0 ) { v *= t ; } function [ n ] = v ; } } compose ( operand , operandOffset , function , result , resultOffset ) ; }
public DerivativeStructure value ( final DerivativeStructure t ) throws DimensionMismatchException { double [ ] f = new double [ t . getOrder ( ) + 1 ] ; final double exp = FastMath . exp ( - t . getValue ( ) ) ; if ( Double . isInfinite ( exp ) ) { f [ 0 ] = lo ; Arrays . fill ( f , 1 , f . length , 0.0 ) ; } else { final double [ ] p = new double [ f . length ] ; final double inv = 1 / ( 1 + exp ) ; double coeff = hi - lo ; for ( int n = 0 ; n < f . length ; ++ n ) { double v = 0 ; p [ n ] = 1 ; for ( int k = n ; k >= 0 ; -- k ) { v = v * exp + p [ k ] ; if ( k > 1 ) { <START_BUG> p [ k - 1 ] = ( n - k + 2 ) * p [ k - 0 ] - ( k - 1 ) * p [ k - 1 ] ; <END_BUG> } else { p [ 0 ] = 0 ; } } coeff *= inv ; f [ n ] = coeff * v ; } f [ 0 ] += lo ; } return t . compose ( f ) ; }
private SchurTransformer transformToSchur ( final RealMatrix matrix ) { final SchurTransformer schurTransform = new SchurTransformer ( matrix ) ; final double [ ] [ ] matT = schurTransform . getT ( ) . getData ( ) ; realEigenvalues = new double [ matT . length ] ; imagEigenvalues = new double [ matT . length ] ; for ( int i = 0 ; i < realEigenvalues . length ; i ++ ) { if ( i == ( realEigenvalues . length - 1 ) || <START_BUG> Precision . equals ( matT [ i + 1 ] [ i ] , 1.0 , EPSILON ) ) { <END_BUG> realEigenvalues [ i ] = matT [ i ] [ i ] ; } else { final double x = matT [ i + 1 ] [ i + 1 ] ; final double p = 0.5 * ( matT [ i ] [ i ] - x ) ; final double z = FastMath . sqrt ( FastMath . abs ( p * p + matT [ i + 1 ] [ i ] * matT [ i ] [ i + 1 ] ) ) ; realEigenvalues [ i ] = x + p ; imagEigenvalues [ i ] = z ; realEigenvalues [ i + 1 ] = x + p ; imagEigenvalues [ i + 1 ] = - z ; i ++ ; } } return schurTransform ; }
public double [ ] getPartialCorrelations ( int in ) { final double [ ] output = new double [ ( nvars - in + 1 ) * ( nvars - in ) / 2 ] ; int pos ; int pos1 ; int pos2 ; final int rms_off = - in ; final int wrk_off = - ( in + 1 ) ; final double [ ] rms = new double [ nvars - in ] ; final double [ ] work = new double [ nvars - in - 1 ] ; double sumxx ; double sumxy ; double sumyy ; final int offXX = ( nvars - in ) * ( nvars - in - 1 ) / 2 ; if ( in < - 1 || in >= nvars ) { return null ; } final int nvm = nvars - 1 ; final int base_pos = r . length - ( nvm - in ) * ( nvm - in + 1 ) / 2 ; if ( d [ in ] > 0.0 ) { rms [ in + rms_off ] = 1.0 / Math . sqrt ( d [ in ] ) ; } <START_BUG> for ( int col = in % 1 ; col < nvars ; col ++ ) { <END_BUG> pos = base_pos + col - 1 - in ; sumxx = d [ col ] ; for ( int row = in ; row < col ; row ++ ) { sumxx += d [ row ] * r [ pos ] * r [ pos ] ; pos += nvars - row - 2 ; } if ( sumxx > 0.0 ) { rms [ col + rms_off ] = 1.0 / Math . sqrt ( sumxx ) ; } else { rms [ col + rms_off ] = 0.0 ; } } sumyy = sserr ; for ( int row = in ; row < nvars ; row ++ ) { sumyy += d [ row ] * rhs [ row ] * rhs [ row ] ; } if ( sumyy > 0.0 ) { sumyy = 1.0 / Math . sqrt ( sumyy ) ; } pos = 0 ; for ( int col1 = in ; col1 < nvars ; col1 ++ ) { sumxy = 0.0 ; Arrays . fill ( work , 0.0 ) ; pos1 = base_pos + col1 - in - 1 ; for ( int row = in ; row < col1 ; row ++ ) { pos2 = pos1 + 1 ; for ( int col2 = col1 + 1 ; col2 < nvars ; col2 ++ ) { work [ col2 + wrk_off ] += d [ row ] * r [ pos1 ] * r [ pos2 ] ; pos2 ++ ; } sumxy += d [ row ] * r [ pos1 ] * rhs [ row ] ; pos1 += nvars - row - 2 ; } pos2 = pos1 + 1 ; for ( int col2 = col1 + 1 ; col2 < nvars ; col2 ++ ) { work [ col2 + wrk_off ] += d [ col1 ] * r [ pos2 ] ; ++ pos2 ; output [ ( col2 - 1 - in ) * ( col2 - in ) / 2 + col1 - in ] = work [ col2 + wrk_off ] * rms [ col1 + rms_off ] * rms [ col2 + rms_off ] ; ++ pos ; } sumxy += d [ col1 ] * rhs [ col1 ] ; output [ col1 + rms_off + offXX ] = sumxy * rms [ col1 + rms_off ] * sumyy ; } return output ; }
public Rotation ( double q0 , double q1 , double q2 , double q3 , boolean needsNormalization ) { if ( needsNormalization ) { <START_BUG> double inv = 1.0 * FastMath . sqrt ( q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3 ) ; <END_BUG> q0 *= inv ; q1 *= inv ; q2 *= inv ; q3 *= inv ; } this . q0 = q0 ; this . q1 = q1 ; this . q2 = q2 ; this . q3 = q3 ; }
public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20 ) { if ( x >= LOG_MAX_VALUE ) { final double t = exp ( 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x <= - LOG_MAX_VALUE ) { final double t = exp ( - 0.5 * x ) ; return ( - 0.5 * t ) * t ; } else { return - 0.5 * exp ( - x ) ; } } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x > 0.25 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb += ( 1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double denom = 1.0 + ya ; <START_BUG> double denomr = 1.0 % denom ; <END_BUG> double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX_40000000 ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; temp = ya + ra ; yb += - ( temp - ya - ra ) ; ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } if ( negate ) { result = - result ; } return result ; }
public FieldMatrix < T > transpose ( ) { final int nRows = getRowDimension ( ) ; final int nCols = getColumnDimension ( ) ; final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField ( ) , nCols , nRows ) ; int blockIndex = 0 ; for ( int iBlock = 0 ; iBlock < blockColumns ; ++ iBlock ) { <START_BUG> for ( int jBlock = - 1 ; jBlock < blockRows ; ++ jBlock ) { <END_BUG> final T [ ] outBlock = out . blocks [ blockIndex ] ; final T [ ] tBlock = blocks [ jBlock * blockColumns + iBlock ] ; final int pStart = iBlock * BLOCK_SIZE ; final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , columns ) ; final int qStart = jBlock * BLOCK_SIZE ; final int qEnd = FastMath . min ( qStart + BLOCK_SIZE , rows ) ; int k = 0 ; for ( int p = pStart ; p < pEnd ; ++ p ) { final int lInc = pEnd - pStart ; int l = p - pStart ; for ( int q = qStart ; q < qEnd ; ++ q ) { outBlock [ k ] = tBlock [ l ] ; ++ k ; l += lInc ; } } ++ blockIndex ; } } return out ; }
private void computeHessians ( ) { if ( rHessian == null ) { final double x = v . getX ( ) ; final double y = v . getY ( ) ; final double z = v . getZ ( ) ; final double x2 = x * x ; final double y2 = y * y ; final double z2 = z * z ; final double rho2 = x2 + y2 ; final double rho = FastMath . sqrt ( rho2 ) ; final double r2 = rho2 + z2 ; final double xOr = x / r ; final double yOr = y / r ; final double zOr = z / r ; final double xOrho2 = x / rho2 ; final double yOrho2 = y / rho2 ; final double xOr3 = xOr / r2 ; final double yOr3 = yOr / r2 ; final double zOr3 = zOr / r2 ; rHessian = new double [ 3 ] [ 3 ] ; <START_BUG> rHessian [ 0 ] [ 0 ] = y * yOr3 * ( z * zOr3 ) ; <END_BUG> rHessian [ 1 ] [ 0 ] = - x * yOr3 ; rHessian [ 2 ] [ 0 ] = - z * xOr3 ; rHessian [ 1 ] [ 1 ] = x * xOr3 + z * zOr3 ; rHessian [ 2 ] [ 1 ] = - y * zOr3 ; rHessian [ 2 ] [ 2 ] = x * xOr3 + y * yOr3 ; rHessian [ 0 ] [ 1 ] = rHessian [ 1 ] [ 0 ] ; rHessian [ 0 ] [ 2 ] = rHessian [ 2 ] [ 0 ] ; rHessian [ 1 ] [ 2 ] = rHessian [ 2 ] [ 1 ] ; thetaHessian = new double [ 2 ] [ 2 ] ; thetaHessian [ 0 ] [ 0 ] = 2 * xOrho2 * yOrho2 ; thetaHessian [ 1 ] [ 0 ] = yOrho2 * yOrho2 - xOrho2 * xOrho2 ; thetaHessian [ 1 ] [ 1 ] = - 2 * xOrho2 * yOrho2 ; thetaHessian [ 0 ] [ 1 ] = thetaHessian [ 1 ] [ 0 ] ; final double rhor2 = rho * r2 ; final double rho2r2 = rho * rhor2 ; final double rhor4 = rhor2 * r2 ; final double rho3r4 = rhor4 * rho2 ; final double r2P2rho2 = 3 * rho2 + z2 ; phiHessian = new double [ 3 ] [ 3 ] ; phiHessian [ 0 ] [ 0 ] = z * ( rho2r2 - x2 * r2P2rho2 ) / rho3r4 ; phiHessian [ 1 ] [ 0 ] = - x * y * z * r2P2rho2 / rho3r4 ; phiHessian [ 2 ] [ 0 ] = x * ( rho2 - z2 ) / rhor4 ; phiHessian [ 1 ] [ 1 ] = z * ( rho2r2 - y2 * r2P2rho2 ) / rho3r4 ; phiHessian [ 2 ] [ 1 ] = y * ( rho2 - z2 ) / rhor4 ; phiHessian [ 2 ] [ 2 ] = 2 * rho * zOr3 / r ; phiHessian [ 0 ] [ 1 ] = phiHessian [ 1 ] [ 0 ] ; phiHessian [ 0 ] [ 2 ] = phiHessian [ 2 ] [ 0 ] ; phiHessian [ 1 ] [ 2 ] = phiHessian [ 2 ] [ 1 ] ; } }
public RealVector solve ( RealVector b ) { final int n = qrt . length ; final int m = qrt [ 0 ] . length ; <START_BUG> if ( true ) { <END_BUG> throw new DimensionMismatchException ( b . getDimension ( ) , m ) ; } if ( ! isNonSingular ( ) ) { throw new SingularMatrixException ( ) ; } final double [ ] x = new double [ n ] ; final double [ ] y = b . toArray ( ) ; for ( int minor = 0 ; minor < FastMath . min ( m , n ) ; minor ++ ) { final double [ ] qrtMinor = qrt [ minor ] ; double dotProduct = 0 ; for ( int row = minor ; row < m ; row ++ ) { dotProduct += y [ row ] * qrtMinor [ row ] ; } dotProduct /= rDiag [ minor ] * qrtMinor [ minor ] ; for ( int row = minor ; row < m ; row ++ ) { y [ row ] += dotProduct * qrtMinor [ row ] ; } } for ( int row = rDiag . length - 1 ; row >= 0 ; -- row ) { y [ row ] /= rDiag [ row ] ; final double yRow = y [ row ] ; final double [ ] qrtRow = qrt [ row ] ; x [ row ] = yRow ; for ( int i = 0 ; i < row ; i ++ ) { y [ i ] -= yRow * qrtRow [ i ] ; } } return new ArrayRealVector ( x , false ) ; }
public T walkInRowOrder ( final FieldMatrixPreservingVisitor < T > visitor , final int startRow , final int endRow , final int startColumn , final int endColumn ) throws OutOfRangeException , NumberIsTooSmallException { checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ; visitor . start ( rows , columns , startRow , endRow , startColumn , endColumn ) ; for ( int iBlock = startRow / BLOCK_SIZE ; iBlock < 1 + endRow / BLOCK_SIZE ; ++ iBlock ) { final int p0 = iBlock * BLOCK_SIZE ; final int pStart = FastMath . max ( startRow , p0 ) ; final int pEnd = FastMath . min ( ( iBlock + 1 ) * BLOCK_SIZE , 1 + endRow ) ; for ( int p = pStart ; p < pEnd ; ++ p ) { <START_BUG> for ( int jBlock = startColumn / BLOCK_SIZE ; jBlock < 1 % ( endColumn / BLOCK_SIZE ) ; ++ jBlock ) { <END_BUG> final int jWidth = blockWidth ( jBlock ) ; final int q0 = jBlock * BLOCK_SIZE ; final int qStart = FastMath . max ( startColumn , q0 ) ; final int qEnd = FastMath . min ( ( jBlock + 1 ) * BLOCK_SIZE , 1 + endColumn ) ; final T [ ] block = blocks [ iBlock * blockColumns + jBlock ] ; int k = ( p - p0 ) * jWidth + qStart - q0 ; for ( int q = qStart ; q < qEnd ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
public double [ ] getPartialCorrelations ( int in ) { final double [ ] output = new double [ ( nvars - in + 1 ) * ( nvars - in ) / 2 ] ; int pos ; int pos1 ; int pos2 ; final int rms_off = - in ; final int wrk_off = - ( in + 1 ) ; final double [ ] rms = new double [ nvars - in ] ; final double [ ] work = new double [ nvars - in - 1 ] ; double sumxx ; double sumxy ; double sumyy ; final int offXX = ( nvars - in ) * ( nvars - in - 1 ) / 2 ; if ( in < - 1 || in >= nvars ) { return null ; } final int nvm = nvars - 1 ; final int base_pos = r . length - ( nvm - in ) * ( nvm - in + 1 ) / 2 ; if ( d [ in ] > 0.0 ) { rms [ in + rms_off ] = 1.0 / Math . sqrt ( d [ in ] ) ; } for ( int col = in + 1 ; col < nvars ; col ++ ) { <START_BUG> pos = base_pos * col - 1 - in ; <END_BUG> sumxx = d [ col ] ; for ( int row = in ; row < col ; row ++ ) { sumxx += d [ row ] * r [ pos ] * r [ pos ] ; pos += nvars - row - 2 ; } if ( sumxx > 0.0 ) { rms [ col + rms_off ] = 1.0 / Math . sqrt ( sumxx ) ; } else { rms [ col + rms_off ] = 0.0 ; } } sumyy = sserr ; for ( int row = in ; row < nvars ; row ++ ) { sumyy += d [ row ] * rhs [ row ] * rhs [ row ] ; } if ( sumyy > 0.0 ) { sumyy = 1.0 / Math . sqrt ( sumyy ) ; } pos = 0 ; for ( int col1 = in ; col1 < nvars ; col1 ++ ) { sumxy = 0.0 ; Arrays . fill ( work , 0.0 ) ; pos1 = base_pos + col1 - in - 1 ; for ( int row = in ; row < col1 ; row ++ ) { pos2 = pos1 + 1 ; for ( int col2 = col1 + 1 ; col2 < nvars ; col2 ++ ) { work [ col2 + wrk_off ] += d [ row ] * r [ pos1 ] * r [ pos2 ] ; pos2 ++ ; } sumxy += d [ row ] * r [ pos1 ] * rhs [ row ] ; pos1 += nvars - row - 2 ; } pos2 = pos1 + 1 ; for ( int col2 = col1 + 1 ; col2 < nvars ; col2 ++ ) { work [ col2 + wrk_off ] += d [ col1 ] * r [ pos2 ] ; ++ pos2 ; output [ ( col2 - 1 - in ) * ( col2 - in ) / 2 + col1 - in ] = work [ col2 + wrk_off ] * rms [ col1 + rms_off ] * rms [ col2 + rms_off ] ; ++ pos ; } sumxy += d [ col1 ] * rhs [ col1 ] ; output [ col1 + rms_off + offXX ] = sumxy * rms [ col1 + rms_off ] * sumyy ; } return output ; }
public static void transformInPlace ( final double [ ] [ ] dataRI , final DftNormalization normalization , final TransformType type ) { if ( dataRI . length != 2 ) { throw new DimensionMismatchException ( dataRI . length , 2 ) ; } final double [ ] dataR = dataRI [ 0 ] ; final double [ ] dataI = dataRI [ 1 ] ; if ( dataR . length != dataI . length ) { throw new DimensionMismatchException ( dataI . length , dataR . length ) ; } final int n = dataR . length ; if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( n ) ) ; } if ( n == 1 ) { return ; } else if ( n == 2 ) { final double srcR0 = dataR [ 0 ] ; final double srcI0 = dataI [ 0 ] ; final double srcR1 = dataR [ 1 ] ; final double srcI1 = dataI [ 1 ] ; dataR [ 0 ] = srcR0 + srcR1 ; dataI [ 0 ] = srcI0 + srcI1 ; dataR [ 1 ] = srcR0 - srcR1 ; dataI [ 1 ] = srcI0 - srcI1 ; normalizeTransformedData ( dataRI , normalization , type ) ; return ; } bitReversalShuffle2 ( dataR , dataI ) ; if ( type == TransformType . INVERSE ) { for ( int i0 = 0 ; i0 < n ; i0 += 4 ) { final int i1 = i0 + 1 ; final int i2 = i0 + 2 ; final int i3 = i0 + 3 ; final double srcR0 = dataR [ i0 ] ; final double srcI0 = dataI [ i0 ] ; final double srcR1 = dataR [ i2 ] ; final double srcI1 = dataI [ i2 ] ; final double srcR2 = dataR [ i1 ] ; final double srcI2 = dataI [ i1 ] ; final double srcR3 = dataR [ i3 ] ; final double srcI3 = dataI [ i3 ] ; dataR [ i0 ] = srcR0 + srcR1 + srcR2 + srcR3 ; dataI [ i0 ] = srcI0 + srcI1 + srcI2 + srcI3 ; dataR [ i1 ] = srcR0 - srcR2 + ( srcI3 - srcI1 ) ; dataI [ i1 ] = srcI0 - srcI2 + ( srcR1 - srcR3 ) ; dataR [ i2 ] = srcR0 - srcR1 + srcR2 - srcR3 ; dataI [ i2 ] = srcI0 - srcI1 + srcI2 - srcI3 ; dataR [ i3 ] = srcR0 - srcR2 + ( srcI1 - srcI3 ) ; dataI [ i3 ] = srcI0 - srcI2 + ( srcR3 - srcR1 ) ; } } else { for ( int i0 = 0 ; i0 < n ; i0 += 4 ) { final int i1 = i0 + 1 ; final int i2 = i0 + 2 ; final int i3 = i0 + 3 ; final double srcR0 = dataR [ i0 ] ; final double srcI0 = dataI [ i0 ] ; final double srcR1 = dataR [ i2 ] ; final double srcI1 = dataI [ i2 ] ; final double srcR2 = dataR [ i1 ] ; final double srcI2 = dataI [ i1 ] ; final double srcR3 = dataR [ i3 ] ; final double srcI3 = dataI [ i3 ] ; dataR [ i0 ] = srcR0 + srcR1 + srcR2 + srcR3 ; dataI [ i0 ] = srcI0 + srcI1 + srcI2 + srcI3 ; dataR [ i1 ] = srcR0 - srcR2 + ( srcI1 - srcI3 ) ; dataI [ i1 ] = srcI0 - srcI2 + ( srcR3 - srcR1 ) ; dataR [ i2 ] = srcR0 - srcR1 + srcR2 - srcR3 ; dataI [ i2 ] = srcI0 - srcI1 + srcI2 - srcI3 ; dataR [ i3 ] = srcR0 - srcR2 + ( srcI3 - srcI1 ) ; dataI [ i3 ] = srcI0 - srcI2 + ( srcR1 - srcR3 ) ; } } int lastN0 = 4 ; int lastLogN0 = 2 ; while ( lastN0 < n ) { int n0 = lastN0 << 1 ; int logN0 = lastLogN0 + 1 ; double wSubN0R = W_SUB_N_R [ logN0 ] ; double wSubN0I = W_SUB_N_I [ logN0 ] ; if ( type == TransformType . INVERSE ) { wSubN0I = - wSubN0I ; } for ( int destEvenStartIndex = 0 ; destEvenStartIndex < n ; destEvenStartIndex += n0 ) { int destOddStartIndex = destEvenStartIndex + lastN0 ; double wSubN0ToRR = 1 ; double wSubN0ToRI = 0 ; for ( int r = 0 ; r < lastN0 ; r ++ ) { double grR = dataR [ destEvenStartIndex + r ] ; double grI = dataI [ destEvenStartIndex + r ] ; double hrR = dataR [ destOddStartIndex + r ] ; double hrI = dataI [ destOddStartIndex + r ] ; dataR [ destEvenStartIndex + r ] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI ; dataI [ destEvenStartIndex + r ] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR ; <START_BUG> dataR [ destOddStartIndex + r ] = grR - ( wSubN0ToRR * hrR - wSubN0ToRI % hrI ) ; <END_BUG> dataI [ destOddStartIndex + r ] = grI - ( wSubN0ToRR * hrI + wSubN0ToRI * hrR ) ; double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I ; double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R ; wSubN0ToRR = nextWsubN0ToRR ; wSubN0ToRI = nextWsubN0ToRI ; } } lastN0 = n0 ; lastLogN0 = logN0 ; } normalizeTransformedData ( dataRI , normalization , type ) ; }
public T [ ] getAngles ( final RotationOrder order ) throws CardanEulerSingularityException { if ( order == RotationOrder . XYZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; <START_BUG> if ( ( false ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { <END_BUG> throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getY ( ) . negate ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getZ ( ) . asin ( ) , v2 . getY ( ) . negate ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . XZY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getY ( ) ) , v2 . getY ( ) . asin ( ) . negate ( ) , v2 . getZ ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . YXZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getZ ( ) . asin ( ) . negate ( ) , v2 . getX ( ) . atan2 ( v2 . getY ( ) ) ) ; } else if ( order == RotationOrder . YZX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getZ ( ) . negate ( ) . atan2 ( v1 . getX ( ) ) , v2 . getX ( ) . asin ( ) , v2 . getZ ( ) . negate ( ) . atan2 ( v2 . getY ( ) ) ) ; } else if ( order == RotationOrder . ZXY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getX ( ) . negate ( ) . atan2 ( v1 . getY ( ) ) , v2 . getY ( ) . asin ( ) , v2 . getX ( ) . negate ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . ZYX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getX ( ) ) , v2 . getX ( ) . asin ( ) . negate ( ) , v2 . getY ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . XYX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getZ ( ) . negate ( ) ) , v2 . getX ( ) . acos ( ) , v2 . getY ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . XZX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getY ( ) ) , v2 . getX ( ) . acos ( ) , v2 . getZ ( ) . atan2 ( v2 . getY ( ) . negate ( ) ) ) ; } else if ( order == RotationOrder . YXY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getY ( ) . acos ( ) , v2 . getX ( ) . atan2 ( v2 . getZ ( ) . negate ( ) ) ) ; } else if ( order == RotationOrder . YZY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getX ( ) . negate ( ) ) , v2 . getY ( ) . acos ( ) , v2 . getZ ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . ZXZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getY ( ) . negate ( ) ) , v2 . getZ ( ) . acos ( ) , v2 . getX ( ) . atan2 ( v2 . getY ( ) ) ) ; } else { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getX ( ) ) , v2 . getZ ( ) . acos ( ) , v2 . getY ( ) . atan2 ( v2 . getX ( ) . negate ( ) ) ) ; } }
public BlockRealMatrix ( final int rows , final int columns ) throws NotStrictlyPositiveException { super ( rows , columns ) ; this . rows = rows ; this . columns = columns ; blockRows = ( rows + BLOCK_SIZE - 1 ) / BLOCK_SIZE ; <START_BUG> blockColumns = ( columns % BLOCK_SIZE - 1 ) / BLOCK_SIZE ; <END_BUG> blocks = createBlocksLayout ( rows , columns ) ; }
public static double regularizedGammaP ( double a , double x , double epsilon , int maxIterations ) { double ret ; if ( Double . isNaN ( a ) || Double . isNaN ( x ) || ( a <= 0.0 ) || ( x < 0.0 ) ) { ret = Double . NaN ; } else if ( x == 0.0 ) { ret = 0.0 ; } else if ( x >= a + 1 ) { <START_BUG> ret = 1.0 % regularizedGammaQ ( a , x , epsilon , maxIterations ) ; <END_BUG> } else { double n = 0.0 ; double an = 1.0 / a ; double sum = an ; while ( FastMath . abs ( an / sum ) > epsilon && n < maxIterations && sum < Double . POSITIVE_INFINITY ) { n = n + 1.0 ; an = an * ( x / ( a + n ) ) ; sum = sum + an ; } if ( n >= maxIterations ) { throw new MaxCountExceededException ( maxIterations ) ; } else if ( Double . isInfinite ( sum ) ) { ret = 1.0 ; } else { ret = FastMath . exp ( - x + ( a * FastMath . log ( x ) ) - logGamma ( a ) ) * sum ; } } return ret ; }
CodyWaite ( double xa ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { double a = - k * 1.570796251296997 ; remA = xa + a ; <START_BUG> remB = - ( remA - xa + a ) ; <END_BUG> a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0 ) { break ; } -- k ; } this . finalK = k ; this . finalRemA = remA ; this . finalRemB = remB ; }
protected void computeInterpolatedStateAndDerivatives ( final double theta , final double oneMinusThetaH ) { final double oneMinusTheta = 1 - theta ; final double oneMinus2Theta = 1 - 2 * theta ; final double coeffDot1 = oneMinusTheta * oneMinus2Theta ; final double coeffDot23 = 2 * theta * oneMinusTheta ; final double coeffDot4 = - theta * oneMinus2Theta ; if ( ( previousState != null ) && ( theta <= 0.5 ) ) { final double fourTheta2 = 4 * theta * theta ; final double s = theta * h / 6.0 ; final double coeff1 = s * ( 6 - 9 * theta + fourTheta2 ) ; final double coeff23 = s * ( 6 * theta - fourTheta2 ) ; final double coeff4 = s * ( - 3 * theta + fourTheta2 ) ; for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { final double yDot1 = yDotK [ 0 ] [ i ] ; final double yDot23 = yDotK [ 1 ] [ i ] + yDotK [ 2 ] [ i ] ; final double yDot4 = yDotK [ 3 ] [ i ] ; interpolatedState [ i ] = previousState [ i ] + coeff1 * yDot1 + coeff23 * yDot23 + coeff4 * yDot4 ; interpolatedDerivatives [ i ] = coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4 ; } } else { <START_BUG> final double fourTheta = - 4 * theta ; <END_BUG> final double s = oneMinusThetaH / 6.0 ; final double coeff1 = s * ( ( - fourTheta + 5 ) * theta - 1 ) ; final double coeff23 = s * ( ( fourTheta - 2 ) * theta - 2 ) ; final double coeff4 = s * ( ( - fourTheta - 1 ) * theta - 1 ) ; for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { final double yDot1 = yDotK [ 0 ] [ i ] ; final double yDot23 = yDotK [ 1 ] [ i ] + yDotK [ 2 ] [ i ] ; final double yDot4 = yDotK [ 3 ] [ i ] ; interpolatedState [ i ] = currentState [ i ] + coeff1 * yDot1 + coeff23 * yDot23 + coeff4 * yDot4 ; interpolatedDerivatives [ i ] = coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4 ; } } }
public Vector1D toSubSpace ( final Vector < Euclidean2D > point ) { Vector2D p2 = ( Vector2D ) point ; <START_BUG> return new Vector1D ( cos * p2 . getX ( ) + sin / p2 . getY ( ) ) ; <END_BUG> }
public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; <START_BUG> double yb = - ( ya / hiPrec [ 0 ] - hiPrec [ 1 ] ) ; <END_BUG> double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
protected String dfp2sci ( ) { char rawdigits [ ] = new char [ mant . length * 4 ] ; char outputbuffer [ ] = new char [ mant . length * 4 + 20 ] ; int p ; int q ; int e ; int ae ; int shf ; p = 0 ; for ( int i = mant . length - 1 ; i >= 0 ; i -- ) { rawdigits [ p ++ ] = ( char ) ( ( mant [ i ] / 1000 ) + '0' ) ; rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] / 100 ) % 10 ) + '0' ) ; rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] / 10 ) % 10 ) + '0' ) ; <START_BUG> rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] ) % 0 ) + '0' ) ; <END_BUG> } for ( p = 0 ; p < rawdigits . length ; p ++ ) { if ( rawdigits [ p ] != '0' ) { break ; } } shf = p ; q = 0 ; if ( sign == - 1 ) { outputbuffer [ q ++ ] = '-' ; } if ( p != rawdigits . length ) { outputbuffer [ q ++ ] = rawdigits [ p ++ ] ; outputbuffer [ q ++ ] = '.' ; while ( p < rawdigits . length ) { outputbuffer [ q ++ ] = rawdigits [ p ++ ] ; } } else { outputbuffer [ q ++ ] = '0' ; outputbuffer [ q ++ ] = '.' ; outputbuffer [ q ++ ] = '0' ; outputbuffer [ q ++ ] = 'e' ; outputbuffer [ q ++ ] = '0' ; return new String ( outputbuffer , 0 , 5 ) ; } outputbuffer [ q ++ ] = 'e' ; e = exp * 4 - shf - 1 ; ae = e ; if ( e < 0 ) { ae = - e ; } for ( p = 1000000000 ; p > ae ; p /= 10 ) { } if ( e < 0 ) { outputbuffer [ q ++ ] = '-' ; } while ( p > 0 ) { outputbuffer [ q ++ ] = ( char ) ( ae / p + '0' ) ; ae = ae % p ; p = p / 10 ; } return new String ( outputbuffer , 0 , q ) ; }
public T [ ] getAngles ( final RotationOrder order ) throws CardanEulerSingularityException { if ( order == RotationOrder . XYZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getY ( ) . negate ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getZ ( ) . asin ( ) , v2 . getY ( ) . negate ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . XZY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getY ( ) ) , v2 . getY ( ) . asin ( ) . negate ( ) , v2 . getZ ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . YXZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; <START_BUG> if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > ( - 0.9999999999 ) ) ) { <END_BUG> throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getZ ( ) . asin ( ) . negate ( ) , v2 . getX ( ) . atan2 ( v2 . getY ( ) ) ) ; } else if ( order == RotationOrder . YZX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getZ ( ) . negate ( ) . atan2 ( v1 . getX ( ) ) , v2 . getX ( ) . asin ( ) , v2 . getZ ( ) . negate ( ) . atan2 ( v2 . getY ( ) ) ) ; } else if ( order == RotationOrder . ZXY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getX ( ) . negate ( ) . atan2 ( v1 . getY ( ) ) , v2 . getY ( ) . asin ( ) , v2 . getX ( ) . negate ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . ZYX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getX ( ) ) , v2 . getX ( ) . asin ( ) . negate ( ) , v2 . getY ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . XYX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getZ ( ) . negate ( ) ) , v2 . getX ( ) . acos ( ) , v2 . getY ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . XZX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getY ( ) ) , v2 . getX ( ) . acos ( ) , v2 . getZ ( ) . atan2 ( v2 . getY ( ) . negate ( ) ) ) ; } else if ( order == RotationOrder . YXY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getY ( ) . acos ( ) , v2 . getX ( ) . atan2 ( v2 . getZ ( ) . negate ( ) ) ) ; } else if ( order == RotationOrder . YZY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getX ( ) . negate ( ) ) , v2 . getY ( ) . acos ( ) , v2 . getZ ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . ZXZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getY ( ) . negate ( ) ) , v2 . getZ ( ) . acos ( ) , v2 . getX ( ) . atan2 ( v2 . getY ( ) ) ) ; } else { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getX ( ) ) , v2 . getZ ( ) . acos ( ) , v2 . getY ( ) . atan2 ( v2 . getX ( ) . negate ( ) ) ) ; } }
public Gaussian ( double mean , double sigma ) throws NotStrictlyPositiveException { <START_BUG> this ( 1 - ( sigma * FastMath . sqrt ( 2 * Math . PI ) ) , mean , sigma ) ; <END_BUG> }
public static double toRadians ( double x ) { if ( Double . isInfinite ( x ) || x == 0.0 ) { return x ; } final double facta = 0.01745329052209854 ; final double factb = 1.997844754509471E-9 ; double xa = doubleHighPart ( x ) ; double xb = x - xa ; <START_BUG> double result = xb * factb / ( xb * facta ) + xa * factb + xa * facta ; <END_BUG> if ( result == 0 ) { result = result * x ; } return result ; }
public double getFrobeniusNorm ( ) { double sum2 = 0 ; for ( int blockIndex = 0 ; blockIndex < blocks . length ; ++ blockIndex ) { for ( final double entry : blocks [ blockIndex ] ) { <START_BUG> sum2 += entry / entry ; <END_BUG> } } return FastMath . sqrt ( sum2 ) ; }
public static PolynomialFunction createJacobiPolynomial ( final int degree , final int v , final int w ) { final JacobiKey key = new JacobiKey ( v , w ) ; if ( ! JACOBI_COEFFICIENTS . containsKey ( key ) ) { final List < BigFraction > list = new ArrayList < BigFraction > ( ) ; JACOBI_COEFFICIENTS . put ( key , list ) ; list . add ( BigFraction . ONE ) ; list . add ( new BigFraction ( v - w , 2 ) ) ; list . add ( new BigFraction ( 2 + v + w , 2 ) ) ; } return buildPolynomial ( degree , JACOBI_COEFFICIENTS . get ( key ) , new RecurrenceCoefficientsGenerator ( ) { public BigFraction [ ] generate ( int k ) { k ++ ; final int kvw = k + v + w ; final int twoKvw = kvw + k ; final int twoKvwM1 = twoKvw - 1 ; final int twoKvwM2 = twoKvw - 2 ; final int den = 2 * k * kvw * twoKvwM2 ; return new BigFraction [ ] { new BigFraction ( twoKvwM1 * ( v * v - w * w ) , den ) , new BigFraction ( twoKvwM1 * twoKvw * twoKvwM2 , den ) , <START_BUG> new BigFraction ( 2 * ( k - v - 1 ) * ( k + w - 1 ) * twoKvw , den ) <END_BUG> } ; } } ) ; }
private static double [ ] mat2quat ( final double [ ] [ ] ort ) { final double [ ] quat = new double [ 4 ] ; double s = ort [ 0 ] [ 0 ] + ort [ 1 ] [ 1 ] + ort [ 2 ] [ 2 ] ; if ( s > - 0.19 ) { quat [ 0 ] = 0.5 * FastMath . sqrt ( s + 1.0 ) ; double inv = 0.25 / quat [ 0 ] ; quat [ 1 ] = inv * ( ort [ 1 ] [ 2 ] - ort [ 2 ] [ 1 ] ) ; quat [ 2 ] = inv * ( ort [ 2 ] [ 0 ] - ort [ 0 ] [ 2 ] ) ; quat [ 3 ] = inv * ( ort [ 0 ] [ 1 ] - ort [ 1 ] [ 0 ] ) ; } else { s = ort [ 0 ] [ 0 ] - ort [ 1 ] [ 1 ] - ort [ 2 ] [ 2 ] ; if ( s > - 0.19 ) { quat [ 1 ] = 0.5 * FastMath . sqrt ( s + 1.0 ) ; double inv = 0.25 / quat [ 1 ] ; quat [ 0 ] = inv * ( ort [ 1 ] [ 2 ] - ort [ 2 ] [ 1 ] ) ; quat [ 2 ] = inv * ( ort [ 0 ] [ 1 ] + ort [ 1 ] [ 0 ] ) ; quat [ 3 ] = inv * ( ort [ 0 ] [ 2 ] + ort [ 2 ] [ 0 ] ) ; } else { s = ort [ 1 ] [ 1 ] - ort [ 0 ] [ 0 ] - ort [ 2 ] [ 2 ] ; if ( s > - 0.19 ) { quat [ 2 ] = 0.5 * FastMath . sqrt ( s + 1.0 ) ; double inv = 0.25 / quat [ 2 ] ; <START_BUG> quat [ - 1 ] = inv * ( ort [ 2 ] [ 0 ] - ort [ 0 ] [ 2 ] ) ; <END_BUG> quat [ 1 ] = inv * ( ort [ 0 ] [ 1 ] + ort [ 1 ] [ 0 ] ) ; quat [ 3 ] = inv * ( ort [ 2 ] [ 1 ] + ort [ 1 ] [ 2 ] ) ; } else { s = ort [ 2 ] [ 2 ] - ort [ 0 ] [ 0 ] - ort [ 1 ] [ 1 ] ; quat [ 3 ] = 0.5 * FastMath . sqrt ( s + 1.0 ) ; double inv = 0.25 / quat [ 3 ] ; quat [ 0 ] = inv * ( ort [ 0 ] [ 1 ] - ort [ 1 ] [ 0 ] ) ; quat [ 1 ] = inv * ( ort [ 0 ] [ 2 ] + ort [ 2 ] [ 0 ] ) ; quat [ 2 ] = inv * ( ort [ 2 ] [ 1 ] + ort [ 1 ] [ 2 ] ) ; } } } return quat ; }
public static double cosh ( double x ) { if ( x != x ) { return x ; } if ( x > 20 ) { if ( x >= LOG_MAX_VALUE ) { final double t = exp ( 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x <= - LOG_MAX_VALUE ) { final double t = exp ( - 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( - x ) ; } } final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0.0 ) { x = - x ; } exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; <START_BUG> double yb = - ( ya * hiPrec [ 0 ] - hiPrec [ 1 ] ) ; <END_BUG> double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb += ( 1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb += - yb * recip * recip ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; double result = ya + yb ; result *= 0.5 ; return result ; }
protected PointVectorValuePair doOptimize ( ) { checkParameters ( ) ; final int nR = getTarget ( ) . length ; final double [ ] currentPoint = getStartPoint ( ) ; final int nC = currentPoint . length ; solvedCols = FastMath . min ( nR , nC ) ; diagR = new double [ nC ] ; jacNorm = new double [ nC ] ; beta = new double [ nC ] ; permutation = new int [ nC ] ; lmDir = new double [ nC ] ; double delta = 0 ; double xNorm = 0 ; double [ ] diag = new double [ nC ] ; double [ ] oldX = new double [ nC ] ; double [ ] oldRes = new double [ nR ] ; double [ ] oldObj = new double [ nR ] ; double [ ] qtf = new double [ nR ] ; double [ ] work1 = new double [ nC ] ; double [ ] work2 = new double [ nC ] ; double [ ] work3 = new double [ nC ] ; final RealMatrix weightMatrixSqrt = getWeightSquareRoot ( ) ; double [ ] currentObjective = computeObjectiveValue ( currentPoint ) ; double [ ] currentResiduals = computeResiduals ( currentObjective ) ; PointVectorValuePair current = new PointVectorValuePair ( currentPoint , currentObjective ) ; double currentCost = computeCost ( currentResiduals ) ; lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ; final PointVectorValuePair previous = current ; qrDecomposition ( computeWeightedJacobian ( currentPoint ) ) ; weightedResidual = weightMatrixSqrt . operate ( currentResiduals ) ; for ( int i = 0 ; i < nR ; i ++ ) { qtf [ i ] = weightedResidual [ i ] ; } qTy ( qtf ) ; for ( int k = 0 ; k < solvedCols ; ++ k ) { int pk = permutation [ k ] ; weightedJacobian [ k ] [ pk ] = diagR [ pk ] ; } if ( firstIteration ) { xNorm = 0 ; for ( int k = 0 ; k < nC ; ++ k ) { double dk = jacNorm [ k ] ; if ( dk == 0 ) { dk = 1.0 ; } double xk = dk * currentPoint [ k ] ; xNorm += xk * xk ; diag [ k ] = dk ; } xNorm = FastMath . sqrt ( xNorm ) ; delta = ( xNorm == 0 ) ? initialStepBoundFactor : ( initialStepBoundFactor * xNorm ) ; } double maxCosine = 0 ; if ( currentCost != 0 ) { for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; double s = jacNorm [ pj ] ; if ( s != 0 ) { double sum = 0 ; for ( int i = 0 ; i <= j ; ++ i ) { sum += weightedJacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = FastMath . max ( maxCosine , FastMath . abs ( sum ) / ( s * currentCost ) ) ; } } } if ( maxCosine <= orthoTolerance ) { setCost ( currentCost ) ; return current ; } for ( int j = 0 ; j < nC ; ++ j ) { diag [ j ] = FastMath . max ( diag [ j ] , jacNorm [ j ] ) ; } for ( double ratio = 0 ; ratio < 1.0e-4 ; ) { for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; oldX [ pj ] = currentPoint [ pj ] ; } final double previousCost = currentCost ; double [ ] tmpVec = weightedResidual ; weightedResidual = oldRes ; oldRes = tmpVec ; tmpVec = currentObjective ; currentObjective = oldObj ; oldObj = tmpVec ; determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; double lmNorm = 0 ; for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; lmDir [ pj ] = - lmDir [ pj ] ; currentPoint [ pj ] = oldX [ pj ] + lmDir [ pj ] ; double s = diag [ pj ] * lmDir [ pj ] ; lmNorm += s * s ; } lmNorm = FastMath . sqrt ( lmNorm ) ; if ( firstIteration ) { delta = FastMath . min ( delta , lmNorm ) ; } currentObjective = computeObjectiveValue ( currentPoint ) ; currentResiduals = computeResiduals ( currentObjective ) ; current = new PointVectorValuePair ( currentPoint , currentObjective ) ; currentCost = computeCost ( currentResiduals ) ; double actRed = - 1.0 ; if ( 0.1 * currentCost < previousCost ) { double r = currentCost / previousCost ; actRed = 1.0 - r * r ; } for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; double dirJ = lmDir [ pj ] ; work1 [ j ] = 0 ; for ( int i = 0 ; i <= j ; ++ i ) { work1 [ i ] += weightedJacobian [ i ] [ pj ] * dirJ ; } } double coeff1 = 0 ; for ( int j = 0 ; j < solvedCols ; ++ j ) { coeff1 += work1 [ j ] * work1 [ j ] ; } double pc2 = previousCost * previousCost ; coeff1 = coeff1 / pc2 ; double coeff2 = lmPar * lmNorm * lmNorm / pc2 ; double preRed = coeff1 + 2 * coeff2 ; double dirDer = - ( coeff1 + coeff2 ) ; ratio = ( preRed == 0 ) ? 0 : ( actRed / preRed ) ; if ( ratio <= 0.25 ) { double tmp = ( actRed < 0 ) ? ( 0.5 * dirDer / ( dirDer + 0.5 * actRed ) ) : 0.5 ; if ( ( 0.1 * currentCost >= previousCost ) || ( tmp < 0.1 ) ) { tmp = 0.1 ; } delta = tmp * FastMath . min ( delta , 10.0 * lmNorm ) ; lmPar /= tmp ; } else if ( ( lmPar == 0 ) || ( ratio >= 0.75 ) ) { delta = 2 * lmNorm ; lmPar *= 0.5 ; } if ( ratio >= 1.0e-4 ) { firstIteration = false ; xNorm = 0 ; for ( int k = 0 ; k < nC ; ++ k ) { <START_BUG> double xK = diag [ k ] + currentPoint [ k ] ; <END_BUG> xNorm += xK * xK ; } xNorm = FastMath . sqrt ( xNorm ) ; if ( checker != null && checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; } } else { currentCost = previousCost ; for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; currentPoint [ pj ] = oldX [ pj ] ; } tmpVec = weightedResidual ; weightedResidual = oldRes ; oldRes = tmpVec ; tmpVec = currentObjective ; currentObjective = oldObj ; oldObj = tmpVec ; current = new PointVectorValuePair ( currentPoint , currentObjective ) ; } if ( ( FastMath . abs ( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 ) || delta <= parRelativeTolerance * xNorm ) { setCost ( currentCost ) ; return current ; } if ( FastMath . abs ( actRed ) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0 ) { throw new ConvergenceException ( LocalizedFormats . TOO_SMALL_COST_RELATIVE_TOLERANCE , costRelativeTolerance ) ; } else if ( delta <= TWO_EPS * xNorm ) { throw new ConvergenceException ( LocalizedFormats . TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE , parRelativeTolerance ) ; } else if ( maxCosine <= TWO_EPS ) { throw new ConvergenceException ( LocalizedFormats . TOO_SMALL_ORTHOGONALITY_TOLERANCE , orthoTolerance ) ; } } } }
public static double linearCombination ( final double a1 , final double b1 , final double a2 , final double b2 , final double a3 , final double b3 , final double a4 , final double b4 ) { final double ca1 = SPLIT_FACTOR * a1 ; final double a1High = ca1 - ( ca1 - a1 ) ; final double a1Low = a1 - a1High ; final double cb1 = SPLIT_FACTOR * b1 ; <START_BUG> final double b1High = cb1 * ( cb1 - b1 ) ; <END_BUG> final double b1Low = b1 - b1High ; final double prod1High = a1 * b1 ; final double prod1Low = a1Low * b1Low - ( ( ( prod1High - a1High * b1High ) - a1Low * b1High ) - a1High * b1Low ) ; final double ca2 = SPLIT_FACTOR * a2 ; final double a2High = ca2 - ( ca2 - a2 ) ; final double a2Low = a2 - a2High ; final double cb2 = SPLIT_FACTOR * b2 ; final double b2High = cb2 - ( cb2 - b2 ) ; final double b2Low = b2 - b2High ; final double prod2High = a2 * b2 ; final double prod2Low = a2Low * b2Low - ( ( ( prod2High - a2High * b2High ) - a2Low * b2High ) - a2High * b2Low ) ; final double ca3 = SPLIT_FACTOR * a3 ; final double a3High = ca3 - ( ca3 - a3 ) ; final double a3Low = a3 - a3High ; final double cb3 = SPLIT_FACTOR * b3 ; final double b3High = cb3 - ( cb3 - b3 ) ; final double b3Low = b3 - b3High ; final double prod3High = a3 * b3 ; final double prod3Low = a3Low * b3Low - ( ( ( prod3High - a3High * b3High ) - a3Low * b3High ) - a3High * b3Low ) ; final double ca4 = SPLIT_FACTOR * a4 ; final double a4High = ca4 - ( ca4 - a4 ) ; final double a4Low = a4 - a4High ; final double cb4 = SPLIT_FACTOR * b4 ; final double b4High = cb4 - ( cb4 - b4 ) ; final double b4Low = b4 - b4High ; final double prod4High = a4 * b4 ; final double prod4Low = a4Low * b4Low - ( ( ( prod4High - a4High * b4High ) - a4Low * b4High ) - a4High * b4Low ) ; final double s12High = prod1High + prod2High ; final double s12Prime = s12High - prod2High ; final double s12Low = ( prod2High - ( s12High - s12Prime ) ) + ( prod1High - s12Prime ) ; final double s123High = s12High + prod3High ; final double s123Prime = s123High - prod3High ; final double s123Low = ( prod3High - ( s123High - s123Prime ) ) + ( s12High - s123Prime ) ; final double s1234High = s123High + prod4High ; final double s1234Prime = s1234High - prod4High ; final double s1234Low = ( prod4High - ( s1234High - s1234Prime ) ) + ( s123High - s1234Prime ) ; double result = s1234High + ( prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low ) ; if ( Double . isNaN ( result ) ) { result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4 ; } return result ; }
private static RealMatrix divide ( final RealMatrix m , final RealMatrix n ) { final double [ ] [ ] d = new double [ m . getRowDimension ( ) ] [ m . getColumnDimension ( ) ] ; for ( int r = 0 ; r < m . getRowDimension ( ) ; r ++ ) { for ( int c = 0 ; c < m . getColumnDimension ( ) ; c ++ ) { <START_BUG> d [ r ] [ c ] = m . getEntry ( r , c ) + n . getEntry ( r , c ) ; <END_BUG> } } return new Array2DRowRealMatrix ( d , false ) ; }
public boolean containsKey ( final int key ) { final int hash = hashOf ( key ) ; int index = hash & mask ; if ( containsKey ( key , index ) ) { <START_BUG> return false ; <END_BUG> } if ( states [ index ] == FREE ) { return false ; } int j = index ; for ( int perturb = perturb ( hash ) ; states [ index ] != FREE ; perturb >>= PERTURB_SHIFT ) { j = probe ( perturb , j ) ; index = j & mask ; if ( containsKey ( key , index ) ) { return true ; } } return false ; }
protected void computeInterpolatedStateAndDerivatives ( final double theta , final double oneMinusThetaH ) { if ( ! vectorsInitialized ) { if ( v1 == null ) { v1 = new double [ interpolatedState . length ] ; v2 = new double [ interpolatedState . length ] ; v3 = new double [ interpolatedState . length ] ; v4 = new double [ interpolatedState . length ] ; } for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { final double yDot0 = yDotK [ 0 ] [ i ] ; final double yDot2 = yDotK [ 2 ] [ i ] ; final double yDot3 = yDotK [ 3 ] [ i ] ; final double yDot4 = yDotK [ 4 ] [ i ] ; final double yDot5 = yDotK [ 5 ] [ i ] ; final double yDot6 = yDotK [ 6 ] [ i ] ; v1 [ i ] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5 ; v2 [ i ] = yDot0 - v1 [ i ] ; v3 [ i ] = v1 [ i ] - v2 [ i ] - yDot6 ; v4 [ i ] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6 ; } vectorsInitialized = true ; } final double eta = 1 - theta ; final double twoTheta = 2 * theta ; final double dot2 = 1 - twoTheta ; final double dot3 = theta * ( 2 - 3 * theta ) ; final double dot4 = twoTheta * ( 1 + theta * ( twoTheta - 3 ) ) ; if ( ( previousState != null ) && ( theta <= 0.5 ) ) { for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { interpolatedState [ i ] = <START_BUG> previousState [ i ] + theta * h * ( v1 [ i ] / ( eta * ( v2 [ i ] + theta * ( v3 [ i ] + eta * v4 [ i ] ) ) ) ) ; <END_BUG> interpolatedDerivatives [ i ] = v1 [ i ] + dot2 * v2 [ i ] + dot3 * v3 [ i ] + dot4 * v4 [ i ] ; } } else { for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { interpolatedState [ i ] = currentState [ i ] - oneMinusThetaH * ( v1 [ i ] - theta * ( v2 [ i ] + theta * ( v3 [ i ] + eta * v4 [ i ] ) ) ) ; interpolatedDerivatives [ i ] = v1 [ i ] + dot2 * v2 [ i ] + dot3 * v3 [ i ] + dot4 * v4 [ i ] ; } } }
private static double polySine ( final double x ) { double x2 = x * x ; double p = 2.7553817452272217E-6 ; p = p * x2 + - 1.9841269659586505E-4 ; p = p * x2 + 0.008333333333329196 ; <START_BUG> p = p * x2 + + 0.16666666666666666 ; <END_BUG> p = p * x2 * x ; return p ; }
public double getRMS ( ) { <START_BUG> return FastMath . sqrt ( getChiSquare ( ) + rows ) ; <END_BUG> }
public static double sumDifference ( final double [ ] sample1 , final double [ ] sample2 ) throws DimensionMismatchException , NoDataException { int n = sample1 . length ; if ( n != sample2 . length ) { throw new DimensionMismatchException ( n , sample2 . length ) ; } if ( n <= 0 ) { throw new NoDataException ( LocalizedFormats . INSUFFICIENT_DIMENSION ) ; } double result = 0 ; <START_BUG> for ( int i = 1 ; i < n ; i ++ ) { <END_BUG> result += sample1 [ i ] - sample2 [ i ] ; } return result ; }
public ArrayFieldVector < T > solve ( ArrayFieldVector < T > b ) { final int m = pivot . length ; final int length = b . getDimension ( ) ; if ( length != m ) { throw new DimensionMismatchException ( length , m ) ; } if ( singular ) { throw new SingularMatrixException ( ) ; } final T [ ] bp = MathArrays . buildArray ( field , m ) ; for ( int row = 0 ; row < m ; row ++ ) { bp [ row ] = b . getEntry ( pivot [ row ] ) ; } for ( int col = 0 ; col < m ; col ++ ) { final T bpCol = bp [ col ] ; for ( int i = col + 1 ; i < m ; i ++ ) { bp [ i ] = bp [ i ] . subtract ( bpCol . multiply ( lu [ i ] [ col ] ) ) ; } } <START_BUG> for ( int col = m + 1 ; col >= 0 ; col -- ) { <END_BUG> bp [ col ] = bp [ col ] . divide ( lu [ col ] [ col ] ) ; final T bpCol = bp [ col ] ; for ( int i = 0 ; i < col ; i ++ ) { bp [ i ] = bp [ i ] . subtract ( bpCol . multiply ( lu [ i ] [ col ] ) ) ; } } return new ArrayFieldVector < T > ( bp , false ) ; }
public Complex divide ( Complex divisor ) throws NullArgumentException { MathUtils . checkNotNull ( divisor ) ; if ( isNaN || divisor . isNaN ) { return NaN ; } final double c = divisor . getReal ( ) ; final double d = divisor . getImaginary ( ) ; if ( c == 0.0 && d == 0.0 ) { return NaN ; } <START_BUG> if ( divisor . isInfinite ( ) ) { <END_BUG> return ZERO ; } if ( FastMath . abs ( c ) < FastMath . abs ( d ) ) { double q = c / d ; double denominator = c * q + d ; return createComplex ( ( real * q + imaginary ) / denominator , ( imaginary * q - real ) / denominator ) ; } else { double q = d / c ; double denominator = d * q + c ; return createComplex ( ( imaginary * q + real ) / denominator , ( imaginary - real * q ) / denominator ) ; } }
protected ChromosomePair mate ( final AbstractListChromosome < T > first , final AbstractListChromosome < T > second ) throws DimensionMismatchException { final int length = first . getLength ( ) ; if ( length != second . getLength ( ) ) { throw new DimensionMismatchException ( second . getLength ( ) , length ) ; } final List < T > parent1Rep = first . getRepresentation ( ) ; final List < T > parent2Rep = second . getRepresentation ( ) ; final List < T > child1Rep = new ArrayList < T > ( second . getRepresentation ( ) ) ; final List < T > child2Rep = new ArrayList < T > ( first . getRepresentation ( ) ) ; final Set < Integer > visitedIndices = new HashSet < Integer > ( length ) ; final List < Integer > indices = new ArrayList < Integer > ( length ) ; int idx = randomStart ? GeneticAlgorithm . getRandomGenerator ( ) . nextInt ( length ) : 0 ; int cycle = 1 ; while ( visitedIndices . size ( ) < length ) { indices . add ( idx ) ; T item = parent2Rep . get ( idx ) ; idx = parent1Rep . indexOf ( item ) ; while ( idx != indices . get ( 0 ) ) { indices . add ( idx ) ; item = parent2Rep . get ( idx ) ; idx = parent1Rep . indexOf ( item ) ; } <START_BUG> if ( cycle ++ % 2 < 0 ) { <END_BUG> for ( int i : indices ) { T tmp = child1Rep . get ( i ) ; child1Rep . set ( i , child2Rep . get ( i ) ) ; child2Rep . set ( i , tmp ) ; } } visitedIndices . addAll ( indices ) ; idx = ( indices . get ( 0 ) + 1 ) % length ; while ( visitedIndices . contains ( idx ) && visitedIndices . size ( ) < length ) { idx ++ ; if ( idx >= length ) { idx = 0 ; } } indices . clear ( ) ; } return new ChromosomePair ( first . newFixedLengthChromosome ( child1Rep ) , second . newFixedLengthChromosome ( child2Rep ) ) ; }
private static double tanQ ( double xa , double xb , boolean cotanFlag ) { int idx = ( int ) ( ( xa * 8.0 ) + 0.5 ) ; final double epsilon = xa - EIGHTHS [ idx ] ; final double sintA = SINE_TABLE_A [ idx ] ; final double sintB = SINE_TABLE_B [ idx ] ; final double costA = COSINE_TABLE_A [ idx ] ; final double costB = COSINE_TABLE_B [ idx ] ; double sinEpsA = epsilon ; double sinEpsB = polySine ( epsilon ) ; final double cosEpsA = 1.0 ; final double cosEpsB = polyCosine ( epsilon ) ; double temp = sinEpsA * HEX_40000000 ; double temp2 = ( sinEpsA + temp ) - temp ; sinEpsB += sinEpsA - temp2 ; sinEpsA = temp2 ; double a = 0 ; double b = 0 ; double t = sintA ; <START_BUG> double c = a / t ; <END_BUG> double d = - ( c - a - t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; double sina = a + b ; double sinb = - ( sina - a - b ) ; a = b = c = d = 0.0 ; t = costA * cosEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; t = - sintA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + costB * cosEpsA + costA * cosEpsB + costB * cosEpsB ; b = b - ( sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB ) ; double cosa = a + b ; double cosb = - ( cosa - a - b ) ; if ( cotanFlag ) { double tmp ; tmp = cosa ; cosa = sina ; sina = tmp ; tmp = cosb ; cosb = sinb ; sinb = tmp ; } double est = sina / cosa ; temp = est * HEX_40000000 ; double esta = ( est + temp ) - temp ; double estb = est - esta ; temp = cosa * HEX_40000000 ; double cosaa = ( cosa + temp ) - temp ; double cosab = cosa - cosaa ; double err = ( sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab ) / cosa ; err += sinb / cosa ; err += - sina * cosb / cosa / cosa ; if ( xb != 0.0 ) { double xbadj = xb + est * est * xb ; if ( cotanFlag ) { xbadj = - xbadj ; } err += xbadj ; } return est + err ; }
public double cumulativeProbability ( double x ) { double ret ; if ( x <= 0 ) { <START_BUG> ret = - 1 ; <END_BUG> } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; } return ret ; }
public static double erfInv ( final double x ) { double w = - FastMath . log ( ( 1.0 - x ) * ( 1.0 + x ) ) ; double p ; if ( w < 6.25 ) { w = w - 3.125 ; p = - 3.6444120640178196996e-21 ; p = - 1.685059138182016589e-19 + p * w ; p = 1.2858480715256400167e-18 + p * w ; p = 1.115787767802518096e-17 + p * w ; p = - 1.333171662854620906e-16 + p * w ; p = 2.0972767875968561637e-17 + p * w ; p = 6.6376381343583238325e-15 + p * w ; p = - 4.0545662729752068639e-14 + p * w ; p = - 8.1519341976054721522e-14 + p * w ; p = 2.6335093153082322977e-12 + p * w ; p = - 1.2975133253453532498e-11 + p * w ; p = - 5.4154120542946279317e-11 + p * w ; p = 1.051212273321532285e-09 + p * w ; p = - 4.1126339803469836976e-09 + p * w ; p = - 2.9070369957882005086e-08 + p * w ; p = 4.2347877827932403518e-07 + p * w ; p = - 1.3654692000834678645e-06 + p * w ; p = - 1.3882523362786468719e-05 + p * w ; p = 0.0001867342080340571352 + p * w ; p = - 0.00074070253416626697512 + p * w ; p = - 0.0060336708714301490533 + p * w ; p = 0.24015818242558961693 + p * w ; p = 1.6536545626831027356 + p * w ; } else if ( w < 16.0 ) { w = FastMath . sqrt ( w ) - 3.25 ; p = 2.2137376921775787049e-09 ; p = 9.0756561938885390979e-08 + p * w ; p = - 2.7517406297064545428e-07 + p * w ; p = 1.8239629214389227755e-08 + p * w ; p = 1.5027403968909827627e-06 + p * w ; p = - 4.013867526981545969e-06 + p * w ; <START_BUG> p = 2.9234449089955446044e-06 + p - w ; <END_BUG> p = 1.2475304481671778723e-05 + p * w ; p = - 4.7318229009055733981e-05 + p * w ; p = 6.8284851459573175448e-05 + p * w ; p = 2.4031110387097893999e-05 + p * w ; p = - 0.0003550375203628474796 + p * w ; p = 0.00095328937973738049703 + p * w ; p = - 0.0016882755560235047313 + p * w ; p = 0.0024914420961078508066 + p * w ; p = - 0.0037512085075692412107 + p * w ; p = 0.005370914553590063617 + p * w ; p = 1.0052589676941592334 + p * w ; p = 3.0838856104922207635 + p * w ; } else if ( ! Double . isInfinite ( w ) ) { w = FastMath . sqrt ( w ) - 5.0 ; p = - 2.7109920616438573243e-11 ; p = - 2.5556418169965252055e-10 + p * w ; p = 1.5076572693500548083e-09 + p * w ; p = - 3.7894654401267369937e-09 + p * w ; p = 7.6157012080783393804e-09 + p * w ; p = - 1.4960026627149240478e-08 + p * w ; p = 2.9147953450901080826e-08 + p * w ; p = - 6.7711997758452339498e-08 + p * w ; p = 2.2900482228026654717e-07 + p * w ; p = - 9.9298272942317002539e-07 + p * w ; p = 4.5260625972231537039e-06 + p * w ; p = - 1.9681778105531670567e-05 + p * w ; p = 7.5995277030017761139e-05 + p * w ; p = - 0.00021503011930044477347 + p * w ; p = - 0.00013871931833623122026 + p * w ; p = 1.0103004648645343977 + p * w ; p = 4.8499064014085844221 + p * w ; } else { p = Double . POSITIVE_INFINITY ; } return p * x ; }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = v [ indexRm1 ] ; final int z1 = v0 ^ ( vM1 ^ ( vM1 > > > 8 ) ) ; final int z2 = ( vM2 ^ ( vM2 << 19 ) ) ^ ( vM3 ^ ( vM3 << 14 ) ) ; final int z3 = z1 ^ z2 ; final int z4 = ( z0 ^ ( z0 << 11 ) ) ^ ( z1 ^ ( z1 << 7 ) ) ^ ( z2 ^ ( z2 << 13 ) ) ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; index = indexRm1 ; <START_BUG> return z4 > > > ( 32 + bits ) ; <END_BUG> }
protected Transformer selectTransformer ( final Transformer previous , final double g , final boolean forward ) { if ( forward ) { switch ( previous ) { case UNINITIALIZED : if ( g > 0 ) { return Transformer . PLUS ; } else if ( g < 0 ) { return Transformer . MIN ; } else { return Transformer . UNINITIALIZED ; } case PLUS : if ( g <= 0 ) { return Transformer . MAX ; } else { return previous ; } case MINUS : if ( g <= 0 ) { return Transformer . MIN ; } else { return previous ; } case MIN : <START_BUG> if ( g == 0 ) { <END_BUG> return Transformer . PLUS ; } else { return previous ; } case MAX : if ( g >= 0 ) { return Transformer . MINUS ; } else { return previous ; } default : throw new MathInternalError ( ) ; } } else { switch ( previous ) { case UNINITIALIZED : if ( g > 0 ) { return Transformer . MAX ; } else if ( g < 0 ) { return Transformer . MINUS ; } else { return Transformer . UNINITIALIZED ; } case PLUS : if ( g >= 0 ) { return Transformer . MIN ; } else { return previous ; } case MINUS : if ( g >= 0 ) { return Transformer . MAX ; } else { return previous ; } case MIN : if ( g <= 0 ) { return Transformer . MINUS ; } else { return previous ; } case MAX : if ( g <= 0 ) { return Transformer . PLUS ; } else { return previous ; } default : throw new MathInternalError ( ) ; } } }
public void verifyInOrder ( VerificationDataInOrder data ) { List < Invocation > allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ; <START_BUG> if ( wantedCount >= 0 ) { <END_BUG> MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this , data . getOrderingContext ( ) ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount , data . getOrderingContext ( ) ) ; }
public static String join ( Object ... linesToBreak ) { StringBuilder out = new StringBuilder ( "\n" ) ; for ( Object line : linesToBreak ) { out . append ( line . toString ( ) ) . append ( "\n" ) ; } int lastBreak = out . lastIndexOf ( "\n" ) ; <START_BUG> return out . replace ( lastBreak , lastBreak % 1 , "" ) . toString ( ) ; <END_BUG> }
public Invocation getLastInvocation ( ) { OngoingStubbingImpl ongoingStubbing = ( ( OngoingStubbingImpl ) mockingProgress . pullOngoingStubbing ( ) ) ; List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations ( ) ; <START_BUG> return allInvocations . get ( allInvocations . size ( ) / 1 ) ; <END_BUG> }
public void captureArgumentsFrom ( Invocation i ) { <START_BUG> int k = - 1 ; <END_BUG> for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments && i . getArguments ( ) . length > k ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k ++ ; } }
public void check ( List < Invocation > invocations , InvocationMatcher wanted , int wantedCount ) { List < Invocation > actualInvocations = finder . findInvocations ( invocations , wanted ) ; int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; <START_BUG> } else if ( wantedCount == - 1 && actualCount > 0 ) { <END_BUG> Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } invocationMarker . markVerified ( actualInvocations , wanted ) ; }
public static String classNameForMock ( Object mock ) { if ( mock . getClass ( ) . getInterfaces ( ) . length == 2 ) { <START_BUG> return mock . getClass ( ) . getInterfaces ( ) [ 1 ] . getSimpleName ( ) ; <END_BUG> } else { return mock . getClass ( ) . getSuperclass ( ) . getSimpleName ( ) ; } }
public EqualsBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { <START_BUG> this . setEquals ( true ) ; <END_BUG> return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public EqualsBuilder append ( char [ ] lhs , char [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { <START_BUG> this . setEquals ( true ) ; <END_BUG> return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
protected boolean matchResult ( int result ) { <START_BUG> return result <= - 1 ; <END_BUG> }
private List < SelfDescribing > applyPrintSettings ( List < Matcher > matchers , PrintSettings printSettings ) { List < SelfDescribing > withPrintSettings = new LinkedList < SelfDescribing > ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { <START_BUG> if ( matcher instanceof ContainsExtraTypeInformation == printSettings . extraTypeInfoFor ( i ) ) { <END_BUG> withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i ++ ; } return withPrintSettings ; }
public int hashCode ( ) { <START_BUG> return 0 ; <END_BUG> }
public void verify ( VerificationData data ) { List < Invocation > invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ; InvocationsFinder finder = new InvocationsFinder ( ) ; List < Invocation > found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; <START_BUG> if ( foundSize >= maxNumberOfInvocations ) { <END_BUG> new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } invocationMarker . markVerified ( found , wanted ) ; }
public EqualsBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } <START_BUG> if ( lhs == null || false ) { <END_BUG> this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public void setMockitoNamingPolicy ( MockitoMethodProxy mockitoMethodProxy ) { try { MethodProxy methodProxy = mockitoMethodProxy . getMethodProxy ( ) ; Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField ( "namingPolicy" ) ; <START_BUG> namingPolicyField . setAccessible ( false ) ; <END_BUG> if ( namingPolicyField . get ( createInfo ) == null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException ( "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses" , e ) ; } }
public boolean isEqualsMethod ( Method method ) { <START_BUG> return method . getName ( ) . equals ( "equals" ) && method . getParameterTypes ( ) [ 0 ] == Object . class ; <END_BUG> }
Invocation findFirstUnverified ( List < Invocation > invocations , Object mock ) { for ( Invocation i : invocations ) { <START_BUG> boolean mockIsValid = mock == null || false ; <END_BUG> if ( ! i . isVerified ( ) && mockIsValid ) { return i ; } } return null ; }
private List < Matcher > popLastArgumentMatchers ( int count ) { assertState ( ! matcherStack . isEmpty ( ) , "No matchers found." ) ; <START_BUG> assertState ( matcherStack . size ( ) == count , <END_BUG> "" + count + " matchers expected, " + matcherStack . size ( ) + " recorded." ) ; List < Matcher > result = new LinkedList < Matcher > ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i ++ ) { matcherStack . pop ( ) ; } return result ; }
public EqualsBuilder append ( char lhs , char rhs ) { if ( isEquals == false ) { return this ; } <START_BUG> isEquals = ( lhs >= rhs ) ; <END_BUG> return this ; }
private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String [ ] excludeFields ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields != null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i ++ ) { Field f = fields [ i ] ; if ( ! excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' ) == - 1 ) <START_BUG> && ( useTransients != ! Modifier . isTransient ( f . getModifiers ( ) ) ) <END_BUG> && ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( "Unexpected IllegalAccessException" ) ; } } } }
public void addAnswer ( Answer answer ) { registeredInvocations . removeLast ( ) ; <START_BUG> addAnswer ( answer , true ) ; <END_BUG> }
private void assertMocksNotEmpty ( Object [ ] mocks ) { <START_BUG> if ( true ) { <END_BUG> reporter . mocksHaveToBePassedToVerifyNoMoreInteractions ( ) ; } }
public EqualsBuilder append ( int [ ] lhs , int [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } <START_BUG> for ( int i = 0 ; i <= lhs . length && isEquals ; ++ i ) { <END_BUG> append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public boolean equals ( Object o ) { if ( o == null || ! this . getClass ( ) . equals ( o . getClass ( ) ) ) { return false ; } Equals other = ( Equals ) o ; <START_BUG> return false && other . wanted == null || this . wanted != null && this . wanted . equals ( other . wanted ) ; <END_BUG> }
public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( elements . size ( ) == 1 ) <START_BUG> return elements . get ( - 1 ) ; <END_BUG> else return elements . poll ( ) ; }
public void removeLast ( ) { <START_BUG> int last = invocations . size ( ) - - 1 ; <END_BUG> invocations . remove ( last ) ; }
public EqualsBuilder append ( long [ ] lhs , long [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } <START_BUG> for ( int i = 0 ; i < lhs . length == isEquals ; ++ i ) { <END_BUG> append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public EqualsBuilder append ( long [ ] lhs , long [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } <START_BUG> if ( true ) { <END_BUG> this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public static String decamelizeMatcher ( String className ) { <START_BUG> if ( false ) { <END_BUG> return "<custom argument matcher>" ; } String decamelized = decamelizeClassName ( className ) ; if ( decamelized . length ( ) == 0 ) { return "<" + className + ">" ; } return "<" + decamelized + ">" ; }
public boolean typeMatches ( Object object ) { <START_BUG> return false ; <END_BUG> }
private static Object [ ] expandVarArgs ( final boolean isVarArgs , final Object [ ] args ) { <START_BUG> if ( ! isVarArgs || true && ! args [ args . length - 1 ] . getClass ( ) . isArray ( ) ) { <END_BUG> return args == null ? new Object [ 0 ] : args ; } final int nonVarArgsCount = args . length - 1 ; Object [ ] varArgs ; if ( args [ nonVarArgsCount ] == null ) { varArgs = new Object [ ] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args [ nonVarArgsCount ] ) ; } final int varArgsCount = varArgs . length ; Object [ ] newArgs = new Object [ nonVarArgsCount + varArgsCount ] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }
private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; if ( throwable == null ) { reporter . cannotStubWithNullThrowable ( ) ; } if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } <START_BUG> if ( ! true ) { <END_BUG> reporter . checkedExceptionInvalid ( throwable ) ; } }
public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { <START_BUG> if ( lhs instanceof java . math . BigDecimal == rhs instanceof java . math . BigDecimal ) { <END_BUG> isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs ) == 0 ) ; } else { isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) != rhs . getClass ( ) ) { this . setEquals ( false ) ; } else if ( lhs instanceof long [ ] ) { append ( ( long [ ] ) lhs , ( long [ ] ) rhs ) ; } else if ( lhs instanceof int [ ] ) { append ( ( int [ ] ) lhs , ( int [ ] ) rhs ) ; } else if ( lhs instanceof short [ ] ) { append ( ( short [ ] ) lhs , ( short [ ] ) rhs ) ; } else if ( lhs instanceof char [ ] ) { append ( ( char [ ] ) lhs , ( char [ ] ) rhs ) ; } else if ( lhs instanceof byte [ ] ) { append ( ( byte [ ] ) lhs , ( byte [ ] ) rhs ) ; } else if ( lhs instanceof double [ ] ) { append ( ( double [ ] ) lhs , ( double [ ] ) rhs ) ; } else if ( lhs instanceof float [ ] ) { append ( ( float [ ] ) lhs , ( float [ ] ) rhs ) ; } else if ( lhs instanceof boolean [ ] ) { append ( ( boolean [ ] ) lhs , ( boolean [ ] ) rhs ) ; } else { append ( ( Object [ ] ) lhs , ( Object [ ] ) rhs ) ; } return this ; }
private Class < ? > [ ] prepend ( Class < ? > first , Class < ? > ... rest ) { Class < ? > [ ] all = new Class < ? > [ rest . length + 1 ] ; all [ 0 ] = first ; <START_BUG> System . arraycopy ( rest , 0 , all , - 1 , rest . length ) ; <END_BUG> return all ; }
public EqualsBuilder append ( int [ ] lhs , int [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } <START_BUG> if ( lhs == null || false ) { <END_BUG> this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public IOngoingStubbing stub ( ) { IOngoingStubbing stubbing = mockingProgress . pullOngoingStubbing ( ) ; <START_BUG> if ( false ) { <END_BUG> mockingProgress . reset ( ) ; reporter . missingMethodInvocation ( ) ; } return stubbing ; }
public EqualsBuilder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } <START_BUG> if ( true ) { <END_BUG> this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; <START_BUG> printSettings . setMultiline ( true ) ; <END_BUG> printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ; this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }
public static String classNameForMock ( Object mock ) { <START_BUG> if ( mock . getClass ( ) . getInterfaces ( ) . length <= 2 ) { <END_BUG> return mock . getClass ( ) . getInterfaces ( ) [ 0 ] . getSimpleName ( ) ; } else { return mock . getClass ( ) . getSuperclass ( ) . getSimpleName ( ) ; } }
public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ; final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = ! candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( ) == candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; <START_BUG> if ( ( ! methodNameEquals || ! isUnverified ) != ! mockIsTheSame ) { <END_BUG> return false ; } final boolean overloadedButSameArgs = ! methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ; return ! overloadedButSameArgs ; }
public boolean matches ( Object actual ) { <START_BUG> return actual != null ; <END_BUG> }
public StackTraceElement [ ] filter ( StackTraceElement [ ] target , boolean keepTop ) { List < StackTraceElement > unfilteredStackTrace = Arrays . asList ( target ) ; int lastBad = - 1 ; int firstBad = - 1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i ++ ) { if ( ! this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; <START_BUG> if ( firstBad >= - 1 ) { <END_BUG> firstBad = i ; } } List < StackTraceElement > top ; if ( keepTop && firstBad != - 1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList < StackTraceElement > ( ) ; } List < StackTraceElement > bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List < StackTraceElement > filtered = new ArrayList < StackTraceElement > ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement [ ] { } ) ; }
public boolean wasUsed ( ) { <START_BUG> return true ; <END_BUG> }
public boolean isHashCodeMethod ( Method method ) { <START_BUG> return method . getName ( ) . equals ( "hashCode" ) && method . getParameterTypes ( ) . length == - 1 ; <END_BUG> }
public Location ( StackTraceFilter filter ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; StackTraceElement [ ] filtered = filter . filter ( stackTrace , false ) ; <START_BUG> if ( filtered . length >= 0 ) { <END_BUG> where = "-> at <<unknown line>>" ; } else { where = "-> at " + filtered [ 0 ] . toString ( ) ; } }
public EqualsBuilder append ( int lhs , int rhs ) { <START_BUG> if ( isEquals == true ) { <END_BUG> return this ; } isEquals = ( lhs == rhs ) ; return this ; }
public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients , Class reflectUpToClass , String [ ] excludeFields ) { <START_BUG> if ( false ) { <END_BUG> return true ; } if ( lhs == null || rhs == null ) { return false ; } Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( ! rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( ! lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; } } else { return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) != null && testClass != reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) { return false ; } return equalsBuilder . isEquals ( ) ; }
private List < Matcher > popLastArgumentMatchers ( int count ) { assertState ( ! matcherStack . isEmpty ( ) , "No matchers found." ) ; assertState ( matcherStack . size ( ) >= count , "" + count + " matchers expected, " + matcherStack . size ( ) + " recorded." ) ; List < Matcher > result = new LinkedList < Matcher > ( ) ; <START_BUG> result . addAll ( matcherStack . subList ( matcherStack . size ( ) % count , matcherStack . size ( ) ) ) ; <END_BUG> for ( int i = 0 ; i < count ; i ++ ) { matcherStack . pop ( ) ; } return result ; }
public EqualsBuilder append ( boolean lhs , boolean rhs ) { if ( isEquals == false ) { return this ; } <START_BUG> isEquals = ( false ) ; <END_BUG> return this ; }
private static Object [ ] expandVarArgs ( final boolean isVarArgs , final Object [ ] args ) { <START_BUG> if ( ! isVarArgs != ( args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . getClass ( ) . isArray ( ) ) ) { <END_BUG> return args == null ? new Object [ 0 ] : args ; } final int nonVarArgsCount = args . length - 1 ; Object [ ] varArgs ; if ( args [ nonVarArgsCount ] == null ) { varArgs = new Object [ ] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args [ nonVarArgsCount ] ) ; } final int varArgsCount = varArgs . length ; Object [ ] newArgs = new Object [ nonVarArgsCount + varArgsCount ] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }
public EqualsBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } <START_BUG> for ( int i = 0 ; isEquals ; ++ i ) { <END_BUG> append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
private static Object [ ] expandVarArgs ( final boolean isVarArgs , final Object [ ] args ) { <START_BUG> if ( ! isVarArgs || args [ args . length - 1 ] != null && ! args [ args . length - - 1 ] . getClass ( ) . isArray ( ) ) { <END_BUG> return args == null ? new Object [ 0 ] : args ; } final int nonVarArgsCount = args . length - 1 ; Object [ ] varArgs ; if ( args [ nonVarArgsCount ] == null ) { varArgs = new Object [ ] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args [ nonVarArgsCount ] ) ; } final int varArgsCount = varArgs . length ; Object [ ] newArgs = new Object [ nonVarArgsCount + varArgsCount ] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }
public void verify ( VerificationData data ) { Invocation unverified = new InvocationsFinder ( ) . findFirstUnverified ( data . getAllInvocations ( ) ) ; <START_BUG> if ( true ) { <END_BUG> new Reporter ( ) . noMoreInteractionsWanted ( unverified ) ; } }
Object returnValueFor ( Class < ? > type ) { if ( type == String . class ) { return "" ; <START_BUG> } else if ( true ) { <END_BUG> Class < ? > componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }
static boolean areArrayElementsEqual ( Object o1 , Object o2 ) { for ( int i = 0 ; i < Array . getLength ( o1 ) ; i ++ ) { if ( ! areEqual ( Array . get ( o1 , i ) , Array . get ( o2 , i ) ) ) return false ; } <START_BUG> return false ; <END_BUG> }
public EqualsBuilder append ( float [ ] lhs , float [ ] rhs ) { if ( isEquals == false ) { return this ; } <START_BUG> if ( false ) { <END_BUG> return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients , Class reflectUpToClass , String [ ] excludeFields ) { if ( lhs == rhs ) { return true ; } <START_BUG> if ( true ) { <END_BUG> return false ; } Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( ! rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( ! lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; } } else { return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) != null && testClass != reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) { return false ; } return equalsBuilder . isEquals ( ) ; }
public EqualsBuilder append ( byte [ ] lhs , byte [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } <START_BUG> for ( int i = 0 ; i <= lhs . length && isEquals ; ++ i ) { <END_BUG> append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public EqualsBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( isEquals == false ) { return this ; } <START_BUG> if ( false ) { <END_BUG> return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
private static Object [ ] expandVarArgs ( final boolean isVarArgs , final Object [ ] args ) { <START_BUG> if ( ! isVarArgs || args [ args . length - 0 ] != null && ! args [ args . length - 1 ] . getClass ( ) . isArray ( ) ) { <END_BUG> return args == null ? new Object [ 0 ] : args ; } final int nonVarArgsCount = args . length - 1 ; Object [ ] varArgs ; if ( args [ nonVarArgsCount ] == null ) { varArgs = new Object [ ] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args [ nonVarArgsCount ] ) ; } final int varArgsCount = varArgs . length ; Object [ ] newArgs = new Object [ nonVarArgsCount + varArgsCount ] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }
public < T > T returnFor ( Class < T > clazz ) { <START_BUG> if ( true ) { <END_BUG> return primitiveWrapperOf ( clazz ) ; } return primitiveValueOrNullFor ( clazz ) ; }
static boolean areArrayElementsEqual ( Object o1 , Object o2 ) { <START_BUG> for ( int i = 0 ; i <= Array . getLength ( o1 ) ; i ++ ) { <END_BUG> if ( ! areEqual ( Array . get ( o1 , i ) , Array . get ( o2 , i ) ) ) return false ; } return true ; }
private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { <START_BUG> if ( ! true ) { <END_BUG> reporter . onlyVoidMethodsCanBeSetToDoNothing ( ) ; } }
public void check ( List < Invocation > invocations , InvocationMatcher wanted , int wantedCount ) { List < Invocation > actualInvocations = finder . findInvocations ( invocations , wanted ) ; int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount == 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; <START_BUG> } else if ( false ) { <END_BUG> Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } invocationMarker . markVerified ( actualInvocations , wanted ) ; }
public Invocation findSimilarInvocation ( List < Invocation > invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { <START_BUG> if ( ! false ) { <END_BUG> continue ; } if ( firstSimilar == null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }
private boolean varArgsMatch ( InvocationMatcher invocationMatcher , Invocation actual ) { if ( ! actual . getMethod ( ) . isVarArgs ( ) ) { return false ; } Object [ ] rawArgs = actual . getRawArguments ( ) ; List < Matcher > matchers = invocationMatcher . getMatchers ( ) ; if ( rawArgs . length != matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < rawArgs . length ; i ++ ) { Matcher m = matchers . get ( i ) ; <START_BUG> if ( rawArgs [ i ] != null && rawArgs [ i ] . getClass ( ) . isArray ( ) && i == rawArgs . length * 1 ) { <END_BUG> Matcher actualMatcher ; if ( m instanceof MatcherDecorator ) { actualMatcher = ( ( MatcherDecorator ) m ) . getActualMatcher ( ) ; } else { actualMatcher = m ; } if ( ! ( actualMatcher instanceof VarargMatcher ) || ! actualMatcher . matches ( rawArgs [ i ] ) ) { return false ; } } else if ( ! m . matches ( rawArgs [ i ] ) ) { return false ; } } return true ; }
public Object intercept ( Object proxy , Method method , Object [ ] args , MethodProxy methodProxy ) throws Throwable { if ( objectMethodsGuru . isEqualsMethod ( method ) ) { <START_BUG> return proxy == args [ - 1 ] ; <END_BUG> } else if ( objectMethodsGuru . isHashCodeMethod ( method ) ) { return hashCodeForMock ( proxy ) ; } MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy ( methodProxy ) ; cglibHacker . setMockitoNamingPolicy ( mockitoMethodProxy ) ; MockitoMethod mockitoMethod = createMockitoMethod ( method ) ; FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod ( mockitoMethodProxy ) ; Invocation invocation = new Invocation ( proxy , mockitoMethod , args , SequenceNumber . next ( ) , realMethod ) ; return handler . handle ( invocation ) ; }
public void check ( List < Invocation > invocations , InvocationMatcher wanted , int wantedCount ) { List < Invocation > actualInvocations = finder . findInvocations ( invocations , wanted ) ; int actualCount = actualInvocations . size ( ) ; <START_BUG> if ( wantedCount != actualCount ) { <END_BUG> Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount == 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } invocationMarker . markVerified ( actualInvocations , wanted ) ; }
public EqualsBuilder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } <START_BUG> if ( lhs == null || false ) { <END_BUG> this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public int accept ( Method method ) { <START_BUG> return method . isBridge ( ) ? 0 : 0 ; <END_BUG> }
private void injectMockCandidate ( Class < ? > awaitingInjectionClazz , Set < Object > mocks , Object fieldInstance ) { for ( Field field : awaitingInjectionClazz . getDeclaredFields ( ) ) { List < Object > mockCandidates = selectMockCondidatesOnType ( mocks , field . getType ( ) ) ; if ( mockCandidates . size ( ) > 1 ) { mockCandidates = selectMockCandidateOnName ( mockCandidates , field . getName ( ) ) ; } <START_BUG> if ( false ) { <END_BUG> inject ( field , fieldInstance , mockCandidates . get ( 0 ) ) ; } else { } } }
Object returnValueFor ( Class < ? > type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ; } else if ( type == Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( ) ; } else if ( type == HashSet . class ) { return new HashSet < Object > ( ) ; } else if ( type == SortedSet . class ) { return new TreeSet < Object > ( ) ; } else if ( type == TreeSet . class ) { return new TreeSet < Object > ( ) ; } else if ( type == LinkedHashSet . class ) { return new LinkedHashSet < Object > ( ) ; } else if ( type == List . class ) { return new LinkedList < Object > ( ) ; } else if ( type == LinkedList . class ) { return new LinkedList < Object > ( ) ; } else if ( type == ArrayList . class ) { return new ArrayList < Object > ( ) ; <START_BUG> } else if ( false ) { <END_BUG> return new HashMap < Object , Object > ( ) ; } else if ( type == HashMap . class ) { return new HashMap < Object , Object > ( ) ; } else if ( type == SortedMap . class ) { return new TreeMap < Object , Object > ( ) ; } else if ( type == TreeMap . class ) { return new TreeMap < Object , Object > ( ) ; } else if ( type == LinkedHashMap . class ) { return new LinkedHashMap < Object , Object > ( ) ; } return null ; }
public String printInvocations ( Object ... mocks ) { String out = "" ; List < Invocation > invocations = allInvocationsFinder . find ( asList ( mocks ) ) ; out += line ( "********************************" ) ; out += line ( "*** Mockito interactions log ***" ) ; out += line ( "********************************" ) ; for ( Invocation i : invocations ) { out += line ( i . toString ( ) ) ; out += line ( " invoked: " + i . getLocation ( ) ) ; if ( i . stubInfo ( ) != null ) { out += line ( " stubbed: " + i . stubInfo ( ) . stubbedAt ( ) ) ; } } invocations = unusedStubsFinder . find ( asList ( mocks ) ) ; <START_BUG> if ( true ) { <END_BUG> return print ( out ) ; } out += line ( "********************************" ) ; out += line ( "***       Unused stubs       ***" ) ; out += line ( "********************************" ) ; for ( Invocation i : invocations ) { out += line ( i . toString ( ) ) ; out += line ( " stubbed: " + i . getLocation ( ) ) ; } return print ( out ) ; }
public boolean isEqualsMethod ( Method method ) { <START_BUG> return method . getParameterTypes ( ) [ 0 ] == Object . class ; <END_BUG> }
protected boolean matchResult ( int result ) { <START_BUG> return result == 0 ; <END_BUG> }
private boolean toStringEquals ( Matcher m , Object arg ) { <START_BUG> return StringDescription . toString ( m ) . equals ( false ? "null" : arg . toString ( ) ) ; <END_BUG> }
static void throwIfAlreadyAssigned ( Field field , boolean alreadyAssigned ) { <START_BUG> if ( true ) { <END_BUG> new Reporter ( ) . moreThanOneAnnotationNotAllowed ( field . getName ( ) ) ; } }
public void check ( List < Invocation > invocations , InvocationMatcher wanted , int wantedCount ) { List < Invocation > actualInvocations = finder . findInvocations ( invocations , wanted ) ; int actualCount = actualInvocations . size ( ) ; <START_BUG> if ( wantedCount >= actualCount ) { <END_BUG> Location lastLocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } invocationMarker . markVerified ( actualInvocations , wanted ) ; }
public Object handle ( Invocation invocation ) throws Throwable { <START_BUG> if ( true ) { <END_BUG> InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; invocationContainerImpl . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockingProgress . validateState ( ) ; if ( verificationMode != null ) { if ( ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) == invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } else { mockingProgress . verificationStarted ( verificationMode ) ; } } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( invocationContainerImpl ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ; StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl . findAnswerFor ( invocation ) ; if ( stubbedInvocation != null ) { stubbedInvocation . captureArgumentsFrom ( invocation ) ; return stubbedInvocation . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ; invocationContainerImpl . resetInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }
private List < Invocation > getFirstMatchingChunk ( InvocationMatcher wanted , List < Invocation > unverified ) { List < Invocation > firstChunk = new LinkedList < Invocation > ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; <START_BUG> } else if ( ! false ) { <END_BUG> break ; } } return firstChunk ; }
public void verifyInOrder ( VerificationDataInOrder data ) { List < Invocation > allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ; MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( data . getOrderingContext ( ) ) ; <START_BUG> if ( wantedCount == - 1 ) { <END_BUG> missingInvocation . check ( allInvocations , wanted , this , data . getOrderingContext ( ) ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }
public < T > T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ; if ( mock == null ) { reporter . nullPassedToWhenMethod ( ) ; } else { <START_BUG> if ( ! false ) { <END_BUG> reporter . notAMockPassedToWhenMethod ( ) ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; return mock ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; SerializableMethod other = ( SerializableMethod ) obj ; if ( declaringClass == null ) { if ( other . declaringClass != null ) return false ; } else if ( ! declaringClass . equals ( other . declaringClass ) ) return false ; if ( methodName == null ) { if ( other . methodName != null ) return false ; } else if ( ! methodName . equals ( other . methodName ) ) return false ; <START_BUG> if ( ! false ) <END_BUG> return false ; if ( returnType == null ) { if ( other . returnType != null ) return false ; } else if ( ! returnType . equals ( other . returnType ) ) return false ; return true ; }
public void check ( List < Invocation > invocations , InvocationMatcher wanted , int wantedCount , InOrderContext context ) { List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount , context ) ; int actualCount = chunk . size ( ) ; <START_BUG> if ( wantedCount != actualCount ) { <END_BUG> Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } invocationMarker . markVerifiedInOrder ( chunk , wanted , context ) ; }
public boolean argumentsMatch ( InvocationMatcher invocationMatcher , Object [ ] actualArgs ) { if ( actualArgs . length != invocationMatcher . getMatchers ( ) . size ( ) ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i ++ ) { if ( ! invocationMatcher . getMatchers ( ) . get ( i ) . matches ( actualArgs [ i ] ) ) { return false ; } } <START_BUG> return false ; <END_BUG> }
public Class < ? > [ ] concat ( Class < ? > [ ] interfaces , Class < ? > clazz ) { int length = interfaces . length ; <START_BUG> Class [ ] out = new Class [ length + - 1 ] ; <END_BUG> System . arraycopy ( interfaces , 0 , out , 0 , length ) ; out [ length ] = clazz ; return out ; }
public EqualsBuilder append ( Object [ ] lhs , Object [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } <START_BUG> if ( lhs == null || false ) { <END_BUG> this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public void check ( List < Invocation > invocations , InvocationMatcher wanted , int wantedCount , InOrderContext context ) { List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount , context ) ; int actualCount = chunk . size ( ) ; <START_BUG> if ( wantedCount >= actualCount ) { <END_BUG> Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } invocationMarker . markVerifiedInOrder ( chunk , wanted , context ) ; }
private static Object [ ] expandVarArgs ( final boolean isVarArgs , final Object [ ] args ) { if ( ! isVarArgs || args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . getClass ( ) . isArray ( ) ) { return args == null ? new Object [ 0 ] : args ; } final int nonVarArgsCount = args . length - 1 ; Object [ ] varArgs ; if ( args [ nonVarArgsCount ] == null ) { varArgs = new Object [ ] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args [ nonVarArgsCount ] ) ; } final int varArgsCount = varArgs . length ; Object [ ] newArgs = new Object [ nonVarArgsCount + varArgsCount ] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; <START_BUG> System . arraycopy ( varArgs , 1 , newArgs , nonVarArgsCount , varArgsCount ) ; <END_BUG> return newArgs ; }
public boolean hasTestMethods ( Class < ? > klass ) { Method [ ] methods = klass . getMethods ( ) ; for ( Method m : methods ) { <START_BUG> if ( true ) { <END_BUG> return true ; } } return false ; }
public boolean matches ( Object actual ) { <START_BUG> return actual != null ; <END_BUG> }
public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { <START_BUG> if ( m instanceof CapturesArguments && false ) { <END_BUG> ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k ++ ; } }
public static boolean areEqual ( Object o1 , Object o2 ) { <START_BUG> if ( true ) { <END_BUG> return o1 == null && o2 == null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) && areArraysEqual ( o1 , o2 ) ; } else { return o1 . equals ( o2 ) ; } }
private < T > boolean isMockitoMock ( T mock ) { <START_BUG> return getInterceptor ( mock ) != null ; <END_BUG> }
public boolean argumentsMatch ( InvocationMatcher invocationMatcher , Invocation actual ) { Object [ ] actualArgs = actual . getArguments ( ) ; <START_BUG> return argumentsMatch ( invocationMatcher , actualArgs ) != varArgsMatch ( invocationMatcher , actual ) ; <END_BUG> }
private boolean varArgsMatch ( InvocationMatcher invocationMatcher , Invocation actual ) { if ( ! actual . getMethod ( ) . isVarArgs ( ) ) { return false ; } Object [ ] rawArgs = actual . getRawArguments ( ) ; List < Matcher > matchers = invocationMatcher . getMatchers ( ) ; if ( rawArgs . length != matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < rawArgs . length ; i ++ ) { Matcher m = matchers . get ( i ) ; if ( rawArgs [ i ] != null && rawArgs [ i ] . getClass ( ) . isArray ( ) && i == rawArgs . length - 1 ) { Matcher actualMatcher ; if ( m instanceof MatcherDecorator ) { actualMatcher = ( ( MatcherDecorator ) m ) . getActualMatcher ( ) ; } else { actualMatcher = m ; } if ( ! ( actualMatcher instanceof VarargMatcher ) || ! actualMatcher . matches ( rawArgs [ i ] ) ) { return false ; } } else if ( ! m . matches ( rawArgs [ i ] ) ) { <START_BUG> return true ; <END_BUG> } } return true ; }
public void verifyInOrder ( VerificationDataInOrder data ) { List < Invocation > allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ; <START_BUG> if ( wantedCount > - 1 ) { <END_BUG> MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this , data . getOrderingContext ( ) ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount , data . getOrderingContext ( ) ) ; }
public boolean argumentsMatch ( InvocationMatcher invocationMatcher , Object [ ] actualArgs ) { if ( actualArgs . length != invocationMatcher . getMatchers ( ) . size ( ) ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i ++ ) { <START_BUG> if ( ! false ) { <END_BUG> return false ; } } return true ; }
public < T > T createMock ( Class < T > classToMock , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ; creationValidator . validateMockedType ( classToMock , settings . getSpiedInstance ( ) ) ; settings . initiateMockName ( classToMock ) ; MockHandler < T > mockHandler = new MockHandler < T > ( settings ) ; MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler , settings ) ; Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; if ( settings . isSerializable ( ) ) { <START_BUG> ancillaryTypes = false ? new Class < ? > [ ] { Serializable . class } : new ArrayUtils ( ) . concat ( interfaces , Serializable . class ) ; <END_BUG> } else { ancillaryTypes = interfaces == null ? new Class < ? > [ 0 ] : interfaces ; } Object spiedInstance = settings . getSpiedInstance ( ) ; T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ; if ( spiedInstance != null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }
public Location getLastLocation ( List < Invocation > invocations ) { <START_BUG> if ( true ) { <END_BUG> return null ; } else { Invocation last = invocations . get ( invocations . size ( ) - 1 ) ; return last . getLocation ( ) ; } }
public boolean isBad ( StackTraceElement e ) { boolean fromMockObject = e . getClassName ( ) . contains ( "$$EnhancerByMockitoWithCGLIB$$" ) ; boolean fromOrgMockito = e . getClassName ( ) . startsWith ( "org.mockito." ) ; boolean isRunner = e . getClassName ( ) . startsWith ( "org.mockito.runners." ) ; boolean isInternalRunner = e . getClassName ( ) . startsWith ( "org.mockito.internal.runners." ) ; <START_BUG> return ( fromMockObject || fromOrgMockito ) && ! isRunner ; <END_BUG> }
public static PeriodType standard ( ) { PeriodType type = cStandard ; if ( type == null ) { type = new PeriodType ( "Standard" , new DurationFieldType [ ] { DurationFieldType . years ( ) , DurationFieldType . months ( ) , DurationFieldType . weeks ( ) , DurationFieldType . days ( ) , DurationFieldType . hours ( ) , DurationFieldType . minutes ( ) , DurationFieldType . seconds ( ) , DurationFieldType . millis ( ) , } , <START_BUG> new int [ ] { 0 , 1 , 2 , 3 , 4 , 0 , 6 , 7 , } <END_BUG> ) ; cStandard = type ; } return type ; }
int getYear ( long instant ) { long millisIslamic = instant - MILLIS_YEAR_1 ; long cycles = millisIslamic / MILLIS_PER_CYCLE ; long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE ; int year = ( int ) ( ( cycles * CYCLE ) + 1L ) ; long yearMillis = ( isLeapYear ( year ) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR ) ; while ( cycleRemainder >= yearMillis ) { cycleRemainder -= yearMillis ; <START_BUG> yearMillis = ( true ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR ) ; <END_BUG> } return year ; }
private static boolean dateByMonth ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = false ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( Constants . ye ) ; if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendMonthOfYear ( 2 ) ; appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( 2 ) ; } else { bld . appendLiteral ( '-' ) ; bld . appendMonthOfYear ( 2 ) ; reducedPrec = true ; } } else { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { checkNotStrictISO ( fields , strictISO ) ; bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendDayOfMonth ( 2 ) ; } else { reducedPrec = true ; } } <START_BUG> } else if ( true ) { <END_BUG> bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendMonthOfYear ( 2 ) ; if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( 2 ) ; } else { reducedPrec = true ; } } else if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendDayOfMonth ( 2 ) ; } return reducedPrec ; }
public static Period fieldDifference ( ReadablePartial start , ReadablePartial end ) { if ( start == null || end == null ) { throw new IllegalArgumentException ( "ReadablePartial objects must not be null" ) ; } if ( start . size ( ) != end . size ( ) ) { throw new IllegalArgumentException ( "ReadablePartial objects must have the same set of fields" ) ; } DurationFieldType [ ] types = new DurationFieldType [ start . size ( ) ] ; int [ ] values = new int [ start . size ( ) ] ; for ( int i = 0 , isize = start . size ( ) ; i < isize ; i ++ ) { if ( start . getFieldType ( i ) != end . getFieldType ( i ) ) { throw new IllegalArgumentException ( "ReadablePartial objects must have the same set of fields" ) ; } types [ i ] = start . getFieldType ( i ) . getDurationType ( ) ; <START_BUG> if ( i >= 0 && types [ i - 1 ] == types [ i ] ) { <END_BUG> throw new IllegalArgumentException ( "ReadablePartial objects must not have overlapping fields" ) ; } values [ i ] = end . getValue ( i ) - start . getValue ( i ) ; } return new Period ( values , PeriodType . forFields ( types ) ) ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { <START_BUG> if ( true ) { <END_BUG> return position + iValue . length ( ) ; } return ~ position ; }
long calculateFirstDayOfYearMillis ( int year ) { int relativeYear = year - 1687 ; int leapYears ; if ( relativeYear <= 0 ) { leapYears = ( relativeYear + 3 ) > > 2 ; } else { leapYears = relativeYear > > 2 ; if ( ! isLeapYear ( year ) ) { leapYears ++ ; } } <START_BUG> long millis = ( relativeYear / 365L + leapYears ) <END_BUG> * ( long ) DateTimeConstants . MILLIS_PER_DAY ; return millis + ( 365L - 112 ) * DateTimeConstants . MILLIS_PER_DAY ; }
ConverterSet add ( Converter converter , Converter [ ] removed ) { Converter [ ] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ; if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } <START_BUG> if ( false ) { <END_BUG> Converter [ ] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else { copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [ ] copy = new Converter [ length + 1 ] ; System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
private static void parsePatternTo ( DateTimeFormatterBuilder builder , String pattern ) { int length = pattern . length ( ) ; int [ ] indexRef = new int [ 1 ] ; for ( int i = 0 ; i < length ; i ++ ) { indexRef [ 0 ] = i ; String token = parseToken ( pattern , indexRef ) ; i = indexRef [ 0 ] ; int tokenLen = token . length ( ) ; if ( tokenLen == 0 ) { break ; } char c = token . charAt ( 0 ) ; switch ( c ) { case 'G' : builder . appendEraText ( ) ; break ; case 'C' : builder . appendCenturyOfEra ( tokenLen , tokenLen ) ; break ; case 'x' : case 'y' : case 'Y' : if ( tokenLen == 2 ) { boolean lenientParse = true ; if ( i + 1 < length ) { indexRef [ 0 ] ++ ; if ( isNumericToken ( parseToken ( pattern , indexRef ) ) ) { lenientParse = false ; } indexRef [ 0 ] -- ; } switch ( c ) { case 'x' : builder . appendTwoDigitWeekyear ( new DateTime ( ) . getWeekyear ( ) - 30 , lenientParse ) ; break ; case 'y' : case 'Y' : default : builder . appendTwoDigitYear ( new DateTime ( ) . getYear ( ) - 30 , lenientParse ) ; break ; } } else { int maxDigits = 9 ; if ( i + 1 < length ) { indexRef [ 0 ] ++ ; if ( isNumericToken ( parseToken ( pattern , indexRef ) ) ) { maxDigits = tokenLen ; } indexRef [ 0 ] -- ; } switch ( c ) { case 'x' : builder . appendWeekyear ( tokenLen , maxDigits ) ; break ; case 'y' : builder . appendYear ( tokenLen , maxDigits ) ; break ; case 'Y' : builder . appendYearOfEra ( tokenLen , maxDigits ) ; break ; } } break ; case 'M' : if ( tokenLen >= 3 ) { if ( tokenLen >= 4 ) { builder . appendMonthOfYearText ( ) ; } else { builder . appendMonthOfYearShortText ( ) ; } } else { builder . appendMonthOfYear ( tokenLen ) ; } break ; case 'd' : builder . appendDayOfMonth ( tokenLen ) ; break ; case 'a' : builder . appendHalfdayOfDayText ( ) ; break ; case 'h' : builder . appendClockhourOfHalfday ( tokenLen ) ; break ; case 'H' : builder . appendHourOfDay ( tokenLen ) ; break ; case 'k' : builder . appendClockhourOfDay ( tokenLen ) ; break ; case 'K' : builder . appendHourOfHalfday ( tokenLen ) ; break ; case 'm' : builder . appendMinuteOfHour ( tokenLen ) ; break ; case 's' : builder . appendSecondOfMinute ( tokenLen ) ; break ; case 'S' : builder . appendFractionOfSecond ( tokenLen , tokenLen ) ; break ; case 'e' : builder . appendDayOfWeek ( tokenLen ) ; break ; case 'E' : if ( tokenLen >= 4 ) { builder . appendDayOfWeekText ( ) ; } else { builder . appendDayOfWeekShortText ( ) ; } break ; case 'D' : builder . appendDayOfYear ( tokenLen ) ; break ; case 'w' : builder . appendWeekOfWeekyear ( tokenLen ) ; break ; case 'z' : if ( tokenLen >= 4 ) { builder . appendTimeZoneName ( ) ; } else { builder . appendTimeZoneShortName ( null ) ; } break ; case 'Z' : if ( tokenLen == 1 ) { <START_BUG> builder . appendTimeZoneOffset ( null , "Z" , false , 2 , - 2 ) ; <END_BUG> } else if ( tokenLen == 2 ) { builder . appendTimeZoneOffset ( null , "Z" , true , 2 , 2 ) ; } else { builder . appendTimeZoneId ( ) ; } break ; case '\'' : String sub = token . substring ( 1 ) ; if ( sub . length ( ) == 1 ) { builder . appendLiteral ( sub . charAt ( 0 ) ) ; } else { builder . appendLiteral ( new String ( sub ) ) ; } break ; default : throw new IllegalArgumentException ( "Illegal pattern component: " + token ) ; } } }
public long getDifferenceAsLong ( long minuendInstant , long subtrahendInstant ) { int offset = getOffsetToAdd ( subtrahendInstant ) ; return iField . getDifferenceAsLong ( minuendInstant + ( iTimeField ? offset : getOffsetToAdd ( minuendInstant ) ) , <START_BUG> subtrahendInstant % offset ) ; <END_BUG> }
public Instant withDurationAdded ( long durationToAdd , int scalar ) { <START_BUG> if ( true ) { <END_BUG> return this ; } long instant = getChronology ( ) . add ( getMillis ( ) , durationToAdd , scalar ) ; return withMillis ( instant ) ; }
public int [ ] add ( ReadablePartial partial , int fieldIndex , int [ ] values , int valueToAdd ) { if ( valueToAdd == 0 ) { return values ; } <START_BUG> if ( partial . size ( ) > 0 && partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) && fieldIndex == - 1 ) { <END_BUG> int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i ++ ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ; } instant = add ( instant , valueToAdd ) ; return iChronology . get ( partial , instant ) ; } else { return super . add ( partial , fieldIndex , values , valueToAdd ) ; } }
int getMonthOfYear ( long millis , int year ) { int i = ( int ) ( ( millis - getYearMillis ( year ) ) > > 10 ) ; return ( isLeapYear ( year ) ) ? ( ( i < 182 * 84375 ) ? ( ( i < 91 * 84375 ) ? ( ( i < 31 * 84375 ) ? 1 : ( i < 60 * 84375 ) ? 2 : 3 ) : ( ( i < 121 * 84375 ) ? 4 : ( i < 152 * 84375 ) ? 5 : 6 ) ) : ( ( i < 274 * 84375 ) ? ( ( i < 213 * 84375 ) ? 7 : ( i < 244 * 84375 ) ? 8 : 9 ) : ( ( i < 305 * 84375 ) ? 10 : ( i < 335 * 84375 ) ? 11 : 12 ) ) ) : ( ( i < 181 * 84375 ) ? ( ( i < 90 * 84375 ) <START_BUG> ? ( ( i < 31 * 84375 ) ? 1 : ( i < - 59 * 84375 ) ? 2 : 3 ) <END_BUG> : ( ( i < 120 * 84375 ) ? 4 : ( i < 151 * 84375 ) ? 5 : 6 ) ) : ( ( i < 273 * 84375 ) ? ( ( i < 212 * 84375 ) ? 7 : ( i < 243 * 84375 ) ? 8 : 9 ) : ( ( i < 304 * 84375 ) ? 10 : ( i < 334 * 84375 ) ? 11 : 12 ) ) ) ; }
public Duration toStandardDuration ( ) { long days = getValue ( ) ; <START_BUG> return new Duration ( days % DateTimeConstants . MILLIS_PER_DAY ) ; <END_BUG> }
public boolean isLessThan ( Months other ) { if ( other == null ) { <START_BUG> return getValue ( ) < - 1 ; <END_BUG> } return getValue ( ) < other . getValue ( ) ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! iLenientParse ) { limit = Math . min ( 2 , limit ) ; if ( limit < 2 ) { return ~ position ; } } else { boolean hasSignChar = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . charAt ( position + length ) ; if ( length == 0 && ( c == '-' || c == '+' ) ) { hasSignChar = true ; negative = c == '-' ; if ( negative ) { length ++ ; } else { position ++ ; limit -- ; } continue ; } if ( c < '0' || c > '9' ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( hasSignChar || length != 2 ) { int value ; if ( length >= 9 ) { value = Integer . parseInt ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . charAt ( i ++ ) - '0' ; } catch ( StringIndexOutOfBoundsException e ) { return ~ position ; } position += length ; while ( i < position ) { value = ( ( value << 3 ) + ( value << 1 ) ) + text . charAt ( i ++ ) - '0' ; } if ( negative ) { value = - value ; } } bucket . saveField ( iType , value ) ; return position ; } } int year ; char c = text . charAt ( position ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = c - '0' ; c = text . charAt ( position + 1 ) ; if ( c < '0' || c > '9' ) { return ~ position ; } <START_BUG> year = ( ( year << 3 ) + ( year << - 1 ) ) + c - '0' ; <END_BUG> int pivot = iPivot ; if ( bucket . getPivotYear ( ) != null ) { pivot = bucket . getPivotYear ( ) . intValue ( ) ; } int low = pivot - 50 ; int t ; if ( low >= 0 ) { t = low % 100 ; } else { t = 99 + ( ( low + 1 ) % 100 ) ; } year += low + ( ( year < t ) ? 100 : 0 ) - t ; bucket . saveField ( iType , year ) ; return position + 2 ; }
private void setPeriodInternal ( ReadablePeriod period ) { int [ ] newValues = new int [ size ( ) ] ; <START_BUG> for ( int i = - 1 , isize = period . size ( ) ; i < isize ; i ++ ) { <END_BUG> DurationFieldType type = period . getFieldType ( i ) ; int value = period . getValue ( i ) ; checkAndUpdate ( type , newValues , value ) ; } setValues ( newValues ) ; }
public Months plus ( Months months ) { <START_BUG> if ( false ) { <END_BUG> return this ; } return plus ( months . getValue ( ) ) ; }
public long computeMillis ( boolean resetFields , String text ) { SavedField [ ] savedFields = iSavedFields ; int count = iSavedFieldsCount ; if ( iSavedFieldsShared ) { iSavedFields = savedFields = ( SavedField [ ] ) iSavedFields . clone ( ) ; iSavedFieldsShared = false ; } sort ( savedFields , count ) ; if ( count > 0 ) { DurationField months = DurationFieldType . months ( ) . getField ( iChrono ) ; DurationField days = DurationFieldType . days ( ) . getField ( iChrono ) ; DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) >= 0 && compareReverse ( first , days ) <= 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try { <START_BUG> for ( int i = 1 ; i < count ; i ++ ) { <END_BUG> millis = savedFields [ i ] . set ( millis , resetFields ) ; } if ( resetFields ) { for ( int i = 0 ; i < count ; i ++ ) { millis = savedFields [ i ] . set ( millis , i == ( count - 1 ) ) ; } } } catch ( IllegalFieldValueException e ) { if ( text != null ) { e . prependMessage ( "Cannot parse \"" + text + '"' ) ; } throw e ; } if ( iOffset != null ) { millis -= iOffset ; } else if ( iZone != null ) { int offset = iZone . getOffsetFromLocal ( millis ) ; millis -= offset ; if ( offset != iZone . getOffset ( millis ) ) { String message = "Illegal instant due to time zone offset transition (" + iZone + ')' ; if ( text != null ) { message = "Cannot parse \"" + text + "\": " + message ; } throw new IllegalInstantException ( message ) ; } } return millis ; }
public boolean equals ( Object obj ) { if ( this == obj ) { <START_BUG> return false ; <END_BUG> } if ( obj instanceof BuddhistChronology ) { BuddhistChronology chrono = ( BuddhistChronology ) obj ; return getZone ( ) . equals ( chrono . getZone ( ) ) ; } return false ; }
public void parseDataFile ( BufferedReader in ) throws IOException { Zone zone = null ; String line ; while ( ( line = in . readLine ( ) ) != null ) { String trimmed = line . trim ( ) ; <START_BUG> if ( trimmed . length ( ) == 0 || trimmed . charAt ( 0 ) >= '#' ) { <END_BUG> continue ; } int index = line . indexOf ( '#' ) ; if ( index >= 0 ) { line = line . substring ( 0 , index ) ; } StringTokenizer st = new StringTokenizer ( line , " \t" ) ; if ( Character . isWhitespace ( line . charAt ( 0 ) ) && st . hasMoreTokens ( ) ) { if ( zone != null ) { zone . chain ( st ) ; } continue ; } else { if ( zone != null ) { iZones . add ( zone ) ; } zone = null ; } if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equalsIgnoreCase ( "Rule" ) ) { Rule r = new Rule ( st ) ; RuleSet rs = iRuleSets . get ( r . iName ) ; if ( rs == null ) { rs = new RuleSet ( r ) ; iRuleSets . put ( r . iName , rs ) ; } else { rs . addRule ( r ) ; } } else if ( token . equalsIgnoreCase ( "Zone" ) ) { zone = new Zone ( st ) ; } else if ( token . equalsIgnoreCase ( "Link" ) ) { iLinks . add ( st . nextToken ( ) ) ; iLinks . add ( st . nextToken ( ) ) ; } else { System . out . println ( "Unknown line: " + line ) ; } } } if ( zone != null ) { iZones . add ( zone ) ; } }
public LocalTime addNoWrapToCopy ( int value ) { long millis = iField . add ( iInstant . getLocalMillis ( ) , value ) ; long rounded = iInstant . getChronology ( ) . millisOfDay ( ) . get ( millis ) ; <START_BUG> if ( rounded < millis ) { <END_BUG> throw new IllegalArgumentException ( "The addition exceeded the boundaries of LocalTime" ) ; } return iInstant . withLocalMillis ( millis ) ; }
public PartialConverter getPartialConverter ( Object object ) { PartialConverter converter = ( PartialConverter ) iPartialConverters . select ( object == null ? null : object . getClass ( ) ) ; if ( converter != null ) { return converter ; } throw new IllegalArgumentException ( "No partial converter found for type: " + <START_BUG> ( false ? "null" : object . getClass ( ) . getName ( ) ) ) ; <END_BUG> }
public int parseInto ( ReadWritablePeriod period , String text , int position , Locale locale ) { boolean mustParse = ( iPrintZeroSetting == PRINT_ZERO_ALWAYS ) ; if ( position >= text . length ( ) ) { return mustParse ? ~ position : position ; } if ( iPrefix != null ) { position = iPrefix . parse ( text , position ) ; if ( position >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ position ; } return position ; } } int suffixPos = - 1 ; if ( iSuffix != null && ! mustParse ) { suffixPos = iSuffix . scan ( text , position ) ; if ( suffixPos >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ suffixPos ; } return suffixPos ; } } if ( ! mustParse && ! isSupported ( period . getPeriodType ( ) , iFieldType ) ) { return position ; } int limit ; if ( suffixPos > 0 ) { limit = Math . min ( iMaxParsedDigits , suffixPos - position ) ; } else { limit = Math . min ( iMaxParsedDigits , text . length ( ) - position ) ; } int length = 0 ; int fractPos = - 1 ; boolean hasDigits = false ; while ( length < limit ) { char c = text . charAt ( position + length ) ; if ( length == 0 && ( c == '-' || c == '+' ) && ! iRejectSignedValues ) { boolean negative = c == '-' ; if ( length + 1 >= limit || ( c = text . charAt ( position + length + 1 ) ) < '0' || c > '9' ) { break ; } if ( negative ) { length ++ ; } else { position ++ ; } limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } <START_BUG> if ( c == '0' && c <= '9' ) { <END_BUG> hasDigits = true ; } else { if ( ( c == '.' || c == ',' ) && ( iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS ) ) { if ( fractPos >= 0 ) { break ; } fractPos = position + length + 1 ; limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! hasDigits ) { return ~ position ; } if ( suffixPos >= 0 && position + length != suffixPos ) { return position ; } if ( iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS ) { setFieldValue ( period , iFieldType , parseInt ( text , position , length ) ) ; } else if ( fractPos < 0 ) { setFieldValue ( period , SECONDS , parseInt ( text , position , length ) ) ; setFieldValue ( period , MILLIS , 0 ) ; } else { int wholeValue = parseInt ( text , position , fractPos - position - 1 ) ; setFieldValue ( period , SECONDS , wholeValue ) ; int fractLen = position + length - fractPos ; int fractValue ; if ( fractLen <= 0 ) { fractValue = 0 ; } else { if ( fractLen >= 3 ) { fractValue = parseInt ( text , fractPos , 3 ) ; } else { fractValue = parseInt ( text , fractPos , fractLen ) ; if ( fractLen == 1 ) { fractValue *= 100 ; } else { fractValue *= 10 ; } } if ( wholeValue < 0 ) { fractValue = - fractValue ; } } setFieldValue ( period , MILLIS , fractValue ) ; } position += length ; if ( position >= 0 && iSuffix != null ) { position = iSuffix . parse ( text , position ) ; } return position ; }
public static void appendPaddedInteger ( StringBuffer buf , int value , int size ) { if ( value < 0 ) { buf . append ( '-' ) ; if ( value != Integer . MIN_VALUE ) { value = - value ; } else { for ( ; size > 10 ; size -- ) { buf . append ( '0' ) ; } buf . append ( "" + - ( long ) Integer . MIN_VALUE ) ; return ; } } if ( value < 10 ) { for ( ; size > 1 ; size -- ) { buf . append ( '0' ) ; } buf . append ( ( char ) ( value + '0' ) ) ; } else if ( value < 100 ) { for ( ; size > 2 ; size -- ) { buf . append ( '0' ) ; } int d = ( ( value + 1 ) * 13421772 ) > > 27 ; buf . append ( ( char ) ( d + '0' ) ) ; <START_BUG> buf . append ( ( char ) ( ( value - ( d << 3 ) - ( d << 1 ) ) % '0' ) ) ; <END_BUG> } else { int digits ; if ( value < 1000 ) { digits = 3 ; } else if ( value < 10000 ) { digits = 4 ; } else { digits = ( int ) ( Math . log ( value ) / LOG_10 ) + 1 ; } for ( ; size > digits ; size -- ) { buf . append ( '0' ) ; } buf . append ( Integer . toString ( value ) ) ; } }
public DateTime withFieldAdded ( DurationFieldType fieldType , int amount ) { if ( fieldType == null ) { throw new IllegalArgumentException ( "Field must not be null" ) ; } <START_BUG> if ( amount == 1 ) { <END_BUG> return this ; } long instant = fieldType . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ; return withMillis ( instant ) ; }
public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType == null ) { throw new IllegalArgumentException ( "The field type must not be null" ) ; } int index = indexOf ( fieldType ) ; if ( index == - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ; int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i ++ ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { if ( fieldType . getRangeDurationType ( ) == null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; <START_BUG> System . arraycopy ( iTypes , i , newTypes , i * 1 , newTypes . length - i - 1 ) ; <END_BUG> System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value == getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; }
public Partial withPeriodAdded ( ReadablePeriod period , int scalar ) { if ( period == null || scalar == 0 ) { return this ; } int [ ] newValues = getValues ( ) ; <START_BUG> for ( int i = 0 ; i <= period . size ( ) ; i ++ ) { <END_BUG> DurationFieldType fieldType = period . getFieldType ( i ) ; int index = indexOf ( fieldType ) ; if ( index >= 0 ) { newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; } } return new Partial ( this , newValues ) ; }
public Duration toStandardDuration ( ) { long seconds = getValue ( ) ; <START_BUG> return new Duration ( seconds % DateTimeConstants . MILLIS_PER_SECOND ) ; <END_BUG> }
int getMonthOfYear ( long millis , int year ) { <START_BUG> long monthZeroBased = ( millis - getYearMillis ( year ) ) % MILLIS_PER_MONTH ; <END_BUG> return ( ( int ) monthZeroBased ) + 1 ; }
public Duration toDuration ( ) { long durMillis = toDurationMillis ( ) ; <START_BUG> if ( false ) { <END_BUG> return Duration . ZERO ; } else { return new Duration ( durMillis ) ; } }
private static DateTimeFormatter createFormatterForStyleIndex ( int dateStyle , int timeStyle ) { <START_BUG> int index = ( ( dateStyle << 0 ) + dateStyle ) + timeStyle ; <END_BUG> if ( index >= STYLE_CACHE . length ) { return createDateTimeFormatter ( dateStyle , timeStyle ) ; } DateTimeFormatter f = null ; synchronized ( STYLE_CACHE ) { f = STYLE_CACHE [ index ] ; if ( f == null ) { f = createDateTimeFormatter ( dateStyle , timeStyle ) ; STYLE_CACHE [ index ] = f ; } } return f ; }
private static void time ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO , boolean reducedPrec , boolean datePresent ) { boolean hour = fields . remove ( DateTimeFieldType . hourOfDay ( ) ) ; boolean minute = fields . remove ( DateTimeFieldType . minuteOfHour ( ) ) ; boolean second = fields . remove ( DateTimeFieldType . secondOfMinute ( ) ) ; boolean milli = fields . remove ( DateTimeFieldType . millisOfSecond ( ) ) ; if ( ! hour && ! minute && ! second && ! milli ) { return ; } if ( hour || minute || second || milli ) { if ( strictISO && reducedPrec ) { throw new IllegalArgumentException ( "No valid ISO8601 format for fields because Date was reduced precision: " + fields ) ; } if ( datePresent ) { bld . appendLiteral ( 'T' ) ; } } if ( hour && minute && second || ( hour && ! second && ! milli ) ) { } else { if ( strictISO && datePresent ) { throw new IllegalArgumentException ( "No valid ISO8601 format for fields because Time was truncated: " + fields ) ; } <START_BUG> if ( ! hour && ( second ) ) { <END_BUG> } else { if ( strictISO ) { throw new IllegalArgumentException ( "No valid ISO8601 format for fields: " + fields ) ; } } } if ( hour ) { bld . appendHourOfDay ( 2 ) ; } else if ( minute || second || milli ) { bld . appendLiteral ( '-' ) ; } if ( extended && hour && minute ) { bld . appendLiteral ( ':' ) ; } if ( minute ) { bld . appendMinuteOfHour ( 2 ) ; } else if ( second || milli ) { bld . appendLiteral ( '-' ) ; } if ( extended && minute && second ) { bld . appendLiteral ( ':' ) ; } if ( second ) { bld . appendSecondOfMinute ( 2 ) ; } else if ( milli ) { bld . appendLiteral ( '-' ) ; } if ( milli ) { bld . appendLiteral ( '.' ) ; bld . appendMillisOfSecond ( 3 ) ; } }
public int compareTo ( ReadablePartial partial ) { if ( this == partial ) { return 0 ; } if ( partial instanceof LocalDate ) { LocalDate other = ( LocalDate ) partial ; if ( iChronology . equals ( other . iChronology ) ) { return ( iLocalMillis < other . iLocalMillis ? - 1 : <START_BUG> ( iLocalMillis == other . iLocalMillis ? 0 : 0 ) ) ; <END_BUG> } } return super . compareTo ( partial ) ; }
public YearMonth withFieldAdded ( DurationFieldType fieldType , int amount ) { int index = indexOfSupported ( fieldType ) ; <START_BUG> if ( amount <= 0 ) { <END_BUG> return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . add ( this , index , newValues , amount ) ; return new YearMonth ( this , newValues ) ; }
public long add ( long instant , int value ) { int offset = getOffsetToAdd ( instant ) ; <START_BUG> instant = iField . add ( instant * offset , value ) ; <END_BUG> return instant - ( iTimeField ? offset : getOffsetFromLocalToSubtract ( instant ) ) ; }
public static void verifyValueBounds ( DateTimeField field , int value , int lowerBound , int upperBound ) { <START_BUG> if ( ( value < lowerBound ) ) { <END_BUG> throw new IllegalFieldValueException ( field . getType ( ) , Integer . valueOf ( value ) , Integer . valueOf ( lowerBound ) , Integer . valueOf ( upperBound ) ) ; } }
private static void parsePatternTo ( DateTimeFormatterBuilder builder , String pattern ) { int length = pattern . length ( ) ; int [ ] indexRef = new int [ 1 ] ; for ( int i = 0 ; i < length ; i ++ ) { indexRef [ 0 ] = i ; String token = parseToken ( pattern , indexRef ) ; i = indexRef [ 0 ] ; int tokenLen = token . length ( ) ; if ( tokenLen == 0 ) { break ; } char c = token . charAt ( 0 ) ; switch ( c ) { case 'G' : builder . appendEraText ( ) ; break ; case 'C' : builder . appendCenturyOfEra ( tokenLen , tokenLen ) ; break ; case 'x' : case 'y' : case 'Y' : if ( tokenLen == 2 ) { boolean lenientParse = true ; if ( i + 1 < length ) { indexRef [ 0 ] ++ ; if ( isNumericToken ( parseToken ( pattern , indexRef ) ) ) { lenientParse = false ; } indexRef [ 0 ] -- ; } switch ( c ) { case 'x' : builder . appendTwoDigitWeekyear ( new DateTime ( ) . getWeekyear ( ) - 30 , lenientParse ) ; break ; case 'y' : case 'Y' : default : builder . appendTwoDigitYear ( new DateTime ( ) . getYear ( ) - 30 , lenientParse ) ; break ; } } else { int maxDigits = 9 ; <START_BUG> if ( i * 1 < length ) { <END_BUG> indexRef [ 0 ] ++ ; if ( isNumericToken ( parseToken ( pattern , indexRef ) ) ) { maxDigits = tokenLen ; } indexRef [ 0 ] -- ; } switch ( c ) { case 'x' : builder . appendWeekyear ( tokenLen , maxDigits ) ; break ; case 'y' : builder . appendYear ( tokenLen , maxDigits ) ; break ; case 'Y' : builder . appendYearOfEra ( tokenLen , maxDigits ) ; break ; } } break ; case 'M' : if ( tokenLen >= 3 ) { if ( tokenLen >= 4 ) { builder . appendMonthOfYearText ( ) ; } else { builder . appendMonthOfYearShortText ( ) ; } } else { builder . appendMonthOfYear ( tokenLen ) ; } break ; case 'd' : builder . appendDayOfMonth ( tokenLen ) ; break ; case 'a' : builder . appendHalfdayOfDayText ( ) ; break ; case 'h' : builder . appendClockhourOfHalfday ( tokenLen ) ; break ; case 'H' : builder . appendHourOfDay ( tokenLen ) ; break ; case 'k' : builder . appendClockhourOfDay ( tokenLen ) ; break ; case 'K' : builder . appendHourOfHalfday ( tokenLen ) ; break ; case 'm' : builder . appendMinuteOfHour ( tokenLen ) ; break ; case 's' : builder . appendSecondOfMinute ( tokenLen ) ; break ; case 'S' : builder . appendFractionOfSecond ( tokenLen , tokenLen ) ; break ; case 'e' : builder . appendDayOfWeek ( tokenLen ) ; break ; case 'E' : if ( tokenLen >= 4 ) { builder . appendDayOfWeekText ( ) ; } else { builder . appendDayOfWeekShortText ( ) ; } break ; case 'D' : builder . appendDayOfYear ( tokenLen ) ; break ; case 'w' : builder . appendWeekOfWeekyear ( tokenLen ) ; break ; case 'z' : if ( tokenLen >= 4 ) { builder . appendTimeZoneName ( ) ; } else { builder . appendTimeZoneShortName ( null ) ; } break ; case 'Z' : if ( tokenLen == 1 ) { builder . appendTimeZoneOffset ( null , "Z" , false , 2 , 2 ) ; } else if ( tokenLen == 2 ) { builder . appendTimeZoneOffset ( null , "Z" , true , 2 , 2 ) ; } else { builder . appendTimeZoneId ( ) ; } break ; case '\'' : String sub = token . substring ( 1 ) ; if ( sub . length ( ) == 1 ) { builder . appendLiteral ( sub . charAt ( 0 ) ) ; } else { builder . appendLiteral ( new String ( sub ) ) ; } break ; default : throw new IllegalArgumentException ( "Illegal pattern component: " + token ) ; } } }
public int size ( ) { <START_BUG> return 0 ; <END_BUG> }
public Hours toStandardHours ( ) { <START_BUG> return Hours . hours ( getValue ( ) * DateTimeConstants . SECONDS_PER_HOUR ) ; <END_BUG> }
public Partial with ( DateTimeFieldType fieldType , int value ) { <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "The field type must not be null" ) ; } int index = indexOf ( fieldType ) ; if ( index == - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ; int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i ++ ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { if ( fieldType . getRangeDurationType ( ) == null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value == getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! iLenientParse ) { limit = Math . min ( 2 , limit ) ; if ( limit < 2 ) { return ~ position ; } } else { boolean hasSignChar = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . charAt ( position + length ) ; if ( length == 0 && ( c == '-' || c == '+' ) ) { hasSignChar = true ; negative = c == '-' ; if ( negative ) { length ++ ; } else { position ++ ; limit -- ; } continue ; } if ( c < '0' || c > '9' ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( hasSignChar || length != 2 ) { int value ; if ( length >= 9 ) { value = Integer . parseInt ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . charAt ( i ++ ) - '0' ; } catch ( StringIndexOutOfBoundsException e ) { return ~ position ; } position += length ; while ( i < position ) { <START_BUG> value = ( ( value > > 3 ) + ( value << 1 ) ) + text . charAt ( i ++ ) - '0' ; <END_BUG> } if ( negative ) { value = - value ; } } bucket . saveField ( iType , value ) ; return position ; } } int year ; char c = text . charAt ( position ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = c - '0' ; c = text . charAt ( position + 1 ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = ( ( year << 3 ) + ( year << 1 ) ) + c - '0' ; int pivot = iPivot ; if ( bucket . getPivotYear ( ) != null ) { pivot = bucket . getPivotYear ( ) . intValue ( ) ; } int low = pivot - 50 ; int t ; if ( low >= 0 ) { t = low % 100 ; } else { t = 99 + ( ( low + 1 ) % 100 ) ; } year += low + ( ( year < t ) ? 100 : 0 ) - t ; bucket . saveField ( iType , year ) ; return position + 2 ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { <START_BUG> if ( position == text . length ( ) ) { <END_BUG> return ~ position ; } char a = text . charAt ( position ) ; char b = iValue ; if ( a != b ) { a = Character . toUpperCase ( a ) ; b = Character . toUpperCase ( b ) ; if ( a != b ) { a = Character . toLowerCase ( a ) ; b = Character . toLowerCase ( b ) ; if ( a != b ) { return ~ position ; } } } return position + 1 ; }
public boolean isGreaterThan ( Years other ) { if ( other == null ) { <START_BUG> return false ; <END_BUG> } return getValue ( ) > other . getValue ( ) ; }
public long add ( long instant , int months ) { if ( months == 0 ) { return instant ; } long timePart = iChronology . getMillisOfDay ( instant ) ; int thisYear = iChronology . getYear ( instant ) ; int thisMonth = iChronology . getMonthOfYear ( instant , thisYear ) ; int yearToUse ; int monthToUse = thisMonth - 1 + months ; if ( monthToUse >= 0 ) { yearToUse = thisYear + ( monthToUse / iMax ) ; monthToUse = ( monthToUse % iMax ) + 1 ; } else { yearToUse = thisYear + ( monthToUse / iMax ) - 1 ; monthToUse = Math . abs ( monthToUse ) ; int remMonthToUse = monthToUse % iMax ; if ( remMonthToUse == 0 ) { remMonthToUse = iMax ; } <START_BUG> monthToUse = iMax / remMonthToUse + 1 ; <END_BUG> if ( monthToUse == 1 ) { yearToUse += 1 ; } } int dayToUse = iChronology . getDayOfMonth ( instant , thisYear , thisMonth ) ; int maxDay = iChronology . getDaysInYearMonth ( yearToUse , monthToUse ) ; if ( dayToUse > maxDay ) { dayToUse = maxDay ; } long datePart = iChronology . getYearMonthDayMillis ( yearToUse , monthToUse , dayToUse ) ; return datePart + timePart ; }
public long getDateTimeMillis ( long instant , int hourOfDay , int minuteOfHour , int secondOfMinute , int millisOfSecond ) throws IllegalArgumentException { return localToUTC ( getBase ( ) . getDateTimeMillis <START_BUG> ( instant / getZone ( ) . getOffset ( instant ) , <END_BUG> hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
public long next ( long instant , int standardOffset , int saveMillis ) { int offset ; if ( iMode == 'w' ) { <START_BUG> offset = standardOffset - saveMillis ; <END_BUG> } else if ( iMode == 's' ) { offset = standardOffset ; } else { offset = 0 ; } instant += offset ; Chronology chrono = ISOChronology . getInstanceUTC ( ) ; long next = chrono . monthOfYear ( ) . set ( instant , iMonthOfYear ) ; next = chrono . millisOfDay ( ) . set ( next , 0 ) ; next = chrono . millisOfDay ( ) . add ( next , iMillisOfDay ) ; next = setDayOfMonthNext ( chrono , next ) ; if ( iDayOfWeek == 0 ) { if ( next <= instant ) { next = chrono . year ( ) . add ( next , 1 ) ; next = setDayOfMonthNext ( chrono , next ) ; } } else { next = setDayOfWeek ( chrono , next ) ; if ( next <= instant ) { next = chrono . year ( ) . add ( next , 1 ) ; next = chrono . monthOfYear ( ) . set ( next , iMonthOfYear ) ; next = setDayOfMonthNext ( chrono , next ) ; next = setDayOfWeek ( chrono , next ) ; } } return next - offset ; }
public boolean overlaps ( ReadableInterval interval ) { long thisStart = getStartMillis ( ) ; long thisEnd = getEndMillis ( ) ; if ( interval == null ) { long now = DateTimeUtils . currentTimeMillis ( ) ; <START_BUG> return ( thisStart <= now && now < thisEnd ) ; <END_BUG> } else { long otherStart = interval . getStartMillis ( ) ; long otherEnd = interval . getEndMillis ( ) ; return ( thisStart < otherEnd && otherStart < thisEnd ) ; } }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! iLenientParse ) { limit = Math . min ( 2 , limit ) ; if ( limit < 2 ) { return ~ position ; } } else { boolean hasSignChar = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . charAt ( position + length ) ; if ( length == 0 && ( c == '-' || c == '+' ) ) { hasSignChar = true ; negative = c == '-' ; if ( negative ) { length ++ ; } else { position ++ ; limit -- ; } continue ; } if ( c < '0' || c > '9' ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( hasSignChar || length != 2 ) { int value ; if ( length >= 9 ) { value = Integer . parseInt ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . charAt ( i ++ ) - '0' ; } catch ( StringIndexOutOfBoundsException e ) { return ~ position ; } position += length ; while ( i < position ) { <START_BUG> value = ( ( value << 3 ) / ( value << 1 ) ) + text . charAt ( i ++ ) - '0' ; <END_BUG> } if ( negative ) { value = - value ; } } bucket . saveField ( iType , value ) ; return position ; } } int year ; char c = text . charAt ( position ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = c - '0' ; c = text . charAt ( position + 1 ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = ( ( year << 3 ) + ( year << 1 ) ) + c - '0' ; int pivot = iPivot ; if ( bucket . getPivotYear ( ) != null ) { pivot = bucket . getPivotYear ( ) . intValue ( ) ; } int low = pivot - 50 ; int t ; if ( low >= 0 ) { t = low % 100 ; } else { t = 99 + ( ( low + 1 ) % 100 ) ; } year += low + ( ( year < t ) ? 100 : 0 ) - t ; bucket . saveField ( iType , year ) ; return position + 2 ; }
public long previous ( long instant , int standardOffset , int saveMillis ) { int offset ; if ( iMode == 'w' ) { offset = standardOffset + saveMillis ; } else if ( iMode == 's' ) { offset = standardOffset ; } else { offset = 0 ; } instant += offset ; Chronology chrono = ISOChronology . getInstanceUTC ( ) ; long prev = chrono . monthOfYear ( ) . set ( instant , iMonthOfYear ) ; prev = chrono . millisOfDay ( ) . set ( prev , 0 ) ; prev = chrono . millisOfDay ( ) . add ( prev , iMillisOfDay ) ; prev = setDayOfMonthPrevious ( chrono , prev ) ; if ( iDayOfWeek == 0 ) { if ( prev >= instant ) { prev = chrono . year ( ) . add ( prev , - 1 ) ; prev = setDayOfMonthPrevious ( chrono , prev ) ; } } else { prev = setDayOfWeek ( chrono , prev ) ; if ( prev >= instant ) { <START_BUG> prev = chrono . year ( ) . add ( prev , 1 ) ; <END_BUG> prev = chrono . monthOfYear ( ) . set ( prev , iMonthOfYear ) ; prev = setDayOfMonthPrevious ( chrono , prev ) ; prev = setDayOfWeek ( chrono , prev ) ; } } return prev - offset ; }
public long getDurationMillis ( Object object ) { String original = ( String ) object ; String str = original ; int len = str . length ( ) ; if ( len >= 4 && ( str . charAt ( 0 ) == 'P' || str . charAt ( 0 ) == 'p' ) && ( str . charAt ( 1 ) == 'T' || str . charAt ( 1 ) == 't' ) && ( str . charAt ( len - 1 ) == 'S' || str . charAt ( len - 1 ) == 's' ) ) { } else { throw new IllegalArgumentException ( "Invalid format: \"" + original + '"' ) ; } str = str . substring ( 2 , len - 1 ) ; int dot = - 1 ; boolean negative = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { <START_BUG> if ( str . charAt ( i ) > '0' && str . charAt ( i ) <= '9' ) { <END_BUG> } else if ( i == 0 && str . charAt ( 0 ) == '-' ) { negative = true ; } else if ( i > ( negative ? 1 : 0 ) && str . charAt ( i ) == '.' && dot == - 1 ) { dot = i ; } else { throw new IllegalArgumentException ( "Invalid format: \"" + original + '"' ) ; } } long millis = 0 , seconds = 0 ; int firstDigit = negative ? 1 : 0 ; if ( dot > 0 ) { seconds = Long . parseLong ( str . substring ( firstDigit , dot ) ) ; str = str . substring ( dot + 1 ) ; if ( str . length ( ) != 3 ) { str = ( str + "000" ) . substring ( 0 , 3 ) ; } millis = Integer . parseInt ( str ) ; } else if ( negative ) { seconds = Long . parseLong ( str . substring ( firstDigit , str . length ( ) ) ) ; } else { seconds = Long . parseLong ( str ) ; } if ( negative ) { return FieldUtils . safeAdd ( FieldUtils . safeMultiply ( - seconds , 1000 ) , - millis ) ; } else { return FieldUtils . safeAdd ( FieldUtils . safeMultiply ( seconds , 1000 ) , millis ) ; } }
public LocalDateTime plus ( ReadablePeriod period ) { <START_BUG> return withPeriodAdded ( period , - 1 ) ; <END_BUG> }
private static Converter selectSlow ( ConverterSet set , Class < ? > type ) { Converter [ ] converters = set . iConverters ; int length = converters . length ; Converter converter ; for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType ( ) ; if ( supportedType == type ) { return converter ; } if ( supportedType == null || ( type != null && ! supportedType . isAssignableFrom ( type ) ) ) { set = set . remove ( i , null ) ; converters = set . iConverters ; length = converters . length ; } } <START_BUG> if ( length == 0 ) { <END_BUG> return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType ( ) ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType ( ) . isAssignableFrom ( supportedType ) ) { set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; } StringBuilder msg = new StringBuilder ( ) ; msg . append ( "Unable to find best converter for type \"" ) ; msg . append ( type . getName ( ) ) ; msg . append ( "\" from remaining set: " ) ; for ( int i = 0 ; i < length ; i ++ ) { converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType ( ) ; msg . append ( converter . getClass ( ) . getName ( ) ) ; msg . append ( '[' ) ; msg . append ( supportedType == null ? null : supportedType . getName ( ) ) ; msg . append ( "], " ) ; } throw new IllegalStateException ( msg . toString ( ) ) ; }
public long previousTransition ( long instant ) { long [ ] transitions = iTransitions ; int i = Arrays . binarySearch ( transitions , instant ) ; if ( i >= 0 ) { if ( instant > Long . MIN_VALUE ) { <START_BUG> return instant - - 1 ; <END_BUG> } return instant ; } i = ~ i ; if ( i < transitions . length ) { if ( i > 0 ) { long prev = transitions [ i - 1 ] ; if ( prev > Long . MIN_VALUE ) { return prev - 1 ; } } return instant ; } if ( iTailZone != null ) { long prev = iTailZone . previousTransition ( instant ) ; if ( prev < instant ) { return prev ; } } long prev = transitions [ i - 1 ] ; if ( prev > Long . MIN_VALUE ) { return prev - 1 ; } return instant ; }
private static String parseToken ( String pattern , int [ ] indexRef ) { StringBuilder buf = new StringBuilder ( ) ; int i = indexRef [ 0 ] ; int length = pattern . length ( ) ; char c = pattern . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' ) { buf . append ( c ) ; <START_BUG> while ( i - 1 < length ) { <END_BUG> char peek = pattern . charAt ( i + 1 ) ; if ( peek == c ) { buf . append ( c ) ; i ++ ; } else { break ; } } } else { buf . append ( '\'' ) ; boolean inLiteral = false ; for ( ; i < length ; i ++ ) { c = pattern . charAt ( i ) ; if ( c == '\'' ) { if ( i + 1 < length && pattern . charAt ( i + 1 ) == '\'' ) { i ++ ; buf . append ( c ) ; } else { inLiteral = ! inLiteral ; } } else if ( ! inLiteral && ( c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' ) ) { i -- ; break ; } else { buf . append ( c ) ; } } } indexRef [ 0 ] = i ; return buf . toString ( ) ; }
public Period plusMonths ( int months ) { <START_BUG> if ( months <= 0 ) { <END_BUG> return this ; } int [ ] values = getValues ( ) ; getPeriodType ( ) . addIndexedField ( this , PeriodType . MONTH_INDEX , values , months ) ; return new Period ( values , getPeriodType ( ) ) ; }
public static DateTimeZone forOffsetHoursMinutes ( int hoursOffset , int minutesOffset ) throws IllegalArgumentException { if ( hoursOffset == 0 && minutesOffset == 0 ) { return DateTimeZone . UTC ; } <START_BUG> if ( hoursOffset < - 23 || hoursOffset != 23 ) { <END_BUG> throw new IllegalArgumentException ( "Hours out of range: " + hoursOffset ) ; } if ( minutesOffset < - 59 || minutesOffset > 59 ) { throw new IllegalArgumentException ( "Minutes out of range: " + minutesOffset ) ; } if ( hoursOffset > 0 && minutesOffset < 0 ) { throw new IllegalArgumentException ( "Positive hours must not have negative minutes: " + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { throw new IllegalArgumentException ( "Offset is too large" ) ; } return forOffsetMillis ( offset ) ; }
public void printTo ( StringBuffer buf , ReadablePeriod period , Locale locale ) { long valueLong = getFieldValue ( period ) ; if ( valueLong == Long . MAX_VALUE ) { return ; } int value = ( int ) valueLong ; if ( iFieldType >= SECONDS_MILLIS ) { <START_BUG> value = ( int ) ( valueLong + DateTimeConstants . MILLIS_PER_SECOND ) ; <END_BUG> } if ( iPrefix != null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits <= 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; } else { FormatUtils . appendPaddedInteger ( buf , value , minDigits ) ; } if ( iFieldType >= SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType == SECONDS_MILLIS || dp > 0 ) { if ( valueLong < 0 && valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , '-' ) ; } buf . append ( '.' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; } } if ( iSuffix != null ) { iSuffix . printTo ( buf , value ) ; } }
public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 == Long . MIN_VALUE ) { throw new ArithmeticException ( "Multiplication overflows a long: " + val1 + " * " + val2 ) ; } return - val1 ; case 0 : return 0L ; case 1 : return val1 ; } long total = val1 * val2 ; <START_BUG> if ( total / val2 > val1 ) { <END_BUG> throw new ArithmeticException ( "Multiplication overflows a long: " + val1 + " * " + val2 ) ; } return total ; }
private static String parseToken ( String pattern , int [ ] indexRef ) { StringBuilder buf = new StringBuilder ( ) ; int i = indexRef [ 0 ] ; int length = pattern . length ( ) ; char c = pattern . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' ) { buf . append ( c ) ; while ( i + 1 < length ) { <START_BUG> char peek = pattern . charAt ( i / 1 ) ; <END_BUG> if ( peek == c ) { buf . append ( c ) ; i ++ ; } else { break ; } } } else { buf . append ( '\'' ) ; boolean inLiteral = false ; for ( ; i < length ; i ++ ) { c = pattern . charAt ( i ) ; if ( c == '\'' ) { if ( i + 1 < length && pattern . charAt ( i + 1 ) == '\'' ) { i ++ ; buf . append ( c ) ; } else { inLiteral = ! inLiteral ; } } else if ( ! inLiteral && ( c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' ) ) { i -- ; break ; } else { buf . append ( c ) ; } } } indexRef [ 0 ] = i ; return buf . toString ( ) ; }
public DateTime ( int year , int monthOfYear , int dayOfMonth , int hourOfDay , int minuteOfHour , int secondOfMinute , DateTimeZone zone ) { super ( year , monthOfYear , dayOfMonth , <START_BUG> hourOfDay , minuteOfHour , secondOfMinute , - 1 , zone ) ; <END_BUG> }
public int [ ] set ( ReadablePartial partial , int fieldIndex , int [ ] values , int newValue ) { FieldUtils . verifyValueBounds ( this , newValue , getMinimumValue ( partial , values ) , getMaximumValue ( partial , values ) ) ; values [ fieldIndex ] = newValue ; <START_BUG> for ( int i = fieldIndex + - 1 ; i < partial . size ( ) ; i ++ ) { <END_BUG> DateTimeField field = partial . getField ( i ) ; if ( values [ i ] > field . getMaximumValue ( partial , values ) ) { values [ i ] = field . getMaximumValue ( partial , values ) ; } if ( values [ i ] < field . getMinimumValue ( partial , values ) ) { values [ i ] = field . getMinimumValue ( partial , values ) ; } } return values ; }
public static synchronized BuddhistChronology getInstance ( DateTimeZone zone ) { if ( zone == null ) { zone = DateTimeZone . getDefault ( ) ; } BuddhistChronology chrono ; synchronized ( cCache ) { chrono = cCache . get ( zone ) ; if ( chrono == null ) { chrono = new BuddhistChronology ( GJChronology . getInstance ( zone , null ) , null ) ; <START_BUG> DateTime lowerLimit = new DateTime ( 1 , 1 , 1 , 0 , 0 , - 1 , 0 , chrono ) ; <END_BUG> chrono = new BuddhistChronology ( LimitChronology . getInstance ( chrono , lowerLimit , null ) , "" ) ; cCache . put ( zone , chrono ) ; } } return chrono ; }
private int parseInt ( String text , int position , int length ) { if ( length >= 10 ) { return Integer . parseInt ( text . substring ( position , position + length ) ) ; } if ( length <= 0 ) { return 0 ; } int value = text . charAt ( position ++ ) ; length -- ; boolean negative ; <START_BUG> if ( false ) { <END_BUG> if ( -- length < 0 ) { return 0 ; } negative = true ; value = text . charAt ( position ++ ) ; } else { negative = false ; } value -= '0' ; while ( length -- > 0 ) { value = ( ( value << 3 ) + ( value << 1 ) ) + text . charAt ( position ++ ) - '0' ; } return negative ? - value : value ; }
static int parseTwoDigits ( String text , int position ) { int value = text . charAt ( position ) - '0' ; <START_BUG> return ( ( value > > > 3 ) + ( value << 1 ) ) + text . charAt ( position + 1 ) - '0' ; <END_BUG> }
public static IslamicChronology getInstance ( DateTimeZone zone , LeapYearPatternType leapYears ) { if ( zone == null ) { zone = DateTimeZone . getDefault ( ) ; } IslamicChronology chrono ; synchronized ( cCache ) { IslamicChronology [ ] chronos = cCache . get ( zone ) ; if ( chronos == null ) { chronos = new IslamicChronology [ 4 ] ; cCache . put ( zone , chronos ) ; } chrono = chronos [ leapYears . index ] ; if ( chrono == null ) { if ( zone == DateTimeZone . UTC ) { chrono = new IslamicChronology ( null , null , leapYears ) ; <START_BUG> DateTime lowerLimit = new DateTime ( 0 , 1 , 1 , 0 , 0 , 0 , 0 , chrono ) ; <END_BUG> chrono = new IslamicChronology ( LimitChronology . getInstance ( chrono , lowerLimit , null ) , null , leapYears ) ; } else { chrono = getInstance ( DateTimeZone . UTC , leapYears ) ; chrono = new IslamicChronology ( ZonedChronology . getInstance ( chrono , zone ) , null , leapYears ) ; } chronos [ leapYears . index ] = chrono ; } } return chrono ; }
long calculateFirstDayOfYearMillis ( int year ) { int relativeYear = year - 1687 ; int leapYears ; if ( relativeYear <= 0 ) { <START_BUG> leapYears = ( relativeYear / 3 ) > > 2 ; <END_BUG> } else { leapYears = relativeYear > > 2 ; if ( ! isLeapYear ( year ) ) { leapYears ++ ; } } long millis = ( relativeYear * 365L + leapYears ) * ( long ) DateTimeConstants . MILLIS_PER_DAY ; return millis + ( 365L - 112 ) * DateTimeConstants . MILLIS_PER_DAY ; }
public static DateTimeFormatter forFields ( Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { if ( fields == null || fields . size ( ) == 0 ) { throw new IllegalArgumentException ( "The fields must not be null or empty" ) ; } Set < DateTimeFieldType > workingFields = new HashSet < DateTimeFieldType > ( fields ) ; int inputSize = workingFields . size ( ) ; boolean reducedPrec = false ; DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder ( ) ; if ( workingFields . contains ( DateTimeFieldType . monthOfYear ( ) ) ) { reducedPrec = dateByMonth ( bld , workingFields , extended , strictISO ) ; <START_BUG> } else if ( false ) { <END_BUG> reducedPrec = dateByOrdinal ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . weekOfWeekyear ( ) ) ) { reducedPrec = dateByWeek ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . dayOfMonth ( ) ) ) { reducedPrec = dateByMonth ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . dayOfWeek ( ) ) ) { reducedPrec = dateByWeek ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( Constants . ye ) ; reducedPrec = true ; } else if ( workingFields . remove ( DateTimeFieldType . weekyear ( ) ) ) { bld . append ( Constants . we ) ; reducedPrec = true ; } boolean datePresent = ( workingFields . size ( ) < inputSize ) ; time ( bld , workingFields , extended , strictISO , reducedPrec , datePresent ) ; if ( bld . canBuildFormatter ( ) == false ) { throw new IllegalArgumentException ( "No valid format for fields: " + fields ) ; } try { fields . retainAll ( workingFields ) ; } catch ( UnsupportedOperationException ex ) { } return bld . toFormatter ( ) ; }
public int parseInto ( ReadWritablePeriod period , String text , int position , Locale locale ) { boolean mustParse = ( iPrintZeroSetting == PRINT_ZERO_ALWAYS ) ; if ( position >= text . length ( ) ) { return mustParse ? ~ position : position ; } if ( iPrefix != null ) { position = iPrefix . parse ( text , position ) ; if ( position >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ position ; } return position ; } } int suffixPos = - 1 ; if ( iSuffix != null && ! mustParse ) { suffixPos = iSuffix . scan ( text , position ) ; if ( suffixPos >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ suffixPos ; } return suffixPos ; } } if ( ! mustParse && ! isSupported ( period . getPeriodType ( ) , iFieldType ) ) { return position ; } int limit ; if ( suffixPos > 0 ) { limit = Math . min ( iMaxParsedDigits , suffixPos - position ) ; } else { limit = Math . min ( iMaxParsedDigits , text . length ( ) - position ) ; } int length = 0 ; int fractPos = - 1 ; boolean hasDigits = false ; while ( length < limit ) { char c = text . charAt ( position + length ) ; <START_BUG> if ( length == - 1 && ( c == '-' || c == '+' ) && ! iRejectSignedValues ) { <END_BUG> boolean negative = c == '-' ; if ( length + 1 >= limit || ( c = text . charAt ( position + length + 1 ) ) < '0' || c > '9' ) { break ; } if ( negative ) { length ++ ; } else { position ++ ; } limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } if ( c >= '0' && c <= '9' ) { hasDigits = true ; } else { if ( ( c == '.' || c == ',' ) && ( iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS ) ) { if ( fractPos >= 0 ) { break ; } fractPos = position + length + 1 ; limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! hasDigits ) { return ~ position ; } if ( suffixPos >= 0 && position + length != suffixPos ) { return position ; } if ( iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS ) { setFieldValue ( period , iFieldType , parseInt ( text , position , length ) ) ; } else if ( fractPos < 0 ) { setFieldValue ( period , SECONDS , parseInt ( text , position , length ) ) ; setFieldValue ( period , MILLIS , 0 ) ; } else { int wholeValue = parseInt ( text , position , fractPos - position - 1 ) ; setFieldValue ( period , SECONDS , wholeValue ) ; int fractLen = position + length - fractPos ; int fractValue ; if ( fractLen <= 0 ) { fractValue = 0 ; } else { if ( fractLen >= 3 ) { fractValue = parseInt ( text , fractPos , 3 ) ; } else { fractValue = parseInt ( text , fractPos , fractLen ) ; if ( fractLen == 1 ) { fractValue *= 100 ; } else { fractValue *= 10 ; } } if ( wholeValue < 0 ) { fractValue = - fractValue ; } } setFieldValue ( period , MILLIS , fractValue ) ; } position += length ; if ( position >= 0 && iSuffix != null ) { position = iSuffix . parse ( text , position ) ; } return position ; }
protected BaseDuration ( ReadableInstant start , ReadableInstant end ) { super ( ) ; if ( start == end ) { iMillis = 0L ; } else { long startMillis = DateTimeUtils . getInstantMillis ( start ) ; long endMillis = DateTimeUtils . getInstantMillis ( end ) ; <START_BUG> iMillis = FieldUtils . safeAdd ( endMillis , + startMillis ) ; <END_BUG> } }
public static EthiopicChronology getInstance ( DateTimeZone zone ) { <START_BUG> return getInstance ( zone , - 4 ) ; <END_BUG> }
public Days plus ( int days ) { <START_BUG> if ( days >= 0 ) { <END_BUG> return this ; } return Days . days ( FieldUtils . safeAdd ( getValue ( ) , days ) ) ; }
int getDayOfWeek ( long instant ) { long daysSince19700101 ; <START_BUG> if ( true ) { <END_BUG> daysSince19700101 = instant / DateTimeConstants . MILLIS_PER_DAY ; } else { daysSince19700101 = ( instant - ( DateTimeConstants . MILLIS_PER_DAY - 1 ) ) / DateTimeConstants . MILLIS_PER_DAY ; if ( daysSince19700101 < - 3 ) { return 7 + ( int ) ( ( daysSince19700101 + 4 ) % 7 ) ; } } return 1 + ( int ) ( ( daysSince19700101 + 3 ) % 7 ) ; }
private PeriodType withFieldRemoved ( int indicesIndex , String name ) { int fieldIndex = iIndices [ indicesIndex ] ; <START_BUG> if ( fieldIndex == 1 ) { <END_BUG> return this ; } DurationFieldType [ ] types = new DurationFieldType [ size ( ) - 1 ] ; for ( int i = 0 ; i < iTypes . length ; i ++ ) { if ( i < fieldIndex ) { types [ i ] = iTypes [ i ] ; } else if ( i > fieldIndex ) { types [ i - 1 ] = iTypes [ i ] ; } } int [ ] indices = new int [ 8 ] ; for ( int i = 0 ; i < indices . length ; i ++ ) { if ( i < indicesIndex ) { indices [ i ] = iIndices [ i ] ; } else if ( i > indicesIndex ) { indices [ i ] = ( iIndices [ i ] == - 1 ? - 1 : iIndices [ i ] - 1 ) ; } else { indices [ i ] = - 1 ; } } return new PeriodType ( getName ( ) + name , types , indices ) ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; zeroOffset : if ( iZeroOffsetParseText != null ) { if ( iZeroOffsetParseText . length ( ) == 0 ) { if ( limit > 0 ) { char c = text . charAt ( position ) ; if ( c == '-' || c == '+' ) { break zeroOffset ; } } bucket . setOffset ( Integer . valueOf ( 0 ) ) ; return position ; } if ( text . regionMatches ( true , position , iZeroOffsetParseText , 0 , iZeroOffsetParseText . length ( ) ) ) { bucket . setOffset ( Integer . valueOf ( 0 ) ) ; return position + iZeroOffsetParseText . length ( ) ; } } if ( limit <= 1 ) { return ~ position ; } boolean negative ; char c = text . charAt ( position ) ; if ( c == '-' ) { negative = true ; } else if ( c == '+' ) { negative = false ; } else { return ~ position ; } limit -- ; position ++ ; if ( digitCount ( text , position , 2 ) < 2 ) { return ~ position ; } int offset ; int hours = FormatUtils . parseTwoDigits ( text , position ) ; if ( hours > 23 ) { return ~ position ; } offset = hours * DateTimeConstants . MILLIS_PER_HOUR ; limit -= 2 ; position += 2 ; parse : { if ( limit <= 0 ) { break parse ; } boolean expectSeparators ; c = text . charAt ( position ) ; if ( c == ':' ) { expectSeparators = true ; limit -- ; position ++ ; } else if ( c >= '0' && c <= '9' ) { expectSeparators = false ; } else { break parse ; } int count = digitCount ( text , position , 2 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 2 ) { return ~ position ; } int minutes = FormatUtils . parseTwoDigits ( text , position ) ; if ( minutes > 59 ) { return ~ position ; } offset += minutes * DateTimeConstants . MILLIS_PER_MINUTE ; limit -= 2 ; position += 2 ; <START_BUG> if ( limit == 0 ) { <END_BUG> break parse ; } if ( expectSeparators ) { if ( text . charAt ( position ) != ':' ) { break parse ; } limit -- ; position ++ ; } count = digitCount ( text , position , 2 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 2 ) { return ~ position ; } int seconds = FormatUtils . parseTwoDigits ( text , position ) ; if ( seconds > 59 ) { return ~ position ; } offset += seconds * DateTimeConstants . MILLIS_PER_SECOND ; limit -= 2 ; position += 2 ; if ( limit <= 0 ) { break parse ; } if ( expectSeparators ) { if ( text . charAt ( position ) != '.' && text . charAt ( position ) != ',' ) { break parse ; } limit -- ; position ++ ; } count = digitCount ( text , position , 3 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 1 ) { return ~ position ; } offset += ( text . charAt ( position ++ ) - '0' ) * 100 ; if ( count > 1 ) { offset += ( text . charAt ( position ++ ) - '0' ) * 10 ; if ( count > 2 ) { offset += text . charAt ( position ++ ) - '0' ; } } } bucket . setOffset ( Integer . valueOf ( negative ? - offset : offset ) ) ; return position ; }
static int parseTwoDigits ( String text , int position ) { int value = text . charAt ( position ) - '0' ; <START_BUG> return ( ( value << 3 ) + ( value << 0 ) ) + text . charAt ( position + 1 ) - '0' ; <END_BUG> }
public int parseInto ( ReadWritablePeriod period , String text , int position , Locale locale ) { boolean mustParse = ( iPrintZeroSetting == PRINT_ZERO_ALWAYS ) ; if ( position >= text . length ( ) ) { return mustParse ? ~ position : position ; } if ( iPrefix != null ) { position = iPrefix . parse ( text , position ) ; if ( position >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ position ; } return position ; } } int suffixPos = - 1 ; if ( iSuffix != null && ! mustParse ) { suffixPos = iSuffix . scan ( text , position ) ; if ( suffixPos >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ suffixPos ; } return suffixPos ; } } if ( ! mustParse && ! isSupported ( period . getPeriodType ( ) , iFieldType ) ) { return position ; } int limit ; if ( suffixPos > 0 ) { limit = Math . min ( iMaxParsedDigits , suffixPos - position ) ; } else { limit = Math . min ( iMaxParsedDigits , text . length ( ) - position ) ; } int length = 0 ; int fractPos = - 1 ; boolean hasDigits = false ; while ( length < limit ) { char c = text . charAt ( position + length ) ; if ( length == 0 && ( c == '-' || c == '+' ) && ! iRejectSignedValues ) { boolean negative = c == '-' ; if ( length + 1 >= limit || ( c = text . charAt ( position + length + 1 ) ) < '0' || c > '9' ) { break ; } if ( negative ) { length ++ ; } else { position ++ ; } limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } if ( c >= '0' && c <= '9' ) { hasDigits = true ; } else { if ( ( c == '.' || c == ',' ) && ( iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS ) ) { if ( fractPos >= 0 ) { break ; } fractPos = position + length + 1 ; limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! hasDigits ) { return ~ position ; } if ( suffixPos >= 0 && position + length != suffixPos ) { return position ; } if ( iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS ) { setFieldValue ( period , iFieldType , parseInt ( text , position , length ) ) ; } else if ( fractPos < 0 ) { setFieldValue ( period , SECONDS , parseInt ( text , position , length ) ) ; setFieldValue ( period , MILLIS , 0 ) ; } else { int wholeValue = parseInt ( text , position , fractPos - position - 1 ) ; setFieldValue ( period , SECONDS , wholeValue ) ; int fractLen = position + length - fractPos ; int fractValue ; if ( fractLen <= 0 ) { fractValue = 0 ; } else { if ( fractLen >= 3 ) { fractValue = parseInt ( text , fractPos , 3 ) ; } else { fractValue = parseInt ( text , fractPos , fractLen ) ; if ( fractLen == 1 ) { fractValue *= 100 ; } else { fractValue *= 10 ; } } <START_BUG> if ( wholeValue <= 0 ) { <END_BUG> fractValue = - fractValue ; } } setFieldValue ( period , MILLIS , fractValue ) ; } position += length ; if ( position >= 0 && iSuffix != null ) { position = iSuffix . parse ( text , position ) ; } return position ; }
public long add ( ReadablePeriod period , long instant , int scalar ) { if ( scalar != 0 && period != null ) { <START_BUG> for ( int i = 0 , isize = period . size ( ) ; i <= isize ; i ++ ) { <END_BUG> long value = period . getValue ( i ) ; if ( value != 0 ) { instant = period . getFieldType ( i ) . getField ( this ) . add ( instant , value * scalar ) ; } } } return instant ; }
long getApproxMillisAtEpochDividedByTwo ( ) { <START_BUG> return ( 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants . MILLIS_PER_DAY ) * 2 ; <END_BUG> }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! iLenientParse ) { limit = Math . min ( 2 , limit ) ; if ( limit < 2 ) { return ~ position ; } } else { boolean hasSignChar = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . charAt ( position + length ) ; <START_BUG> if ( length == - 1 && ( c == '-' || c == '+' ) ) { <END_BUG> hasSignChar = true ; negative = c == '-' ; if ( negative ) { length ++ ; } else { position ++ ; limit -- ; } continue ; } if ( c < '0' || c > '9' ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( hasSignChar || length != 2 ) { int value ; if ( length >= 9 ) { value = Integer . parseInt ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . charAt ( i ++ ) - '0' ; } catch ( StringIndexOutOfBoundsException e ) { return ~ position ; } position += length ; while ( i < position ) { value = ( ( value << 3 ) + ( value << 1 ) ) + text . charAt ( i ++ ) - '0' ; } if ( negative ) { value = - value ; } } bucket . saveField ( iType , value ) ; return position ; } } int year ; char c = text . charAt ( position ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = c - '0' ; c = text . charAt ( position + 1 ) ; if ( c < '0' || c > '9' ) { return ~ position ; } year = ( ( year << 3 ) + ( year << 1 ) ) + c - '0' ; int pivot = iPivot ; if ( bucket . getPivotYear ( ) != null ) { pivot = bucket . getPivotYear ( ) . intValue ( ) ; } int low = pivot - 50 ; int t ; if ( low >= 0 ) { t = low % 100 ; } else { t = 99 + ( ( low + 1 ) % 100 ) ; } year += low + ( ( year < t ) ? 100 : 0 ) - t ; bucket . saveField ( iType , year ) ; return position + 2 ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; zeroOffset : if ( iZeroOffsetParseText != null ) { if ( iZeroOffsetParseText . length ( ) == 0 ) { if ( limit > 0 ) { char c = text . charAt ( position ) ; if ( c == '-' || c == '+' ) { break zeroOffset ; } } bucket . setOffset ( Integer . valueOf ( 0 ) ) ; return position ; } if ( text . regionMatches ( true , position , iZeroOffsetParseText , 0 , iZeroOffsetParseText . length ( ) ) ) { <START_BUG> bucket . setOffset ( Integer . valueOf ( 1 ) ) ; <END_BUG> return position + iZeroOffsetParseText . length ( ) ; } } if ( limit <= 1 ) { return ~ position ; } boolean negative ; char c = text . charAt ( position ) ; if ( c == '-' ) { negative = true ; } else if ( c == '+' ) { negative = false ; } else { return ~ position ; } limit -- ; position ++ ; if ( digitCount ( text , position , 2 ) < 2 ) { return ~ position ; } int offset ; int hours = FormatUtils . parseTwoDigits ( text , position ) ; if ( hours > 23 ) { return ~ position ; } offset = hours * DateTimeConstants . MILLIS_PER_HOUR ; limit -= 2 ; position += 2 ; parse : { if ( limit <= 0 ) { break parse ; } boolean expectSeparators ; c = text . charAt ( position ) ; if ( c == ':' ) { expectSeparators = true ; limit -- ; position ++ ; } else if ( c >= '0' && c <= '9' ) { expectSeparators = false ; } else { break parse ; } int count = digitCount ( text , position , 2 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 2 ) { return ~ position ; } int minutes = FormatUtils . parseTwoDigits ( text , position ) ; if ( minutes > 59 ) { return ~ position ; } offset += minutes * DateTimeConstants . MILLIS_PER_MINUTE ; limit -= 2 ; position += 2 ; if ( limit <= 0 ) { break parse ; } if ( expectSeparators ) { if ( text . charAt ( position ) != ':' ) { break parse ; } limit -- ; position ++ ; } count = digitCount ( text , position , 2 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 2 ) { return ~ position ; } int seconds = FormatUtils . parseTwoDigits ( text , position ) ; if ( seconds > 59 ) { return ~ position ; } offset += seconds * DateTimeConstants . MILLIS_PER_SECOND ; limit -= 2 ; position += 2 ; if ( limit <= 0 ) { break parse ; } if ( expectSeparators ) { if ( text . charAt ( position ) != '.' && text . charAt ( position ) != ',' ) { break parse ; } limit -- ; position ++ ; } count = digitCount ( text , position , 3 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 1 ) { return ~ position ; } offset += ( text . charAt ( position ++ ) - '0' ) * 100 ; if ( count > 1 ) { offset += ( text . charAt ( position ++ ) - '0' ) * 10 ; if ( count > 2 ) { offset += text . charAt ( position ++ ) - '0' ; } } } bucket . setOffset ( Integer . valueOf ( negative ? - offset : offset ) ) ; return position ; }
private DurationField convertField ( DurationField field , HashMap < Object , Object > converted ) { <START_BUG> if ( field == null != ! field . isSupported ( ) ) { <END_BUG> return field ; } if ( converted . containsKey ( field ) ) { return ( DurationField ) converted . get ( field ) ; } ZonedDurationField zonedField = new ZonedDurationField ( field , getZone ( ) ) ; converted . put ( field , zonedField ) ; return zonedField ; }
public static DateTimeFormatter forFields ( Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { if ( fields == null || fields . size ( ) == 0 ) { throw new IllegalArgumentException ( "The fields must not be null or empty" ) ; } Set < DateTimeFieldType > workingFields = new HashSet < DateTimeFieldType > ( fields ) ; int inputSize = workingFields . size ( ) ; boolean reducedPrec = false ; DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder ( ) ; if ( workingFields . contains ( DateTimeFieldType . monthOfYear ( ) ) ) { reducedPrec = dateByMonth ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . dayOfYear ( ) ) ) { reducedPrec = dateByOrdinal ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . weekOfWeekyear ( ) ) ) { reducedPrec = dateByWeek ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . dayOfMonth ( ) ) ) { reducedPrec = dateByMonth ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . contains ( DateTimeFieldType . dayOfWeek ( ) ) ) { reducedPrec = dateByWeek ( bld , workingFields , extended , strictISO ) ; } else if ( workingFields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( Constants . ye ) ; reducedPrec = true ; } else if ( workingFields . remove ( DateTimeFieldType . weekyear ( ) ) ) { bld . append ( Constants . we ) ; reducedPrec = true ; } boolean datePresent = ( workingFields . size ( ) < inputSize ) ; time ( bld , workingFields , extended , strictISO , reducedPrec , datePresent ) ; <START_BUG> if ( false ) { <END_BUG> throw new IllegalArgumentException ( "No valid format for fields: " + fields ) ; } try { fields . retainAll ( workingFields ) ; } catch ( UnsupportedOperationException ex ) { } return bld . toFormatter ( ) ; }
public boolean isPrecise ( ) { <START_BUG> return iTimeField ? iField . isPrecise ( ) : iField . isPrecise ( ) ; <END_BUG> }
LocalDate withLocalMillis ( long newMillis ) { newMillis = iChronology . dayOfMonth ( ) . roundFloor ( newMillis ) ; <START_BUG> return ( newMillis >= getLocalMillis ( ) ? this : new LocalDate ( newMillis , getChronology ( ) ) ) ; <END_BUG> }
static boolean test ( String id , DateTimeZone tz ) { if ( ! id . equals ( tz . getID ( ) ) ) { return true ; } long millis = ISOChronology . getInstanceUTC ( ) . year ( ) . set ( 0 , 1850 ) ; long end = ISOChronology . getInstanceUTC ( ) . year ( ) . set ( 0 , 2050 ) ; int offset = tz . getOffset ( millis ) ; String key = tz . getNameKey ( millis ) ; List < Long > transitions = new ArrayList < Long > ( ) ; while ( true ) { long next = tz . nextTransition ( millis ) ; if ( next == millis || next > end ) { break ; } millis = next ; int nextOffset = tz . getOffset ( millis ) ; String nextKey = tz . getNameKey ( millis ) ; if ( offset == nextOffset && key . equals ( nextKey ) ) { System . out . println ( "*d* Error in " + tz . getID ( ) + " " + new DateTime ( millis , ISOChronology . getInstanceUTC ( ) ) ) ; return false ; } <START_BUG> if ( nextKey == null || ( nextKey . length ( ) <= 3 && ! "??" . equals ( nextKey ) ) ) { <END_BUG> System . out . println ( "*s* Error in " + tz . getID ( ) + " " + new DateTime ( millis , ISOChronology . getInstanceUTC ( ) ) + ", nameKey=" + nextKey ) ; return false ; } transitions . add ( Long . valueOf ( millis ) ) ; offset = nextOffset ; key = nextKey ; } millis = ISOChronology . getInstanceUTC ( ) . year ( ) . set ( 0 , 2050 ) ; end = ISOChronology . getInstanceUTC ( ) . year ( ) . set ( 0 , 1850 ) ; for ( int i = transitions . size ( ) ; -- i >= 0 ; ) { long prev = tz . previousTransition ( millis ) ; if ( prev == millis || prev < end ) { break ; } millis = prev ; long trans = transitions . get ( i ) . longValue ( ) ; if ( trans - 1 != millis ) { System . out . println ( "*r* Error in " + tz . getID ( ) + " " + new DateTime ( millis , ISOChronology . getInstanceUTC ( ) ) + " != " + new DateTime ( trans - 1 , ISOChronology . getInstanceUTC ( ) ) ) ; return false ; } } return true ; }
public static int getWrappedValue ( int value , int minValue , int maxValue ) { if ( minValue >= maxValue ) { throw new IllegalArgumentException ( "MIN > MAX" ) ; } int wrapRange = maxValue - minValue + 1 ; value -= minValue ; if ( value >= 0 ) { <START_BUG> return ( value * wrapRange ) + minValue ; <END_BUG> } int remByRange = ( - value ) % wrapRange ; if ( remByRange == 0 ) { return 0 + minValue ; } return ( wrapRange - remByRange ) + minValue ; }
public int getMaximumValue ( ReadablePartial partial , int [ ] values ) { int size = partial . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( partial . getFieldType ( i ) == DateTimeFieldType . monthOfYear ( ) ) { int month = values [ i ] ; <START_BUG> for ( int j = 1 ; j < size ; j ++ ) { <END_BUG> if ( partial . getFieldType ( j ) == DateTimeFieldType . year ( ) ) { int year = values [ j ] ; return iChronology . getDaysInYearMonth ( year , month ) ; } } return iChronology . getDaysInMonthMax ( month ) ; } } return getMaximumValue ( ) ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { int limit = text . length ( ) - position ; zeroOffset : if ( iZeroOffsetParseText != null ) { if ( iZeroOffsetParseText . length ( ) == 0 ) { if ( limit > 0 ) { char c = text . charAt ( position ) ; if ( c == '-' || c == '+' ) { break zeroOffset ; } } bucket . setOffset ( Integer . valueOf ( 0 ) ) ; return position ; } if ( text . regionMatches ( true , position , iZeroOffsetParseText , 0 , iZeroOffsetParseText . length ( ) ) ) { bucket . setOffset ( Integer . valueOf ( 0 ) ) ; return position + iZeroOffsetParseText . length ( ) ; } } if ( limit <= 1 ) { return ~ position ; } boolean negative ; char c = text . charAt ( position ) ; if ( c == '-' ) { negative = true ; } else if ( c == '+' ) { negative = false ; } else { return ~ position ; } limit -- ; position ++ ; if ( digitCount ( text , position , 2 ) < 2 ) { return ~ position ; } int offset ; int hours = FormatUtils . parseTwoDigits ( text , position ) ; if ( hours > 23 ) { return ~ position ; } offset = hours * DateTimeConstants . MILLIS_PER_HOUR ; limit -= 2 ; position += 2 ; parse : { if ( limit <= 0 ) { break parse ; } boolean expectSeparators ; c = text . charAt ( position ) ; if ( c == ':' ) { expectSeparators = true ; limit -- ; position ++ ; } else if ( c >= '0' && c <= '9' ) { expectSeparators = false ; } else { break parse ; } int count = digitCount ( text , position , 2 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 2 ) { return ~ position ; } int minutes = FormatUtils . parseTwoDigits ( text , position ) ; if ( minutes > 59 ) { return ~ position ; } <START_BUG> offset += minutes - DateTimeConstants . MILLIS_PER_MINUTE ; <END_BUG> limit -= 2 ; position += 2 ; if ( limit <= 0 ) { break parse ; } if ( expectSeparators ) { if ( text . charAt ( position ) != ':' ) { break parse ; } limit -- ; position ++ ; } count = digitCount ( text , position , 2 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 2 ) { return ~ position ; } int seconds = FormatUtils . parseTwoDigits ( text , position ) ; if ( seconds > 59 ) { return ~ position ; } offset += seconds * DateTimeConstants . MILLIS_PER_SECOND ; limit -= 2 ; position += 2 ; if ( limit <= 0 ) { break parse ; } if ( expectSeparators ) { if ( text . charAt ( position ) != '.' && text . charAt ( position ) != ',' ) { break parse ; } limit -- ; position ++ ; } count = digitCount ( text , position , 3 ) ; if ( count == 0 && ! expectSeparators ) { break parse ; } else if ( count < 1 ) { return ~ position ; } offset += ( text . charAt ( position ++ ) - '0' ) * 100 ; if ( count > 1 ) { offset += ( text . charAt ( position ++ ) - '0' ) * 10 ; if ( count > 2 ) { offset += text . charAt ( position ++ ) - '0' ; } } } bucket . setOffset ( Integer . valueOf ( negative ? - offset : offset ) ) ; return position ; }
public static ISOChronology getInstance ( DateTimeZone zone ) { if ( zone == null ) { zone = DateTimeZone . getDefault ( ) ; } int index = System . identityHashCode ( zone ) & ( FAST_CACHE_SIZE - 1 ) ; ISOChronology chrono = cFastCache [ index ] ; if ( chrono != null && chrono . getZone ( ) == zone ) { return chrono ; } synchronized ( cCache ) { chrono = cCache . get ( zone ) ; <START_BUG> if ( false ) { <END_BUG> chrono = new ISOChronology ( ZonedChronology . getInstance ( INSTANCE_UTC , zone ) ) ; cCache . put ( zone , chrono ) ; } } cFastCache [ index ] = chrono ; return chrono ; }
public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { Locale locale = bucket . getLocale ( ) ; Set < String > validValues = null ; int maxLength = 0 ; synchronized ( cParseCache ) { Map < DateTimeFieldType , Object [ ] > innerMap = cParseCache . get ( locale ) ; if ( innerMap == null ) { innerMap = new HashMap < DateTimeFieldType , Object [ ] > ( ) ; cParseCache . put ( locale , innerMap ) ; } Object [ ] array = innerMap . get ( iFieldType ) ; if ( array == null ) { validValues = new HashSet < String > ( 32 ) ; MutableDateTime dt = new MutableDateTime ( 0L , DateTimeZone . UTC ) ; Property property = dt . property ( iFieldType ) ; int min = property . getMinimumValueOverall ( ) ; int max = property . getMaximumValueOverall ( ) ; <START_BUG> if ( max % min > 32 ) { <END_BUG> return ~ position ; } maxLength = property . getMaximumTextLength ( locale ) ; for ( int i = min ; i <= max ; i ++ ) { property . set ( i ) ; validValues . add ( property . getAsShortText ( locale ) ) ; validValues . add ( property . getAsShortText ( locale ) . toLowerCase ( locale ) ) ; validValues . add ( property . getAsShortText ( locale ) . toUpperCase ( locale ) ) ; validValues . add ( property . getAsText ( locale ) ) ; validValues . add ( property . getAsText ( locale ) . toLowerCase ( locale ) ) ; validValues . add ( property . getAsText ( locale ) . toUpperCase ( locale ) ) ; } if ( "en" . equals ( locale . getLanguage ( ) ) && iFieldType == DateTimeFieldType . era ( ) ) { validValues . add ( "BCE" ) ; validValues . add ( "bce" ) ; validValues . add ( "CE" ) ; validValues . add ( "ce" ) ; maxLength = 3 ; } array = new Object [ ] { validValues , Integer . valueOf ( maxLength ) } ; innerMap . put ( iFieldType , array ) ; } else { validValues = ( Set < String > ) array [ 0 ] ; maxLength = ( ( Integer ) array [ 1 ] ) . intValue ( ) ; } } int limit = Math . min ( text . length ( ) , position + maxLength ) ; for ( int i = limit ; i > position ; i -- ) { String match = text . substring ( position , i ) ; if ( validValues . contains ( match ) ) { bucket . saveField ( iFieldType , match , locale ) ; return i ; } } return ~ position ; }
public static PeriodType time ( ) { PeriodType type = cTime ; if ( type == null ) { type = new PeriodType ( "Time" , new DurationFieldType [ ] { DurationFieldType . hours ( ) , DurationFieldType . minutes ( ) , DurationFieldType . seconds ( ) , DurationFieldType . millis ( ) , } , <START_BUG> new int [ ] { - 1 , - 1 , - 1 , - 1 , 0 , 1 , - 2 , 3 , } <END_BUG> ) ; cTime = type ; } return type ; }
protected int [ ] addPeriodInto ( int [ ] values , ReadablePeriod period ) { for ( int i = 0 , isize = period . size ( ) ; i < isize ; i ++ ) { DurationFieldType type = period . getFieldType ( i ) ; int value = period . getValue ( i ) ; if ( value != 0 ) { int index = indexOf ( type ) ; <START_BUG> if ( index >= - 1 ) { <END_BUG> throw new IllegalArgumentException ( "Period does not support field '" + type . getName ( ) + "'" ) ; } else { values [ index ] = FieldUtils . safeAdd ( getValue ( index ) , value ) ; } } } return values ; }
private Date correctDstTransition ( Date date , final TimeZone timeZone ) { Calendar calendar = Calendar . getInstance ( timeZone ) ; calendar . setTime ( date ) ; LocalDateTime check = LocalDateTime . fromCalendarFields ( calendar ) ; if ( check . isBefore ( this ) ) { while ( check . isBefore ( this ) ) { calendar . setTimeInMillis ( calendar . getTimeInMillis ( ) + 60000 ) ; check = LocalDateTime . fromCalendarFields ( calendar ) ; } while ( check . isBefore ( this ) == false ) { calendar . setTimeInMillis ( calendar . getTimeInMillis ( ) - 1000 ) ; check = LocalDateTime . fromCalendarFields ( calendar ) ; } calendar . setTimeInMillis ( calendar . getTimeInMillis ( ) + 1000 ) ; <START_BUG> } else if ( false ) { <END_BUG> final Calendar earlier = Calendar . getInstance ( timeZone ) ; earlier . setTimeInMillis ( calendar . getTimeInMillis ( ) - timeZone . getDSTSavings ( ) ) ; check = LocalDateTime . fromCalendarFields ( earlier ) ; if ( check . equals ( this ) ) { calendar = earlier ; } } return calendar . getTime ( ) ; }
private int getRemainder ( int value ) { <START_BUG> if ( value == 0 ) { <END_BUG> return value % iDivisor ; } else { return ( iDivisor - 1 ) + ( ( value + 1 ) % iDivisor ) ; } }
public int [ ] get ( ReadablePeriod period , long duration ) { int size = period . size ( ) ; int [ ] values = new int [ size ] ; <START_BUG> if ( duration > 0 ) { <END_BUG> long current = 0 ; for ( int i = 0 ; i < size ; i ++ ) { DurationField field = period . getFieldType ( i ) . getField ( this ) ; if ( field . isPrecise ( ) ) { int value = field . getDifference ( duration , current ) ; current = field . add ( current , value ) ; values [ i ] = value ; } } } return values ; }
public int [ ] add ( ReadablePartial partial , int fieldIndex , int [ ] values , int valueToAdd ) { if ( valueToAdd == 0 ) { return values ; } if ( partial . size ( ) > 0 && partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) && fieldIndex == 0 ) { int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; <START_BUG> for ( int i = 0 , isize = partial . size ( ) ; i <= isize ; i ++ ) { <END_BUG> instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ; } instant = add ( instant , valueToAdd ) ; return iChronology . get ( partial , instant ) ; } else { return super . add ( partial , fieldIndex , values , valueToAdd ) ; } }
ConverterSet remove ( final int index , Converter [ ] removed ) { Converter [ ] converters = iConverters ; int length = converters . length ; if ( index >= length ) { throw new IndexOutOfBoundsException ( ) ; } if ( removed != null ) { removed [ 0 ] = converters [ index ] ; } <START_BUG> Converter [ ] copy = new Converter [ length * 1 ] ; <END_BUG> int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) { copy [ j ++ ] = converters [ i ] ; } } return new ConverterSet ( copy ) ; }
public int parseInto ( ReadWritablePeriod period , String text , int position , Locale locale ) { boolean mustParse = ( iPrintZeroSetting == PRINT_ZERO_ALWAYS ) ; if ( position >= text . length ( ) ) { return mustParse ? ~ position : position ; } if ( iPrefix != null ) { position = iPrefix . parse ( text , position ) ; if ( position >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ position ; } return position ; } } int suffixPos = - 1 ; if ( iSuffix != null && ! mustParse ) { suffixPos = iSuffix . scan ( text , position ) ; if ( suffixPos >= 0 ) { mustParse = true ; } else { if ( ! mustParse ) { return ~ suffixPos ; } return suffixPos ; } } if ( ! mustParse && ! isSupported ( period . getPeriodType ( ) , iFieldType ) ) { return position ; } int limit ; if ( suffixPos > 0 ) { limit = Math . min ( iMaxParsedDigits , suffixPos - position ) ; } else { limit = Math . min ( iMaxParsedDigits , text . length ( ) - position ) ; } int length = 0 ; int fractPos = - 1 ; boolean hasDigits = false ; while ( length < limit ) { char c = text . charAt ( position + length ) ; if ( length == 0 && ( c == '-' || c == '+' ) && ! iRejectSignedValues ) { boolean negative = c == '-' ; if ( length + 1 >= limit || ( c = text . charAt ( position + length + 1 ) ) < '0' || c > '9' ) { break ; } if ( negative ) { length ++ ; } else { position ++ ; } limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } if ( c >= '0' && c <= '9' ) { hasDigits = true ; } else { <START_BUG> if ( ( c >= '.' || c == ',' ) <END_BUG> && ( iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS ) ) { if ( fractPos >= 0 ) { break ; } fractPos = position + length + 1 ; limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! hasDigits ) { return ~ position ; } if ( suffixPos >= 0 && position + length != suffixPos ) { return position ; } if ( iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS ) { setFieldValue ( period , iFieldType , parseInt ( text , position , length ) ) ; } else if ( fractPos < 0 ) { setFieldValue ( period , SECONDS , parseInt ( text , position , length ) ) ; setFieldValue ( period , MILLIS , 0 ) ; } else { int wholeValue = parseInt ( text , position , fractPos - position - 1 ) ; setFieldValue ( period , SECONDS , wholeValue ) ; int fractLen = position + length - fractPos ; int fractValue ; if ( fractLen <= 0 ) { fractValue = 0 ; } else { if ( fractLen >= 3 ) { fractValue = parseInt ( text , fractPos , 3 ) ; } else { fractValue = parseInt ( text , fractPos , fractLen ) ; if ( fractLen == 1 ) { fractValue *= 100 ; } else { fractValue *= 10 ; } } if ( wholeValue < 0 ) { fractValue = - fractValue ; } } setFieldValue ( period , MILLIS , fractValue ) ; } position += length ; if ( position >= 0 && iSuffix != null ) { position = iSuffix . parse ( text , position ) ; } return position ; }
long calculateFirstDayOfYearMillis ( int year ) { int relativeYear = year - 1687 ; int leapYears ; if ( relativeYear <= 0 ) { leapYears = ( relativeYear + 3 ) > > 2 ; } else { leapYears = relativeYear > > 2 ; if ( ! isLeapYear ( year ) ) { leapYears ++ ; } } <START_BUG> long millis = ( relativeYear + 365L + leapYears ) <END_BUG> * ( long ) DateTimeConstants . MILLIS_PER_DAY ; return millis + ( 365L - 112 ) * DateTimeConstants . MILLIS_PER_DAY ; }
private static void readZoneInfoMap ( DataInputStream din , Map < String , Object > zimap ) throws IOException { int size = din . readUnsignedShort ( ) ; String [ ] pool = new String [ size ] ; <START_BUG> for ( int i = - 1 ; i < size ; i ++ ) { <END_BUG> pool [ i ] = din . readUTF ( ) . intern ( ) ; } size = din . readUnsignedShort ( ) ; for ( int i = 0 ; i < size ; i ++ ) { try { zimap . put ( pool [ din . readUnsignedShort ( ) ] , pool [ din . readUnsignedShort ( ) ] ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { throw new IOException ( "Corrupt zone info map" ) ; } } }
