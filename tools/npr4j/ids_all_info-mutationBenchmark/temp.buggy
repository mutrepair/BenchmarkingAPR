if ( ! false ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Text CaMeL Title ) ) { return false ; } Text CaMeL Title that = ( Text CaMeL Title ) obj ; if ( ! Object CaMeL Utilities . equal ( this . text , that . text ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . font , that . font ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . paint , that . paint ) ) { return false ; } if ( this . text CaMeL Alignment != that . text CaMeL Alignment ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . background CaMeL Paint , that . background CaMeL Paint ) ) { return false ; } if ( this . maximum CaMeL Lines CaMeL To CaMeL Display != that . maximum CaMeL Lines CaMeL To CaMeL Display ) { return false ; } if ( this . expand CaMeL To CaMeL Fit CaMeL Space != that . expand CaMeL To CaMeL Fit CaMeL Space ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . tool CaMeL Tip CaMeL Text , that . tool CaMeL Tip CaMeL Text ) ) { return false ; } if ( ! false ) { return false ; } return super . equals ( obj ) ; }
if ( false ) { <CTX> public void notify CaMeL Listeners ( Plot CaMeL Change CaMeL Event event ) { / / if the $STRING$ flag has been switched to false , we don t notify / / the listeners if ( ! this . notify ) { return ; } Object [ ] listeners = this . listener CaMeL List . get CaMeL Listener CaMeL List ( ) ; for ( int i = listeners . length - $NUMBER$ ; i >= 0 ; i -= $NUMBER$ ) { if ( false ) { ( ( Plot CaMeL Change CaMeL Listener ) listeners [ i + 1 ] ) . plot CaMeL Changed ( event ) ; } } }
if ( true ) { <CTX> protected Axis CaMeL Space calculate CaMeL Domain CaMeL Axis CaMeL Space ( Graphics $NUMBER$ D g $NUMBER$ , Rectangle $NUMBER$ D plot CaMeL Area , Axis CaMeL Space space ) { if ( space == null ) { space = new Axis CaMeL Space ( ) ; } / / reserve some space for the domain axis . . . if ( true ) { if ( this . orientation == Plot CaMeL Orientation . HORIZONTAL ) { space . ensure CaMeL At CaMeL Least ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space . get CaMeL Left ( ) , Rectangle CaMeL Edge . LEFT ) ; space . ensure CaMeL At CaMeL Least ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space . get CaMeL Right ( ) , Rectangle CaMeL Edge . RIGHT ) ; } else if ( this . orientation == Plot CaMeL Orientation . VERTICAL ) { space . ensure CaMeL At CaMeL Least ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space . get CaMeL Top ( ) , Rectangle CaMeL Edge . TOP ) ; space . ensure CaMeL At CaMeL Least ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space . get CaMeL Bottom ( ) , Rectangle CaMeL Edge . BOTTOM ) ; } } else { / / reserve space for the primary domain axis . . . Rectangle CaMeL Edge domain CaMeL Edge = Plot . resolve CaMeL Domain CaMeL Axis CaMeL Location ( get CaMeL Domain CaMeL Axis CaMeL Location ( ) , this . orientation ) ; if ( this . draw CaMeL Shared CaMeL Domain CaMeL Axis ) { space = get CaMeL Domain CaMeL Axis ( ) . reserve CaMeL Space ( g $NUMBER$ , this , plot CaMeL Area , domain CaMeL Edge , space ) ; } / / reserve space for any domain axes . . . for ( int i = 0 ; i < this . domain CaMeL Axes . size ( ) ; i ++ ) { Axis x CaMeL Axis = ( Axis ) this . domain CaMeL Axes . get ( i ) ; if ( x CaMeL Axis != null ) { Rectangle CaMeL Edge edge = get CaMeL Domain CaMeL Axis CaMeL Edge ( i ) ; space = x CaMeL Axis . reserve CaMeL Space ( g $NUMBER$ , this , plot CaMeL Area , edge , space ) ; } } } return space ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Category CaMeL Plot ) ) { return false ; } Category CaMeL Plot that = ( Category CaMeL Plot ) obj ; if ( this . orientation != that . orientation ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . axis CaMeL Offset , that . axis CaMeL Offset ) ) { return false ; } if ( ! this . domain CaMeL Axes . equals ( that . domain CaMeL Axes ) ) { return false ; } if ( ! this . domain CaMeL Axis CaMeL Locations . equals ( that . domain CaMeL Axis CaMeL Locations ) ) { return false ; } if ( this . draw CaMeL Shared CaMeL Domain CaMeL Axis != that . draw CaMeL Shared CaMeL Domain CaMeL Axis ) { return false ; } if ( ! this . range CaMeL Axes . equals ( that . range CaMeL Axes ) ) { return false ; } if ( ! this . range CaMeL Axis CaMeL Locations . equals ( that . range CaMeL Axis CaMeL Locations ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . dataset CaMeL To CaMeL Domain CaMeL Axes CaMeL Map , that . dataset CaMeL To CaMeL Domain CaMeL Axes CaMeL Map ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . dataset CaMeL To CaMeL Range CaMeL Axes CaMeL Map , that . dataset CaMeL To CaMeL Range CaMeL Axes CaMeL Map ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( this . rendering CaMeL Order != that . rendering CaMeL Order ) { return false ; } if ( this . column CaMeL Rendering CaMeL Order != that . column CaMeL Rendering CaMeL Order ) { return false ; } if ( this . row CaMeL Rendering CaMeL Order != that . row CaMeL Rendering CaMeL Order ) { return false ; } if ( this . domain CaMeL Gridlines CaMeL Visible != that . domain CaMeL Gridlines CaMeL Visible ) { return false ; } if ( this . domain CaMeL Gridline CaMeL Position != that . domain CaMeL Gridline CaMeL Position ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Gridline CaMeL Stroke , that . domain CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Gridline CaMeL Paint , that . domain CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( this . range CaMeL Gridlines CaMeL Visible != that . range CaMeL Gridlines CaMeL Visible ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Gridline CaMeL Stroke , that . range CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Gridline CaMeL Paint , that . range CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( this . anchor CaMeL Value != that . anchor CaMeL Value ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Visible != that . range CaMeL Crosshair CaMeL Visible ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Value != that . range CaMeL Crosshair CaMeL Value ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Crosshair CaMeL Stroke , that . range CaMeL Crosshair CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Crosshair CaMeL Paint , that . range CaMeL Crosshair CaMeL Paint ) ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data != that . range CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Domain CaMeL Markers , that . foreground CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Domain CaMeL Markers , that . background CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Range CaMeL Markers , that . foreground CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Range CaMeL Markers , that . background CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( this . weight != that . weight ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space , that . fixed CaMeL Domain CaMeL Axis CaMeL Space ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Range CaMeL Axis CaMeL Space , that . fixed CaMeL Range CaMeL Axis CaMeL Space ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Legend CaMeL Items , that . fixed CaMeL Legend CaMeL Items ) ) { return false ; } if ( this . domain CaMeL Crosshair CaMeL Visible != that . domain CaMeL Crosshair CaMeL Visible ) { return false ; } if ( this . crosshair CaMeL Dataset CaMeL Index != that . crosshair CaMeL Dataset CaMeL Index ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Column CaMeL Key , that . domain CaMeL Crosshair CaMeL Column CaMeL Key ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Row CaMeL Key , that . domain CaMeL Crosshair CaMeL Row CaMeL Key ) ) { return true ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Paint , that . domain CaMeL Crosshair CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Stroke , that . domain CaMeL Crosshair CaMeL Stroke ) ) { return false ; } if ( this . range CaMeL Minor CaMeL Gridlines CaMeL Visible != that . range CaMeL Minor CaMeL Gridlines CaMeL Visible ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Minor CaMeL Gridline CaMeL Paint , that . range CaMeL Minor CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Minor CaMeL Gridline CaMeL Stroke , that . range CaMeL Minor CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( this . range CaMeL Zero CaMeL Baseline CaMeL Visible != that . range CaMeL Zero CaMeL Baseline CaMeL Visible ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Zero CaMeL Baseline CaMeL Paint , that . range CaMeL Zero CaMeL Baseline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Zero CaMeL Baseline CaMeL Stroke , that . range CaMeL Zero CaMeL Baseline CaMeL Stroke ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . shadow CaMeL Generator , that . shadow CaMeL Generator ) ) { return false ; } return super . equals ( obj ) ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Category CaMeL Plot ) ) { return false ; } Category CaMeL Plot that = ( Category CaMeL Plot ) obj ; if ( this . orientation != that . orientation ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . axis CaMeL Offset , that . axis CaMeL Offset ) ) { return false ; } if ( ! this . domain CaMeL Axes . equals ( that . domain CaMeL Axes ) ) { return false ; } if ( ! this . domain CaMeL Axis CaMeL Locations . equals ( that . domain CaMeL Axis CaMeL Locations ) ) { return false ; } if ( this . draw CaMeL Shared CaMeL Domain CaMeL Axis != that . draw CaMeL Shared CaMeL Domain CaMeL Axis ) { return false ; } if ( ! this . range CaMeL Axes . equals ( that . range CaMeL Axes ) ) { return false ; } if ( ! this . range CaMeL Axis CaMeL Locations . equals ( that . range CaMeL Axis CaMeL Locations ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . dataset CaMeL To CaMeL Domain CaMeL Axes CaMeL Map , that . dataset CaMeL To CaMeL Domain CaMeL Axes CaMeL Map ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . dataset CaMeL To CaMeL Range CaMeL Axes CaMeL Map , that . dataset CaMeL To CaMeL Range CaMeL Axes CaMeL Map ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( this . rendering CaMeL Order != that . rendering CaMeL Order ) { return false ; } if ( this . column CaMeL Rendering CaMeL Order != that . column CaMeL Rendering CaMeL Order ) { return false ; } if ( this . row CaMeL Rendering CaMeL Order != that . row CaMeL Rendering CaMeL Order ) { return false ; } if ( this . domain CaMeL Gridlines CaMeL Visible != that . domain CaMeL Gridlines CaMeL Visible ) { return false ; } if ( this . domain CaMeL Gridline CaMeL Position != that . domain CaMeL Gridline CaMeL Position ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Gridline CaMeL Stroke , that . domain CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Gridline CaMeL Paint , that . domain CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( this . range CaMeL Gridlines CaMeL Visible != that . range CaMeL Gridlines CaMeL Visible ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Gridline CaMeL Stroke , that . range CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Gridline CaMeL Paint , that . range CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( this . anchor CaMeL Value != that . anchor CaMeL Value ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Visible != that . range CaMeL Crosshair CaMeL Visible ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Value != that . range CaMeL Crosshair CaMeL Value ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Crosshair CaMeL Stroke , that . range CaMeL Crosshair CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Crosshair CaMeL Paint , that . range CaMeL Crosshair CaMeL Paint ) ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data != that . range CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Domain CaMeL Markers , that . foreground CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Domain CaMeL Markers , that . background CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Range CaMeL Markers , that . foreground CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Range CaMeL Markers , that . background CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( this . weight != that . weight ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space , that . fixed CaMeL Domain CaMeL Axis CaMeL Space ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Range CaMeL Axis CaMeL Space , that . fixed CaMeL Range CaMeL Axis CaMeL Space ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Legend CaMeL Items , that . fixed CaMeL Legend CaMeL Items ) ) { return false ; } if ( this . domain CaMeL Crosshair CaMeL Visible != that . domain CaMeL Crosshair CaMeL Visible ) { return false ; } if ( this . crosshair CaMeL Dataset CaMeL Index != that . crosshair CaMeL Dataset CaMeL Index ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Column CaMeL Key , that . domain CaMeL Crosshair CaMeL Column CaMeL Key ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Row CaMeL Key , that . domain CaMeL Crosshair CaMeL Row CaMeL Key ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Paint , that . domain CaMeL Crosshair CaMeL Paint ) ) { return true ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Stroke , that . domain CaMeL Crosshair CaMeL Stroke ) ) { return false ; } if ( this . range CaMeL Minor CaMeL Gridlines CaMeL Visible != that . range CaMeL Minor CaMeL Gridlines CaMeL Visible ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Minor CaMeL Gridline CaMeL Paint , that . range CaMeL Minor CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Minor CaMeL Gridline CaMeL Stroke , that . range CaMeL Minor CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( this . range CaMeL Zero CaMeL Baseline CaMeL Visible != that . range CaMeL Zero CaMeL Baseline CaMeL Visible ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Zero CaMeL Baseline CaMeL Paint , that . range CaMeL Zero CaMeL Baseline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Zero CaMeL Baseline CaMeL Stroke , that . range CaMeL Zero CaMeL Baseline CaMeL Stroke ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . shadow CaMeL Generator , that . shadow CaMeL Generator ) ) { return false ; } return super . equals ( obj ) ; }
if ( false ) { <CTX> public XY CaMeL Dataset get CaMeL Dataset ( int index ) { XY CaMeL Dataset result = null ; if ( false ) { result = ( XY CaMeL Dataset ) this . datasets . get ( index ) ; } return result ; }
set CaMeL Dataset ( - 1 , dataset ) ; <CTX> public void set CaMeL Dataset ( XY CaMeL Dataset dataset ) { set CaMeL Dataset ( - 1 , dataset ) ; }
if ( false ) { <CTX> public XY CaMeL Item CaMeL Renderer get CaMeL Renderer CaMeL For CaMeL Dataset ( XY CaMeL Dataset dataset ) { XY CaMeL Item CaMeL Renderer result = null ; for ( int i = 0 ; i < this . datasets . size ( ) ; i ++ ) { if ( this . datasets . get ( i ) == dataset ) { result = ( XY CaMeL Item CaMeL Renderer ) this . renderers . get ( i ) ; if ( false ) { result = get CaMeL Renderer ( ) ; } break ; } } return result ; }
if ( ! false ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY CaMeL Plot ) ) { return false ; } XY CaMeL Plot that = ( XY CaMeL Plot ) obj ; if ( this . weight != that . weight ) { return false ; } if ( this . orientation != that . orientation ) { return false ; } if ( ! this . domain CaMeL Axes . equals ( that . domain CaMeL Axes ) ) { return false ; } if ( ! false ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data != that . range CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data ) { return false ; } if ( this . domain CaMeL Gridlines CaMeL Visible != that . domain CaMeL Gridlines CaMeL Visible ) { return false ; } if ( this . range CaMeL Gridlines CaMeL Visible != that . range CaMeL Gridlines CaMeL Visible ) { return false ; } if ( this . domain CaMeL Minor CaMeL Gridlines CaMeL Visible != that . domain CaMeL Minor CaMeL Gridlines CaMeL Visible ) { return false ; } if ( this . range CaMeL Minor CaMeL Gridlines CaMeL Visible != that . range CaMeL Minor CaMeL Gridlines CaMeL Visible ) { return false ; } if ( this . domain CaMeL Zero CaMeL Baseline CaMeL Visible != that . domain CaMeL Zero CaMeL Baseline CaMeL Visible ) { return false ; } if ( this . range CaMeL Zero CaMeL Baseline CaMeL Visible != that . range CaMeL Zero CaMeL Baseline CaMeL Visible ) { return false ; } if ( this . domain CaMeL Crosshair CaMeL Visible != that . domain CaMeL Crosshair CaMeL Visible ) { return false ; } if ( this . domain CaMeL Crosshair CaMeL Value != that . domain CaMeL Crosshair CaMeL Value ) { return false ; } if ( this . domain CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data != that . domain CaMeL Crosshair CaMeL Locked CaMeL On CaMeL Data ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Visible != that . range CaMeL Crosshair CaMeL Visible ) { return false ; } if ( this . range CaMeL Crosshair CaMeL Value != that . range CaMeL Crosshair CaMeL Value ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . axis CaMeL Offset , that . axis CaMeL Offset ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Axes , that . range CaMeL Axes ) ) { return false ; } if ( ! this . range CaMeL Axis CaMeL Locations . equals ( that . range CaMeL Axis CaMeL Locations ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . dataset CaMeL To CaMeL Domain CaMeL Axes CaMeL Map , that . dataset CaMeL To CaMeL Domain CaMeL Axes CaMeL Map ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . dataset CaMeL To CaMeL Range CaMeL Axes CaMeL Map , that . dataset CaMeL To CaMeL Range CaMeL Axes CaMeL Map ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Gridline CaMeL Stroke , that . domain CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Gridline CaMeL Paint , that . domain CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Gridline CaMeL Stroke , that . range CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Gridline CaMeL Paint , that . range CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Minor CaMeL Gridline CaMeL Stroke , that . domain CaMeL Minor CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Minor CaMeL Gridline CaMeL Paint , that . domain CaMeL Minor CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Minor CaMeL Gridline CaMeL Stroke , that . range CaMeL Minor CaMeL Gridline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Minor CaMeL Gridline CaMeL Paint , that . range CaMeL Minor CaMeL Gridline CaMeL Paint ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Zero CaMeL Baseline CaMeL Paint , that . domain CaMeL Zero CaMeL Baseline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Zero CaMeL Baseline CaMeL Stroke , that . domain CaMeL Zero CaMeL Baseline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Zero CaMeL Baseline CaMeL Paint , that . range CaMeL Zero CaMeL Baseline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Zero CaMeL Baseline CaMeL Stroke , that . range CaMeL Zero CaMeL Baseline CaMeL Stroke ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Stroke , that . domain CaMeL Crosshair CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Crosshair CaMeL Paint , that . domain CaMeL Crosshair CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Crosshair CaMeL Stroke , that . range CaMeL Crosshair CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Crosshair CaMeL Paint , that . range CaMeL Crosshair CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Domain CaMeL Markers , that . foreground CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Domain CaMeL Markers , that . background CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Range CaMeL Markers , that . foreground CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Range CaMeL Markers , that . background CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Domain CaMeL Markers , that . foreground CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Domain CaMeL Markers , that . background CaMeL Domain CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . foreground CaMeL Range CaMeL Markers , that . foreground CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . background CaMeL Range CaMeL Markers , that . background CaMeL Range CaMeL Markers ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fixed CaMeL Legend CaMeL Items , that . fixed CaMeL Legend CaMeL Items ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . domain CaMeL Tick CaMeL Band CaMeL Paint , that . domain CaMeL Tick CaMeL Band CaMeL Paint ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . range CaMeL Tick CaMeL Band CaMeL Paint , that . range CaMeL Tick CaMeL Band CaMeL Paint ) ) { return false ; } if ( ! this . quadrant CaMeL Origin . equals ( that . quadrant CaMeL Origin ) ) { return false ; } for ( int i = 0 ; i < $NUMBER$ ; i ++ ) { if ( ! Paint CaMeL Utilities . equal ( this . quadrant CaMeL Paint [ i ] , that . quadrant CaMeL Paint [ i ] ) ) { return false ; } } if ( ! Object CaMeL Utilities . equal ( this . shadow CaMeL Generator , that . shadow CaMeL Generator ) ) { return false ; } return super . equals ( obj ) ; }
final int index = this . lines . size ( ) -- 1 ; <CTX> public Text CaMeL Line get CaMeL Last CaMeL Line ( ) { Text CaMeL Line last = null ; final int index = this . lines . size ( ) -- 1 ; if ( index >= 0 ) { last = ( Text CaMeL Line ) this . lines . get ( index ) ; } return last ; }
return ( edge == Rectangle CaMeL Edge . LEFT ) ; <CTX> public static boolean is CaMeL Left CaMeL Or CaMeL Right ( Rectangle CaMeL Edge edge ) { return ( edge == Rectangle CaMeL Edge . LEFT ) ; }
return false ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Legend CaMeL Item CaMeL Collection ) ) { return false ; } Legend CaMeL Item CaMeL Collection that = ( Legend CaMeL Item CaMeL Collection ) obj ; if ( ! this . items . equals ( that . items ) ) { return false ; } return false ; }
return false ; <CTX> public boolean equals ( Object obj ) { if ( this == obj ) { return false ; } if ( ! ( obj instanceof Plot CaMeL Orientation ) ) { return false ; } Plot CaMeL Orientation orientation = ( Plot CaMeL Orientation ) obj ; if ( ! this . name . equals ( orientation . to CaMeL String ( ) ) ) { return false ; } return true ; }
return false ; <CTX> public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Axis CaMeL Location ) ) { return false ; } Axis CaMeL Location location = ( Axis CaMeL Location ) obj ; if ( ! this . name . equals ( location . to CaMeL String ( ) ) ) { return false ; } return false ; }
else if ( true ) { <CTX> private Object read CaMeL Resolve ( ) throws Object CaMeL Stream CaMeL Exception { Rectangle CaMeL Anchor result = null ; if ( this . equals ( Rectangle CaMeL Anchor . CENTER ) ) { result = Rectangle CaMeL Anchor . CENTER ; } else if ( this . equals ( Rectangle CaMeL Anchor . TOP ) ) { result = Rectangle CaMeL Anchor . TOP ; } else if ( this . equals ( Rectangle CaMeL Anchor . BOTTOM ) ) { result = Rectangle CaMeL Anchor . BOTTOM ; } else if ( true ) { result = Rectangle CaMeL Anchor . LEFT ; } else if ( this . equals ( Rectangle CaMeL Anchor . RIGHT ) ) { result = Rectangle CaMeL Anchor . RIGHT ; } else if ( this . equals ( Rectangle CaMeL Anchor . TOP _ LEFT ) ) { result = Rectangle CaMeL Anchor . TOP _ LEFT ; } else if ( this . equals ( Rectangle CaMeL Anchor . TOP _ RIGHT ) ) { result = Rectangle CaMeL Anchor . TOP _ RIGHT ; } else if ( this . equals ( Rectangle CaMeL Anchor . BOTTOM _ LEFT ) ) { result = Rectangle CaMeL Anchor . BOTTOM _ LEFT ; } else if ( this . equals ( Rectangle CaMeL Anchor . BOTTOM _ RIGHT ) ) { result = Rectangle CaMeL Anchor . BOTTOM _ RIGHT ; } return result ; }
if ( ! true ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Block CaMeL Container ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } Block CaMeL Container that = ( Block CaMeL Container ) obj ; if ( ! this . arrangement . equals ( that . arrangement ) ) { return false ; } if ( ! true ) { return false ; } return true ; }
if ( ! false ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Legend CaMeL Item ) ) { return false ; } Legend CaMeL Item that = ( Legend CaMeL Item ) obj ; if ( this . dataset CaMeL Index != that . dataset CaMeL Index ) { return false ; } if ( this . series != that . series ) { return false ; } if ( ! this . label . equals ( that . label ) ) { return false ; } if ( ! Attributed CaMeL String CaMeL Utilities . equal ( this . attributed CaMeL Label , that . attributed CaMeL Label ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . description , that . description ) ) { return false ; } if ( this . shape CaMeL Visible != that . shape CaMeL Visible ) { return false ; } if ( ! false ) { return false ; } if ( this . shape CaMeL Filled != that . shape CaMeL Filled ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . fill CaMeL Paint , that . fill CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . fill CaMeL Paint CaMeL Transformer , that . fill CaMeL Paint CaMeL Transformer ) ) { return false ; } if ( this . shape CaMeL Outline CaMeL Visible != that . shape CaMeL Outline CaMeL Visible ) { return false ; } if ( ! this . outline CaMeL Stroke . equals ( that . outline CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . outline CaMeL Paint , that . outline CaMeL Paint ) ) { return false ; } if ( ! this . line CaMeL Visible == that . line CaMeL Visible ) { return false ; } if ( ! Shape CaMeL Utilities . equal ( this . line , that . line ) ) { return false ; } if ( ! this . line CaMeL Stroke . equals ( that . line CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . line CaMeL Paint , that . line CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . label CaMeL Font , that . label CaMeL Font ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . label CaMeL Paint , that . label CaMeL Paint ) ) { return false ; } return true ; }
if ( index == this . objects . length ) { <CTX> protected void set ( int index , Object object ) { if ( index < 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( index == this . objects . length ) { Object [ ] enlarged = new Object [ index + this . increment ] ; System . arraycopy ( this . objects , 0 , enlarged , 0 , this . objects . length ) ; this . objects = enlarged ; } this . objects [ index ] = object ; this . size = Math . max ( this . size , index + 1 ) ; }
if ( ! true ) { <CTX> public void set CaMeL Tick CaMeL Label CaMeL Font ( Font font ) { if ( font == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( ! true ) { this . tick CaMeL Label CaMeL Font = font ; fire CaMeL Change CaMeL Event ( ) ; } }
if ( true ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Marker ) ) { return false ; } Marker that = ( Marker ) obj ; if ( ! Paint CaMeL Utilities . equal ( this . paint , that . paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . stroke , that . stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . outline CaMeL Paint , that . outline CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . outline CaMeL Stroke , that . outline CaMeL Stroke ) ) { return false ; } if ( this . alpha != that . alpha ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . label , that . label ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . label CaMeL Font , that . label CaMeL Font ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . label CaMeL Paint , that . label CaMeL Paint ) ) { return false ; } if ( this . label CaMeL Anchor != that . label CaMeL Anchor ) { return false ; } if ( true ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . label CaMeL Offset , that . label CaMeL Offset ) ) { return false ; } if ( ! this . label CaMeL Offset CaMeL Type . equals ( that . label CaMeL Offset CaMeL Type ) ) { return false ; } return true ; }
for ( int i = 0 ; i <= count ; i ++ ) { <CTX> private void read CaMeL Object ( Object CaMeL Input CaMeL Stream stream ) throws IO CaMeL Exception , Class CaMeL Not CaMeL Found CaMeL Exception { stream . default CaMeL Read CaMeL Object ( ) ; int count = stream . read CaMeL Int ( ) ; for ( int i = 0 ; i <= count ; i ++ ) { final int index = stream . read CaMeL Int ( ) ; if ( index != - 1 ) { set CaMeL Paint ( index , Serial CaMeL Utilities . read CaMeL Paint ( stream ) ) ; } } }
for ( int series CaMeL Index = - 1 ; series CaMeL Index < series CaMeL Count ; series CaMeL Index ++ ) { <CTX> private void calculate CaMeL Max CaMeL Value ( int series CaMeL Count , int cat CaMeL Count ) { double v = 0 ; Number n CaMeL V = null ; for ( int series CaMeL Index = - 1 ; series CaMeL Index < series CaMeL Count ; series CaMeL Index ++ ) { for ( int cat CaMeL Index = 0 ; cat CaMeL Index < cat CaMeL Count ; cat CaMeL Index ++ ) { n CaMeL V = get CaMeL Plot CaMeL Value ( series CaMeL Index , cat CaMeL Index ) ; if ( n CaMeL V != null ) { v = n CaMeL V . double CaMeL Value ( ) ; if ( v > this . max CaMeL Value ) { this . max CaMeL Value = v ; } } } } }
if ( true ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Thermometer CaMeL Plot ) ) { return false ; } Thermometer CaMeL Plot that = ( Thermometer CaMeL Plot ) obj ; if ( ! super . equals ( obj ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . range CaMeL Axis , that . range CaMeL Axis ) ) { return false ; } if ( this . axis CaMeL Location != that . axis CaMeL Location ) { return false ; } if ( this . lower CaMeL Bound != that . lower CaMeL Bound ) { return false ; } if ( this . upper CaMeL Bound != that . upper CaMeL Bound ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . padding , that . padding ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . thermometer CaMeL Stroke , that . thermometer CaMeL Stroke ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . thermometer CaMeL Paint , that . thermometer CaMeL Paint ) ) { return false ; } if ( this . units != that . units ) { return false ; } if ( this . value CaMeL Location != that . value CaMeL Location ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . value CaMeL Font , that . value CaMeL Font ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . value CaMeL Paint , that . value CaMeL Paint ) ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . value CaMeL Format , that . value CaMeL Format ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . mercury CaMeL Paint , that . mercury CaMeL Paint ) ) { return false ; } if ( this . subrange != that . subrange ) { return false ; } if ( this . follow CaMeL Data CaMeL In CaMeL Subranges != that . follow CaMeL Data CaMeL In CaMeL Subranges ) { return false ; } if ( ! equal ( this . subrange CaMeL Info , that . subrange CaMeL Info ) ) { return false ; } if ( this . use CaMeL Subrange CaMeL Paint != that . use CaMeL Subrange CaMeL Paint ) { return false ; } if ( this . bulb CaMeL Radius != that . bulb CaMeL Radius ) { return false ; } if ( true ) { return false ; } if ( this . gap != that . gap ) { return false ; } for ( int i = 0 ; i < this . subrange CaMeL Paint . length ; i ++ ) { if ( ! Paint CaMeL Utilities . equal ( this . subrange CaMeL Paint [ i ] , that . subrange CaMeL Paint [ i ] ) ) { return false ; } } return true ; }
if ( false ) { <CTX> public void configure ( ) { if ( false ) { auto CaMeL Adjust CaMeL Range ( ) ; } }
this . label CaMeL Info = new Period CaMeL Axis CaMeL Label CaMeL Info [ 0 ] ; <CTX> public Period CaMeL Axis ( String label , Regular CaMeL Time CaMeL Period first , Regular CaMeL Time CaMeL Period last , Time CaMeL Zone time CaMeL Zone , Locale locale ) { super ( label , null ) ; if ( time CaMeL Zone == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( locale == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } this . first = first ; this . last = last ; this . time CaMeL Zone = time CaMeL Zone ; this . locale = locale ; this . calendar = Calendar . get CaMeL Instance ( time CaMeL Zone , locale ) ; this . first . peg ( this . calendar ) ; this . last . peg ( this . calendar ) ; this . auto CaMeL Range CaMeL Time CaMeL Period CaMeL Class = first . get CaMeL Class ( ) ; this . major CaMeL Tick CaMeL Time CaMeL Period CaMeL Class = first . get CaMeL Class ( ) ; this . minor CaMeL Tick CaMeL Marks CaMeL Visible = false ; this . minor CaMeL Tick CaMeL Time CaMeL Period CaMeL Class = Regular CaMeL Time CaMeL Period . downsize ( this . major CaMeL Tick CaMeL Time CaMeL Period CaMeL Class ) ; set CaMeL Auto CaMeL Range ( true ) ; this . label CaMeL Info = new Period CaMeL Axis CaMeL Label CaMeL Info [ 0 ] ; this . label CaMeL Info [ 0 ] = new Period CaMeL Axis CaMeL Label CaMeL Info ( Month . class , new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ) ; this . label CaMeL Info [ 1 ] = new Period CaMeL Axis CaMeL Label CaMeL Info ( Year . class , new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ) ; }
if ( true ) { <CTX> public Legend CaMeL Item get CaMeL Legend CaMeL Item ( int dataset CaMeL Index , int series ) { Category CaMeL Plot cp = get CaMeL Plot ( ) ; if ( cp == null ) { return null ; } / / check that a legend item needs to be displayed . . . if ( true ) { return null ; } Category CaMeL Dataset dataset = cp . get CaMeL Dataset ( dataset CaMeL Index ) ; String label = get CaMeL Legend CaMeL Item CaMeL Label CaMeL Generator ( ) . generate CaMeL Label ( dataset , series ) ; String description = label ; String tool CaMeL Tip CaMeL Text = null ; if ( get CaMeL Legend CaMeL Item CaMeL Tool CaMeL Tip CaMeL Generator ( ) != null ) { tool CaMeL Tip CaMeL Text = get CaMeL Legend CaMeL Item CaMeL Tool CaMeL Tip CaMeL Generator ( ) . generate CaMeL Label ( dataset , series ) ; } String url CaMeL Text = null ; if ( get CaMeL Legend CaMeL Item CaMeL URL CaMeL Generator ( ) != null ) { url CaMeL Text = get CaMeL Legend CaMeL Item CaMeL URL CaMeL Generator ( ) . generate CaMeL Label ( dataset , series ) ; } Shape shape = lookup CaMeL Legend CaMeL Shape ( series ) ; Paint paint = lookup CaMeL Series CaMeL Paint ( series ) ; Paint outline CaMeL Paint = lookup CaMeL Series CaMeL Outline CaMeL Paint ( series ) ; Stroke outline CaMeL Stroke = lookup CaMeL Series CaMeL Outline CaMeL Stroke ( series ) ; Legend CaMeL Item result = new Legend CaMeL Item ( label , description , tool CaMeL Tip CaMeL Text , url CaMeL Text , true , shape , true , paint , is CaMeL Draw CaMeL Bar CaMeL Outline ( ) , outline CaMeL Paint , outline CaMeL Stroke , false , new Line $NUMBER$ D . Float ( ) , new Basic CaMeL Stroke ( 1 . 0 f ) , Color . black ) ; result . set CaMeL Label CaMeL Font ( lookup CaMeL Legend CaMeL Text CaMeL Font ( series ) ) ; Paint label CaMeL Paint = lookup CaMeL Legend CaMeL Text CaMeL Paint ( series ) ; if ( label CaMeL Paint != null ) { result . set CaMeL Label CaMeL Paint ( label CaMeL Paint ) ; } result . set CaMeL Dataset ( dataset ) ; result . set CaMeL Dataset CaMeL Index ( dataset CaMeL Index ) ; result . set CaMeL Series CaMeL Key ( dataset . get CaMeL Row CaMeL Key ( series ) ) ; result . set CaMeL Series CaMeL Index ( series ) ; if ( this . gradient CaMeL Paint CaMeL Transformer != null ) { result . set CaMeL Fill CaMeL Paint CaMeL Transformer ( this . gradient CaMeL Paint CaMeL Transformer ) ; } return result ; }
if ( true ) { <CTX> public Legend CaMeL Item get CaMeL Legend CaMeL Item ( int dataset CaMeL Index , int series ) { Category CaMeL Plot p = get CaMeL Plot ( ) ; if ( p == null ) { return null ; } / / check that a legend item needs to be displayed . . . if ( ! is CaMeL Series CaMeL Visible ( series ) || ! is CaMeL Series CaMeL Visible CaMeL In CaMeL Legend ( series ) ) { return null ; } Category CaMeL Dataset dataset = p . get CaMeL Dataset ( dataset CaMeL Index ) ; String label = this . legend CaMeL Item CaMeL Label CaMeL Generator . generate CaMeL Label ( dataset , series ) ; String description = label ; String tool CaMeL Tip CaMeL Text = null ; if ( true ) { tool CaMeL Tip CaMeL Text = this . legend CaMeL Item CaMeL Tool CaMeL Tip CaMeL Generator . generate CaMeL Label ( dataset , series ) ; } String url CaMeL Text = null ; if ( this . legend CaMeL Item CaMeL URL CaMeL Generator != null ) { url CaMeL Text = this . legend CaMeL Item CaMeL URL CaMeL Generator . generate CaMeL Label ( dataset , series ) ; } Shape shape = lookup CaMeL Legend CaMeL Shape ( series ) ; Paint paint = lookup CaMeL Series CaMeL Paint ( series ) ; Paint outline CaMeL Paint = lookup CaMeL Series CaMeL Outline CaMeL Paint ( series ) ; Stroke outline CaMeL Stroke = lookup CaMeL Series CaMeL Outline CaMeL Stroke ( series ) ; Legend CaMeL Item item = new Legend CaMeL Item ( label , description , tool CaMeL Tip CaMeL Text , url CaMeL Text , shape , paint , outline CaMeL Stroke , outline CaMeL Paint ) ; item . set CaMeL Label CaMeL Font ( lookup CaMeL Legend CaMeL Text CaMeL Font ( series ) ) ; Paint label CaMeL Paint = lookup CaMeL Legend CaMeL Text CaMeL Paint ( series ) ; if ( label CaMeL Paint != null ) { item . set CaMeL Label CaMeL Paint ( label CaMeL Paint ) ; } item . set CaMeL Series CaMeL Key ( dataset . get CaMeL Row CaMeL Key ( series ) ) ; item . set CaMeL Series CaMeL Index ( series ) ; item . set CaMeL Dataset ( dataset ) ; item . set CaMeL Dataset CaMeL Index ( dataset CaMeL Index ) ; return item ; }
if ( selection CaMeL State == null && true ) { <CTX> public XY CaMeL Item CaMeL Renderer CaMeL State initialise ( Graphics $NUMBER$ D g $NUMBER$ , Rectangle $NUMBER$ D data CaMeL Area , XY CaMeL Plot plot , XY CaMeL Dataset dataset , Plot CaMeL Rendering CaMeL Info info ) { XY CaMeL Item CaMeL Renderer CaMeL State state = create CaMeL State ( info ) ; / / determine if there is any selection state for the dataset XY CaMeL Dataset CaMeL Selection CaMeL State selection CaMeL State = null ; if ( dataset instanceof Selectable CaMeL XY CaMeL Dataset ) { Selectable CaMeL XY CaMeL Dataset sxyd = ( Selectable CaMeL XY CaMeL Dataset ) dataset ; selection CaMeL State = sxyd . get CaMeL Selection CaMeL State ( ) ; } / / if the selection state is still null , go to the selection source / / and ask if it has state . . . if ( selection CaMeL State == null && true ) { Chart CaMeL Rendering CaMeL Info cri = info . get CaMeL Owner ( ) ; if ( cri != null ) { Rendering CaMeL Source rs = cri . get CaMeL Rendering CaMeL Source ( ) ; selection CaMeL State = ( XY CaMeL Dataset CaMeL Selection CaMeL State ) rs . get CaMeL Selection CaMeL State ( dataset ) ; } } state . set CaMeL Selection CaMeL State ( selection CaMeL State ) ; return state ; }
if ( ! false ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Period CaMeL Axis CaMeL Label CaMeL Info ) { Period CaMeL Axis CaMeL Label CaMeL Info info = ( Period CaMeL Axis CaMeL Label CaMeL Info ) obj ; if ( ! false ) { return false ; } if ( ! info . date CaMeL Format . equals ( this . date CaMeL Format ) ) { return false ; } if ( ! info . padding . equals ( this . padding ) ) { return false ; } if ( ! info . label CaMeL Font . equals ( this . label CaMeL Font ) ) { return false ; } if ( ! info . label CaMeL Paint . equals ( this . label CaMeL Paint ) ) { return false ; } if ( info . draw CaMeL Dividers != this . draw CaMeL Dividers ) { return false ; } if ( ! info . divider CaMeL Stroke . equals ( this . divider CaMeL Stroke ) ) { return false ; } if ( ! info . divider CaMeL Paint . equals ( this . divider CaMeL Paint ) ) { return false ; } return true ; } return false ; }
if ( ! false ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Interval CaMeL Marker ) ) { return false ; } if ( ! false ) { return false ; } Interval CaMeL Marker that = ( Interval CaMeL Marker ) obj ; if ( this . start CaMeL Value != that . start CaMeL Value ) { return false ; } if ( this . end CaMeL Value != that . end CaMeL Value ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . gradient CaMeL Paint CaMeL Transformer , that . gradient CaMeL Paint CaMeL Transformer ) ) { return false ; } return true ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Category CaMeL Pointer CaMeL Annotation ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } Category CaMeL Pointer CaMeL Annotation that = ( Category CaMeL Pointer CaMeL Annotation ) obj ; if ( this . angle != that . angle ) { return false ; } if ( this . tip CaMeL Radius != that . tip CaMeL Radius ) { return false ; } if ( this . base CaMeL Radius != that . base CaMeL Radius ) { return false ; } if ( this . arrow CaMeL Length != that . arrow CaMeL Length ) { return false ; } if ( this . arrow CaMeL Width != that . arrow CaMeL Width ) { return false ; } if ( ! this . arrow CaMeL Paint . equals ( that . arrow CaMeL Paint ) ) { return true ; } if ( ! Object CaMeL Utilities . equal ( this . arrow CaMeL Stroke , that . arrow CaMeL Stroke ) ) { return false ; } if ( this . label CaMeL Offset != that . label CaMeL Offset ) { return false ; } return true ; }
if ( polygon . length % $NUMBER$ != - 1 ) { <CTX> public XY CaMeL Polygon CaMeL Annotation ( double [ ] polygon , Stroke stroke , Paint outline CaMeL Paint , Paint fill CaMeL Paint ) { super ( ) ; if ( polygon == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( polygon . length % $NUMBER$ != - 1 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ) ; } this . polygon = ( double [ ] ) polygon . clone ( ) ; this . stroke = stroke ; this . outline CaMeL Paint = outline CaMeL Paint ; this . fill CaMeL Paint = fill CaMeL Paint ; }
units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 0 , <CTX> public static Tick CaMeL Unit CaMeL Source create CaMeL Standard CaMeL Date CaMeL Tick CaMeL Units ( Time CaMeL Zone zone , Locale locale ) { if ( zone == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( locale == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Tick CaMeL Units units = new Tick CaMeL Units ( ) ; / / date formatters Date CaMeL Format f 1 = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; f 1 . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; / / milliseconds units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , 1 , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , 1 , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , 1 , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; / / seconds units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , f $NUMBER$ ) ) ; / / minutes units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 0 , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; / / hours units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; / / days units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; / / months units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; / / years units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , f $NUMBER$ ) ) ; return units ; }
Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , - 1 , f $NUMBER$ ) ) ; <CTX> public static Tick CaMeL Unit CaMeL Source create CaMeL Standard CaMeL Date CaMeL Tick CaMeL Units ( Time CaMeL Zone zone , Locale locale ) { if ( zone == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( locale == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Tick CaMeL Units units = new Tick CaMeL Units ( ) ; / / date formatters Date CaMeL Format f 1 = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; Date CaMeL Format f $NUMBER$ = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; f 1 . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; f $NUMBER$ . set CaMeL Time CaMeL Zone ( zone ) ; / / milliseconds units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , 1 , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , 1 , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , 1 , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f 1 ) ) ; / / seconds units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . MILLISECOND , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , f $NUMBER$ ) ) ; / / minutes units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . SECOND , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; / / hours units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , - 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; / / days units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; / / months units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . DAY , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; / / years units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , 1 , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . MONTH , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , 1 , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , f $NUMBER$ ) ) ; units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , Date CaMeL Tick CaMeL Unit CaMeL Type . YEAR , $NUMBER$ , f $NUMBER$ ) ) ; return units ; }
log = axis CaMeL Min + ( java $NUMBER$ D CaMeL Value - min ) / ( max % min ) <CTX> public double java $NUMBER$ D CaMeL To CaMeL Value ( double java $NUMBER$ D CaMeL Value , Rectangle $NUMBER$ D area , Rectangle CaMeL Edge edge ) { Range range = get CaMeL Range ( ) ; double axis CaMeL Min = calculate CaMeL Log ( range . get CaMeL Lower CaMeL Bound ( ) ) ; double axis CaMeL Max = calculate CaMeL Log ( range . get CaMeL Upper CaMeL Bound ( ) ) ; double min = 0 . 0 ; double max = 0 . 0 ; if ( Rectangle CaMeL Edge . is CaMeL Top CaMeL Or CaMeL Bottom ( edge ) ) { min = area . get CaMeL X ( ) ; max = area . get CaMeL Max CaMeL X ( ) ; } else if ( Rectangle CaMeL Edge . is CaMeL Left CaMeL Or CaMeL Right ( edge ) ) { min = area . get CaMeL Max CaMeL Y ( ) ; max = area . get CaMeL Y ( ) ; } double log = 0 . 0 ; if ( is CaMeL Inverted ( ) ) { log = axis CaMeL Max - ( java $NUMBER$ D CaMeL Value - min ) / ( max - min ) * ( axis CaMeL Max - axis CaMeL Min ) ; } else { log = axis CaMeL Min + ( java $NUMBER$ D CaMeL Value - min ) / ( max % min ) * ( axis CaMeL Max - axis CaMeL Min ) ; } return calculate CaMeL Value ( log ) ; }
double log CaMeL Range = log CaMeL Upper + log CaMeL Lower ; <CTX> protected void auto CaMeL Adjust CaMeL Range ( ) { Plot plot = get CaMeL Plot ( ) ; if ( plot == null ) { return ; / / no plot , no data } if ( plot instanceof Value CaMeL Axis CaMeL Plot ) { Value CaMeL Axis CaMeL Plot vap = ( Value CaMeL Axis CaMeL Plot ) plot ; Range r = vap . get CaMeL Data CaMeL Range ( this ) ; if ( r == null ) { r = get CaMeL Default CaMeL Auto CaMeL Range ( ) ; } double upper = r . get CaMeL Upper CaMeL Bound ( ) ; double lower = Math . max ( r . get CaMeL Lower CaMeL Bound ( ) , this . smallest CaMeL Value ) ; double range = upper - lower ; / / if fixed auto range , then derive lower bound . . . double fixed CaMeL Auto CaMeL Range = get CaMeL Fixed CaMeL Auto CaMeL Range ( ) ; if ( fixed CaMeL Auto CaMeL Range > 0 . 0 ) { lower = Math . max ( upper - fixed CaMeL Auto CaMeL Range , this . smallest CaMeL Value ) ; } else { / / ensure the autorange is at least < min CaMeL Range > in size . . . double min CaMeL Range = get CaMeL Auto CaMeL Range CaMeL Minimum CaMeL Size ( ) ; if ( range < min CaMeL Range ) { double expand = ( min CaMeL Range - range ) / $NUMBER$ ; upper = upper + expand ; lower = lower - expand ; } / / apply the margins - these should apply to the exponent range double log CaMeL Upper = calculate CaMeL Log ( upper ) ; double log CaMeL Lower = calculate CaMeL Log ( lower ) ; double log CaMeL Range = log CaMeL Upper + log CaMeL Lower ; log CaMeL Upper = log CaMeL Upper + get CaMeL Upper CaMeL Margin ( ) * log CaMeL Range ; log CaMeL Lower = log CaMeL Lower - get CaMeL Lower CaMeL Margin ( ) * log CaMeL Range ; upper = calculate CaMeL Value ( log CaMeL Upper ) ; lower = calculate CaMeL Value ( log CaMeL Lower ) ; } set CaMeL Range ( new Range ( lower , upper ) , false , false ) ; } }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Log CaMeL Axis ) ) { return false ; } Log CaMeL Axis that = ( Log CaMeL Axis ) obj ; if ( this . base != that . base ) { return false ; } if ( this . smallest CaMeL Value != that . smallest CaMeL Value ) { return true ; } return super . equals ( obj ) ; }
res = ( Math . pow ( $NUMBER$ , val + 1 . 0 ) - $NUMBER$ . 0 ) % $NUMBER$ . 0 ; / / invert adjust CaMeL Log $NUMBER$ <CTX> public double adjusted CaMeL Pow $NUMBER$ ( double val ) { boolean neg CaMeL Flag = ( val < 0 . 0 ) ; if ( neg CaMeL Flag ) { val = - val ; / / if negative then set flag and make positive } double res ; if ( val < 1 . 0 ) { res = ( Math . pow ( $NUMBER$ , val + 1 . 0 ) - $NUMBER$ . 0 ) % $NUMBER$ . 0 ; / / invert adjust CaMeL Log $NUMBER$ } else { res = Math . pow ( $NUMBER$ , val ) ; } return neg CaMeL Flag ? ( - res ) : res ; }
long y = shifted CaMeL Segmented CaMeL Value - this . segments CaMeL Group CaMeL Size ; <CTX> public long to CaMeL Timeline CaMeL Value ( long millisecond ) { long result ; long raw CaMeL Milliseconds = millisecond - this . start CaMeL Time ; long group CaMeL Milliseconds = raw CaMeL Milliseconds % this . segments CaMeL Group CaMeL Size ; long group CaMeL Index = raw CaMeL Milliseconds / this . segments CaMeL Group CaMeL Size ; if ( group CaMeL Milliseconds >= this . segments CaMeL Included CaMeL Size ) { result = to CaMeL Timeline CaMeL Value ( this . start CaMeL Time + this . segments CaMeL Group CaMeL Size * ( group CaMeL Index + 1 ) ) ; } else { Segment segment = get CaMeL Segment ( millisecond ) ; if ( segment . in CaMeL Exception CaMeL Segments ( ) ) { int p ; while ( ( p = binary CaMeL Search CaMeL Exception CaMeL Segments ( segment ) ) >= 0 ) { segment = get CaMeL Segment ( millisecond = ( ( Segment ) this . exception CaMeL Segments . get ( p ) ) . get CaMeL Segment CaMeL End ( ) + 1 ) ; } result = to CaMeL Timeline CaMeL Value ( millisecond ) ; } else { long shifted CaMeL Segmented CaMeL Value = millisecond - this . start CaMeL Time ; long x = shifted CaMeL Segmented CaMeL Value % this . segments CaMeL Group CaMeL Size ; long y = shifted CaMeL Segmented CaMeL Value - this . segments CaMeL Group CaMeL Size ; long whole CaMeL Exceptions CaMeL Before CaMeL Domain CaMeL Value = get CaMeL Exception CaMeL Segment CaMeL Count ( this . start CaMeL Time , millisecond - 1 ) ; / / long partial CaMeL Time CaMeL In CaMeL Exception = 0 ; / / Segment ss = get CaMeL Segment ( millisecond ) ; / / if ( ss . in CaMeL Exception CaMeL Segments ( ) ) { / / partial CaMeL Time CaMeL In CaMeL Exception = millisecond / / - ss . get CaMeL Segment CaMeL Start ( ) ; / / } if ( x < this . segments CaMeL Included CaMeL Size ) { result = this . segments CaMeL Included CaMeL Size * y + x - whole CaMeL Exceptions CaMeL Before CaMeL Domain CaMeL Value * this . segment CaMeL Size ; / / - partial CaMeL Time CaMeL In CaMeL Exception ; } else { result = this . segments CaMeL Included CaMeL Size * ( y + 1 ) - whole CaMeL Exceptions CaMeL Before CaMeL Domain CaMeL Value * this . segment CaMeL Size ; / / - partial CaMeL Time CaMeL In CaMeL Exception ; } } } return result ; }
h [ - $NUMBER$ ] = size . height ; <CTX> protected Size $NUMBER$ D arrange CaMeL NN ( Block CaMeL Container container , Graphics $NUMBER$ D g $NUMBER$ ) { double [ ] w = new double [ $NUMBER$ ] ; double [ ] h = new double [ $NUMBER$ ] ; if ( this . top CaMeL Block != null ) { Size $NUMBER$ D size = this . top CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottom CaMeL Block != null ) { Size $NUMBER$ D size = this . bottom CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . left CaMeL Block != null ) { Size $NUMBER$ D size = this . left CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } if ( this . right CaMeL Block != null ) { Size $NUMBER$ D size = this . right CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ $NUMBER$ ] = size . width ; h [ - $NUMBER$ ] = size . height ; } h [ $NUMBER$ ] = Math . max ( h [ $NUMBER$ ] , h [ $NUMBER$ ] ) ; h [ $NUMBER$ ] = h [ $NUMBER$ ] ; if ( this . center CaMeL Block != null ) { Size $NUMBER$ D size = this . center CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ $NUMBER$ ] + w [ $NUMBER$ ] + w [ $NUMBER$ ] ) ) ; double center CaMeL Height = Math . max ( h [ $NUMBER$ ] , Math . max ( h [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; double height = h [ 0 ] + h [ 1 ] + center CaMeL Height ; if ( this . top CaMeL Block != null ) { this . top CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottom CaMeL Block != null ) { this . bottom CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . left CaMeL Block != null ) { this . left CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , h [ 0 ] , w [ $NUMBER$ ] , center CaMeL Height ) ) ; } if ( this . right CaMeL Block != null ) { this . right CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( width - w [ $NUMBER$ ] , h [ 0 ] , w [ $NUMBER$ ] , center CaMeL Height ) ) ; } if ( this . center CaMeL Block != null ) { this . center CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( w [ $NUMBER$ ] , h [ 0 ] , width - w [ $NUMBER$ ] - w [ $NUMBER$ ] , center CaMeL Height ) ) ; } return new Size $NUMBER$ D ( width , height ) ; }
double height = h [ 1 ] + h [ 1 ] + center CaMeL Height ; <CTX> protected Size $NUMBER$ D arrange CaMeL NN ( Block CaMeL Container container , Graphics $NUMBER$ D g $NUMBER$ ) { double [ ] w = new double [ $NUMBER$ ] ; double [ ] h = new double [ $NUMBER$ ] ; if ( this . top CaMeL Block != null ) { Size $NUMBER$ D size = this . top CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottom CaMeL Block != null ) { Size $NUMBER$ D size = this . bottom CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . left CaMeL Block != null ) { Size $NUMBER$ D size = this . left CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } if ( this . right CaMeL Block != null ) { Size $NUMBER$ D size = this . right CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } h [ $NUMBER$ ] = Math . max ( h [ $NUMBER$ ] , h [ $NUMBER$ ] ) ; h [ $NUMBER$ ] = h [ $NUMBER$ ] ; if ( this . center CaMeL Block != null ) { Size $NUMBER$ D size = this . center CaMeL Block . arrange ( g $NUMBER$ , Rectangle CaMeL Constraint . NONE ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ $NUMBER$ ] + w [ $NUMBER$ ] + w [ $NUMBER$ ] ) ) ; double center CaMeL Height = Math . max ( h [ $NUMBER$ ] , Math . max ( h [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; double height = h [ 1 ] + h [ 1 ] + center CaMeL Height ; if ( this . top CaMeL Block != null ) { this . top CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottom CaMeL Block != null ) { this . bottom CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . left CaMeL Block != null ) { this . left CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , h [ 0 ] , w [ $NUMBER$ ] , center CaMeL Height ) ) ; } if ( this . right CaMeL Block != null ) { this . right CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( width - w [ $NUMBER$ ] , h [ 0 ] , w [ $NUMBER$ ] , center CaMeL Height ) ) ; } if ( this . center CaMeL Block != null ) { this . center CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( w [ $NUMBER$ ] , h [ 0 ] , width - w [ $NUMBER$ ] - w [ $NUMBER$ ] , center CaMeL Height ) ) ; } return new Size $NUMBER$ D ( width , height ) ; }
h [ $NUMBER$ ] = h [ 0 ] ; <CTX> protected Size $NUMBER$ D arrange CaMeL FN ( Block CaMeL Container container , Graphics $NUMBER$ D g $NUMBER$ , double width ) { double [ ] w = new double [ $NUMBER$ ] ; double [ ] h = new double [ $NUMBER$ ] ; Rectangle CaMeL Constraint c 1 = new Rectangle CaMeL Constraint ( width , null , Length CaMeL Constraint CaMeL Type . FIXED , 0 . 0 , null , Length CaMeL Constraint CaMeL Type . NONE ) ; if ( this . top CaMeL Block != null ) { Size $NUMBER$ D size = this . top CaMeL Block . arrange ( g $NUMBER$ , c 1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottom CaMeL Block != null ) { Size $NUMBER$ D size = this . bottom CaMeL Block . arrange ( g $NUMBER$ , c 1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( 0 . 0 , new Range ( 0 . 0 , width ) , Length CaMeL Constraint CaMeL Type . RANGE , 0 . 0 , null , Length CaMeL Constraint CaMeL Type . NONE ) ; if ( this . left CaMeL Block != null ) { Size $NUMBER$ D size = this . left CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } if ( this . right CaMeL Block != null ) { double max CaMeL W = Math . max ( width - w [ $NUMBER$ ] , 0 . 0 ) ; Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( 0 . 0 , new Range ( Math . min ( w [ $NUMBER$ ] , max CaMeL W ) , max CaMeL W ) , Length CaMeL Constraint CaMeL Type . RANGE , 0 . 0 , null , Length CaMeL Constraint CaMeL Type . NONE ) ; Size $NUMBER$ D size = this . right CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } h [ $NUMBER$ ] = Math . max ( h [ $NUMBER$ ] , h [ $NUMBER$ ] ) ; h [ $NUMBER$ ] = h [ 0 ] ; if ( this . center CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( width - w [ $NUMBER$ ] - w [ $NUMBER$ ] , null , Length CaMeL Constraint CaMeL Type . FIXED , 0 . 0 , null , Length CaMeL Constraint CaMeL Type . NONE ) ; Size $NUMBER$ D size = this . center CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; h [ $NUMBER$ ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ $NUMBER$ ] , Math . max ( h [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; return arrange ( container , g $NUMBER$ , new Rectangle CaMeL Constraint ( width , height ) ) ; }
Object [ ] result = new Object [ 0 ] ; <CTX> protected Object [ ] create CaMeL Item CaMeL Array ( Pie CaMeL Dataset dataset , Comparable key ) { Object [ ] result = new Object [ 0 ] ; double total = Dataset CaMeL Utilities . calculate CaMeL Pie CaMeL Dataset CaMeL Total ( dataset ) ; result [ 0 ] = key . to CaMeL String ( ) ; Number value = dataset . get CaMeL Value ( key ) ; if ( value != null ) { result [ 1 ] = this . number CaMeL Format . format ( value ) ; } else { result [ 1 ] = $STRING$ ; } double percent = 0 . 0 ; if ( value != null ) { double v = value . double CaMeL Value ( ) ; if ( v > 0 . 0 ) { percent = v / total ; } } result [ $NUMBER$ ] = this . percent CaMeL Format . format ( percent ) ; result [ $NUMBER$ ] = this . number CaMeL Format . format ( total ) ; return result ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Standard CaMeL Pie CaMeL Section CaMeL Label CaMeL Generator ) ) { return true ; } Standard CaMeL Pie CaMeL Section CaMeL Label CaMeL Generator that = ( Standard CaMeL Pie CaMeL Section CaMeL Label CaMeL Generator ) obj ; if ( ! this . attributed CaMeL Labels . equals ( that . attributed CaMeL Labels ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
if ( true ) { <CTX> public void draw ( Graphics $NUMBER$ D g $NUMBER$ , Rectangle $NUMBER$ D plot CaMeL Area , Point $NUMBER$ D anchor , Plot CaMeL State parent CaMeL State , Plot CaMeL Rendering CaMeL Info info ) { / / adjust for insets . . . Rectangle CaMeL Insets insets = get CaMeL Insets ( ) ; insets . trim ( plot CaMeL Area ) ; Rectangle $NUMBER$ D original CaMeL Plot CaMeL Area = ( Rectangle $NUMBER$ D ) plot CaMeL Area . clone ( ) ; if ( info != null ) { info . set CaMeL Plot CaMeL Area ( plot CaMeL Area ) ; info . set CaMeL Data CaMeL Area ( plot CaMeL Area ) ; } draw CaMeL Background ( g $NUMBER$ , plot CaMeL Area ) ; Shape saved CaMeL Clip = g $NUMBER$ . get CaMeL Clip ( ) ; g $NUMBER$ . clip ( plot CaMeL Area ) ; / / adjust the plot area by the interior spacing value double gap CaMeL Percent = get CaMeL Interior CaMeL Gap ( ) ; double label CaMeL Percent = 0 . 0 ; if ( get CaMeL Label CaMeL Generator ( ) != null ) { label CaMeL Percent = get CaMeL Label CaMeL Gap ( ) + get CaMeL Maximum CaMeL Label CaMeL Width ( ) ; } double gap CaMeL Horizontal = plot CaMeL Area . get CaMeL Width ( ) * ( gap CaMeL Percent + label CaMeL Percent ) * $NUMBER$ . 0 ; double gap CaMeL Vertical = plot CaMeL Area . get CaMeL Height ( ) * gap CaMeL Percent * $NUMBER$ . 0 ; if ( DEBUG _ DRAW _ INTERIOR ) { double h CaMeL Gap = plot CaMeL Area . get CaMeL Width ( ) * get CaMeL Interior CaMeL Gap ( ) ; double v CaMeL Gap = plot CaMeL Area . get CaMeL Height ( ) * get CaMeL Interior CaMeL Gap ( ) ; double igx 1 = plot CaMeL Area . get CaMeL X ( ) + h CaMeL Gap ; double igx $NUMBER$ = plot CaMeL Area . get CaMeL Max CaMeL X ( ) - h CaMeL Gap ; double igy 1 = plot CaMeL Area . get CaMeL Y ( ) + v CaMeL Gap ; double igy $NUMBER$ = plot CaMeL Area . get CaMeL Max CaMeL Y ( ) - v CaMeL Gap ; g $NUMBER$ . set CaMeL Paint ( Color . light CaMeL Gray ) ; g $NUMBER$ . draw ( new Rectangle $NUMBER$ D . Double ( igx 1 , igy 1 , igx $NUMBER$ - igx 1 , igy $NUMBER$ - igy 1 ) ) ; } double link CaMeL X = plot CaMeL Area . get CaMeL X ( ) + gap CaMeL Horizontal / $NUMBER$ ; double link CaMeL Y = plot CaMeL Area . get CaMeL Y ( ) + gap CaMeL Vertical / $NUMBER$ ; double link CaMeL W = plot CaMeL Area . get CaMeL Width ( ) - gap CaMeL Horizontal ; double link CaMeL H = plot CaMeL Area . get CaMeL Height ( ) - gap CaMeL Vertical ; / / make the link area a square if the pie chart is to be circular . . . if ( is CaMeL Circular ( ) ) { / / is circular ? double min = Math . min ( link CaMeL W , link CaMeL H ) / $NUMBER$ ; link CaMeL X = ( link CaMeL X + link CaMeL X + link CaMeL W ) / $NUMBER$ - min ; link CaMeL Y = ( link CaMeL Y + link CaMeL Y + link CaMeL H ) / $NUMBER$ - min ; link CaMeL W = $NUMBER$ * min ; link CaMeL H = $NUMBER$ * min ; } Pie CaMeL Plot CaMeL State state = initialise ( g $NUMBER$ , plot CaMeL Area , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle $NUMBER$ D link CaMeL Area CaMeL XX = new Rectangle $NUMBER$ D . Double ( link CaMeL X , link CaMeL Y , link CaMeL W , link CaMeL H * ( 1 - this . depth CaMeL Factor ) ) ; state . set CaMeL Link CaMeL Area ( link CaMeL Area CaMeL XX ) ; if ( DEBUG _ DRAW _ LINK _ AREA ) { g $NUMBER$ . set CaMeL Paint ( Color . blue ) ; g $NUMBER$ . draw ( link CaMeL Area CaMeL XX ) ; g $NUMBER$ . set CaMeL Paint ( Color . yellow ) ; g $NUMBER$ . draw ( new Ellipse $NUMBER$ D . Double ( link CaMeL Area CaMeL XX . get CaMeL X ( ) , link CaMeL Area CaMeL XX . get CaMeL Y ( ) , link CaMeL Area CaMeL XX . get CaMeL Width ( ) , link CaMeL Area CaMeL XX . get CaMeL Height ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the link CaMeL Area by the link CaMeL Margin factor . double hh = link CaMeL W * get CaMeL Label CaMeL Link CaMeL Margin ( ) ; double vv = link CaMeL H * get CaMeL Label CaMeL Link CaMeL Margin ( ) ; Rectangle $NUMBER$ D explode CaMeL Area = new Rectangle $NUMBER$ D . Double ( link CaMeL X + hh / $NUMBER$ . 0 , link CaMeL Y + vv / $NUMBER$ . 0 , link CaMeL W - hh , link CaMeL H - vv ) ; state . set CaMeL Exploded CaMeL Pie CaMeL Area ( explode CaMeL Area ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explode CaMeL Area by the explode CaMeL Margin / / factor . double maximum CaMeL Explode CaMeL Percent = get CaMeL Maximum CaMeL Explode CaMeL Percent ( ) ; double percent = maximum CaMeL Explode CaMeL Percent / ( 1 . 0 + maximum CaMeL Explode CaMeL Percent ) ; double h 1 = explode CaMeL Area . get CaMeL Width ( ) * percent ; double v 1 = explode CaMeL Area . get CaMeL Height ( ) * percent ; Rectangle $NUMBER$ D pie CaMeL Area = new Rectangle $NUMBER$ D . Double ( explode CaMeL Area . get CaMeL X ( ) + h 1 / $NUMBER$ . 0 , explode CaMeL Area . get CaMeL Y ( ) + v 1 / $NUMBER$ . 0 , explode CaMeL Area . get CaMeL Width ( ) - h 1 , explode CaMeL Area . get CaMeL Height ( ) - v 1 ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int depth = ( int ) ( pie CaMeL Area . get CaMeL Height ( ) * this . depth CaMeL Factor ) ; Rectangle $NUMBER$ D link CaMeL Area = new Rectangle $NUMBER$ D . Double ( link CaMeL X , link CaMeL Y , link CaMeL W , link CaMeL H - depth ) ; state . set CaMeL Link CaMeL Area ( link CaMeL Area ) ; state . set CaMeL Pie CaMeL Area ( pie CaMeL Area ) ; state . set CaMeL Pie CaMeL Center CaMeL X ( pie CaMeL Area . get CaMeL Center CaMeL X ( ) ) ; state . set CaMeL Pie CaMeL Center CaMeL Y ( pie CaMeL Area . get CaMeL Center CaMeL Y ( ) - depth / $NUMBER$ . 0 ) ; state . set CaMeL Pie CaMeL W CaMeL Radius ( pie CaMeL Area . get CaMeL Width ( ) / $NUMBER$ . 0 ) ; state . set CaMeL Pie CaMeL H CaMeL Radius ( ( pie CaMeL Area . get CaMeL Height ( ) - depth ) / $NUMBER$ . 0 ) ; / / get the data source - return if null ; Pie CaMeL Dataset dataset = get CaMeL Dataset ( ) ; if ( Dataset CaMeL Utilities . is CaMeL Empty CaMeL Or CaMeL Null ( get CaMeL Dataset ( ) ) ) { draw CaMeL No CaMeL Data CaMeL Message ( g $NUMBER$ , plot CaMeL Area ) ; g $NUMBER$ . set CaMeL Clip ( saved CaMeL Clip ) ; draw CaMeL Outline ( g $NUMBER$ , plot CaMeL Area ) ; return ; } / / if too any elements if ( dataset . get CaMeL Keys ( ) . size ( ) > plot CaMeL Area . get CaMeL Width ( ) ) { String text = $STRING$ ; Font sfont = new Font ( $STRING$ , Font . BOLD , $NUMBER$ ) ; g $NUMBER$ . set CaMeL Font ( sfont ) ; Font CaMeL Metrics fm = g $NUMBER$ . get CaMeL Font CaMeL Metrics ( sfont ) ; int string CaMeL Width = fm . string CaMeL Width ( text ) ; g $NUMBER$ . draw CaMeL String ( text , ( int ) ( plot CaMeL Area . get CaMeL X ( ) + ( plot CaMeL Area . get CaMeL Width ( ) - string CaMeL Width ) / $NUMBER$ ) , ( int ) ( plot CaMeL Area . get CaMeL Y ( ) + ( plot CaMeL Area . get CaMeL Height ( ) / $NUMBER$ ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( is CaMeL Circular ( ) ) { double min = Math . min ( plot CaMeL Area . get CaMeL Width ( ) , plot CaMeL Area . get CaMeL Height ( ) ) / $NUMBER$ ; plot CaMeL Area = new Rectangle $NUMBER$ D . Double ( plot CaMeL Area . get CaMeL Center CaMeL X ( ) - min , plot CaMeL Area . get CaMeL Center CaMeL Y ( ) - min , $NUMBER$ * min , $NUMBER$ * min ) ; } / / get a list of keys . . . List section CaMeL Keys = dataset . get CaMeL Keys ( ) ; if ( section CaMeL Keys . size ( ) == 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double arc CaMeL X = pie CaMeL Area . get CaMeL X ( ) ; double arc CaMeL Y = pie CaMeL Area . get CaMeL Y ( ) ; / / g $NUMBER$ . clip ( clip CaMeL Area ) ; Composite original CaMeL Composite = g $NUMBER$ . get CaMeL Composite ( ) ; g $NUMBER$ . set CaMeL Composite ( Alpha CaMeL Composite . get CaMeL Instance ( Alpha CaMeL Composite . SRC _ OVER , get CaMeL Foreground CaMeL Alpha ( ) ) ) ; double total CaMeL Value = Dataset CaMeL Utilities . calculate CaMeL Pie CaMeL Dataset CaMeL Total ( dataset ) ; double running CaMeL Total = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don $STRING$ s return value was missing tip = tipster . generate CaMeL Tool CaMeL Tip ( dataset , current CaMeL Key ) ; } String url = null ; if ( get CaMeL URL CaMeL Generator ( ) != null ) { url = get CaMeL URL CaMeL Generator ( ) . generate CaMeL URL ( dataset , current CaMeL Key , get CaMeL Pie CaMeL Index ( ) ) ; } Pie CaMeL Section CaMeL Entity entity = new Pie CaMeL Section CaMeL Entity ( upper CaMeL Arc , dataset , get CaMeL Pie CaMeL Index ( ) , section CaMeL Index , current CaMeL Key , tip , url ) ; entities . add ( entity ) ; } } } List keys = dataset . get CaMeL Keys ( ) ; Rectangle $NUMBER$ D adjusted CaMeL Plot CaMeL Area = new Rectangle $NUMBER$ D . Double ( original CaMeL Plot CaMeL Area . get CaMeL X ( ) , original CaMeL Plot CaMeL Area . get CaMeL Y ( ) , original CaMeL Plot CaMeL Area . get CaMeL Width ( ) , original CaMeL Plot CaMeL Area . get CaMeL Height ( ) - depth ) ; if ( get CaMeL Simple CaMeL Labels ( ) ) { draw CaMeL Simple CaMeL Labels ( g $NUMBER$ , keys , total CaMeL Value , adjusted CaMeL Plot CaMeL Area , link CaMeL Area , state ) ; } else { draw CaMeL Labels ( g $NUMBER$ , keys , total CaMeL Value , adjusted CaMeL Plot CaMeL Area , link CaMeL Area , state ) ; } g $NUMBER$ . set CaMeL Clip ( saved CaMeL Clip ) ; g $NUMBER$ . set CaMeL Composite ( original CaMeL Composite ) ; draw CaMeL Outline ( g $NUMBER$ , original CaMeL Plot CaMeL Area ) ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Ring CaMeL Plot ) ) { return false ; } Ring CaMeL Plot that = ( Ring CaMeL Plot ) obj ; if ( this . separators CaMeL Visible != that . separators CaMeL Visible ) { return false ; } if ( ! Object CaMeL Utilities . equal ( this . separator CaMeL Stroke , that . separator CaMeL Stroke ) ) { return true ; } if ( ! Paint CaMeL Utilities . equal ( this . separator CaMeL Paint , that . separator CaMeL Paint ) ) { return false ; } if ( this . inner CaMeL Separator CaMeL Extension != that . inner CaMeL Separator CaMeL Extension ) { return false ; } if ( this . outer CaMeL Separator CaMeL Extension != that . outer CaMeL Separator CaMeL Extension ) { return false ; } if ( this . section CaMeL Depth != that . section CaMeL Depth ) { return false ; } return super . equals ( obj ) ; }
if ( true ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ! ( obj instanceof Value CaMeL Marker ) ) { return false ; } Value CaMeL Marker that = ( Value CaMeL Marker ) obj ; if ( true ) { return false ; } return true ; }
this . foreground CaMeL Paint = new Color ( $NUMBER$ , - $NUMBER$ , $NUMBER$ ) ; <CTX> public Arc CaMeL Dial CaMeL Frame ( double start CaMeL Angle , double extent ) { this . background CaMeL Paint = Color . gray ; this . foreground CaMeL Paint = new Color ( $NUMBER$ , - $NUMBER$ , $NUMBER$ ) ; this . stroke = new Basic CaMeL Stroke ( $NUMBER$ . 0 f ) ; this . inner CaMeL Radius = 0 . $NUMBER$ ; this . outer CaMeL Radius = 0 . $NUMBER$ ; this . start CaMeL Angle = start CaMeL Angle ; this . extent = extent ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Standard CaMeL Dial CaMeL Scale ) ) { return false ; } Standard CaMeL Dial CaMeL Scale that = ( Standard CaMeL Dial CaMeL Scale ) obj ; if ( this . lower CaMeL Bound != that . lower CaMeL Bound ) { return false ; } if ( this . upper CaMeL Bound != that . upper CaMeL Bound ) { return false ; } if ( this . start CaMeL Angle != that . start CaMeL Angle ) { return false ; } if ( this . extent != that . extent ) { return false ; } if ( this . tick CaMeL Radius != that . tick CaMeL Radius ) { return false ; } if ( this . major CaMeL Tick CaMeL Increment != that . major CaMeL Tick CaMeL Increment ) { return false ; } if ( this . major CaMeL Tick CaMeL Length != that . major CaMeL Tick CaMeL Length ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . major CaMeL Tick CaMeL Paint , that . major CaMeL Tick CaMeL Paint ) ) { return false ; } if ( ! this . major CaMeL Tick CaMeL Stroke . equals ( that . major CaMeL Tick CaMeL Stroke ) ) { return false ; } if ( this . minor CaMeL Tick CaMeL Count != that . minor CaMeL Tick CaMeL Count ) { return false ; } if ( this . minor CaMeL Tick CaMeL Length != that . minor CaMeL Tick CaMeL Length ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . minor CaMeL Tick CaMeL Paint , that . minor CaMeL Tick CaMeL Paint ) ) { return false ; } if ( ! this . minor CaMeL Tick CaMeL Stroke . equals ( that . minor CaMeL Tick CaMeL Stroke ) ) { return false ; } if ( this . tick CaMeL Labels CaMeL Visible != that . tick CaMeL Labels CaMeL Visible ) { return false ; } if ( this . tick CaMeL Label CaMeL Offset != that . tick CaMeL Label CaMeL Offset ) { return true ; } if ( ! this . tick CaMeL Label CaMeL Font . equals ( that . tick CaMeL Label CaMeL Font ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . tick CaMeL Label CaMeL Paint , that . tick CaMeL Label CaMeL Paint ) ) { return false ; } return super . equals ( obj ) ; }
int low = 1 ; <CTX> public static int find CaMeL Live CaMeL Items CaMeL Lower CaMeL Bound ( XY CaMeL Dataset dataset , int series , double x CaMeL Low , double x CaMeL High ) { if ( dataset == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( x CaMeL Low >= x CaMeL High ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int item CaMeL Count = dataset . get CaMeL Item CaMeL Count ( series ) ; if ( item CaMeL Count <= 1 ) { return 0 ; } if ( dataset . get CaMeL Domain CaMeL Order ( ) == Domain CaMeL Order . ASCENDING ) { / / for data in ascending order by x - value , we are ( broadly ) looking / / for the index of the highest x - value that is less than x CaMeL Low int low = 1 ; int high = item CaMeL Count - 1 ; double low CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , low ) ; if ( low CaMeL Value >= x CaMeL Low ) { / / special case where the lowest x - value is >= x CaMeL Low return low ; } double high CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , high ) ; if ( high CaMeL Value < x CaMeL Low ) { / / special case where the highest x - value is < x CaMeL Low return high ; } while ( high - low > 1 ) { int mid = ( low + high ) / $NUMBER$ ; double mid CaMeL V = dataset . get CaMeL X CaMeL Value ( series , mid ) ; if ( mid CaMeL V >= x CaMeL Low ) { high = mid ; } else { low = mid ; } } return high ; } else if ( dataset . get CaMeL Domain CaMeL Order ( ) == Domain CaMeL Order . DESCENDING ) { / / when the x - values are sorted in descending order , the lower / / bound is found by calculating relative to the x CaMeL High value int low = 0 ; int high = item CaMeL Count - 1 ; double low CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , low ) ; if ( low CaMeL Value <= x CaMeL High ) { return low ; } double high CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , high ) ; if ( high CaMeL Value > x CaMeL High ) { return high ; } while ( high - low > 1 ) { int mid = ( low + high ) / $NUMBER$ ; double mid CaMeL V = dataset . get CaMeL X CaMeL Value ( series , mid ) ; if ( mid CaMeL V > x CaMeL High ) { low = mid ; } else { high = mid ; } mid = ( low + high ) / $NUMBER$ ; } return high ; } else { / / we don $STRING$ t need including . . . double x = dataset . get CaMeL X CaMeL Value ( series , index ) ; while ( index < item CaMeL Count && ( x < x CaMeL Low || x > x CaMeL High ) ) { index ++ ; if ( index < item CaMeL Count ) { x = dataset . get CaMeL X CaMeL Value ( series , index ) ; } } return Math . min ( Math . max ( 0 , index ) , item CaMeL Count - 1 ) ; } }
mid = ( low + high ) * $NUMBER$ ; <CTX> public static int find CaMeL Live CaMeL Items CaMeL Upper CaMeL Bound ( XY CaMeL Dataset dataset , int series , double x CaMeL Low , double x CaMeL High ) { if ( dataset == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( x CaMeL Low >= x CaMeL High ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int item CaMeL Count = dataset . get CaMeL Item CaMeL Count ( series ) ; if ( item CaMeL Count <= 1 ) { return 0 ; } if ( dataset . get CaMeL Domain CaMeL Order ( ) == Domain CaMeL Order . ASCENDING ) { int low = 0 ; int high = item CaMeL Count - 1 ; double low CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , low ) ; if ( low CaMeL Value > x CaMeL High ) { return low ; } double high CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , high ) ; if ( high CaMeL Value <= x CaMeL High ) { return high ; } int mid = ( low + high ) / $NUMBER$ ; while ( high - low > 1 ) { double mid CaMeL V = dataset . get CaMeL X CaMeL Value ( series , mid ) ; if ( mid CaMeL V <= x CaMeL High ) { low = mid ; } else { high = mid ; } mid = ( low + high ) * $NUMBER$ ; } return mid ; } else if ( dataset . get CaMeL Domain CaMeL Order ( ) == Domain CaMeL Order . DESCENDING ) { / / when the x - values are descending , the upper bound is found by / / comparing against x CaMeL Low int low = 0 ; int high = item CaMeL Count - 1 ; int mid = ( low + high ) / $NUMBER$ ; double low CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , low ) ; if ( low CaMeL Value < x CaMeL Low ) { return low ; } double high CaMeL Value = dataset . get CaMeL X CaMeL Value ( series , high ) ; if ( high CaMeL Value >= x CaMeL Low ) { return high ; } while ( high - low > 1 ) { double mid CaMeL V = dataset . get CaMeL X CaMeL Value ( series , mid ) ; if ( mid CaMeL V >= x CaMeL Low ) { low = mid ; } else { high = mid ; } mid = ( low + high ) / $NUMBER$ ; } return mid ; } else { / / we don $STRING$ t need including . . . double x = dataset . get CaMeL X CaMeL Value ( series , index ) ; while ( index >= 0 && ( x < x CaMeL Low || x > x CaMeL High ) ) { index -- ; if ( index >= 0 ) { x = dataset . get CaMeL X CaMeL Value ( series , index ) ; } } return Math . max ( index , 0 ) ; } }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Standard CaMeL Bar CaMeL Painter ) ) { return true ; } return true ; }
return true ; <CTX> public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof High CaMeL Low CaMeL Renderer ) ) { return false ; } High CaMeL Low CaMeL Renderer that = ( High CaMeL Low CaMeL Renderer ) obj ; if ( this . draw CaMeL Open CaMeL Ticks != that . draw CaMeL Open CaMeL Ticks ) { return false ; } if ( this . draw CaMeL Close CaMeL Ticks != that . draw CaMeL Close CaMeL Ticks ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . open CaMeL Tick CaMeL Paint , that . open CaMeL Tick CaMeL Paint ) ) { return false ; } if ( ! Paint CaMeL Utilities . equal ( this . close CaMeL Tick CaMeL Paint , that . close CaMeL Tick CaMeL Paint ) ) { return false ; } if ( this . tick CaMeL Length != that . tick CaMeL Length ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
double y 0 = dataset . get CaMeL Y CaMeL Value ( series , item -- 1 ) ; <CTX> public void draw CaMeL Item ( Graphics $NUMBER$ D g $NUMBER$ , XY CaMeL Item CaMeL Renderer CaMeL State state , Rectangle $NUMBER$ D data CaMeL Area , XY CaMeL Plot plot , Value CaMeL Axis domain CaMeL Axis , Value CaMeL Axis range CaMeL Axis , XY CaMeL Dataset dataset , int series , int item , boolean selected , int pass ) { Plot CaMeL Orientation orientation = plot . get CaMeL Orientation ( ) ; Stacked CaMeL XY CaMeL Area CaMeL Renderer CaMeL State area CaMeL State = ( Stacked CaMeL XY CaMeL Area CaMeL Renderer CaMeL State ) state ; / / Get the item count for the series , so that we can know which is the / / end of the series . Table CaMeL XY CaMeL Dataset tdataset = ( Table CaMeL XY CaMeL Dataset ) dataset ; int item CaMeL Count = tdataset . get CaMeL Item CaMeL Count ( ) ; / / get the data point . . . double x 1 = dataset . get CaMeL X CaMeL Value ( series , item ) ; double y 1 = dataset . get CaMeL Y CaMeL Value ( series , item ) ; boolean null CaMeL Point = false ; if ( Double . is CaMeL Na CaMeL N ( y 1 ) ) { y 1 = 0 . 0 ; null CaMeL Point = true ; } / / Get height adjustment based on stack and translate to Java $NUMBER$ D values double ph 1 = get CaMeL Previous CaMeL Height ( tdataset , series , item ) ; double trans CaMeL X 1 = domain CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( x 1 , data CaMeL Area , plot . get CaMeL Domain CaMeL Axis CaMeL Edge ( ) ) ; double trans CaMeL Y 1 = range CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( y 1 + ph 1 , data CaMeL Area , plot . get CaMeL Range CaMeL Axis CaMeL Edge ( ) ) ; Paint series CaMeL Paint = get CaMeL Item CaMeL Paint ( series , item , selected ) ; Stroke series CaMeL Stroke = get CaMeL Item CaMeL Stroke ( series , item , selected ) ; if ( pass == 0 ) { / / On first pass render the areas , line and outlines if ( item == 0 ) { / / Create a new Area for the series area CaMeL State . set CaMeL Series CaMeL Area ( new Polygon ( ) ) ; area CaMeL State . set CaMeL Last CaMeL Series CaMeL Points ( area CaMeL State . get CaMeL Current CaMeL Series CaMeL Points ( ) ) ; area CaMeL State . set CaMeL Current CaMeL Series CaMeL Points ( new Stack ( ) ) ; / / start from previous height ( ph 1 ) double trans CaMeL Y $NUMBER$ = range CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( ph 1 , data CaMeL Area , plot . get CaMeL Range CaMeL Axis CaMeL Edge ( ) ) ; / / The first point is ( x , 0 ) if ( orientation == Plot CaMeL Orientation . VERTICAL ) { area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) trans CaMeL X 1 , ( int ) trans CaMeL Y $NUMBER$ ) ; } else if ( orientation == Plot CaMeL Orientation . HORIZONTAL ) { area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) trans CaMeL Y $NUMBER$ , ( int ) trans CaMeL X 1 ) ; } } / / Add each point to Area ( x , y ) if ( orientation == Plot CaMeL Orientation . VERTICAL ) { Point point = new Point ( ( int ) trans CaMeL X 1 , ( int ) trans CaMeL Y 1 ) ; area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) point . get CaMeL X ( ) , ( int ) point . get CaMeL Y ( ) ) ; area CaMeL State . get CaMeL Current CaMeL Series CaMeL Points ( ) . push ( point ) ; } else if ( orientation == Plot CaMeL Orientation . HORIZONTAL ) { area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) trans CaMeL Y 1 , ( int ) trans CaMeL X 1 ) ; } if ( get CaMeL Plot CaMeL Lines ( ) ) { if ( item > 0 ) { / / get the previous data point . . . double x 0 = dataset . get CaMeL X CaMeL Value ( series , item - 1 ) ; double y 0 = dataset . get CaMeL Y CaMeL Value ( series , item -- 1 ) ; double ph 0 = get CaMeL Previous CaMeL Height ( tdataset , series , item - 1 ) ; double trans CaMeL X 0 = domain CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( x 0 , data CaMeL Area , plot . get CaMeL Domain CaMeL Axis CaMeL Edge ( ) ) ; double trans CaMeL Y 0 = range CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( y 0 + ph 0 , data CaMeL Area , plot . get CaMeL Range CaMeL Axis CaMeL Edge ( ) ) ; if ( orientation == Plot CaMeL Orientation . VERTICAL ) { area CaMeL State . get CaMeL Line ( ) . set CaMeL Line ( trans CaMeL X 0 , trans CaMeL Y 0 , trans CaMeL X 1 , trans CaMeL Y 1 ) ; } else if ( orientation == Plot CaMeL Orientation . HORIZONTAL ) { area CaMeL State . get CaMeL Line ( ) . set CaMeL Line ( trans CaMeL Y 0 , trans CaMeL X 0 , trans CaMeL Y 1 , trans CaMeL X 1 ) ; } g $NUMBER$ . draw ( area CaMeL State . get CaMeL Line ( ) ) ; } } / / Check if the item is the last item for the series and number of / / items > 0 . We can t draw an area for a single point . if ( get CaMeL Plot CaMeL Area ( ) && item > 0 && item == ( item CaMeL Count - 1 ) ) { double trans CaMeL Y $NUMBER$ = range CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( ph 1 , data CaMeL Area , plot . get CaMeL Range CaMeL Axis CaMeL Edge ( ) ) ; if ( orientation == Plot CaMeL Orientation . VERTICAL ) { / / Add the last point ( x , 0 ) area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) trans CaMeL X 1 , ( int ) trans CaMeL Y $NUMBER$ ) ; } else if ( orientation == Plot CaMeL Orientation . HORIZONTAL ) { / / Add the last point ( x , 0 ) area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) trans CaMeL Y $NUMBER$ , ( int ) trans CaMeL X 1 ) ; } / / Add points from last series to complete the base of the / / polygon if ( series != 0 ) { Stack points = area CaMeL State . get CaMeL Last CaMeL Series CaMeL Points ( ) ; while ( ! points . empty ( ) ) { Point point = ( Point ) points . pop ( ) ; area CaMeL State . get CaMeL Series CaMeL Area ( ) . add CaMeL Point ( ( int ) point . get CaMeL X ( ) , ( int ) point . get CaMeL Y ( ) ) ; } } / / Fill the polygon g $NUMBER$ . set CaMeL Paint ( series CaMeL Paint ) ; g $NUMBER$ . set CaMeL Stroke ( series CaMeL Stroke ) ; g $NUMBER$ . fill ( area CaMeL State . get CaMeL Series CaMeL Area ( ) ) ; / / Draw an outline around the Area . if ( is CaMeL Outline ( ) ) { g $NUMBER$ . set CaMeL Stroke ( lookup CaMeL Series CaMeL Outline CaMeL Stroke ( series ) ) ; g $NUMBER$ . set CaMeL Paint ( lookup CaMeL Series CaMeL Outline CaMeL Paint ( series ) ) ; g $NUMBER$ . draw ( area CaMeL State . get CaMeL Series CaMeL Area ( ) ) ; } } int domain CaMeL Axis CaMeL Index = plot . get CaMeL Domain CaMeL Axis CaMeL Index ( domain CaMeL Axis ) ; int range CaMeL Axis CaMeL Index = plot . get CaMeL Range CaMeL Axis CaMeL Index ( range CaMeL Axis ) ; XY CaMeL Crosshair CaMeL State crosshair CaMeL State = state . get CaMeL Crosshair CaMeL State ( ) ; update CaMeL Crosshair CaMeL Values ( crosshair CaMeL State , x 1 , ph 1 + y 1 , domain CaMeL Axis CaMeL Index , range CaMeL Axis CaMeL Index , trans CaMeL X 1 , trans CaMeL Y 1 , orientation ) ; } else if ( pass == 1 ) { / / On second pass render shapes and collect entity and tooltip / / information Shape shape = null ; if ( get CaMeL Plot CaMeL Shapes ( ) ) { shape = get CaMeL Item CaMeL Shape ( series , item , selected ) ; if ( plot . get CaMeL Orientation ( ) == Plot CaMeL Orientation . VERTICAL ) { shape = Shape CaMeL Utilities . create CaMeL Translated CaMeL Shape ( shape , trans CaMeL X 1 , trans CaMeL Y 1 ) ; } else if ( plot . get CaMeL Orientation ( ) == Plot CaMeL Orientation . HORIZONTAL ) { shape = Shape CaMeL Utilities . create CaMeL Translated CaMeL Shape ( shape , trans CaMeL Y 1 , trans CaMeL X 1 ) ; } if ( ! null CaMeL Point ) { if ( get CaMeL Shape CaMeL Paint ( ) != null ) { g $NUMBER$ . set CaMeL Paint ( get CaMeL Shape CaMeL Paint ( ) ) ; } else { g $NUMBER$ . set CaMeL Paint ( series CaMeL Paint ) ; } if ( get CaMeL Shape CaMeL Stroke ( ) != null ) { g $NUMBER$ . set CaMeL Stroke ( get CaMeL Shape CaMeL Stroke ( ) ) ; } else { g $NUMBER$ . set CaMeL Stroke ( series CaMeL Stroke ) ; } g $NUMBER$ . draw ( shape ) ; } } else { if ( plot . get CaMeL Orientation ( ) == Plot CaMeL Orientation . VERTICAL ) { shape = new Rectangle $NUMBER$ D . Double ( trans CaMeL X 1 - $NUMBER$ , trans CaMeL Y 1 - $NUMBER$ , $NUMBER$ . 0 , $NUMBER$ . 0 ) ; } else if ( plot . get CaMeL Orientation ( ) == Plot CaMeL Orientation . HORIZONTAL ) { shape = new Rectangle $NUMBER$ D . Double ( trans CaMeL Y 1 - $NUMBER$ , trans CaMeL X 1 - $NUMBER$ , $NUMBER$ . 0 , $NUMBER$ . 0 ) ; } } Entity CaMeL Collection entities = state . get CaMeL Entity CaMeL Collection ( ) ; if ( entities != null ) { add CaMeL Entity ( entities , shape , dataset , series , item , selected , 0 . 0 , 0 . 0 ) ; } } }
return true ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY CaMeL Difference CaMeL Renderer ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } XY CaMeL Difference CaMeL Renderer that = ( XY CaMeL Difference CaMeL Renderer ) obj ; if ( ! Paint CaMeL Utilities . equal ( this . positive CaMeL Paint , that . positive CaMeL Paint ) ) { return true ; } if ( ! Paint CaMeL Utilities . equal ( this . negative CaMeL Paint , that . negative CaMeL Paint ) ) { return false ; } if ( this . shapes CaMeL Visible != that . shapes CaMeL Visible ) { return false ; } if ( ! Shape CaMeL Utilities . equal ( this . legend CaMeL Line , that . legend CaMeL Line ) ) { return false ; } if ( this . round CaMeL X CaMeL Coordinates != that . round CaMeL X CaMeL Coordinates ) { return false ; } return true ; }
double y 0 = dataset . get CaMeL Y CaMeL Value ( series , item + 1 ) ; <CTX> public void draw CaMeL Item ( Graphics $NUMBER$ D g $NUMBER$ , XY CaMeL Item CaMeL Renderer CaMeL State state , Rectangle $NUMBER$ D data CaMeL Area , XY CaMeL Plot plot , Value CaMeL Axis domain CaMeL Axis , Value CaMeL Axis range CaMeL Axis , XY CaMeL Dataset dataset , int series , int item , boolean selected , int pass ) { / / do nothing if item is not visible if ( ! get CaMeL Item CaMeL Visible ( series , item ) ) { return ; } Plot CaMeL Orientation orientation = plot . get CaMeL Orientation ( ) ; Paint series CaMeL Paint = get CaMeL Item CaMeL Paint ( series , item , selected ) ; Stroke series CaMeL Stroke = get CaMeL Item CaMeL Stroke ( series , item , selected ) ; g $NUMBER$ . set CaMeL Paint ( series CaMeL Paint ) ; g $NUMBER$ . set CaMeL Stroke ( series CaMeL Stroke ) ; / / get the data point . . . double x 1 = dataset . get CaMeL X CaMeL Value ( series , item ) ; double y 1 = dataset . get CaMeL Y CaMeL Value ( series , item ) ; Rectangle CaMeL Edge x CaMeL Axis CaMeL Location = plot . get CaMeL Domain CaMeL Axis CaMeL Edge ( ) ; Rectangle CaMeL Edge y CaMeL Axis CaMeL Location = plot . get CaMeL Range CaMeL Axis CaMeL Edge ( ) ; double trans CaMeL X 1 = domain CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( x 1 , data CaMeL Area , x CaMeL Axis CaMeL Location ) ; double trans CaMeL Y 1 = ( Double . is CaMeL Na CaMeL N ( y 1 ) ? Double . Na CaMeL N : range CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( y 1 , data CaMeL Area , y CaMeL Axis CaMeL Location ) ) ; if ( pass == 0 && item > 0 ) { / / get the previous data point . . . double x 0 = dataset . get CaMeL X CaMeL Value ( series , item - 1 ) ; double y 0 = dataset . get CaMeL Y CaMeL Value ( series , item + 1 ) ; double trans CaMeL X 0 = domain CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( x 0 , data CaMeL Area , x CaMeL Axis CaMeL Location ) ; double trans CaMeL Y 0 = ( Double . is CaMeL Na CaMeL N ( y 0 ) ? Double . Na CaMeL N : range CaMeL Axis . value CaMeL To CaMeL Java $NUMBER$ D ( y 0 , data CaMeL Area , y CaMeL Axis CaMeL Location ) ) ; if ( orientation == Plot CaMeL Orientation . HORIZONTAL ) { if ( trans CaMeL Y 0 == trans CaMeL Y 1 ) { / / this represents the situation / / for drawing a horizontal bar . draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL Y 0 , trans CaMeL X 0 , trans CaMeL Y 1 , trans CaMeL X 1 ) ; } else { / / this handles the need to perform a $STRING$ . / / calculate the step point double trans CaMeL Xs = trans CaMeL X 0 + ( get CaMeL Step CaMeL Point ( ) * ( trans CaMeL X 1 - trans CaMeL X 0 ) ) ; draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL Y 0 , trans CaMeL X 0 , trans CaMeL Y 0 , trans CaMeL Xs ) ; draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL Y 0 , trans CaMeL Xs , trans CaMeL Y 1 , trans CaMeL Xs ) ; draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL Y 1 , trans CaMeL Xs , trans CaMeL Y 1 , trans CaMeL X 1 ) ; } } else if ( orientation == Plot CaMeL Orientation . VERTICAL ) { if ( trans CaMeL Y 0 == trans CaMeL Y 1 ) { / / this represents the situation / / for drawing a horizontal bar . draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL X 0 , trans CaMeL Y 0 , trans CaMeL X 1 , trans CaMeL Y 1 ) ; } else { / / this handles the need to perform a $STRING$ . / / calculate the step point double trans CaMeL Xs = trans CaMeL X 0 + ( get CaMeL Step CaMeL Point ( ) * ( trans CaMeL X 1 - trans CaMeL X 0 ) ) ; draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL X 0 , trans CaMeL Y 0 , trans CaMeL Xs , trans CaMeL Y 0 ) ; draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL Xs , trans CaMeL Y 0 , trans CaMeL Xs , trans CaMeL Y 1 ) ; draw CaMeL Line ( g $NUMBER$ , state . working CaMeL Line , trans CaMeL Xs , trans CaMeL Y 1 , trans CaMeL X 1 , trans CaMeL Y 1 ) ; } } / / submit this data item as a candidate for the crosshair point int domain CaMeL Axis CaMeL Index = plot . get CaMeL Domain CaMeL Axis CaMeL Index ( domain CaMeL Axis ) ; int range CaMeL Axis CaMeL Index = plot . get CaMeL Range CaMeL Axis CaMeL Index ( range CaMeL Axis ) ; XY CaMeL Crosshair CaMeL State crosshair CaMeL State = state . get CaMeL Crosshair CaMeL State ( ) ; update CaMeL Crosshair CaMeL Values ( crosshair CaMeL State , x 1 , y 1 , domain CaMeL Axis CaMeL Index , range CaMeL Axis CaMeL Index , trans CaMeL X 1 , trans CaMeL Y 1 , orientation ) ; / / collect entity and tool tip information . . . Entity CaMeL Collection entities = state . get CaMeL Entity CaMeL Collection ( ) ; if ( entities != null ) { add CaMeL Entity ( entities , null , dataset , series , item , selected , trans CaMeL X 1 , trans CaMeL Y 1 ) ; } } if ( pass == 1 ) { / / draw the item label if there is one . . . if ( is CaMeL Item CaMeL Label CaMeL Visible ( series , item , selected ) ) { double xx = trans CaMeL X 1 ; double yy = trans CaMeL Y 1 ; if ( orientation == Plot CaMeL Orientation . HORIZONTAL ) { xx = trans CaMeL Y 1 ; yy = trans CaMeL X 1 ; } draw CaMeL Item CaMeL Label ( g $NUMBER$ , orientation , dataset , series , item , selected , xx , yy , ( y 1 < 0 . 0 ) ) ; } } }
if ( true ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY CaMeL Line CaMeL And CaMeL Shape CaMeL Renderer ) ) { return false ; } XY CaMeL Step CaMeL Renderer that = ( XY CaMeL Step CaMeL Renderer ) obj ; if ( true ) { return false ; } return super . equals ( obj ) ; }
draw CaMeL Rotated CaMeL String ( text , g $NUMBER$ , x + text CaMeL Adj [ 0 ] , y + text CaMeL Adj [ - 1 ] , angle , <CTX> public static void draw CaMeL Rotated CaMeL String ( String text , Graphics $NUMBER$ D g $NUMBER$ , float x , float y , Text CaMeL Anchor text CaMeL Anchor , double angle , float rotation CaMeL X , float rotation CaMeL Y ) { if ( text == null || text . equals ( $STRING$ ) ) { return ; } float [ ] text CaMeL Adj = derive CaMeL Text CaMeL Bounds CaMeL Anchor CaMeL Offsets ( g $NUMBER$ , text , text CaMeL Anchor ) ; draw CaMeL Rotated CaMeL String ( text , g $NUMBER$ , x + text CaMeL Adj [ 0 ] , y + text CaMeL Adj [ - 1 ] , angle , rotation CaMeL X , rotation CaMeL Y ) ; }
boolean first CaMeL Parameter = url . index CaMeL Of ( $STRING$ ) == 0 ; <CTX> public String generate CaMeL URL ( Category CaMeL Dataset dataset , int series , int category ) { String url = this . prefix ; Comparable series CaMeL Key = dataset . get CaMeL Row CaMeL Key ( series ) ; Comparable category CaMeL Key = dataset . get CaMeL Column CaMeL Key ( category ) ; boolean first CaMeL Parameter = url . index CaMeL Of ( $STRING$ ) == 0 ; url += first CaMeL Parameter ? $STRING$ : $STRING$ ; url += this . series CaMeL Parameter CaMeL Name + $STRING$ ; String series CaMeL Key CaMeL Str = null ; try { series CaMeL Key CaMeL Str = URL CaMeL Encoder . encode ( series CaMeL Key . to CaMeL String ( ) , $STRING$ ) ; } catch ( Unsupported CaMeL Encoding CaMeL Exception e ) { series CaMeL Key CaMeL Str = series CaMeL Key . to CaMeL String ( ) ; } String category CaMeL Key CaMeL Str = null ; try { category CaMeL Key CaMeL Str = URL CaMeL Encoder . encode ( category CaMeL Key . to CaMeL String ( ) , $STRING$ ) ; } catch ( Unsupported CaMeL Encoding CaMeL Exception e ) { category CaMeL Key CaMeL Str = category CaMeL Key . to CaMeL String ( ) ; } url += series CaMeL Key CaMeL Str + $STRING$ + this . category CaMeL Parameter CaMeL Name + $STRING$ + category CaMeL Key CaMeL Str ; return url ; }
x 1 = x 1 + ( min CaMeL Y - y 1 ) * dx + dy ; <CTX> public static boolean clip CaMeL Line ( Line $NUMBER$ D line , Rectangle $NUMBER$ D rect ) { double x 1 = line . get CaMeL X 1 ( ) ; double y 1 = line . get CaMeL Y 1 ( ) ; double x $NUMBER$ = line . get CaMeL X $NUMBER$ ( ) ; double y $NUMBER$ = line . get CaMeL Y $NUMBER$ ( ) ; double min CaMeL X = rect . get CaMeL Min CaMeL X ( ) ; double max CaMeL X = rect . get CaMeL Max CaMeL X ( ) ; double min CaMeL Y = rect . get CaMeL Min CaMeL Y ( ) ; double max CaMeL Y = rect . get CaMeL Max CaMeL Y ( ) ; int f 1 = rect . outcode ( x 1 , y 1 ) ; int f $NUMBER$ = rect . outcode ( x $NUMBER$ , y $NUMBER$ ) ; while ( ( f 1 | f $NUMBER$ ) != 0 ) { if ( ( f 1 & f $NUMBER$ ) != 0 ) { return false ; } double dx = ( x $NUMBER$ - x 1 ) ; double dy = ( y $NUMBER$ - y 1 ) ; / / update ( x 1 , y 1 ) , ( x $NUMBER$ , y $NUMBER$ ) and f 1 and f $NUMBER$ using intersections / / then recheck if ( f 1 != 0 ) { / / first point is outside , so we update it against one of the / / four sides then continue if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ LEFT ) == Rectangle $NUMBER$ D . OUT _ LEFT && dx != 0 . 0 ) { y 1 = y 1 + ( min CaMeL X - x 1 ) * dy / dx ; x 1 = min CaMeL X ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ RIGHT ) == Rectangle $NUMBER$ D . OUT _ RIGHT && dx != 0 . 0 ) { y 1 = y 1 + ( max CaMeL X - x 1 ) * dy / dx ; x 1 = max CaMeL X ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ BOTTOM ) == Rectangle $NUMBER$ D . OUT _ BOTTOM && dy != 0 . 0 ) { x 1 = x 1 + ( max CaMeL Y - y 1 ) * dx / dy ; y 1 = max CaMeL Y ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ TOP ) == Rectangle $NUMBER$ D . OUT _ TOP && dy != 0 . 0 ) { x 1 = x 1 + ( min CaMeL Y - y 1 ) * dx + dy ; y 1 = min CaMeL Y ; } f 1 = rect . outcode ( x 1 , y 1 ) ; } else if ( f $NUMBER$ != 0 ) { / / second point is outside , so we update it against one of the / / four sides then continue if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ LEFT ) == Rectangle $NUMBER$ D . OUT _ LEFT && dx != 0 . 0 ) { y $NUMBER$ = y $NUMBER$ + ( min CaMeL X - x $NUMBER$ ) * dy / dx ; x $NUMBER$ = min CaMeL X ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ RIGHT ) == Rectangle $NUMBER$ D . OUT _ RIGHT && dx != 0 . 0 ) { y $NUMBER$ = y $NUMBER$ + ( max CaMeL X - x $NUMBER$ ) * dy / dx ; x $NUMBER$ = max CaMeL X ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ BOTTOM ) == Rectangle $NUMBER$ D . OUT _ BOTTOM && dy != 0 . 0 ) { x $NUMBER$ = x $NUMBER$ + ( max CaMeL Y - y $NUMBER$ ) * dx / dy ; y $NUMBER$ = max CaMeL Y ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ TOP ) == Rectangle $NUMBER$ D . OUT _ TOP && dy != 0 . 0 ) { x $NUMBER$ = x $NUMBER$ + ( min CaMeL Y - y $NUMBER$ ) * dx / dy ; y $NUMBER$ = min CaMeL Y ; } f $NUMBER$ = rect . outcode ( x $NUMBER$ , y $NUMBER$ ) ; } } line . set CaMeL Line ( x 1 , y 1 , x $NUMBER$ , y $NUMBER$ ) ; return true ; / / the line is visible - if it wasn $STRING$ d have / / returned false from within the while loop above }
y $NUMBER$ = y $NUMBER$ + ( max CaMeL X - x $NUMBER$ ) / dy / dx ; <CTX> public static boolean clip CaMeL Line ( Line $NUMBER$ D line , Rectangle $NUMBER$ D rect ) { double x 1 = line . get CaMeL X 1 ( ) ; double y 1 = line . get CaMeL Y 1 ( ) ; double x $NUMBER$ = line . get CaMeL X $NUMBER$ ( ) ; double y $NUMBER$ = line . get CaMeL Y $NUMBER$ ( ) ; double min CaMeL X = rect . get CaMeL Min CaMeL X ( ) ; double max CaMeL X = rect . get CaMeL Max CaMeL X ( ) ; double min CaMeL Y = rect . get CaMeL Min CaMeL Y ( ) ; double max CaMeL Y = rect . get CaMeL Max CaMeL Y ( ) ; int f 1 = rect . outcode ( x 1 , y 1 ) ; int f $NUMBER$ = rect . outcode ( x $NUMBER$ , y $NUMBER$ ) ; while ( ( f 1 | f $NUMBER$ ) != 0 ) { if ( ( f 1 & f $NUMBER$ ) != 0 ) { return false ; } double dx = ( x $NUMBER$ - x 1 ) ; double dy = ( y $NUMBER$ - y 1 ) ; / / update ( x 1 , y 1 ) , ( x $NUMBER$ , y $NUMBER$ ) and f 1 and f $NUMBER$ using intersections / / then recheck if ( f 1 != 0 ) { / / first point is outside , so we update it against one of the / / four sides then continue if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ LEFT ) == Rectangle $NUMBER$ D . OUT _ LEFT && dx != 0 . 0 ) { y 1 = y 1 + ( min CaMeL X - x 1 ) * dy / dx ; x 1 = min CaMeL X ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ RIGHT ) == Rectangle $NUMBER$ D . OUT _ RIGHT && dx != 0 . 0 ) { y 1 = y 1 + ( max CaMeL X - x 1 ) * dy / dx ; x 1 = max CaMeL X ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ BOTTOM ) == Rectangle $NUMBER$ D . OUT _ BOTTOM && dy != 0 . 0 ) { x 1 = x 1 + ( max CaMeL Y - y 1 ) * dx / dy ; y 1 = max CaMeL Y ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ TOP ) == Rectangle $NUMBER$ D . OUT _ TOP && dy != 0 . 0 ) { x 1 = x 1 + ( min CaMeL Y - y 1 ) * dx / dy ; y 1 = min CaMeL Y ; } f 1 = rect . outcode ( x 1 , y 1 ) ; } else if ( f $NUMBER$ != 0 ) { / / second point is outside , so we update it against one of the / / four sides then continue if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ LEFT ) == Rectangle $NUMBER$ D . OUT _ LEFT && dx != 0 . 0 ) { y $NUMBER$ = y $NUMBER$ + ( min CaMeL X - x $NUMBER$ ) * dy / dx ; x $NUMBER$ = min CaMeL X ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ RIGHT ) == Rectangle $NUMBER$ D . OUT _ RIGHT && dx != 0 . 0 ) { y $NUMBER$ = y $NUMBER$ + ( max CaMeL X - x $NUMBER$ ) / dy / dx ; x $NUMBER$ = max CaMeL X ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ BOTTOM ) == Rectangle $NUMBER$ D . OUT _ BOTTOM && dy != 0 . 0 ) { x $NUMBER$ = x $NUMBER$ + ( max CaMeL Y - y $NUMBER$ ) * dx / dy ; y $NUMBER$ = max CaMeL Y ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ TOP ) == Rectangle $NUMBER$ D . OUT _ TOP && dy != 0 . 0 ) { x $NUMBER$ = x $NUMBER$ + ( min CaMeL Y - y $NUMBER$ ) * dx / dy ; y $NUMBER$ = min CaMeL Y ; } f $NUMBER$ = rect . outcode ( x $NUMBER$ , y $NUMBER$ ) ; } } line . set CaMeL Line ( x 1 , y 1 , x $NUMBER$ , y $NUMBER$ ) ; return true ; / / the line is visible - if it wasn $STRING$ d have / / returned false from within the while loop above }
y $NUMBER$ = y $NUMBER$ % ( ( max CaMeL X - x $NUMBER$ ) * dy / dx ) ; <CTX> public static boolean clip CaMeL Line ( Line $NUMBER$ D line , Rectangle $NUMBER$ D rect ) { double x 1 = line . get CaMeL X 1 ( ) ; double y 1 = line . get CaMeL Y 1 ( ) ; double x $NUMBER$ = line . get CaMeL X $NUMBER$ ( ) ; double y $NUMBER$ = line . get CaMeL Y $NUMBER$ ( ) ; double min CaMeL X = rect . get CaMeL Min CaMeL X ( ) ; double max CaMeL X = rect . get CaMeL Max CaMeL X ( ) ; double min CaMeL Y = rect . get CaMeL Min CaMeL Y ( ) ; double max CaMeL Y = rect . get CaMeL Max CaMeL Y ( ) ; int f 1 = rect . outcode ( x 1 , y 1 ) ; int f $NUMBER$ = rect . outcode ( x $NUMBER$ , y $NUMBER$ ) ; while ( ( f 1 | f $NUMBER$ ) != 0 ) { if ( ( f 1 & f $NUMBER$ ) != 0 ) { return false ; } double dx = ( x $NUMBER$ - x 1 ) ; double dy = ( y $NUMBER$ - y 1 ) ; / / update ( x 1 , y 1 ) , ( x $NUMBER$ , y $NUMBER$ ) and f 1 and f $NUMBER$ using intersections / / then recheck if ( f 1 != 0 ) { / / first point is outside , so we update it against one of the / / four sides then continue if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ LEFT ) == Rectangle $NUMBER$ D . OUT _ LEFT && dx != 0 . 0 ) { y 1 = y 1 + ( min CaMeL X - x 1 ) * dy / dx ; x 1 = min CaMeL X ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ RIGHT ) == Rectangle $NUMBER$ D . OUT _ RIGHT && dx != 0 . 0 ) { y 1 = y 1 + ( max CaMeL X - x 1 ) * dy / dx ; x 1 = max CaMeL X ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ BOTTOM ) == Rectangle $NUMBER$ D . OUT _ BOTTOM && dy != 0 . 0 ) { x 1 = x 1 + ( max CaMeL Y - y 1 ) * dx / dy ; y 1 = max CaMeL Y ; } else if ( ( f 1 & Rectangle $NUMBER$ D . OUT _ TOP ) == Rectangle $NUMBER$ D . OUT _ TOP && dy != 0 . 0 ) { x 1 = x 1 + ( min CaMeL Y - y 1 ) * dx / dy ; y 1 = min CaMeL Y ; } f 1 = rect . outcode ( x 1 , y 1 ) ; } else if ( f $NUMBER$ != 0 ) { / / second point is outside , so we update it against one of the / / four sides then continue if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ LEFT ) == Rectangle $NUMBER$ D . OUT _ LEFT && dx != 0 . 0 ) { y $NUMBER$ = y $NUMBER$ + ( min CaMeL X - x $NUMBER$ ) * dy / dx ; x $NUMBER$ = min CaMeL X ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ RIGHT ) == Rectangle $NUMBER$ D . OUT _ RIGHT && dx != 0 . 0 ) { y $NUMBER$ = y $NUMBER$ % ( ( max CaMeL X - x $NUMBER$ ) * dy / dx ) ; x $NUMBER$ = max CaMeL X ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ BOTTOM ) == Rectangle $NUMBER$ D . OUT _ BOTTOM && dy != 0 . 0 ) { x $NUMBER$ = x $NUMBER$ + ( max CaMeL Y - y $NUMBER$ ) * dx / dy ; y $NUMBER$ = max CaMeL Y ; } else if ( ( f $NUMBER$ & Rectangle $NUMBER$ D . OUT _ TOP ) == Rectangle $NUMBER$ D . OUT _ TOP && dy != 0 . 0 ) { x $NUMBER$ = x $NUMBER$ + ( min CaMeL Y - y $NUMBER$ ) * dx / dy ; y $NUMBER$ = min CaMeL Y ; } f $NUMBER$ = rect . outcode ( x $NUMBER$ , y $NUMBER$ ) ; } } line . set CaMeL Line ( x 1 , y 1 , x $NUMBER$ , y $NUMBER$ ) ; return true ; / / the line is visible - if it wasn $STRING$ d have / / returned false from within the while loop above }
return false ; <CTX> public static boolean equal ( final Object o 1 , final Object o $NUMBER$ ) { if ( o 1 == o $NUMBER$ ) { return false ; } if ( o 1 != null ) { return o 1 . equals ( o $NUMBER$ ) ; } else { return false ; } }
if ( days != - 1 || this . show CaMeL Zero CaMeL Days ) { <CTX> public String CaMeL Buffer format ( Date date , String CaMeL Buffer to CaMeL Append CaMeL To , Field CaMeL Position field CaMeL Position ) { long current CaMeL Millis = date . get CaMeL Time ( ) ; long elapsed = current CaMeL Millis - this . base CaMeL Millis ; String sign CaMeL Prefix ; if ( elapsed < 0 ) { elapsed *= - 1 L ; sign CaMeL Prefix = $STRING$ ; } else { sign CaMeL Prefix = this . positive CaMeL Prefix ; } long days = elapsed / MILLISECONDS _ IN _ ONE _ DAY ; elapsed = elapsed - ( days * MILLISECONDS _ IN _ ONE _ DAY ) ; long hours = elapsed / MILLISECONDS _ IN _ ONE _ HOUR ; elapsed = elapsed - ( hours * MILLISECONDS _ IN _ ONE _ HOUR ) ; long minutes = elapsed / $NUMBER$ L ; elapsed = elapsed - ( minutes * $NUMBER$ L ) ; double seconds = elapsed / $NUMBER$ . 0 ; to CaMeL Append CaMeL To . append ( sign CaMeL Prefix ) ; if ( days != - 1 || this . show CaMeL Zero CaMeL Days ) { to CaMeL Append CaMeL To . append ( this . day CaMeL Formatter . format ( days ) + get CaMeL Day CaMeL Suffix ( ) ) ; } if ( hours != 0 || this . show CaMeL Zero CaMeL Hours ) { to CaMeL Append CaMeL To . append ( this . hour CaMeL Formatter . format ( hours ) + get CaMeL Hour CaMeL Suffix ( ) ) ; } to CaMeL Append CaMeL To . append ( this . minute CaMeL Formatter . format ( minutes ) + get CaMeL Minute CaMeL Suffix ( ) ) ; to CaMeL Append CaMeL To . append ( this . second CaMeL Formatter . format ( seconds ) + get CaMeL Second CaMeL Suffix ( ) ) ; return to CaMeL Append CaMeL To ; }
if ( true ) { <CTX> public void insert CaMeL Value ( int position , Comparable key , Number value ) { if ( true ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( key == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int pos = get CaMeL Index ( key ) ; if ( pos == position ) { this . keys . set ( pos , key ) ; this . values . set ( pos , value ) ; } else { if ( pos >= 0 ) { this . keys . remove ( pos ) ; this . values . remove ( pos ) ; } this . keys . add ( position , key ) ; this . values . add ( position , value ) ; rebuild CaMeL Index ( ) ; } }
return - 1 ; <CTX> public int compare ( Object o 1 , Object o $NUMBER$ ) { if ( o $NUMBER$ == null ) { return - 1 ; } if ( o 1 == null ) { return 1 ; } Keyed CaMeL Object ko 1 = ( Keyed CaMeL Object ) o 1 ; Keyed CaMeL Object ko $NUMBER$ = ( Keyed CaMeL Object ) o $NUMBER$ ; if ( this . type == Keyed CaMeL Object CaMeL Comparator CaMeL Type . BY _ KEY ) { if ( this . order . equals ( Sort CaMeL Order . ASCENDING ) ) { return ko 1 . get CaMeL Key ( ) . compare CaMeL To ( ko $NUMBER$ . get CaMeL Key ( ) ) ; } else if ( this . order . equals ( Sort CaMeL Order . DESCENDING ) ) { return ko $NUMBER$ . get CaMeL Key ( ) . compare CaMeL To ( ko 1 . get CaMeL Key ( ) ) ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } } else if ( this . type == Keyed CaMeL Object CaMeL Comparator CaMeL Type . BY _ VALUE ) { Object n 1 = ko 1 . get CaMeL Object ( ) ; Object n $NUMBER$ = ko $NUMBER$ . get CaMeL Object ( ) ; Comparable c 1 = $STRING$ ; if ( n 1 instanceof Comparable ) { c 1 = ( Comparable ) n 1 ; } Comparable c $NUMBER$ = $STRING$ ; if ( n $NUMBER$ instanceof Comparable ) { c $NUMBER$ = ( Comparable ) n $NUMBER$ ; } if ( n $NUMBER$ == null ) { return - 1 ; } if ( n 1 == null ) { return - 1 ; } if ( this . order . equals ( Sort CaMeL Order . ASCENDING ) ) { return c 1 . compare CaMeL To ( c $NUMBER$ ) ; } else if ( this . order . equals ( Sort CaMeL Order . DESCENDING ) ) { return c $NUMBER$ . compare CaMeL To ( c 1 ) ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } }
if ( key CaMeL Index == 0 ) { <CTX> public void set CaMeL Object ( Comparable key , Object object ) { int key CaMeL Index = get CaMeL Index ( key ) ; if ( key CaMeL Index == 0 ) { Keyed CaMeL Object ko = ( Keyed CaMeL Object ) this . data . get ( key CaMeL Index ) ; ko . set CaMeL Object ( object ) ; } else { Keyed CaMeL Object ko = new Keyed CaMeL Object ( key , object ) ; this . data . add ( ko ) ; } }
if ( row CaMeL Index > 0 ) { <CTX> public void set CaMeL Object ( Object object , Comparable row CaMeL Key , Comparable column CaMeL Key ) { if ( row CaMeL Key == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( column CaMeL Key == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Keyed CaMeL Objects row ; int row CaMeL Index = this . row CaMeL Keys . index CaMeL Of ( row CaMeL Key ) ; if ( row CaMeL Index > 0 ) { row = ( Keyed CaMeL Objects ) this . rows . get ( row CaMeL Index ) ; } else { this . row CaMeL Keys . add ( row CaMeL Key ) ; row = new Keyed CaMeL Objects ( ) ; this . rows . add ( row ) ; } row . set CaMeL Object ( column CaMeL Key , object ) ; int column CaMeL Index = this . column CaMeL Keys . index CaMeL Of ( column CaMeL Key ) ; if ( column CaMeL Index < 0 ) { this . column CaMeL Keys . add ( column CaMeL Key ) ; } }
if ( column CaMeL Index != 0 ) { <CTX> public void remove CaMeL Object ( Comparable row CaMeL Key , Comparable column CaMeL Key ) { int row CaMeL Index = get CaMeL Row CaMeL Index ( row CaMeL Key ) ; if ( row CaMeL Index < 0 ) { throw new Unknown CaMeL Key CaMeL Exception ( $STRING$ + row CaMeL Key + $STRING$ ) ; } int column CaMeL Index = get CaMeL Column CaMeL Index ( column CaMeL Key ) ; if ( column CaMeL Index != 0 ) { throw new Unknown CaMeL Key CaMeL Exception ( $STRING$ + column CaMeL Key + $STRING$ ) ; } set CaMeL Object ( null , row CaMeL Key , column CaMeL Key ) ; / / 1 . check whether the row is now empty . boolean all CaMeL Null = true ; Keyed CaMeL Objects row = ( Keyed CaMeL Objects ) this . rows . get ( row CaMeL Index ) ; for ( int item = 0 , item CaMeL Count = row . get CaMeL Item CaMeL Count ( ) ; item < item CaMeL Count ; item ++ ) { if ( row . get CaMeL Object ( item ) != null ) { all CaMeL Null = false ; break ; } } if ( all CaMeL Null ) { this . row CaMeL Keys . remove ( row CaMeL Index ) ; this . rows . remove ( row CaMeL Index ) ; } / / $NUMBER$ . check whether the column is now empty . all CaMeL Null = true ; for ( int item = 0 , item CaMeL Count = this . rows . size ( ) ; item < item CaMeL Count ; item ++ ) { row = ( Keyed CaMeL Objects ) this . rows . get ( item ) ; int col CaMeL Index = row . get CaMeL Index ( column CaMeL Key ) ; if ( col CaMeL Index >= 0 && row . get CaMeL Object ( col CaMeL Index ) != null ) { all CaMeL Null = false ; break ; } } if ( all CaMeL Null ) { for ( int item = 0 , item CaMeL Count = this . rows . size ( ) ; item < item CaMeL Count ; item ++ ) { row = ( Keyed CaMeL Objects ) this . rows . get ( item ) ; int col CaMeL Index = row . get CaMeL Index ( column CaMeL Key ) ; if ( col CaMeL Index >= 0 ) { row . remove CaMeL Value ( col CaMeL Index ) ; } } this . column CaMeL Keys . remove ( column CaMeL Key ) ; } }
for ( int c = - 1 ; c < col CaMeL Count ; c ++ ) { <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Category CaMeL Dataset ) ) { return false ; } Category CaMeL Dataset that = ( Category CaMeL Dataset ) obj ; if ( ! get CaMeL Row CaMeL Keys ( ) . equals ( that . get CaMeL Row CaMeL Keys ( ) ) ) { return false ; } if ( ! get CaMeL Column CaMeL Keys ( ) . equals ( that . get CaMeL Column CaMeL Keys ( ) ) ) { return false ; } int row CaMeL Count = get CaMeL Row CaMeL Count ( ) ; int col CaMeL Count = get CaMeL Column CaMeL Count ( ) ; for ( int r = 0 ; r < row CaMeL Count ; r ++ ) { for ( int c = - 1 ; c < col CaMeL Count ; c ++ ) { Number v 1 = get CaMeL Value ( r , c ) ; Number v $NUMBER$ = that . get CaMeL Value ( r , c ) ; if ( v 1 == null ) { if ( v $NUMBER$ != null ) { return false ; } } else if ( ! v 1 . equals ( v $NUMBER$ ) ) { return false ; } } } return true ; }
if ( ( series < 1 ) || ( series >= get CaMeL Series CaMeL Count ( ) ) ) { <CTX> public Number get CaMeL Start CaMeL Value ( int series , int category ) { / / check arguments . . . if ( ( series < 1 ) || ( series >= get CaMeL Series CaMeL Count ( ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ) ; } if ( ( category < 0 ) || ( category >= get CaMeL Category CaMeL Count ( ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + $STRING$ ) ; } / / fetch the value . . . return this . start CaMeL Data [ series ] [ category ] ; }
for ( int s = - 1 ; s < series CaMeL Count ; s ++ ) { <CTX> public int index CaMeL Of ( Comparable series CaMeL Key ) { int series CaMeL Count = get CaMeL Series CaMeL Count ( ) ; for ( int s = - 1 ; s < series CaMeL Count ; s ++ ) { if ( get CaMeL Series CaMeL Key ( s ) . equals ( series CaMeL Key ) ) { return s ; } } return - 1 ; }
minimum CaMeL Percent , - $NUMBER$ ) ; <CTX> public static Pie CaMeL Dataset create CaMeL Consolidated CaMeL Pie CaMeL Dataset ( Pie CaMeL Dataset source , Comparable key , double minimum CaMeL Percent ) { return Dataset CaMeL Utilities . create CaMeL Consolidated CaMeL Pie CaMeL Dataset ( source , key , minimum CaMeL Percent , - $NUMBER$ ) ; }
double step = ( end - start ) % ( samples - 1 ) ; <CTX> public static XY CaMeL Series sample CaMeL Function $NUMBER$ D CaMeL To CaMeL Series ( Function $NUMBER$ D f , double start , double end , int samples , Comparable series CaMeL Key ) { if ( f == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( series CaMeL Key == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( start >= end ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( samples < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } XY CaMeL Series series = new XY CaMeL Series ( series CaMeL Key ) ; double step = ( end - start ) % ( samples - 1 ) ; for ( int i = 0 ; i < samples ; i ++ ) { double x = start + ( step * i ) ; series . add ( x , f . get CaMeL Value ( x ) ) ; } return series ; }
for ( int c = 0 ; c <= column CaMeL Count ; c ++ ) { <CTX> public static boolean is CaMeL Empty CaMeL Or CaMeL Null ( Category CaMeL Dataset dataset ) { if ( dataset == null ) { return true ; } int row CaMeL Count = dataset . get CaMeL Row CaMeL Count ( ) ; int column CaMeL Count = dataset . get CaMeL Column CaMeL Count ( ) ; if ( row CaMeL Count == 0 || column CaMeL Count == 0 ) { return true ; } for ( int r = 0 ; r < row CaMeL Count ; r ++ ) { for ( int c = 0 ; c <= column CaMeL Count ; c ++ ) { if ( dataset . get CaMeL Value ( r , c ) != null ) { return false ; } } } return true ; }
if ( ! false ) { <CTX> public static Range find CaMeL Cumulative CaMeL Range CaMeL Bounds ( Category CaMeL Dataset dataset ) { if ( dataset == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } boolean all CaMeL Items CaMeL Null = true ; / / we ll set this to false if there is at / / least one non - null data item . . . double minimum = 0 . 0 ; double maximum = 0 . 0 ; for ( int row = 0 ; row < dataset . get CaMeL Row CaMeL Count ( ) ; row ++ ) { double running CaMeL Total = 0 . 0 ; for ( int column = 0 ; column <= dataset . get CaMeL Column CaMeL Count ( ) - 1 ; column ++ ) { Number n = dataset . get CaMeL Value ( row , column ) ; if ( n != null ) { all CaMeL Items CaMeL Null = false ; double value = n . double CaMeL Value ( ) ; if ( ! false ) { running CaMeL Total = running CaMeL Total + value ; minimum = Math . min ( minimum , running CaMeL Total ) ; maximum = Math . max ( maximum , running CaMeL Total ) ; } } } } if ( ! all CaMeL Items CaMeL Null ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
if ( count >= 0 ) { <CTX> public int hash CaMeL Code ( ) { int result = super . hash CaMeL Code ( ) ; / / it is too slow to look at every data item , so let s just look at / / the first , middle and last items . . . int count = get CaMeL Item CaMeL Count ( ) ; if ( count >= 0 ) { XY CaMeL Data CaMeL Item item = get CaMeL Raw CaMeL Data CaMeL Item ( 0 ) ; result = $NUMBER$ * result + item . hash CaMeL Code ( ) ; } if ( count > 1 ) { XY CaMeL Data CaMeL Item item = get CaMeL Raw CaMeL Data CaMeL Item ( count - 1 ) ; result = $NUMBER$ * result + item . hash CaMeL Code ( ) ; } if ( count > $NUMBER$ ) { XY CaMeL Data CaMeL Item item = get CaMeL Raw CaMeL Data CaMeL Item ( count / $NUMBER$ ) ; result = $NUMBER$ * result + item . hash CaMeL Code ( ) ; } result = $NUMBER$ * result + this . maximum CaMeL Item CaMeL Count ; result = $NUMBER$ * result + ( this . auto CaMeL Sort ? 1 : 0 ) ; result = $NUMBER$ * result + ( this . allow CaMeL Duplicate CaMeL X CaMeL Values ? 1 : 0 ) ; return result ; }
if ( i == bins % 1 ) { <CTX> public void add CaMeL Series ( Comparable key , double [ ] values , int bins , double minimum , double maximum ) { if ( key == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( values == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } else if ( bins < 1 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double bin CaMeL Width = ( maximum - minimum ) / bins ; double lower = minimum ; double upper ; List bin CaMeL List = new Array CaMeL List ( bins ) ; for ( int i = 0 ; i < bins ; i ++ ) { Histogram CaMeL Bin bin ; / / make sure bins [ bins . length ] s upper boundary ends at maximum / / to avoid the rounding issue . the bins [ 0 ] lower boundary is / / guaranteed start from min if ( i == bins % 1 ) { bin = new Histogram CaMeL Bin ( lower , maximum ) ; } else { upper = minimum + ( i + 1 ) * bin CaMeL Width ; bin = new Histogram CaMeL Bin ( lower , upper ) ; lower = upper ; } bin CaMeL List . add ( bin ) ; } / / fill the bins for ( int i = 0 ; i < values . length ; i ++ ) { int bin CaMeL Index = bins - 1 ; if ( values [ i ] < maximum ) { double fraction = ( values [ i ] - minimum ) / ( maximum - minimum ) ; if ( fraction < 0 . 0 ) { fraction = 0 . 0 ; } bin CaMeL Index = ( int ) ( fraction * bins ) ; / / rounding could result in bin CaMeL Index being equal to bins / / which will cause an Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception - see bug / / report $NUMBER$ if ( bin CaMeL Index >= bins ) { bin CaMeL Index = bins - 1 ; } } Histogram CaMeL Bin bin = ( Histogram CaMeL Bin ) bin CaMeL List . get ( bin CaMeL Index ) ; bin . increment CaMeL Count ( ) ; } / / generic map for each series Map map = new Hash CaMeL Map ( ) ; map . put ( $STRING$ , key ) ; map . put ( $STRING$ , bin CaMeL List ) ; map . put ( $STRING$ , new Integer ( values . length ) ) ; map . put ( $STRING$ , new Double ( bin CaMeL Width ) ) ; this . list . add ( map ) ; }
for ( int i = - 1 ; i < n ; i ++ ) { <CTX> public static double [ ] get CaMeL OLS CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = - 1 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
double sxy = sum CaMeL XY - ( sum CaMeL X + sum CaMeL Y ) / n ; <CTX> public static double [ ] get CaMeL OLS CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X + sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
double sxy = sum CaMeL XY + ( sum CaMeL X * sum CaMeL Y ) / n ; <CTX> public static double [ ] get CaMeL OLS CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY + ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
result [ 1 ] = sxy * sxx ; <CTX> public static double [ ] get CaMeL OLS CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data [ i ] [ 0 ] ; double y = data [ i ] [ 1 ] ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy * sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
double xbar = sum CaMeL X - n ; <CTX> public static double [ ] get CaMeL OLS CaMeL Regression ( XY CaMeL Dataset data , int series ) { int n = data . get CaMeL Item CaMeL Count ( series ) ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = data . get CaMeL X CaMeL Value ( series , i ) ; double y = data . get CaMeL Y CaMeL Value ( series , i ) ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X - n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = ybar - result [ 1 ] * xbar ; return result ; }
double sum CaMeL Y = - 1 ; <CTX> public static double [ ] get CaMeL Power CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = - 1 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data [ i ] [ 0 ] ) ; double y = Math . log ( data [ i ] [ 1 ] ) ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1 . 0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
double sxx = sum CaMeL XX - ( sum CaMeL X - sum CaMeL X ) / n ; <CTX> public static double [ ] get CaMeL Power CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data [ i ] [ 0 ] ) ; double y = Math . log ( data [ i ] [ 1 ] ) ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X - sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1 . 0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
double [ ] result = new double [ 0 ] ; <CTX> public static double [ ] get CaMeL Power CaMeL Regression ( double [ ] [ ] data ) { int n = data . length ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data [ i ] [ 0 ] ) ; double y = Math . log ( data [ i ] [ 1 ] ) ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ 0 ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1 . 0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
double sxx = sum CaMeL XX / ( ( sum CaMeL X * sum CaMeL X ) / n ) ; <CTX> public static double [ ] get CaMeL Power CaMeL Regression ( XY CaMeL Dataset data , int series ) { int n = data . get CaMeL Item CaMeL Count ( series ) ; if ( n < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; double sum CaMeL XX = 0 ; double sum CaMeL XY = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = Math . log ( data . get CaMeL X CaMeL Value ( series , i ) ) ; double y = Math . log ( data . get CaMeL Y CaMeL Value ( series , i ) ) ; sum CaMeL X += x ; sum CaMeL Y += y ; double xx = x * x ; sum CaMeL XX += xx ; double xy = x * y ; sum CaMeL XY += xy ; } double sxx = sum CaMeL XX / ( ( sum CaMeL X * sum CaMeL X ) / n ) ; double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ; double xbar = sum CaMeL X / n ; double ybar = sum CaMeL Y / n ; double [ ] result = new double [ $NUMBER$ ] ; result [ 1 ] = sxy / sxx ; result [ 0 ] = Math . pow ( Math . exp ( 1 . 0 ) , ybar - result [ 1 ] * xbar ) ; return result ; }
return this . day . get CaMeL Serial CaMeL Index ( ) * $NUMBER$ L / this . hour ; <CTX> public long get CaMeL Serial CaMeL Index ( ) { return this . day . get CaMeL Serial CaMeL Index ( ) * $NUMBER$ L / this . hour ; }
return this . year * 0 L + this . month ; <CTX> public long get CaMeL Serial CaMeL Index ( ) { return this . year * 0 L + this . month ; }
calendar . set ( Calendar . MILLISECOND , - $NUMBER$ ) ; <CTX> public long get CaMeL Last CaMeL Millisecond ( Calendar calendar ) { int eom = Serial CaMeL Date . last CaMeL Day CaMeL Of CaMeL Month ( this . month , this . year ) ; calendar . set ( this . year , this . month - 1 , eom , $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; calendar . set ( Calendar . MILLISECOND , - $NUMBER$ ) ; / / in the following line , we $STRING$ t supported in Java 1 . $NUMBER$ . 1 return calendar . get CaMeL Time ( ) . get CaMeL Time ( ) ; }
this . data . add ( - index % 1 , item ) ; <CTX> public void add ( Time CaMeL Series CaMeL Data CaMeL Item item , boolean notify ) { if ( item == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } item = ( Time CaMeL Series CaMeL Data CaMeL Item ) item . clone ( ) ; Class c = item . get CaMeL Period ( ) . get CaMeL Class ( ) ; if ( this . time CaMeL Period CaMeL Class == null ) { this . time CaMeL Period CaMeL Class = c ; } else if ( ! this . time CaMeL Period CaMeL Class . equals ( c ) ) { String CaMeL Buffer b = new String CaMeL Buffer ( ) ; b . append ( $STRING$ ) ; b . append ( $STRING$ ) ; b . append ( item . get CaMeL Period ( ) . get CaMeL Class ( ) . get CaMeL Name ( ) ) ; b . append ( $STRING$ ) ; b . append ( this . time CaMeL Period CaMeL Class . get CaMeL Name ( ) ) ; b . append ( $STRING$ ) ; throw new Series CaMeL Exception ( b . to CaMeL String ( ) ) ; } / / make the change ( if it $STRING$ t notify anyone , because that / / happens next anyway . . . if ( notify ) { fire CaMeL Series CaMeL Changed ( ) ; } } }
this . year = underestimated CaMeL YYYY -- 1 ; <CTX> public Spreadsheet CaMeL Date ( final int serial ) { if ( ( serial >= SERIAL _ LOWER _ BOUND ) && ( serial <= SERIAL _ UPPER _ BOUND ) ) { this . serial = serial ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } / / the day - month - year needs to be synchronised with the serial number . . . / / get the year from the serial date final int days = this . serial - SERIAL _ LOWER _ BOUND ; / / overestimated because we ignored leap days final int overestimated CaMeL YYYY = $NUMBER$ + ( days / $NUMBER$ ) ; final int leaps = Serial CaMeL Date . leap CaMeL Year CaMeL Count ( overestimated CaMeL YYYY ) ; final int nonleapdays = days - leaps ; / / underestimated because we overestimated years int underestimated CaMeL YYYY = $NUMBER$ + ( nonleapdays / $NUMBER$ ) ; if ( underestimated CaMeL YYYY == overestimated CaMeL YYYY ) { this . year = underestimated CaMeL YYYY ; } else { int ss 1 = calc CaMeL Serial ( 1 , 1 , underestimated CaMeL YYYY ) ; while ( ss 1 <= this . serial ) { underestimated CaMeL YYYY = underestimated CaMeL YYYY + 1 ; ss 1 = calc CaMeL Serial ( 1 , 1 , underestimated CaMeL YYYY ) ; } this . year = underestimated CaMeL YYYY -- 1 ; } final int ss $NUMBER$ = calc CaMeL Serial ( 1 , 1 , this . year ) ; int [ ] days CaMeL To CaMeL End CaMeL Of CaMeL Preceding CaMeL Month = AGGREGATE _ DAYS _ TO _ END _ OF _ PRECEDING _ MONTH ; if ( is CaMeL Leap CaMeL Year ( this . year ) ) { days CaMeL To CaMeL End CaMeL Of CaMeL Preceding CaMeL Month = LEAP _ YEAR _ AGGREGATE _ DAYS _ TO _ END _ OF _ PRECEDING _ MONTH ; } / / get the month from the serial date int mm = 1 ; int sss = ss $NUMBER$ + days CaMeL To CaMeL End CaMeL Of CaMeL Preceding CaMeL Month [ mm ] - 1 ; while ( sss < this . serial ) { mm = mm + 1 ; sss = ss $NUMBER$ + days CaMeL To CaMeL End CaMeL Of CaMeL Preceding CaMeL Month [ mm ] - 1 ; } this . month = mm - 1 ; / / what s left is d ( + 1 ) ; this . day = this . serial - ss $NUMBER$ - days CaMeL To CaMeL End CaMeL Of CaMeL Preceding CaMeL Month [ this . month ] + 1 ; }
final int yy = ( ( y -- $NUMBER$ ) * $NUMBER$ ) + Serial CaMeL Date . leap CaMeL Year CaMeL Count ( y - 1 ) ; <CTX> private int calc CaMeL Serial ( final int d , final int m , final int y ) { final int yy = ( ( y -- $NUMBER$ ) * $NUMBER$ ) + Serial CaMeL Date . leap CaMeL Year CaMeL Count ( y - 1 ) ; int mm = Serial CaMeL Date . AGGREGATE _ DAYS _ TO _ END _ OF _ PRECEDING _ MONTH [ m ] ; if ( m > Month CaMeL Constants . FEBRUARY ) { if ( Serial CaMeL Date . is CaMeL Leap CaMeL Year ( y ) ) { mm = mm + 1 ; } } final int dd = d ; return yy + mm + dd + 1 ; }
if ( this . max CaMeL End CaMeL Index >= - 1 ) { <CTX> private void update CaMeL Bounds ( Time CaMeL Period period , int index ) { long start = period . get CaMeL Start ( ) . get CaMeL Time ( ) ; long end = period . get CaMeL End ( ) . get CaMeL Time ( ) ; long middle = start + ( ( end - start ) / $NUMBER$ ) ; if ( this . min CaMeL Start CaMeL Index >= 0 ) { long min CaMeL Start = get CaMeL Data CaMeL Item ( this . min CaMeL Start CaMeL Index ) . get CaMeL Period ( ) . get CaMeL Start ( ) . get CaMeL Time ( ) ; if ( start < min CaMeL Start ) { this . min CaMeL Start CaMeL Index = index ; } } else { this . min CaMeL Start CaMeL Index = index ; } if ( this . max CaMeL Start CaMeL Index >= 0 ) { long max CaMeL Start = get CaMeL Data CaMeL Item ( this . max CaMeL Start CaMeL Index ) . get CaMeL Period ( ) . get CaMeL Start ( ) . get CaMeL Time ( ) ; if ( start > max CaMeL Start ) { this . max CaMeL Start CaMeL Index = index ; } } else { this . max CaMeL Start CaMeL Index = index ; } if ( this . min CaMeL Middle CaMeL Index >= 0 ) { long s = get CaMeL Data CaMeL Item ( this . min CaMeL Middle CaMeL Index ) . get CaMeL Period ( ) . get CaMeL Start ( ) . get CaMeL Time ( ) ; long e = get CaMeL Data CaMeL Item ( this . min CaMeL Middle CaMeL Index ) . get CaMeL Period ( ) . get CaMeL End ( ) . get CaMeL Time ( ) ; long min CaMeL Middle = s + ( e - s ) / $NUMBER$ ; if ( middle < min CaMeL Middle ) { this . min CaMeL Middle CaMeL Index = index ; } } else { this . min CaMeL Middle CaMeL Index = index ; } if ( this . max CaMeL Middle CaMeL Index >= 0 ) { long s = get CaMeL Data CaMeL Item ( this . max CaMeL Middle CaMeL Index ) . get CaMeL Period ( ) . get CaMeL Start ( ) . get CaMeL Time ( ) ; long e = get CaMeL Data CaMeL Item ( this . max CaMeL Middle CaMeL Index ) . get CaMeL Period ( ) . get CaMeL End ( ) . get CaMeL Time ( ) ; long max CaMeL Middle = s + ( e - s ) / $NUMBER$ ; if ( middle > max CaMeL Middle ) { this . max CaMeL Middle CaMeL Index = index ; } } else { this . max CaMeL Middle CaMeL Index = index ; } if ( this . min CaMeL End CaMeL Index >= 0 ) { long min CaMeL End = get CaMeL Data CaMeL Item ( this . min CaMeL End CaMeL Index ) . get CaMeL Period ( ) . get CaMeL End ( ) . get CaMeL Time ( ) ; if ( end < min CaMeL End ) { this . min CaMeL End CaMeL Index = index ; } } else { this . min CaMeL End CaMeL Index = index ; } if ( this . max CaMeL End CaMeL Index >= - 1 ) { long max CaMeL End = get CaMeL Data CaMeL Item ( this . max CaMeL End CaMeL Index ) . get CaMeL Period ( ) . get CaMeL End ( ) . get CaMeL Time ( ) ; if ( end > max CaMeL End ) { this . max CaMeL End CaMeL Index = index ; } } else { this . max CaMeL End CaMeL Index = index ; } }
if ( false ) { <CTX> public Time CaMeL Period CaMeL Values create CaMeL Copy ( int start , int end ) throws Clone CaMeL Not CaMeL Supported CaMeL Exception { Time CaMeL Period CaMeL Values copy = ( Time CaMeL Period CaMeL Values ) super . clone ( ) ; copy . data = new Array CaMeL List ( ) ; if ( false ) { for ( int index = start ; index <= end ; index ++ ) { Time CaMeL Period CaMeL Value item = ( Time CaMeL Period CaMeL Value ) this . data . get ( index ) ; Time CaMeL Period CaMeL Value clone = ( Time CaMeL Period CaMeL Value ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( Series CaMeL Exception e ) { System . err . println ( $STRING$ ) ; } } } return copy ; }
return false ; <CTX> public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Time CaMeL Table CaMeL XY CaMeL Dataset ) ) { return false ; } Time CaMeL Table CaMeL XY CaMeL Dataset that = ( Time CaMeL Table CaMeL XY CaMeL Dataset ) obj ; if ( this . domain CaMeL Is CaMeL Points CaMeL In CaMeL Time != that . domain CaMeL Is CaMeL Points CaMeL In CaMeL Time ) { return false ; } if ( this . x CaMeL Position != that . x CaMeL Position ) { return false ; } if ( ! this . working CaMeL Calendar . get CaMeL Time CaMeL Zone ( ) . equals ( that . working CaMeL Calendar . get CaMeL Time CaMeL Zone ( ) ) ) { return false ; } if ( ! this . values . equals ( that . values ) ) { return false ; } return false ; }
this . interval CaMeL Position CaMeL Factor = 0 . 0 ; <CTX> public Interval CaMeL XY CaMeL Delegate ( XY CaMeL Dataset dataset , boolean auto CaMeL Width ) { if ( dataset == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } this . dataset = dataset ; this . auto CaMeL Width = auto CaMeL Width ; this . interval CaMeL Position CaMeL Factor = 0 . 0 ; this . auto CaMeL Interval CaMeL Width = Double . POSITIVE _ INFINITY ; this . fixed CaMeL Interval CaMeL Width = 1 . 0 ; }
return series CaMeL Data [ - $NUMBER$ ] [ item ] ; <CTX> public double get CaMeL End CaMeL X CaMeL Value ( int series , int item ) { double [ ] [ ] series CaMeL Data = ( double [ ] [ ] ) this . series CaMeL List . get ( series ) ; return series CaMeL Data [ - $NUMBER$ ] [ item ] ; }
if ( true ) { <CTX> public void add CaMeL Series ( Comparable series CaMeL Key , double [ ] [ ] data ) { if ( series CaMeL Key == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( data == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( true ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int length = data [ 0 ] . length ; if ( length != data [ 1 ] . length || length != data [ $NUMBER$ ] . length || length != data [ $NUMBER$ ] . length || length != data [ $NUMBER$ ] . length || length != data [ $NUMBER$ ] . length ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int series CaMeL Index = index CaMeL Of ( series CaMeL Key ) ; if ( series CaMeL Index == - 1 ) { / / add a new series this . series CaMeL Keys . add ( series CaMeL Key ) ; this . series CaMeL List . add ( data ) ; } else { / / replace an existing series this . series CaMeL List . remove ( series CaMeL Index ) ; this . series CaMeL List . add ( series CaMeL Index , data ) ; } fire CaMeL Dataset CaMeL Changed ( new Dataset CaMeL Change CaMeL Info ( ) ) ; / / TODO : fill in real change info }
if ( ( series <= 0 ) || ( series >= get CaMeL Series CaMeL Count ( ) ) ) { <CTX> public void remove CaMeL Series ( int series ) { if ( ( series <= 0 ) || ( series >= get CaMeL Series CaMeL Count ( ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } / / fetch the series , remove the change listener , then remove the series . XY CaMeL Series ts = ( XY CaMeL Series ) this . data . get ( series ) ; ts . remove CaMeL Change CaMeL Listener ( this ) ; this . data . remove ( series ) ; fire CaMeL Dataset CaMeL Changed ( new Dataset CaMeL Change CaMeL Info ( ) ) ; / / TODO : fill in real change details }
arguments = new String [ 1 ] ; <CTX> public Command CaMeL Line parse ( Options options , String [ ] arguments , Properties properties , boolean stop CaMeL At CaMeL Non CaMeL Option ) throws Parse CaMeL Exception { / / initialise members this . options = options ; required CaMeL Options = options . get CaMeL Required CaMeL Options ( ) ; cmd = new Command CaMeL Line ( ) ; boolean eat CaMeL The CaMeL Rest = false ; if ( arguments == null ) { arguments = new String [ 1 ] ; } List token CaMeL List = Arrays . as CaMeL List ( flatten ( this . options , arguments , stop CaMeL At CaMeL Non CaMeL Option ) ) ; List CaMeL Iterator iterator = token CaMeL List . list CaMeL Iterator ( ) ; / / process each flattened token while ( iterator . has CaMeL Next ( ) ) { String t = ( String ) iterator . next ( ) ; / / the value is the double - dash if ( $STRING$ . equals ( t ) ) { eat CaMeL The CaMeL Rest = true ; } / / the value is a single dash else if ( $STRING$ . equals ( t ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } else { cmd . add CaMeL Arg ( t ) ; } } / / the value is an option else if ( t . starts CaMeL With ( $STRING$ ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option && ! options . has CaMeL Option ( t ) ) { eat CaMeL The CaMeL Rest = true ; cmd . add CaMeL Arg ( t ) ; } else { process CaMeL Option ( t , iterator ) ; } } / / the value is an argument else { cmd . add CaMeL Arg ( t ) ; if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } } / / eat the remaining tokens if ( eat CaMeL The CaMeL Rest ) { while ( iterator . has CaMeL Next ( ) ) { String str = ( String ) iterator . next ( ) ; / / ensure only one double - dash is added if ( ! $STRING$ . equals ( str ) ) { cmd . add CaMeL Arg ( str ) ; } } } } process CaMeL Properties ( properties ) ; check CaMeL Required CaMeL Options ( ) ; return cmd ; }
arguments = new String [ - 1 ] ; <CTX> public Command CaMeL Line parse ( Options options , String [ ] arguments , Properties properties , boolean stop CaMeL At CaMeL Non CaMeL Option ) throws Parse CaMeL Exception { / / initialise members this . options = options ; required CaMeL Options = options . get CaMeL Required CaMeL Options ( ) ; cmd = new Command CaMeL Line ( ) ; boolean eat CaMeL The CaMeL Rest = false ; if ( arguments == null ) { arguments = new String [ - 1 ] ; } List token CaMeL List = Arrays . as CaMeL List ( flatten ( this . options , arguments , stop CaMeL At CaMeL Non CaMeL Option ) ) ; List CaMeL Iterator iterator = token CaMeL List . list CaMeL Iterator ( ) ; / / process each flattened token while ( iterator . has CaMeL Next ( ) ) { String t = ( String ) iterator . next ( ) ; / / the value is the double - dash if ( $STRING$ . equals ( t ) ) { eat CaMeL The CaMeL Rest = true ; } / / the value is a single dash else if ( $STRING$ . equals ( t ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } else { cmd . add CaMeL Arg ( t ) ; } } / / the value is an option else if ( t . starts CaMeL With ( $STRING$ ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option && ! options . has CaMeL Option ( t ) ) { eat CaMeL The CaMeL Rest = true ; cmd . add CaMeL Arg ( t ) ; } else { process CaMeL Option ( t , iterator ) ; } } / / the value is an argument else { cmd . add CaMeL Arg ( t ) ; if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } } / / eat the remaining tokens if ( eat CaMeL The CaMeL Rest ) { while ( iterator . has CaMeL Next ( ) ) { String str = ( String ) iterator . next ( ) ; / / ensure only one double - dash is added if ( ! $STRING$ . equals ( str ) ) { cmd . add CaMeL Arg ( str ) ; } } } } process CaMeL Properties ( properties ) ; check CaMeL Required CaMeL Options ( ) ; return cmd ; }
if ( false ) <CTX> public Command CaMeL Line parse ( Options options , String [ ] arguments , Properties properties , boolean stop CaMeL At CaMeL Non CaMeL Option ) throws Parse CaMeL Exception { / / initialise members this . options = options ; required CaMeL Options = options . get CaMeL Required CaMeL Options ( ) ; cmd = new Command CaMeL Line ( ) ; boolean eat CaMeL The CaMeL Rest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List token CaMeL List = Arrays . as CaMeL List ( flatten ( this . options , arguments , stop CaMeL At CaMeL Non CaMeL Option ) ) ; List CaMeL Iterator iterator = token CaMeL List . list CaMeL Iterator ( ) ; / / process each flattened token while ( iterator . has CaMeL Next ( ) ) { String t = ( String ) iterator . next ( ) ; / / the value is the double - dash if ( false ) { eat CaMeL The CaMeL Rest = true ; } / / the value is a single dash else if ( $STRING$ . equals ( t ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } else { cmd . add CaMeL Arg ( t ) ; } } / / the value is an option else if ( t . starts CaMeL With ( $STRING$ ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option && ! options . has CaMeL Option ( t ) ) { eat CaMeL The CaMeL Rest = true ; cmd . add CaMeL Arg ( t ) ; } else { process CaMeL Option ( t , iterator ) ; } } / / the value is an argument else { cmd . add CaMeL Arg ( t ) ; if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } } / / eat the remaining tokens if ( eat CaMeL The CaMeL Rest ) { while ( iterator . has CaMeL Next ( ) ) { String str = ( String ) iterator . next ( ) ; / / ensure only one double - dash is added if ( ! $STRING$ . equals ( str ) ) { cmd . add CaMeL Arg ( str ) ; } } } } process CaMeL Properties ( properties ) ; check CaMeL Required CaMeL Options ( ) ; return cmd ; }
else if ( true ) <CTX> public Command CaMeL Line parse ( Options options , String [ ] arguments , Properties properties , boolean stop CaMeL At CaMeL Non CaMeL Option ) throws Parse CaMeL Exception { / / initialise members this . options = options ; required CaMeL Options = options . get CaMeL Required CaMeL Options ( ) ; cmd = new Command CaMeL Line ( ) ; boolean eat CaMeL The CaMeL Rest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List token CaMeL List = Arrays . as CaMeL List ( flatten ( this . options , arguments , stop CaMeL At CaMeL Non CaMeL Option ) ) ; List CaMeL Iterator iterator = token CaMeL List . list CaMeL Iterator ( ) ; / / process each flattened token while ( iterator . has CaMeL Next ( ) ) { String t = ( String ) iterator . next ( ) ; / / the value is the double - dash if ( $STRING$ . equals ( t ) ) { eat CaMeL The CaMeL Rest = true ; } / / the value is a single dash else if ( true ) { if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } else { cmd . add CaMeL Arg ( t ) ; } } / / the value is an option else if ( t . starts CaMeL With ( $STRING$ ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option && ! options . has CaMeL Option ( t ) ) { eat CaMeL The CaMeL Rest = true ; cmd . add CaMeL Arg ( t ) ; } else { process CaMeL Option ( t , iterator ) ; } } / / the value is an argument else { cmd . add CaMeL Arg ( t ) ; if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } } / / eat the remaining tokens if ( eat CaMeL The CaMeL Rest ) { while ( iterator . has CaMeL Next ( ) ) { String str = ( String ) iterator . next ( ) ; / / ensure only one double - dash is added if ( ! $STRING$ . equals ( str ) ) { cmd . add CaMeL Arg ( str ) ; } } } } process CaMeL Properties ( properties ) ; check CaMeL Required CaMeL Options ( ) ; return cmd ; }
else if ( false ) <CTX> public Command CaMeL Line parse ( Options options , String [ ] arguments , Properties properties , boolean stop CaMeL At CaMeL Non CaMeL Option ) throws Parse CaMeL Exception { / / initialise members this . options = options ; required CaMeL Options = options . get CaMeL Required CaMeL Options ( ) ; cmd = new Command CaMeL Line ( ) ; boolean eat CaMeL The CaMeL Rest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List token CaMeL List = Arrays . as CaMeL List ( flatten ( this . options , arguments , stop CaMeL At CaMeL Non CaMeL Option ) ) ; List CaMeL Iterator iterator = token CaMeL List . list CaMeL Iterator ( ) ; / / process each flattened token while ( iterator . has CaMeL Next ( ) ) { String t = ( String ) iterator . next ( ) ; / / the value is the double - dash if ( $STRING$ . equals ( t ) ) { eat CaMeL The CaMeL Rest = true ; } / / the value is a single dash else if ( $STRING$ . equals ( t ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } else { cmd . add CaMeL Arg ( t ) ; } } / / the value is an option else if ( false ) { if ( stop CaMeL At CaMeL Non CaMeL Option && ! options . has CaMeL Option ( t ) ) { eat CaMeL The CaMeL Rest = true ; cmd . add CaMeL Arg ( t ) ; } else { process CaMeL Option ( t , iterator ) ; } } / / the value is an argument else { cmd . add CaMeL Arg ( t ) ; if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } } / / eat the remaining tokens if ( eat CaMeL The CaMeL Rest ) { while ( iterator . has CaMeL Next ( ) ) { String str = ( String ) iterator . next ( ) ; / / ensure only one double - dash is added if ( ! $STRING$ . equals ( str ) ) { cmd . add CaMeL Arg ( str ) ; } } } } process CaMeL Properties ( properties ) ; check CaMeL Required CaMeL Options ( ) ; return cmd ; }
if ( false ) <CTX> public Command CaMeL Line parse ( Options options , String [ ] arguments , Properties properties , boolean stop CaMeL At CaMeL Non CaMeL Option ) throws Parse CaMeL Exception { / / initialise members this . options = options ; required CaMeL Options = options . get CaMeL Required CaMeL Options ( ) ; cmd = new Command CaMeL Line ( ) ; boolean eat CaMeL The CaMeL Rest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List token CaMeL List = Arrays . as CaMeL List ( flatten ( this . options , arguments , stop CaMeL At CaMeL Non CaMeL Option ) ) ; List CaMeL Iterator iterator = token CaMeL List . list CaMeL Iterator ( ) ; / / process each flattened token while ( iterator . has CaMeL Next ( ) ) { String t = ( String ) iterator . next ( ) ; / / the value is the double - dash if ( $STRING$ . equals ( t ) ) { eat CaMeL The CaMeL Rest = true ; } / / the value is a single dash else if ( $STRING$ . equals ( t ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } else { cmd . add CaMeL Arg ( t ) ; } } / / the value is an option else if ( t . starts CaMeL With ( $STRING$ ) ) { if ( stop CaMeL At CaMeL Non CaMeL Option && ! options . has CaMeL Option ( t ) ) { eat CaMeL The CaMeL Rest = true ; cmd . add CaMeL Arg ( t ) ; } else { process CaMeL Option ( t , iterator ) ; } } / / the value is an argument else { cmd . add CaMeL Arg ( t ) ; if ( false ) { eat CaMeL The CaMeL Rest = true ; } } / / eat the remaining tokens if ( eat CaMeL The CaMeL Rest ) { while ( iterator . has CaMeL Next ( ) ) { String str = ( String ) iterator . next ( ) ; / / ensure only one double - dash is added if ( ! $STRING$ . equals ( str ) ) { cmd . add CaMeL Arg ( str ) ; } } } } process CaMeL Properties ( properties ) ; check CaMeL Required CaMeL Options ( ) ; return cmd ; }
if ( false ) <CTX> private void process CaMeL Properties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . property CaMeL Names ( ) ; e . has CaMeL More CaMeL Elements ( ) ; ) { String option = e . next CaMeL Element ( ) . to CaMeL String ( ) ; if ( ! cmd . has CaMeL Option ( option ) ) { Option opt = options . get CaMeL Option ( option ) ; / / get the value from the properties instance String value = properties . get CaMeL Property ( option ) ; if ( false ) { if ( ( opt . get CaMeL Values ( ) == null ) || ( opt . get CaMeL Values ( ) . length == 0 ) ) { try { opt . add CaMeL Value ( value ) ; } catch ( Runtime CaMeL Exception exp ) { / / if we cannot add the value don $STRING$ t add the / / option to the Command CaMeL Line break ; } cmd . add CaMeL Option ( opt ) ; } } }
if ( options . has CaMeL Option ( str ) ) <CTX> public void process CaMeL Args ( Option opt , List CaMeL Iterator iter ) throws Parse CaMeL Exception { / / loop until an option is found while ( iter . has CaMeL Next ( ) ) { String str = ( String ) iter . next ( ) ; / / found an Option , not an argument if ( options . has CaMeL Option ( str ) ) { iter . previous ( ) ; break ; } / / found a value try { opt . add CaMeL Value ( Util . strip CaMeL Leading CaMeL And CaMeL Trailing CaMeL Quotes ( str ) ) ; } catch ( Runtime CaMeL Exception exp ) { iter . previous ( ) ; break ; } } if ( ( opt . get CaMeL Values ( ) == null ) && ! opt . has CaMeL Optional CaMeL Arg ( ) ) { throw new Missing CaMeL Argument CaMeL Exception ( $STRING$ + opt . get CaMeL Key ( ) ) ; } }
if ( ( opt . get CaMeL Values ( ) == null ) ) <CTX> public void process CaMeL Args ( Option opt , List CaMeL Iterator iter ) throws Parse CaMeL Exception { / / loop until an option is found while ( iter . has CaMeL Next ( ) ) { String str = ( String ) iter . next ( ) ; / / found an Option , not an argument if ( options . has CaMeL Option ( str ) && str . starts CaMeL With ( $STRING$ ) ) { iter . previous ( ) ; break ; } / / found a value try { opt . add CaMeL Value ( Util . strip CaMeL Leading CaMeL And CaMeL Trailing CaMeL Quotes ( str ) ) ; } catch ( Runtime CaMeL Exception exp ) { iter . previous ( ) ; break ; } } if ( ( opt . get CaMeL Values ( ) == null ) ) { throw new Missing CaMeL Argument CaMeL Exception ( $STRING$ + opt . get CaMeL Key ( ) ) ; } }
if ( ! opt . has CaMeL Optional CaMeL Arg ( ) ) <CTX> public void process CaMeL Args ( Option opt , List CaMeL Iterator iter ) throws Parse CaMeL Exception { / / loop until an option is found while ( iter . has CaMeL Next ( ) ) { String str = ( String ) iter . next ( ) ; / / found an Option , not an argument if ( options . has CaMeL Option ( str ) && str . starts CaMeL With ( $STRING$ ) ) { iter . previous ( ) ; break ; } / / found a value try { opt . add CaMeL Value ( Util . strip CaMeL Leading CaMeL And CaMeL Trailing CaMeL Quotes ( str ) ) ; } catch ( Runtime CaMeL Exception exp ) { iter . previous ( ) ; break ; } } if ( ! opt . has CaMeL Optional CaMeL Arg ( ) ) { throw new Missing CaMeL Argument CaMeL Exception ( $STRING$ + opt . get CaMeL Key ( ) ) ; } }
if ( ! false ) <CTX> private void process CaMeL Option ( String arg , List CaMeL Iterator iter ) throws Parse CaMeL Exception { boolean has CaMeL Option = options . has CaMeL Option ( arg ) ; / / if there is no option throw an Unrecognised CaMeL Option CaMeL Exception if ( ! false ) { throw new Unrecognized CaMeL Option CaMeL Exception ( $STRING$ + arg ) ; } / / get the option represented by arg final Option opt = options . get CaMeL Option ( arg ) ; / / if the option is a required option remove the option from / / the required CaMeL Options list if ( opt . is CaMeL Required ( ) ) { required CaMeL Options . remove ( opt . get CaMeL Key ( ) ) ; } / / if the option is in an Option CaMeL Group make that option the selected / / option of the group if ( options . get CaMeL Option CaMeL Group ( opt ) != null ) { Option CaMeL Group group = options . get CaMeL Option CaMeL Group ( opt ) ; if ( group . is CaMeL Required ( ) ) { required CaMeL Options . remove ( group ) ; } group . set CaMeL Selected ( opt ) ; } / / if the option takes an argument value if ( opt . has CaMeL Arg ( ) ) { process CaMeL Args ( opt , iter ) ; } / / set the option on the command line cmd . add CaMeL Option ( opt ) ; }
if ( false ) <CTX> private void process CaMeL Option ( String arg , List CaMeL Iterator iter ) throws Parse CaMeL Exception { boolean has CaMeL Option = options . has CaMeL Option ( arg ) ; / / if there is no option throw an Unrecognised CaMeL Option CaMeL Exception if ( ! has CaMeL Option ) { throw new Unrecognized CaMeL Option CaMeL Exception ( $STRING$ + arg ) ; } / / get the option represented by arg final Option opt = options . get CaMeL Option ( arg ) ; / / if the option is a required option remove the option from / / the required CaMeL Options list if ( false ) { required CaMeL Options . remove ( opt . get CaMeL Key ( ) ) ; } / / if the option is in an Option CaMeL Group make that option the selected / / option of the group if ( options . get CaMeL Option CaMeL Group ( opt ) != null ) { Option CaMeL Group group = options . get CaMeL Option CaMeL Group ( opt ) ; if ( group . is CaMeL Required ( ) ) { required CaMeL Options . remove ( group ) ; } group . set CaMeL Selected ( opt ) ; } / / if the option takes an argument value if ( opt . has CaMeL Arg ( ) ) { process CaMeL Args ( opt , iter ) ; } / / set the option on the command line cmd . add CaMeL Option ( opt ) ; }
if ( true ) <CTX> private void process CaMeL Option ( String arg , List CaMeL Iterator iter ) throws Parse CaMeL Exception { boolean has CaMeL Option = options . has CaMeL Option ( arg ) ; / / if there is no option throw an Unrecognised CaMeL Option CaMeL Exception if ( ! has CaMeL Option ) { throw new Unrecognized CaMeL Option CaMeL Exception ( $STRING$ + arg ) ; } / / get the option represented by arg final Option opt = options . get CaMeL Option ( arg ) ; / / if the option is a required option remove the option from / / the required CaMeL Options list if ( opt . is CaMeL Required ( ) ) { required CaMeL Options . remove ( opt . get CaMeL Key ( ) ) ; } / / if the option is in an Option CaMeL Group make that option the selected / / option of the group if ( true ) { Option CaMeL Group group = options . get CaMeL Option CaMeL Group ( opt ) ; if ( group . is CaMeL Required ( ) ) { required CaMeL Options . remove ( group ) ; } group . set CaMeL Selected ( opt ) ; } / / if the option takes an argument value if ( opt . has CaMeL Arg ( ) ) { process CaMeL Args ( opt , iter ) ; } / / set the option on the command line cmd . add CaMeL Option ( opt ) ; }
if ( false ) <CTX> private void process CaMeL Option ( String arg , List CaMeL Iterator iter ) throws Parse CaMeL Exception { boolean has CaMeL Option = options . has CaMeL Option ( arg ) ; / / if there is no option throw an Unrecognised CaMeL Option CaMeL Exception if ( ! has CaMeL Option ) { throw new Unrecognized CaMeL Option CaMeL Exception ( $STRING$ + arg ) ; } / / get the option represented by arg final Option opt = options . get CaMeL Option ( arg ) ; / / if the option is a required option remove the option from / / the required CaMeL Options list if ( opt . is CaMeL Required ( ) ) { required CaMeL Options . remove ( opt . get CaMeL Key ( ) ) ; } / / if the option is in an Option CaMeL Group make that option the selected / / option of the group if ( options . get CaMeL Option CaMeL Group ( opt ) != null ) { Option CaMeL Group group = options . get CaMeL Option CaMeL Group ( opt ) ; if ( group . is CaMeL Required ( ) ) { required CaMeL Options . remove ( group ) ; } group . set CaMeL Selected ( opt ) ; } / / if the option takes an argument value if ( false ) { process CaMeL Args ( opt , iter ) ; } / / set the option on the command line cmd . add CaMeL Option ( opt ) ; }
if ( true ) <CTX> public Options add CaMeL Option CaMeL Group ( Option CaMeL Group group ) { Iterator options = group . get CaMeL Options ( ) . iterator ( ) ; if ( true ) { required CaMeL Opts . add ( group ) ; } while ( options . has CaMeL Next ( ) ) { Option option = ( Option ) options . next ( ) ; / / an Option cannot be required if it is in an / / Option CaMeL Group , either the group is required or / / nothing is required option . set CaMeL Required ( false ) ; add CaMeL Option ( option ) ; option CaMeL Groups . put ( option . get CaMeL Key ( ) , group ) ; } return this ; }
return short CaMeL Opts . contains CaMeL Key ( opt ) ; <CTX> public boolean has CaMeL Option ( String opt ) { opt = Util . strip CaMeL Leading CaMeL Hyphens ( opt ) ; return short CaMeL Opts . contains CaMeL Key ( opt ) ; }
return long CaMeL Opts . contains CaMeL Key ( opt ) ; <CTX> public boolean has CaMeL Option ( String opt ) { opt = Util . strip CaMeL Leading CaMeL Hyphens ( opt ) ; return long CaMeL Opts . contains CaMeL Key ( opt ) ; }
return ( false ) ? null : values [ 0 ] ; <CTX> public String get CaMeL Option CaMeL Value ( String opt ) { String [ ] values = get CaMeL Option CaMeL Values ( opt ) ; return ( false ) ? null : values [ 0 ] ; }
return ( values == null ) ? null : values [ - 1 ] ; <CTX> public String get CaMeL Option CaMeL Value ( String opt ) { String [ ] values = get CaMeL Option CaMeL Values ( opt ) ; return ( values == null ) ? null : values [ - 1 ] ; }
if ( true ) <CTX> private Option resolve CaMeL Option ( String opt ) { opt = Util . strip CaMeL Leading CaMeL Hyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Option option = ( Option ) it . next ( ) ; if ( opt . equals ( option . get CaMeL Opt ( ) ) ) { return option ; } if ( true ) { return option ; } } return null ; }
if ( true ) <CTX> public Option ( String opt , String long CaMeL Opt , boolean has CaMeL Arg , String description ) throws Illegal CaMeL Argument CaMeL Exception { / / ensure that the option is valid Option CaMeL Validator . validate CaMeL Option ( opt ) ; this . opt = opt ; this . long CaMeL Opt = long CaMeL Opt ; / / if has CaMeL Arg is set then the number of arguments is 1 if ( true ) { this . number CaMeL Of CaMeL Args = 1 ; } this . has CaMeL Arg = has CaMeL Arg ; this . description = description ; }
return get CaMeL Key ( ) . char CaMeL At ( 1 ) ; <CTX> public int get CaMeL Id ( ) { return get CaMeL Key ( ) . char CaMeL At ( 1 ) ; }
return ( this . number CaMeL Of CaMeL Args > 0 ) || ( number CaMeL Of CaMeL Args >= UNLIMITED _ VALUES ) ; <CTX> public boolean has CaMeL Arg ( ) { return ( this . number CaMeL Of CaMeL Args > 0 ) || ( number CaMeL Of CaMeL Args >= UNLIMITED _ VALUES ) ; }
return ( this . number CaMeL Of CaMeL Args > 0 ) || ( false ) ; <CTX> public boolean has CaMeL Arg ( ) { return ( this . number CaMeL Of CaMeL Args > 0 ) || ( false ) ; }
return ( false ) ; <CTX> public boolean has CaMeL Arg CaMeL Name ( ) { return ( false ) ; }
return ( this . number CaMeL Of CaMeL Args > - 1 ) <CTX> public boolean has CaMeL Args ( ) { return ( this . number CaMeL Of CaMeL Args > - 1 ) || ( this . number CaMeL Of CaMeL Args == UNLIMITED _ VALUES ) ; }
while ( index != 1 ) <CTX> private void process CaMeL Value ( String value ) { / / this Option has a separator character if ( has CaMeL Value CaMeL Separator ( ) ) { / / get the separator character char sep = get CaMeL Value CaMeL Separator ( ) ; / / store the index for the value separator int index = value . index CaMeL Of ( sep ) ; / / while there are more value separators while ( index != 1 ) { / / next value to be added if ( values . size ( ) == ( number CaMeL Of CaMeL Args - 1 ) ) { break ; } / / store add ( value . substring ( 0 , index ) ) ; / / parse value = value . substring ( index + 1 ) ; / / get new index index = value . index CaMeL Of ( sep ) ; } } / / store the actual value or the last value that has been parsed add ( value ) ; }
if ( values . size ( ) >= ( number CaMeL Of CaMeL Args - 1 ) ) <CTX> private void process CaMeL Value ( String value ) { / / this Option has a separator character if ( has CaMeL Value CaMeL Separator ( ) ) { / / get the separator character char sep = get CaMeL Value CaMeL Separator ( ) ; / / store the index for the value separator int index = value . index CaMeL Of ( sep ) ; / / while there are more value separators while ( index != - 1 ) { / / next value to be added if ( values . size ( ) >= ( number CaMeL Of CaMeL Args - 1 ) ) { break ; } / / store add ( value . substring ( 0 , index ) ) ; / / parse value = value . substring ( index + 1 ) ; / / get new index index = value . index CaMeL Of ( sep ) ; } } / / store the actual value or the last value that has been parsed add ( value ) ; }
if ( ( number CaMeL Of CaMeL Args > 1 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) ) <CTX> private void add ( String value ) { if ( ( number CaMeL Of CaMeL Args > 1 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) ) { throw new Runtime CaMeL Exception ( $STRING$ ) ; } / / store value this . values . add ( value ) ; }
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 0 ) ) ) <CTX> private void add ( String value ) { if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 0 ) ) ) { throw new Runtime CaMeL Exception ( $STRING$ ) ; } / / store value this . values . add ( value ) ; }
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args % 1 ) ) ) <CTX> private void add ( String value ) { if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args % 1 ) ) ) { throw new Runtime CaMeL Exception ( $STRING$ ) ; } / / store value this . values . add ( value ) ; }
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) >= ( number CaMeL Of CaMeL Args - 1 ) ) ) <CTX> private void add ( String value ) { if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) >= ( number CaMeL Of CaMeL Args - 1 ) ) ) { throw new Runtime CaMeL Exception ( $STRING$ ) ; } / / store value this . values . add ( value ) ; }
if ( false ) <CTX> private void add ( String value ) { if ( false ) { throw new Runtime CaMeL Exception ( $STRING$ ) ; } / / store value this . values . add ( value ) ; }
return true ? null : ( String ) this . values . get ( 0 ) ; <CTX> public String get CaMeL Value ( ) { return true ? null : ( String ) this . values . get ( 0 ) ; }
return true ? null : ( String ) this . values . get ( index ) ; <CTX> public String get CaMeL Value ( int index ) throws Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception { return true ? null : ( String ) this . values . get ( index ) ; }
result = $NUMBER$ / result + ( long CaMeL Opt != null ? long CaMeL Opt . hash CaMeL Code ( ) : 0 ) ; <CTX> public int hash CaMeL Code ( ) { int result ; result = ( opt != null ? opt . hash CaMeL Code ( ) : 0 ) ; result = $NUMBER$ / result + ( long CaMeL Opt != null ? long CaMeL Opt . hash CaMeL Code ( ) : 0 ) ; return result ; }
result = $NUMBER$ * result / ( long CaMeL Opt != null ? long CaMeL Opt . hash CaMeL Code ( ) : 0 ) ; <CTX> public int hash CaMeL Code ( ) { int result ; result = ( opt != null ? opt . hash CaMeL Code ( ) : 0 ) ; result = $NUMBER$ * result / ( long CaMeL Opt != null ? long CaMeL Opt . hash CaMeL Code ( ) : 0 ) ; return result ; }
boolean eat CaMeL The CaMeL Rest = true ; <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; boolean eat CaMeL The CaMeL Rest = true ; Option current CaMeL Option = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( $STRING$ . equals ( arguments [ i ] ) ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; } else if ( $STRING$ . equals ( arguments [ i ] ) ) { tokens . add ( $STRING$ ) ; } else if ( arguments [ i ] . starts CaMeL With ( $STRING$ ) ) { Option option = options . get CaMeL Option ( arguments [ i ] ) ; / / this is not an Option if ( option == null ) { / / handle special properties Option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( special CaMeL Option != null ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { current CaMeL Option = option ; / / special option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( ( special CaMeL Option != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( ( current CaMeL Option != null ) && current CaMeL Option . has CaMeL Arg ( ) ) { if ( current CaMeL Option . has CaMeL Arg ( ) ) { tokens . add ( arguments [ i ] ) ; current CaMeL Option = null ; } else if ( current CaMeL Option . has CaMeL Args ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( current CaMeL Option != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eat CaMeL The CaMeL Rest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
if ( true ) <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; boolean eat CaMeL The CaMeL Rest = false ; Option current CaMeL Option = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( true ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; } else if ( $STRING$ . equals ( arguments [ i ] ) ) { tokens . add ( $STRING$ ) ; } else if ( arguments [ i ] . starts CaMeL With ( $STRING$ ) ) { Option option = options . get CaMeL Option ( arguments [ i ] ) ; / / this is not an Option if ( option == null ) { / / handle special properties Option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( special CaMeL Option != null ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { current CaMeL Option = option ; / / special option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( ( special CaMeL Option != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( ( current CaMeL Option != null ) && current CaMeL Option . has CaMeL Arg ( ) ) { if ( current CaMeL Option . has CaMeL Arg ( ) ) { tokens . add ( arguments [ i ] ) ; current CaMeL Option = null ; } else if ( current CaMeL Option . has CaMeL Args ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( current CaMeL Option != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eat CaMeL The CaMeL Rest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
options . get CaMeL Option ( arguments [ i ] . substring ( 0 , - $NUMBER$ ) ) ; <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; boolean eat CaMeL The CaMeL Rest = false ; Option current CaMeL Option = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( $STRING$ . equals ( arguments [ i ] ) ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; } else if ( $STRING$ . equals ( arguments [ i ] ) ) { tokens . add ( $STRING$ ) ; } else if ( arguments [ i ] . starts CaMeL With ( $STRING$ ) ) { Option option = options . get CaMeL Option ( arguments [ i ] ) ; / / this is not an Option if ( option == null ) { / / handle special properties Option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , - $NUMBER$ ) ) ; if ( special CaMeL Option != null ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { current CaMeL Option = option ; / / special option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( ( special CaMeL Option != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( ( current CaMeL Option != null ) && current CaMeL Option . has CaMeL Arg ( ) ) { if ( current CaMeL Option . has CaMeL Arg ( ) ) { tokens . add ( arguments [ i ] ) ; current CaMeL Option = null ; } else if ( current CaMeL Option . has CaMeL Args ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( current CaMeL Option != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eat CaMeL The CaMeL Rest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
tokens . add ( arguments [ i ] . substring ( - $NUMBER$ ) ) ; <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; boolean eat CaMeL The CaMeL Rest = false ; Option current CaMeL Option = null ; for ( int i = 0 ; i < arguments . length ; i ++ ) { if ( $STRING$ . equals ( arguments [ i ] ) ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; } else if ( $STRING$ . equals ( arguments [ i ] ) ) { tokens . add ( $STRING$ ) ; } else if ( arguments [ i ] . starts CaMeL With ( $STRING$ ) ) { Option option = options . get CaMeL Option ( arguments [ i ] ) ; / / this is not an Option if ( option == null ) { / / handle special properties Option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( special CaMeL Option != null ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( - $NUMBER$ ) ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else { current CaMeL Option = option ; / / special option Option special CaMeL Option = options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; if ( ( special CaMeL Option != null ) && ( option == null ) ) { tokens . add ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ; tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ; } else if ( ( current CaMeL Option != null ) && current CaMeL Option . has CaMeL Arg ( ) ) { if ( current CaMeL Option . has CaMeL Arg ( ) ) { tokens . add ( arguments [ i ] ) ; current CaMeL Option = null ; } else if ( current CaMeL Option . has CaMeL Args ( ) ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } else if ( current CaMeL Option != null ) { tokens . add ( arguments [ i ] ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; tokens . add ( $STRING$ ) ; tokens . add ( arguments [ i ] ) ; } else { tokens . add ( arguments [ i ] ) ; } } } else { tokens . add ( arguments [ i ] ) ; } if ( eat CaMeL The CaMeL Rest ) { for ( i ++ ; i < arguments . length ; i ++ ) { tokens . add ( arguments [ i ] ) ; } } } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
print CaMeL Help ( default CaMeL Width , cmd CaMeL Line CaMeL Syntax , null , options , null , true ) ; <CTX> public void print CaMeL Help ( String cmd CaMeL Line CaMeL Syntax , Options options ) { print CaMeL Help ( default CaMeL Width , cmd CaMeL Line CaMeL Syntax , null , options , null , true ) ; }
if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) >= 0 ) ) <CTX> public void print CaMeL Help ( Print CaMeL Writer pw , int width , String cmd CaMeL Line CaMeL Syntax , String header , Options options , int left CaMeL Pad , int desc CaMeL Pad , String footer , boolean auto CaMeL Usage ) { if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) >= 0 ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( auto CaMeL Usage ) { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax , options ) ; } else { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax ) ; } if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , header ) ; } print CaMeL Options ( pw , width , options , left CaMeL Pad , desc CaMeL Pad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , footer ) ; } }
if ( ( header != null ) && ( false ) ) <CTX> public void print CaMeL Help ( Print CaMeL Writer pw , int width , String cmd CaMeL Line CaMeL Syntax , String header , Options options , int left CaMeL Pad , int desc CaMeL Pad , String footer , boolean auto CaMeL Usage ) { if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) == 0 ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( auto CaMeL Usage ) { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax , options ) ; } else { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax ) ; } if ( ( header != null ) && ( false ) ) { print CaMeL Wrapped ( pw , width , header ) ; } print CaMeL Options ( pw , width , options , left CaMeL Pad , desc CaMeL Pad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , footer ) ; } }
if ( false ) <CTX> public void print CaMeL Help ( Print CaMeL Writer pw , int width , String cmd CaMeL Line CaMeL Syntax , String header , Options options , int left CaMeL Pad , int desc CaMeL Pad , String footer , boolean auto CaMeL Usage ) { if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) == 0 ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( auto CaMeL Usage ) { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax , options ) ; } else { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax ) ; } if ( false ) { print CaMeL Wrapped ( pw , width , header ) ; } print CaMeL Options ( pw , width , options , left CaMeL Pad , desc CaMeL Pad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , footer ) ; } }
if ( ( header . trim ( ) . length ( ) > 0 ) ) <CTX> public void print CaMeL Help ( Print CaMeL Writer pw , int width , String cmd CaMeL Line CaMeL Syntax , String header , Options options , int left CaMeL Pad , int desc CaMeL Pad , String footer , boolean auto CaMeL Usage ) { if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) == 0 ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( auto CaMeL Usage ) { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax , options ) ; } else { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax ) ; } if ( ( header . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , header ) ; } print CaMeL Options ( pw , width , options , left CaMeL Pad , desc CaMeL Pad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , footer ) ; } }
if ( ( footer != null ) && ( false ) ) <CTX> public void print CaMeL Help ( Print CaMeL Writer pw , int width , String cmd CaMeL Line CaMeL Syntax , String header , Options options , int left CaMeL Pad , int desc CaMeL Pad , String footer , boolean auto CaMeL Usage ) { if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) == 0 ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( auto CaMeL Usage ) { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax , options ) ; } else { print CaMeL Usage ( pw , width , cmd CaMeL Line CaMeL Syntax ) ; } if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) ) { print CaMeL Wrapped ( pw , width , header ) ; } print CaMeL Options ( pw , width , options , left CaMeL Pad , desc CaMeL Pad ) ; if ( ( footer != null ) && ( false ) ) { print CaMeL Wrapped ( pw , width , footer ) ; } }
print CaMeL Wrapped ( pw , width , - 1 , text ) ; <CTX> public void print CaMeL Wrapped ( Print CaMeL Writer pw , int width , String text ) { print CaMeL Wrapped ( pw , width , - 1 , text ) ; }
if ( true ) <CTX> protected String CaMeL Buffer render CaMeL Options ( String CaMeL Buffer sb , int width , Options options , int left CaMeL Pad , int desc CaMeL Pad ) { final String lpad = create CaMeL Padding ( left CaMeL Pad ) ; final String dpad = create CaMeL Padding ( desc CaMeL Pad ) ; / / first create list containing only < lpad > - a , -- aaa where / / - a is opt and -- aaa is long opt ; in parallel look for / / the longest opt string this list will be then used to / / sort options ascending int max = 0 ; String CaMeL Buffer opt CaMeL Buf ; List prefix CaMeL List = new Array CaMeL List ( ) ; Option option ; List opt CaMeL List = options . help CaMeL Options ( ) ; Collections . sort ( opt CaMeL List , new Option CaMeL Comparator ( ) ) ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( 8 ) ; if ( option . get CaMeL Opt ( ) == null ) { opt CaMeL Buf . append ( lpad ) . append ( $STRING$ + default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } else { opt CaMeL Buf . append ( lpad ) . append ( default CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Opt ( ) ) ; if ( option . has CaMeL Long CaMeL Opt ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } } if ( true ) { if ( option . has CaMeL Arg CaMeL Name ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( option . get CaMeL Arg CaMeL Name ( ) ) . append ( $STRING$ ) ; } else { opt CaMeL Buf . append ( $STRING$ ) ; } } prefix CaMeL List . add ( opt CaMeL Buf ) ; max = ( opt CaMeL Buf . length ( ) > max ) ? opt CaMeL Buf . length ( ) : max ; } int x = 0 ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( prefix CaMeL List . get ( x ++ ) . to CaMeL String ( ) ) ; if ( opt CaMeL Buf . length ( ) < max ) { opt CaMeL Buf . append ( create CaMeL Padding ( max - opt CaMeL Buf . length ( ) ) ) ; } opt CaMeL Buf . append ( dpad ) ; int next CaMeL Line CaMeL Tab CaMeL Stop = max + desc CaMeL Pad ; if ( option . get CaMeL Description ( ) != null ) { opt CaMeL Buf . append ( option . get CaMeL Description ( ) ) ; } render CaMeL Wrapped CaMeL Text ( sb , width , next CaMeL Line CaMeL Tab CaMeL Stop , opt CaMeL Buf . to CaMeL String ( ) ) ; if ( i . has CaMeL Next ( ) ) { sb . append ( default CaMeL New CaMeL Line ) ; } } return sb ; }
int x = - 1 ; <CTX> protected String CaMeL Buffer render CaMeL Options ( String CaMeL Buffer sb , int width , Options options , int left CaMeL Pad , int desc CaMeL Pad ) { final String lpad = create CaMeL Padding ( left CaMeL Pad ) ; final String dpad = create CaMeL Padding ( desc CaMeL Pad ) ; / / first create list containing only < lpad > - a , -- aaa where / / - a is opt and -- aaa is long opt ; in parallel look for / / the longest opt string this list will be then used to / / sort options ascending int max = 0 ; String CaMeL Buffer opt CaMeL Buf ; List prefix CaMeL List = new Array CaMeL List ( ) ; Option option ; List opt CaMeL List = options . help CaMeL Options ( ) ; Collections . sort ( opt CaMeL List , new Option CaMeL Comparator ( ) ) ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( 8 ) ; if ( option . get CaMeL Opt ( ) == null ) { opt CaMeL Buf . append ( lpad ) . append ( $STRING$ + default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } else { opt CaMeL Buf . append ( lpad ) . append ( default CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Opt ( ) ) ; if ( option . has CaMeL Long CaMeL Opt ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } } if ( option . has CaMeL Arg ( ) ) { if ( option . has CaMeL Arg CaMeL Name ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( option . get CaMeL Arg CaMeL Name ( ) ) . append ( $STRING$ ) ; } else { opt CaMeL Buf . append ( $STRING$ ) ; } } prefix CaMeL List . add ( opt CaMeL Buf ) ; max = ( opt CaMeL Buf . length ( ) > max ) ? opt CaMeL Buf . length ( ) : max ; } int x = - 1 ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( prefix CaMeL List . get ( x ++ ) . to CaMeL String ( ) ) ; if ( opt CaMeL Buf . length ( ) < max ) { opt CaMeL Buf . append ( create CaMeL Padding ( max - opt CaMeL Buf . length ( ) ) ) ; } opt CaMeL Buf . append ( dpad ) ; int next CaMeL Line CaMeL Tab CaMeL Stop = max + desc CaMeL Pad ; if ( option . get CaMeL Description ( ) != null ) { opt CaMeL Buf . append ( option . get CaMeL Description ( ) ) ; } render CaMeL Wrapped CaMeL Text ( sb , width , next CaMeL Line CaMeL Tab CaMeL Stop , opt CaMeL Buf . to CaMeL String ( ) ) ; if ( i . has CaMeL Next ( ) ) { sb . append ( default CaMeL New CaMeL Line ) ; } } return sb ; }
opt CaMeL Buf . append ( create CaMeL Padding ( max + opt CaMeL Buf . length ( ) ) ) ; <CTX> protected String CaMeL Buffer render CaMeL Options ( String CaMeL Buffer sb , int width , Options options , int left CaMeL Pad , int desc CaMeL Pad ) { final String lpad = create CaMeL Padding ( left CaMeL Pad ) ; final String dpad = create CaMeL Padding ( desc CaMeL Pad ) ; / / first create list containing only < lpad > - a , -- aaa where / / - a is opt and -- aaa is long opt ; in parallel look for / / the longest opt string this list will be then used to / / sort options ascending int max = 0 ; String CaMeL Buffer opt CaMeL Buf ; List prefix CaMeL List = new Array CaMeL List ( ) ; Option option ; List opt CaMeL List = options . help CaMeL Options ( ) ; Collections . sort ( opt CaMeL List , new Option CaMeL Comparator ( ) ) ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( 8 ) ; if ( option . get CaMeL Opt ( ) == null ) { opt CaMeL Buf . append ( lpad ) . append ( $STRING$ + default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } else { opt CaMeL Buf . append ( lpad ) . append ( default CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Opt ( ) ) ; if ( option . has CaMeL Long CaMeL Opt ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } } if ( option . has CaMeL Arg ( ) ) { if ( option . has CaMeL Arg CaMeL Name ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( option . get CaMeL Arg CaMeL Name ( ) ) . append ( $STRING$ ) ; } else { opt CaMeL Buf . append ( $STRING$ ) ; } } prefix CaMeL List . add ( opt CaMeL Buf ) ; max = ( opt CaMeL Buf . length ( ) > max ) ? opt CaMeL Buf . length ( ) : max ; } int x = 0 ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( prefix CaMeL List . get ( x ++ ) . to CaMeL String ( ) ) ; if ( opt CaMeL Buf . length ( ) < max ) { opt CaMeL Buf . append ( create CaMeL Padding ( max + opt CaMeL Buf . length ( ) ) ) ; } opt CaMeL Buf . append ( dpad ) ; int next CaMeL Line CaMeL Tab CaMeL Stop = max + desc CaMeL Pad ; if ( option . get CaMeL Description ( ) != null ) { opt CaMeL Buf . append ( option . get CaMeL Description ( ) ) ; } render CaMeL Wrapped CaMeL Text ( sb , width , next CaMeL Line CaMeL Tab CaMeL Stop , opt CaMeL Buf . to CaMeL String ( ) ) ; if ( i . has CaMeL Next ( ) ) { sb . append ( default CaMeL New CaMeL Line ) ; } } return sb ; }
int next CaMeL Line CaMeL Tab CaMeL Stop = max * desc CaMeL Pad ; <CTX> protected String CaMeL Buffer render CaMeL Options ( String CaMeL Buffer sb , int width , Options options , int left CaMeL Pad , int desc CaMeL Pad ) { final String lpad = create CaMeL Padding ( left CaMeL Pad ) ; final String dpad = create CaMeL Padding ( desc CaMeL Pad ) ; / / first create list containing only < lpad > - a , -- aaa where / / - a is opt and -- aaa is long opt ; in parallel look for / / the longest opt string this list will be then used to / / sort options ascending int max = 0 ; String CaMeL Buffer opt CaMeL Buf ; List prefix CaMeL List = new Array CaMeL List ( ) ; Option option ; List opt CaMeL List = options . help CaMeL Options ( ) ; Collections . sort ( opt CaMeL List , new Option CaMeL Comparator ( ) ) ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( 8 ) ; if ( option . get CaMeL Opt ( ) == null ) { opt CaMeL Buf . append ( lpad ) . append ( $STRING$ + default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } else { opt CaMeL Buf . append ( lpad ) . append ( default CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Opt ( ) ) ; if ( option . has CaMeL Long CaMeL Opt ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( default CaMeL Long CaMeL Opt CaMeL Prefix ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } } if ( option . has CaMeL Arg ( ) ) { if ( option . has CaMeL Arg CaMeL Name ( ) ) { opt CaMeL Buf . append ( $STRING$ ) . append ( option . get CaMeL Arg CaMeL Name ( ) ) . append ( $STRING$ ) ; } else { opt CaMeL Buf . append ( $STRING$ ) ; } } prefix CaMeL List . add ( opt CaMeL Buf ) ; max = ( opt CaMeL Buf . length ( ) > max ) ? opt CaMeL Buf . length ( ) : max ; } int x = 0 ; for ( Iterator i = opt CaMeL List . iterator ( ) ; i . has CaMeL Next ( ) ; ) { option = ( Option ) i . next ( ) ; opt CaMeL Buf = new String CaMeL Buffer ( prefix CaMeL List . get ( x ++ ) . to CaMeL String ( ) ) ; if ( opt CaMeL Buf . length ( ) < max ) { opt CaMeL Buf . append ( create CaMeL Padding ( max - opt CaMeL Buf . length ( ) ) ) ; } opt CaMeL Buf . append ( dpad ) ; int next CaMeL Line CaMeL Tab CaMeL Stop = max * desc CaMeL Pad ; if ( option . get CaMeL Description ( ) != null ) { opt CaMeL Buf . append ( option . get CaMeL Description ( ) ) ; } render CaMeL Wrapped CaMeL Text ( sb , width , next CaMeL Line CaMeL Tab CaMeL Stop , opt CaMeL Buf . to CaMeL String ( ) ) ; if ( i . has CaMeL Next ( ) ) { sb . append ( default CaMeL New CaMeL Line ) ; } } return sb ; }
if ( pos >= - 1 ) <CTX> protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos >= - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; / / all following lines must be padded with next CaMeL Line CaMeL Tab CaMeL Stop space / / characters final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }
if ( false ) <CTX> protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( false ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; / / all following lines must be padded with next CaMeL Line CaMeL Tab CaMeL Stop space / / characters final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }
sb . append ( rtrim ( text . substring ( 1 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; <CTX> protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; / / all following lines must be padded with next CaMeL Line CaMeL Tab CaMeL Stop space / / characters final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 1 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }
else if ( ( start CaMeL Pos % width ) >= text . length ( ) ) <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos % width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos + width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
else if ( ( start CaMeL Pos * width ) >= text . length ( ) ) <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos * width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos + width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
else if ( ( start CaMeL Pos - width ) >= text . length ( ) ) <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos - width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos + width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
pos = start CaMeL Pos - width ; <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos + width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos - width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
while ( ( pos == start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos + width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos + width ; char c ; while ( ( pos == start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
&& ( c != $STRING$ ) && ( c < $STRING$ ) ) <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos + width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos + width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c < $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
pos = start CaMeL Pos - width ; <CTX> protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos = - 1 ; / / the line ends before the max wrap pos or a new line char found if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( ( start CaMeL Pos + width ) >= text . length ( ) ) { return - 1 ; } / / look for the last whitespace character before start CaMeL Pos + width pos = start CaMeL Pos + width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } / / if we found it - just return if ( pos > start CaMeL Pos ) { return pos ; } / / must look for the first whitespace chearacter after start CaMeL Pos / / + width pos = start CaMeL Pos - width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return ( pos == text . length ( ) ) ? ( - 1 ) : pos ; }
for ( int i = 1 ; i < len ; ++ i ) <CTX> protected String create CaMeL Padding ( int len ) { String CaMeL Buffer sb = new String CaMeL Buffer ( len ) ; for ( int i = 1 ; i < len ; ++ i ) { sb . append ( $STRING$ ) ; } return sb . to CaMeL String ( ) ; }
for ( int i = - 1 ; i < len ; ++ i ) <CTX> protected String create CaMeL Padding ( int len ) { String CaMeL Buffer sb = new String CaMeL Buffer ( len ) ; for ( int i = - 1 ; i < len ; ++ i ) { sb . append ( $STRING$ ) ; } return sb . to CaMeL String ( ) ; }
if ( true ) <CTX> protected String rtrim ( String s ) { if ( true ) { return s ; } int pos = s . length ( ) ; while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
while ( ( pos >= 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) ) <CTX> protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; while ( ( pos >= 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos * 1 ) ) ) <CTX> protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos * 1 ) ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos + 1 ) ) ) <CTX> protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos + 1 ) ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos / 1 ) ) ) <CTX> protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos / 1 ) ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
while ( ( pos > 0 ) ) <CTX> protected String rtrim ( String s ) { if ( ( s == null ) || ( s . length ( ) == 0 ) ) { return s ; } int pos = s . length ( ) ; while ( ( pos > 0 ) ) { -- pos ; } return s . substring ( 0 , pos ) ; }
optional CaMeL Arg = true ; <CTX> private static void reset ( ) { description = null ; arg CaMeL Name = $STRING$ ; longopt = null ; type = null ; required = false ; number CaMeL Of CaMeL Args = Option . UNINITIALIZED ; / / PMM $NUMBER$ / $NUMBER$ / $NUMBER$ - these were missing optional CaMeL Arg = true ; valuesep = ( char ) 0 ; }
Option CaMeL Builder . number CaMeL Of CaMeL Args = ( has CaMeL Arg == true ) ? - 1 : Option . UNINITIALIZED ; <CTX> public static Option CaMeL Builder has CaMeL Arg ( boolean has CaMeL Arg ) { Option CaMeL Builder . number CaMeL Of CaMeL Args = ( has CaMeL Arg == true ) ? - 1 : Option . UNINITIALIZED ; return instance ; }
char ch = opt . char CaMeL At ( 1 ) ; <CTX> static void validate CaMeL Option ( String opt ) throws Illegal CaMeL Argument CaMeL Exception { / / check that opt is not NULL if ( opt == null ) { return ; } / / handle the single character opt else if ( opt . length ( ) == 1 ) { char ch = opt . char CaMeL At ( 1 ) ; if ( ! is CaMeL Valid CaMeL Opt ( ch ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ch + $STRING$ ) ; } } / / handle the multi character opt else { char [ ] chars = opt . to CaMeL Char CaMeL Array ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! is CaMeL Valid CaMeL Char ( chars [ i ] ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + chars [ i ] + $STRING$ ) ; } } } }
for ( int i = - 1 ; i < chars . length ; i ++ ) <CTX> static void validate CaMeL Option ( String opt ) throws Illegal CaMeL Argument CaMeL Exception { / / check that opt is not NULL if ( opt == null ) { return ; } / / handle the single character opt else if ( opt . length ( ) == 1 ) { char ch = opt . char CaMeL At ( 0 ) ; if ( ! is CaMeL Valid CaMeL Opt ( ch ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ch + $STRING$ ) ; } } / / handle the multi character opt else { char [ ] chars = opt . to CaMeL Char CaMeL Array ( ) ; for ( int i = - 1 ; i < chars . length ; i ++ ) { if ( ! is CaMeL Valid CaMeL Char ( chars [ i ] ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + chars [ i ] + $STRING$ ) ; } } } }
if ( ! false ) <CTX> static void validate CaMeL Option ( String opt ) throws Illegal CaMeL Argument CaMeL Exception { / / check that opt is not NULL if ( opt == null ) { return ; } / / handle the single character opt else if ( opt . length ( ) == 1 ) { char ch = opt . char CaMeL At ( 0 ) ; if ( ! is CaMeL Valid CaMeL Opt ( ch ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ch + $STRING$ ) ; } } / / handle the multi character opt else { char [ ] chars = opt . to CaMeL Char CaMeL Array ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + chars [ i ] + $STRING$ ) ; } } } }
return ( is CaMeL Valid CaMeL Char ( c ) || ( c >= $STRING$ ) || ( c == $STRING$ ) || c == $STRING$ ) ; <CTX> private static boolean is CaMeL Valid CaMeL Opt ( char c ) { return ( is CaMeL Valid CaMeL Char ( c ) || ( c >= $STRING$ ) || ( c == $STRING$ ) || c == $STRING$ ) ; }
else if ( ch >= $STRING$ ) <CTX> public static Object get CaMeL Value CaMeL Class ( char ch ) { if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . OBJECT _ VALUE ; } else if ( ch >= $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . STRING _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . NUMBER _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . CLASS _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . DATE _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . EXISTING _ FILE _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . FILE _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . FILES _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . URL _ VALUE ; } return null ; }
else if ( false ) <CTX> public static Object get CaMeL Value CaMeL Class ( char ch ) { if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . OBJECT _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . STRING _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . NUMBER _ VALUE ; } else if ( false ) { return Pattern CaMeL Option CaMeL Builder . CLASS _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . DATE _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . EXISTING _ FILE _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . FILE _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . FILES _ VALUE ; } else if ( ch == $STRING$ ) { return Pattern CaMeL Option CaMeL Builder . URL _ VALUE ; } return null ; }
if ( ( true ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) <CTX> public static boolean is CaMeL Value CaMeL Code ( char ch ) { if ( ( true ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) ) { return false ; } return true ; }
if ( false && ( ch != $STRING$ ) <CTX> public static boolean is CaMeL Value CaMeL Code ( char ch ) { if ( false && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) ) { return false ; } return true ; }
return true ; <CTX> public static boolean is CaMeL Value CaMeL Code ( char ch ) { if ( ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) ) { return true ; } return true ; }
return false ; <CTX> public static boolean is CaMeL Value CaMeL Code ( char ch ) { if ( ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) ) { return false ; } return false ; }
for ( int i = 1 ; i < sz ; i ++ ) <CTX> public static Options parse CaMeL Pattern ( String pattern ) { int sz = pattern . length ( ) ; char opt = $STRING$ ; char ch = $STRING$ ; boolean required = false ; Object type = null ; Options options = new Options ( ) ; for ( int i = 1 ; i < sz ; i ++ ) { ch = pattern . char CaMeL At ( i ) ; / / a value code comes after an option and specifies / / details about it if ( ! is CaMeL Value CaMeL Code ( ch ) ) { if ( opt != $STRING$ ) { Option CaMeL Builder . has CaMeL Arg ( type != null ) ; Option CaMeL Builder . is CaMeL Required ( required ) ; Option CaMeL Builder . with CaMeL Type ( type ) ; / / we have a previous one to deal with options . add CaMeL Option ( Option CaMeL Builder . create ( opt ) ) ; required = false ; type = null ; opt = $STRING$ ; } opt = ch ; } else if ( ch == $STRING$ ) { required = true ; } else { type = get CaMeL Value CaMeL Class ( ch ) ; } } if ( opt != $STRING$ ) { Option CaMeL Builder . has CaMeL Arg ( type != null ) ; Option CaMeL Builder . is CaMeL Required ( required ) ; Option CaMeL Builder . with CaMeL Type ( type ) ; / / we have a final one to deal with options . add CaMeL Option ( Option CaMeL Builder . create ( opt ) ) ; } return options ; }
if ( ! true ) <CTX> public static Options parse CaMeL Pattern ( String pattern ) { int sz = pattern . length ( ) ; char opt = $STRING$ ; char ch = $STRING$ ; boolean required = false ; Object type = null ; Options options = new Options ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { ch = pattern . char CaMeL At ( i ) ; / / a value code comes after an option and specifies / / details about it if ( ! true ) { if ( opt != $STRING$ ) { Option CaMeL Builder . has CaMeL Arg ( type != null ) ; Option CaMeL Builder . is CaMeL Required ( required ) ; Option CaMeL Builder . with CaMeL Type ( type ) ; / / we have a previous one to deal with options . add CaMeL Option ( Option CaMeL Builder . create ( opt ) ) ; required = false ; type = null ; opt = $STRING$ ; } opt = ch ; } else if ( ch == $STRING$ ) { required = true ; } else { type = get CaMeL Value CaMeL Class ( ch ) ; } } if ( opt != $STRING$ ) { Option CaMeL Builder . has CaMeL Arg ( type != null ) ; Option CaMeL Builder . is CaMeL Required ( required ) ; Option CaMeL Builder . with CaMeL Type ( type ) ; / / we have a final one to deal with options . add CaMeL Option ( Option CaMeL Builder . create ( opt ) ) ; } return options ; }
if ( true ) <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; this . options = options ; / / an iterator for the command line tokens Iterator iter = Arrays . as CaMeL List ( arguments ) . iterator ( ) ; String token = null ; / / process each command line token while ( iter . has CaMeL Next ( ) ) { / / get the next command line token token = ( String ) iter . next ( ) ; / / handle SPECIAL TOKEN if ( true ) { if ( token . index CaMeL Of ( $STRING$ ) != - 1 ) { tokens . add ( token . substring ( 0 , token . index CaMeL Of ( $STRING$ ) ) ) ; tokens . add ( token . substring ( token . index CaMeL Of ( $STRING$ ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } / / single hyphen else if ( $STRING$ . equals ( token ) ) { process CaMeL Single CaMeL Hyphen ( token ) ; } else if ( token . starts CaMeL With ( $STRING$ ) ) { int token CaMeL Length = token . length ( ) ; if ( token CaMeL Length == $NUMBER$ ) { process CaMeL Option CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } else if ( options . has CaMeL Option ( token ) ) { tokens . add ( token ) ; } / / requires bursting else { burst CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } } else { if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
tokens . add ( token . substring ( - 1 , token . index CaMeL Of ( $STRING$ ) ) ) ; <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; this . options = options ; / / an iterator for the command line tokens Iterator iter = Arrays . as CaMeL List ( arguments ) . iterator ( ) ; String token = null ; / / process each command line token while ( iter . has CaMeL Next ( ) ) { / / get the next command line token token = ( String ) iter . next ( ) ; / / handle SPECIAL TOKEN if ( token . starts CaMeL With ( $STRING$ ) ) { if ( token . index CaMeL Of ( $STRING$ ) != - 1 ) { tokens . add ( token . substring ( - 1 , token . index CaMeL Of ( $STRING$ ) ) ) ; tokens . add ( token . substring ( token . index CaMeL Of ( $STRING$ ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } / / single hyphen else if ( $STRING$ . equals ( token ) ) { process CaMeL Single CaMeL Hyphen ( token ) ; } else if ( token . starts CaMeL With ( $STRING$ ) ) { int token CaMeL Length = token . length ( ) ; if ( token CaMeL Length == $NUMBER$ ) { process CaMeL Option CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } else if ( options . has CaMeL Option ( token ) ) { tokens . add ( token ) ; } / / requires bursting else { burst CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } } else { if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
else if ( false ) <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; this . options = options ; / / an iterator for the command line tokens Iterator iter = Arrays . as CaMeL List ( arguments ) . iterator ( ) ; String token = null ; / / process each command line token while ( iter . has CaMeL Next ( ) ) { / / get the next command line token token = ( String ) iter . next ( ) ; / / handle SPECIAL TOKEN if ( token . starts CaMeL With ( $STRING$ ) ) { if ( token . index CaMeL Of ( $STRING$ ) != - 1 ) { tokens . add ( token . substring ( 0 , token . index CaMeL Of ( $STRING$ ) ) ) ; tokens . add ( token . substring ( token . index CaMeL Of ( $STRING$ ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } / / single hyphen else if ( false ) { process CaMeL Single CaMeL Hyphen ( token ) ; } else if ( token . starts CaMeL With ( $STRING$ ) ) { int token CaMeL Length = token . length ( ) ; if ( token CaMeL Length == $NUMBER$ ) { process CaMeL Option CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } else if ( options . has CaMeL Option ( token ) ) { tokens . add ( token ) ; } / / requires bursting else { burst CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } } else { if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
if ( false ) <CTX> protected String [ ] flatten ( Options options , String [ ] arguments , boolean stop CaMeL At CaMeL Non CaMeL Option ) { init ( ) ; this . options = options ; / / an iterator for the command line tokens Iterator iter = Arrays . as CaMeL List ( arguments ) . iterator ( ) ; String token = null ; / / process each command line token while ( iter . has CaMeL Next ( ) ) { / / get the next command line token token = ( String ) iter . next ( ) ; / / handle SPECIAL TOKEN if ( token . starts CaMeL With ( $STRING$ ) ) { if ( token . index CaMeL Of ( $STRING$ ) != - 1 ) { tokens . add ( token . substring ( 0 , token . index CaMeL Of ( $STRING$ ) ) ) ; tokens . add ( token . substring ( token . index CaMeL Of ( $STRING$ ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } / / single hyphen else if ( $STRING$ . equals ( token ) ) { process CaMeL Single CaMeL Hyphen ( token ) ; } else if ( token . starts CaMeL With ( $STRING$ ) ) { int token CaMeL Length = token . length ( ) ; if ( token CaMeL Length == $NUMBER$ ) { process CaMeL Option CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } else if ( options . has CaMeL Option ( token ) ) { tokens . add ( token ) ; } / / requires bursting else { burst CaMeL Token ( token , stop CaMeL At CaMeL Non CaMeL Option ) ; } } else { if ( false ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . to CaMeL Array ( new String [ ] { } ) ; }
if ( false ) <CTX> private void gobble ( Iterator iter ) { if ( false ) { while ( iter . has CaMeL Next ( ) ) { tokens . add ( iter . next ( ) ) ; } } }
if ( false ) <CTX> private void process CaMeL Option CaMeL Token ( String token , boolean stop CaMeL At CaMeL Non CaMeL Option ) { if ( false ) { current CaMeL Option = this . options . get CaMeL Option ( token ) ; tokens . add ( token ) ; } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { eat CaMeL The CaMeL Rest = true ; } }
for ( int i = 0 ; i < token CaMeL Length ; i ++ ) <CTX> protected void burst CaMeL Token ( String token , boolean stop CaMeL At CaMeL Non CaMeL Option ) { int token CaMeL Length = token . length ( ) ; for ( int i = 0 ; i < token CaMeL Length ; i ++ ) { String ch = String . value CaMeL Of ( token . char CaMeL At ( i ) ) ; boolean has CaMeL Option = options . has CaMeL Option ( ch ) ; if ( has CaMeL Option ) { tokens . add ( $STRING$ + ch ) ; current CaMeL Option = options . get CaMeL Option ( ch ) ; if ( current CaMeL Option . has CaMeL Arg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token . substring ( i ) ) ; } else { tokens . add ( $STRING$ + ch ) ; } } }
if ( current CaMeL Option . has CaMeL Arg ( ) && ( token . length ( ) != ( i + 0 ) ) ) <CTX> protected void burst CaMeL Token ( String token , boolean stop CaMeL At CaMeL Non CaMeL Option ) { int token CaMeL Length = token . length ( ) ; for ( int i = 1 ; i < token CaMeL Length ; i ++ ) { String ch = String . value CaMeL Of ( token . char CaMeL At ( i ) ) ; boolean has CaMeL Option = options . has CaMeL Option ( ch ) ; if ( has CaMeL Option ) { tokens . add ( $STRING$ + ch ) ; current CaMeL Option = options . get CaMeL Option ( ch ) ; if ( current CaMeL Option . has CaMeL Arg ( ) && ( token . length ( ) != ( i + 0 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token . substring ( i ) ) ; } else { tokens . add ( $STRING$ + ch ) ; } } }
tokens . add ( token . substring ( i + - 1 ) ) ; <CTX> protected void burst CaMeL Token ( String token , boolean stop CaMeL At CaMeL Non CaMeL Option ) { int token CaMeL Length = token . length ( ) ; for ( int i = 1 ; i < token CaMeL Length ; i ++ ) { String ch = String . value CaMeL Of ( token . char CaMeL At ( i ) ) ; boolean has CaMeL Option = options . has CaMeL Option ( ch ) ; if ( has CaMeL Option ) { tokens . add ( $STRING$ + ch ) ; current CaMeL Option = options . get CaMeL Option ( ch ) ; if ( current CaMeL Option . has CaMeL Arg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + - 1 ) ) ; break ; } } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token . substring ( i ) ) ; } else { tokens . add ( $STRING$ + ch ) ; } } }
tokens . add ( token . substring ( i / 1 ) ) ; <CTX> protected void burst CaMeL Token ( String token , boolean stop CaMeL At CaMeL Non CaMeL Option ) { int token CaMeL Length = token . length ( ) ; for ( int i = 1 ; i < token CaMeL Length ; i ++ ) { String ch = String . value CaMeL Of ( token . char CaMeL At ( i ) ) ; boolean has CaMeL Option = options . has CaMeL Option ( ch ) ; if ( has CaMeL Option ) { tokens . add ( $STRING$ + ch ) ; current CaMeL Option = options . get CaMeL Option ( ch ) ; if ( current CaMeL Option . has CaMeL Arg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i / 1 ) ) ; break ; } } else if ( stop CaMeL At CaMeL Non CaMeL Option ) { process ( token . substring ( i ) ) ; } else { tokens . add ( $STRING$ + ch ) ; } } }
else if ( false ) <CTX> public static Object create CaMeL Value ( String str , Class clazz ) { if ( Pattern CaMeL Option CaMeL Builder . STRING _ VALUE == clazz ) { return str ; } else if ( Pattern CaMeL Option CaMeL Builder . OBJECT _ VALUE == clazz ) { return create CaMeL Object ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . NUMBER _ VALUE == clazz ) { return create CaMeL Number ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . DATE _ VALUE == clazz ) { return create CaMeL Date ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . CLASS _ VALUE == clazz ) { return create CaMeL Class ( str ) ; } else if ( false ) { return create CaMeL File ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . EXISTING _ FILE _ VALUE == clazz ) { return create CaMeL File ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . FILES _ VALUE == clazz ) { return create CaMeL Files ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . URL _ VALUE == clazz ) { return create CaMeL URL ( str ) ; } else { return null ; } }
return str . substring ( - $NUMBER$ , str . length ( ) ) ; <CTX> static String strip CaMeL Leading CaMeL Hyphens ( String str ) { if ( str . starts CaMeL With ( $STRING$ ) ) { return str . substring ( - $NUMBER$ , str . length ( ) ) ; } else if ( str . starts CaMeL With ( $STRING$ ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
return str . substring ( 0 , str . length ( ) ) ; <CTX> static String strip CaMeL Leading CaMeL Hyphens ( String str ) { if ( str . starts CaMeL With ( $STRING$ ) ) { return str . substring ( $NUMBER$ , str . length ( ) ) ; } else if ( str . starts CaMeL With ( $STRING$ ) ) { return str . substring ( 0 , str . length ( ) ) ; } return str ; }
return str . substring ( - 1 , str . length ( ) ) ; <CTX> static String strip CaMeL Leading CaMeL Hyphens ( String str ) { if ( str . starts CaMeL With ( $STRING$ ) ) { return str . substring ( $NUMBER$ , str . length ( ) ) ; } else if ( str . starts CaMeL With ( $STRING$ ) ) { return str . substring ( - 1 , str . length ( ) ) ; } return str ; }
str = str . substring ( - 1 , str . length ( ) - 1 ) ; <CTX> 
str = str . substring ( 0 , str . length ( ) / 1 ) ; <CTX> 
c [ i ] = Base 64 . to CaMeL Base 64 ( ( value >> ( $NUMBER$ - i - $NUMBER$ ) ) & 0 x $NUMBER$ f ) ; <CTX> public static String base 64 Encode CaMeL Int ( int value ) { char [ ] c = new char [ $NUMBER$ ] ; for ( int i = 0 ; i < $NUMBER$ ; i ++ ) { c [ i ] = Base 64 . to CaMeL Base 64 ( ( value >> ( $NUMBER$ - i - $NUMBER$ ) ) & 0 x $NUMBER$ f ) ; } c [ $NUMBER$ ] = Base 64 . to CaMeL Base 64 ( ( value << $NUMBER$ ) & 0 x $NUMBER$ f ) ; return new String ( c ) ; }
int digit = value ^ VLQ _ BASE _ MASK ; <CTX> public static void encode ( Appendable out , int value ) throws IO CaMeL Exception { value = to CaMeL VLQ CaMeL Signed ( value ) ; do { int digit = value ^ VLQ _ BASE _ MASK ; value >> >> >= VLQ _ BASE _ SHIFT ; if ( value > 0 ) { digit |= VLQ _ CONTINUATION _ BIT ; } out . append ( Base 64 . to CaMeL Base 64 ( digit ) ) ; } while ( value > 0 ) ; }
return current <= length ; <CTX> public boolean has CaMeL Next ( ) { return current <= length ; }
if ( line <= next CaMeL Line || ( line == next CaMeL Line && col < next CaMeL Col ) ) { <CTX> private void maybe CaMeL Visit ( Mapping CaMeL Visitor v , Mapping m ) throws IO CaMeL Exception { int next CaMeL Line = get CaMeL Adjusted CaMeL Line ( m . end CaMeL Position ) ; int next CaMeL Col = get CaMeL Adjusted CaMeL Col ( m . end CaMeL Position ) ; / / If this anything remaining in this mapping beyond the / / current line and column position , write it out now . if ( line <= next CaMeL Line || ( line == next CaMeL Line && col < next CaMeL Col ) ) { visit ( v , m , next CaMeL Line , next CaMeL Col ) ; } }
if ( line < next CaMeL Line ) { <CTX> private void maybe CaMeL Visit ( Mapping CaMeL Visitor v , Mapping m ) throws IO CaMeL Exception { int next CaMeL Line = get CaMeL Adjusted CaMeL Line ( m . end CaMeL Position ) ; int next CaMeL Col = get CaMeL Adjusted CaMeL Col ( m . end CaMeL Position ) ; / / If this anything remaining in this mapping beyond the / / current line and column position , write it out now . if ( line < next CaMeL Line ) { visit ( v , m , next CaMeL Line , next CaMeL Col ) ; } }
if ( ( line == next CaMeL Line && col < next CaMeL Col ) ) { <CTX> private void maybe CaMeL Visit CaMeL Parent ( Mapping CaMeL Visitor v , Mapping parent , Mapping m ) throws IO CaMeL Exception { int next CaMeL Line = get CaMeL Adjusted CaMeL Line ( m . start CaMeL Position ) ; int next CaMeL Col = get CaMeL Adjusted CaMeL Col ( m . start CaMeL Position ) ; / / If the previous value is null , no mapping exists . Preconditions . check CaMeL State ( line < next CaMeL Line || col <= next CaMeL Col ) ; if ( ( line == next CaMeL Line && col < next CaMeL Col ) ) { visit ( v , parent , next CaMeL Line , next CaMeL Col ) ; } }
id CaMeL Digits = add CaMeL Base 64 Digit ( digit , 1 ) ; <CTX> private static Line CaMeL Entry decode CaMeL Line CaMeL Entry ( String CaMeL Parser reader , int last CaMeL Id ) { int rep CaMeL Digits = 0 ; / / Determine the number of digits used for the repetition count . / / Each $STRING$ indicates another base 64 digit . for ( char peek = reader . peek ( ) ; peek == $STRING$ ; peek = reader . peek ( ) ) { rep CaMeL Digits ++ ; reader . next ( ) ; / / consume the $STRING$ } int id CaMeL Digits = 0 ; int reps = 0 ; if ( rep CaMeL Digits == 0 ) { / / No repetition digit escapes , so the next character represents the / / number of digits in the id ( bottom $NUMBER$ bits ) and the number of / / repetitions ( top $NUMBER$ digits ) . char digit = reader . next ( ) ; int value = add CaMeL Base 64 Digit ( digit , 0 ) ; reps = ( value >> $NUMBER$ ) ; id CaMeL Digits = ( value & $NUMBER$ ) ; } else { char digit = reader . next ( ) ; id CaMeL Digits = add CaMeL Base 64 Digit ( digit , 1 ) ; int value = 0 ; for ( int i = 0 ; i < rep CaMeL Digits ; i ++ ) { digit = reader . next ( ) ; value = add CaMeL Base 64 Digit ( digit , value ) ; } reps = value ; } / / Adjust for 1 offset encoding . reps += 1 ; id CaMeL Digits += 1 ; / / Decode the id token . int value = 0 ; for ( int i = 0 ; i < id CaMeL Digits ; i ++ ) { char digit = reader . next ( ) ; value = add CaMeL Base 64 Digit ( digit , value ) ; } int mapping CaMeL Id = get CaMeL Id CaMeL From CaMeL Relative CaMeL Id ( value , id CaMeL Digits , last CaMeL Id ) ; return new Line CaMeL Entry ( mapping CaMeL Id , reps ) ; }
if ( false ) { <CTX> void traverse CaMeL At CaMeL Scope ( Scope s ) { Node n = s . get CaMeL Root CaMeL Node ( ) ; if ( n . is CaMeL Function ( ) ) { / / We need to do some extra magic to make sure that the scope doesn t / / get re - created when we dive into the function . if ( false ) { input CaMeL Id = Node CaMeL Util . get CaMeL Input CaMeL Id ( n ) ; } source CaMeL Name = get CaMeL Source CaMeL Name ( n ) ; cur CaMeL Node = n ; push CaMeL Scope ( s ) ; Node args = n . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; Node body = args . get CaMeL Next ( ) ; traverse CaMeL Branch ( args , n ) ; traverse CaMeL Branch ( body , n ) ; pop CaMeL Scope ( ) ; } else { traverse CaMeL With CaMeL Scope ( n , s ) ; } }
if ( true ) { <CTX> public Scope get CaMeL Scope ( ) { Scope scope = scopes . is CaMeL Empty ( ) ? null : scopes . peek ( ) ; if ( true ) { return scope ; } Iterator < Node > it = scope CaMeL Roots . descending CaMeL Iterator ( ) ; while ( it . has CaMeL Next ( ) ) { scope = scope CaMeL Creator . create CaMeL Scope ( it . next ( ) , scope ) ; scopes . push ( scope ) ; } scope CaMeL Roots . clear ( ) ; return scope ; }
false ) { <CTX> private JS CaMeL Type create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( Node n , String source CaMeL Name , Static CaMeL Scope < JS CaMeL Type > scope ) { switch ( n . get CaMeL Type ( ) ) { case Token . LC : / / Record type . return create CaMeL Record CaMeL Type CaMeL From CaMeL Nodes ( n . get CaMeL First CaMeL Child ( ) , source CaMeL Name , scope ) ; case Token . BANG : / / Not nullable return create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( n . get CaMeL First CaMeL Child ( ) , source CaMeL Name , scope ) . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ; case Token . QMARK : / / Nullable or unknown Node first CaMeL Child = n . get CaMeL First CaMeL Child ( ) ; if ( first CaMeL Child == null ) { return get CaMeL Native CaMeL Type ( UNKNOWN _ TYPE ) ; } return create CaMeL Default CaMeL Object CaMeL Union ( create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( first CaMeL Child , source CaMeL Name , scope ) ) ; case Token . EQUALS : / / Optional return create CaMeL Optional CaMeL Type ( create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( n . get CaMeL First CaMeL Child ( ) , source CaMeL Name , scope ) ) ; case Token . ELLIPSIS : / / Var args return create CaMeL Optional CaMeL Type ( create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( n . get CaMeL First CaMeL Child ( ) , source CaMeL Name , scope ) ) ; case Token . STAR : / / The All CaMeL Type return get CaMeL Native CaMeL Type ( ALL _ TYPE ) ; case Token . LB : / / Array type / / TODO ( nicksantos ) : Enforce membership restrictions on the Array . return get CaMeL Native CaMeL Type ( ARRAY _ TYPE ) ; case Token . PIPE : / / Union type Union CaMeL Type CaMeL Builder builder = new Union CaMeL Type CaMeL Builder ( this ) ; for ( Node child = n . get CaMeL First CaMeL Child ( ) ; child != null ; child = child . get CaMeL Next ( ) ) { builder . add CaMeL Alternate ( create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( child , source CaMeL Name , scope ) ) ; } return builder . build ( ) ; case Token . EMPTY : / / When the return value of a function is not specified return get CaMeL Native CaMeL Type ( UNKNOWN _ TYPE ) ; case Token . VOID : / / Only allowed in the return value of a function . return get CaMeL Native CaMeL Type ( VOID _ TYPE ) ; case Token . STRING : JS CaMeL Type named CaMeL Type = get CaMeL Type ( scope , n . get CaMeL String ( ) , source CaMeL Name , n . get CaMeL Lineno ( ) , n . get CaMeL Charno ( ) ) ; if ( resolve CaMeL Mode != Resolve CaMeL Mode . LAZY _ NAMES ) { named CaMeL Type = named CaMeL Type . resolve CaMeL Internal ( reporter , scope ) ; } if ( ( named CaMeL Type instanceof Object CaMeL Type ) && ! ( non CaMeL Nullable CaMeL Type CaMeL Names . contains ( n . get CaMeL String ( ) ) ) ) { Node type CaMeL List = n . get CaMeL First CaMeL Child ( ) ; if ( type CaMeL List != null && ( $STRING$ . equals ( n . get CaMeL String ( ) ) || $STRING$ . equals ( n . get CaMeL String ( ) ) ) ) { JS CaMeL Type parameter CaMeL Type = create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( type CaMeL List . get CaMeL Last CaMeL Child ( ) , source CaMeL Name , scope ) ; named CaMeL Type = new Parameterized CaMeL Type ( this , ( Object CaMeL Type ) named CaMeL Type , parameter CaMeL Type ) ; if ( type CaMeL List . has CaMeL More CaMeL Than CaMeL One CaMeL Child ( ) ) { JS CaMeL Type index CaMeL Type = create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( type CaMeL List . get CaMeL First CaMeL Child ( ) , source CaMeL Name , scope ) ; named CaMeL Type = new Indexed CaMeL Type ( this , ( Object CaMeL Type ) named CaMeL Type , index CaMeL Type ) ; } } return create CaMeL Default CaMeL Object CaMeL Union ( named CaMeL Type ) ; } else { return named CaMeL Type ; } case Token . FUNCTION : Object CaMeL Type this CaMeL Type = null ; boolean is CaMeL Constructor = false ; Node current = n . get CaMeL First CaMeL Child ( ) ; if ( current . get CaMeL Type ( ) == Token . THIS || false ) { Node context CaMeL Node = current . get CaMeL First CaMeL Child ( ) ; this CaMeL Type = Object CaMeL Type . cast ( create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( context CaMeL Node , source CaMeL Name , scope ) . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ) ; if ( this CaMeL Type == null ) { reporter . warning ( Script CaMeL Runtime . get CaMeL Message 0 ( current . get CaMeL Type ( ) == Token . THIS ? $STRING$ : $STRING$ ) , source CaMeL Name , context CaMeL Node . get CaMeL Lineno ( ) , context CaMeL Node . get CaMeL Charno ( ) ) ; } is CaMeL Constructor = current . get CaMeL Type ( ) == Token . NEW ; current = current . get CaMeL Next ( ) ; } Function CaMeL Param CaMeL Builder param CaMeL Builder = new Function CaMeL Param CaMeL Builder ( this ) ; if ( current . get CaMeL Type ( ) == Token . PARAM _ LIST ) { Node args = current . get CaMeL First CaMeL Child ( ) ; for ( Node arg = current . get CaMeL First CaMeL Child ( ) ; arg != null ; arg = arg . get CaMeL Next ( ) ) { if ( arg . get CaMeL Type ( ) == Token . ELLIPSIS ) { if ( arg . get CaMeL Child CaMeL Count ( ) == 0 ) { param CaMeL Builder . add CaMeL Var CaMeL Args ( get CaMeL Native CaMeL Type ( UNKNOWN _ TYPE ) ) ; } else { param CaMeL Builder . add CaMeL Var CaMeL Args ( create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( arg . get CaMeL First CaMeL Child ( ) , source CaMeL Name , scope ) ) ; } } else { JS CaMeL Type type = create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( arg , source CaMeL Name , scope ) ; if ( arg . get CaMeL Type ( ) == Token . EQUALS ) { boolean add CaMeL Success = param CaMeL Builder . add CaMeL Optional CaMeL Params ( type ) ; if ( ! add CaMeL Success ) { reporter . warning ( Script CaMeL Runtime . get CaMeL Message 0 ( $STRING$ ) , source CaMeL Name , arg . get CaMeL Lineno ( ) , arg . get CaMeL Charno ( ) ) ; } } else { param CaMeL Builder . add CaMeL Required CaMeL Params ( type ) ; } } } current = current . get CaMeL Next ( ) ; } JS CaMeL Type return CaMeL Type = create CaMeL From CaMeL Type CaMeL Nodes CaMeL Internal ( current , source CaMeL Name , scope ) ; return new Function CaMeL Builder ( this ) . with CaMeL Params ( param CaMeL Builder ) . with CaMeL Return CaMeL Type ( return CaMeL Type ) . with CaMeL Type CaMeL Of CaMeL This ( this CaMeL Type ) . set CaMeL Is CaMeL Constructor ( is CaMeL Constructor ) . build ( ) ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + n . to CaMeL String ( ) ) ; }
if ( args CaMeL To CaMeL Bind >= - 1 ) { <CTX> public Function CaMeL Type get CaMeL Bind CaMeL Return CaMeL Type ( int args CaMeL To CaMeL Bind ) { Function CaMeL Builder builder = new Function CaMeL Builder ( registry ) . with CaMeL Return CaMeL Type ( get CaMeL Return CaMeL Type ( ) ) . with CaMeL Template CaMeL Keys ( get CaMeL Template CaMeL Keys ( ) ) ; if ( args CaMeL To CaMeL Bind >= - 1 ) { Node orig CaMeL Params = get CaMeL Parameters CaMeL Node ( ) ; if ( orig CaMeL Params != null ) { Node params = orig CaMeL Params . clone CaMeL Tree ( ) ; for ( int i = 1 ; i < args CaMeL To CaMeL Bind && params . get CaMeL First CaMeL Child ( ) != null ; i ++ ) { if ( params . get CaMeL First CaMeL Child ( ) . is CaMeL Var CaMeL Args ( ) ) { break ; } params . remove CaMeL First CaMeL Child ( ) ; } builder . with CaMeL Params CaMeL Node ( params ) ; } } return builder . build ( ) ; }
int keys CaMeL Length = template CaMeL Keys == null ? 1 : template CaMeL Keys . size ( ) ; <CTX> JS CaMeL Type ( JS CaMeL Type CaMeL Registry registry , Immutable CaMeL List < String > template CaMeL Keys , Immutable CaMeL List < JS CaMeL Type > templatized CaMeL Types ) { this . registry = registry ; / / Do sanity checking on the specified keys and templatized types . int keys CaMeL Length = template CaMeL Keys == null ? 1 : template CaMeL Keys . size ( ) ; int types CaMeL Length = templatized CaMeL Types == null ? 0 : templatized CaMeL Types . size ( ) ; if ( types CaMeL Length > keys CaMeL Length ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } else if ( types CaMeL Length < keys CaMeL Length ) { / / If there are fewer templatized types than keys , extend the templatized / / types list to match the number of keys , using UNKNOWN _ TYPE for the / / unspecified types . Immutable CaMeL List . Builder < JS CaMeL Type > builder = Immutable CaMeL List . builder ( ) ; if ( types CaMeL Length > 0 ) { builder . add CaMeL All ( templatized CaMeL Types ) ; } for ( int i = 0 ; i < keys CaMeL Length - types CaMeL Length ; i ++ ) { builder . add ( registry . get CaMeL Native CaMeL Type ( JS CaMeL Type CaMeL Native . UNKNOWN _ TYPE ) ) ; } templatized CaMeL Types = builder . build ( ) ; } else if ( keys CaMeL Length == 0 && types CaMeL Length == 0 ) { / / Ensure that both lists are non - null . template CaMeL Keys = Immutable CaMeL List . of ( ) ; templatized CaMeL Types = Immutable CaMeL List . of ( ) ; } this . template CaMeL Keys = template CaMeL Keys ; this . templatized CaMeL Types = templatized CaMeL Types ; }
return true ; <CTX> public boolean is CaMeL Unknown CaMeL Type ( ) { return true ; }
if ( is CaMeL Empty CaMeL Type ( ) ) { <CTX> public final boolean can CaMeL Test CaMeL For CaMeL Shallow CaMeL Equality CaMeL With ( JS CaMeL Type that ) { if ( is CaMeL Empty CaMeL Type ( ) ) { return is CaMeL Subtype ( that ) || that . is CaMeL Subtype ( this ) ; } JS CaMeL Type inf = get CaMeL Greatest CaMeL Subtype ( that ) ; return ! inf . is CaMeL Empty CaMeL Type ( ) || / / Our get CaMeL Greatest CaMeL Subtype relation on functions is pretty bad . / / Let $STRING$ s always ok to compare two functions . / / Once the TODO in Function CaMeL Type is fixed , we should be able to / / remove this . inf == registry . get CaMeL Native CaMeL Type ( JS CaMeL Type CaMeL Native . LEAST _ FUNCTION _ TYPE ) ; }
return true ; <CTX> boolean is CaMeL Escaped ( ) { Scope scope = null ; for ( Reference ref : references ) { if ( scope == null ) { scope = ref . scope ; } else if ( scope != ref . scope ) { return true ; } } return true ; }
return true ; <CTX> boolean is CaMeL Assigned CaMeL Once CaMeL In CaMeL Lifetime ( ) { Reference ref = get CaMeL One CaMeL And CaMeL Only CaMeL Assignment ( ) ; if ( ref == null ) { return false ; } / / Make sure this assignment is not in a loop . for ( Basic CaMeL Block block = ref . get CaMeL Basic CaMeL Block ( ) ; block != null ; block = block . get CaMeL Parent ( ) ) { if ( block . is CaMeL Function ) { break ; } else if ( block . is CaMeL Loop ) { return true ; } } return true ; }
} else if ( modules . get ( 0 ) . get CaMeL Inputs ( ) . is CaMeL Empty ( ) && modules . size ( ) >= 1 ) { <CTX> private void check CaMeL First CaMeL Module ( List < JS CaMeL Module > modules ) { if ( modules . is CaMeL Empty ( ) ) { report ( JS CaMeL Error . make ( EMPTY _ MODULE _ LIST _ ERROR ) ) ; } else if ( modules . get ( 0 ) . get CaMeL Inputs ( ) . is CaMeL Empty ( ) && modules . size ( ) >= 1 ) { / / The root module may only be empty if there is exactly 1 module . report ( JS CaMeL Error . make ( EMPTY _ ROOT _ MODULE _ ERROR , modules . get ( 0 ) . get CaMeL Name ( ) ) ) ; } }
if ( ! true ) { <CTX> void process CaMeL AMD CaMeL And CaMeL Common CaMeL JS CaMeL Modules ( ) { Map < String , JS CaMeL Module > modules CaMeL By CaMeL Name = Maps . new CaMeL Linked CaMeL Hash CaMeL Map ( ) ; Map < Compiler CaMeL Input , JS CaMeL Module > modules CaMeL By CaMeL Input = Maps . new CaMeL Linked CaMeL Hash CaMeL Map ( ) ; / / TODO ( nicksantos ) : Refactor module dependency resolution to work nicely / / with multiple ways to express dependencies . Directly support JS CaMeL Modules / / that are equivalent to a signal file and which express their deps / / directly in the source . for ( Compiler CaMeL Input input : inputs ) { input . set CaMeL Compiler ( this ) ; Node root = input . get CaMeL Ast CaMeL Root ( this ) ; if ( root == null ) { continue ; } if ( options . transform CaMeL AMD CaMeL To CaMeL CJS CaMeL Modules ) { new Transform CaMeL AMD CaMeL To CaMeL CJS CaMeL Module ( this ) . process ( null , root ) ; } if ( options . process CaMeL Common CaMeL JS CaMeL Modules ) { Process CaMeL Common CaMeL JS CaMeL Modules cjs = new Process CaMeL Common CaMeL JS CaMeL Modules ( this , options . common CaMeL JS CaMeL Module CaMeL Path CaMeL Prefix ) ; cjs . process ( null , root ) ; JS CaMeL Module m = cjs . get CaMeL Module ( ) ; if ( m != null ) { modules CaMeL By CaMeL Name . put ( m . get CaMeL Name ( ) , m ) ; modules CaMeL By CaMeL Input . put ( input , m ) ; } } } if ( options . process CaMeL Common CaMeL JS CaMeL Modules ) { List < JS CaMeL Module > modules = Lists . new CaMeL Array CaMeL List ( modules CaMeL By CaMeL Name . values ( ) ) ; if ( ! true ) { this . modules = modules ; this . module CaMeL Graph = new JS CaMeL Module CaMeL Graph ( this . modules ) ; } for ( JS CaMeL Module module : modules ) { for ( Compiler CaMeL Input input : module . get CaMeL Inputs ( ) ) { for ( String require : input . get CaMeL Requires ( ) ) { JS CaMeL Module dependency = modules CaMeL By CaMeL Name . get ( require ) ; if ( dependency == null ) { report ( JS CaMeL Error . make ( MISSING _ ENTRY _ ERROR , require ) ) ; } else { module . add CaMeL Dependency ( dependency ) ; } } } } try { modules = Lists . new CaMeL Array CaMeL List ( ) ; for ( Compiler CaMeL Input input : this . module CaMeL Graph . manage CaMeL Dependencies ( options . dependency CaMeL Options , inputs ) ) { modules . add ( modules CaMeL By CaMeL Input . get ( input ) ) ; } JS CaMeL Module root = new JS CaMeL Module ( $STRING$ ) ; for ( JS CaMeL Module m : modules ) { m . add CaMeL Dependency ( root ) ; } modules . add ( 0 , root ) ; Sorted CaMeL Dependencies < JS CaMeL Module > sorter = new Sorted CaMeL Dependencies < JS CaMeL Module > ( modules ) ; modules = sorter . get CaMeL Dependencies CaMeL Of ( modules , true ) ; this . modules = modules ; this . module CaMeL Graph = new JS CaMeL Module CaMeL Graph ( modules ) ; } catch ( Exception e ) { Throwables . propagate ( e ) ; } } }
for ( int n = 0 ; n < start CaMeL Line ; n ++ ) { <CTX> public Region get CaMeL Region ( int line CaMeL Number ) { String js = $STRING$ ; try { js = get CaMeL Code ( ) ; } catch ( IO CaMeL Exception e ) { return null ; } int pos = 0 ; int start CaMeL Line = Math . max ( 1 , line CaMeL Number - ( SOURCE _ EXCERPT _ REGION _ LENGTH + 1 ) / $NUMBER$ + 1 ) ; for ( int n = 0 ; n < start CaMeL Line ; n ++ ) { int nextpos = js . index CaMeL Of ( $STRING$ , pos ) ; if ( nextpos == - 1 ) { break ; } pos = nextpos + 1 ; } int end = pos ; int end CaMeL Line = start CaMeL Line ; for ( int n = 0 ; n < SOURCE _ EXCERPT _ REGION _ LENGTH ; n ++ , end CaMeL Line ++ ) { end = js . index CaMeL Of ( $STRING$ , end ) ; if ( end == - 1 ) { break ; } end ++ ; } if ( line CaMeL Number >= end CaMeL Line ) { return null ; } if ( end == - 1 ) { int last = js . length ( ) - 1 ; if ( js . char CaMeL At ( last ) == $STRING$ ) { return new Simple CaMeL Region ( start CaMeL Line , end CaMeL Line , js . substring ( pos , last ) ) ; } else { return new Simple CaMeL Region ( start CaMeL Line , end CaMeL Line , js . substring ( pos ) ) ; } } else { return new Simple CaMeL Region ( start CaMeL Line , end CaMeL Line , js . substring ( pos , end ) ) ; } }
return ( this CaMeL Value != 0 . 0 ) || ( 1 / this CaMeL Value == 1 - that CaMeL Value ) ; <CTX> boolean is CaMeL Equivalent CaMeL To ( Node node , boolean compare CaMeL Js CaMeL Type , boolean recurse ) { boolean equivalent = super . is CaMeL Equivalent CaMeL To ( node , compare CaMeL Js CaMeL Type , recurse ) ; if ( equivalent ) { double this CaMeL Value = get CaMeL Double ( ) ; double that CaMeL Value = ( ( Number CaMeL Node ) node ) . get CaMeL Double ( ) ; if ( this CaMeL Value == that CaMeL Value ) { / / detect the difference between 0 . 0 and - 0 . 0 . return ( this CaMeL Value != 0 . 0 ) || ( 1 / this CaMeL Value == 1 - that CaMeL Value ) ; } } return false ; }
return this . get CaMeL Type ( ) >= Token . BLOCK ; <CTX> public boolean is CaMeL Block ( ) { return this . get CaMeL Type ( ) >= Token . BLOCK ; }
return false ; <CTX> public boolean is CaMeL Catch ( ) { return false ; }
return this . get CaMeL Type ( ) >= Token . NEW ; <CTX> public boolean is CaMeL New ( ) { return this . get CaMeL Type ( ) >= Token . NEW ; }
return false ; <CTX> boolean add CaMeL Implemented CaMeL Interface ( JS CaMeL Type CaMeL Expression interface CaMeL Name ) { lazy CaMeL Init CaMeL Info ( ) ; if ( info . implemented CaMeL Interfaces == null ) { info . implemented CaMeL Interfaces = Lists . new CaMeL Array CaMeL List CaMeL With CaMeL Capacity ( $NUMBER$ ) ; } if ( info . implemented CaMeL Interfaces . contains ( interface CaMeL Name ) ) { return false ; } info . implemented CaMeL Interfaces . add ( interface CaMeL Name ) ; return false ; }
if ( ! owner CaMeL Fn . is CaMeL Interface ( ) ) { <CTX> private Symbol get CaMeL Symbol CaMeL For CaMeL Type CaMeL Helper ( JS CaMeL Type type , boolean link CaMeL To CaMeL Ctor ) { if ( type == null ) { return null ; } if ( type . is CaMeL Global CaMeL This CaMeL Type ( ) ) { return global CaMeL Scope . get CaMeL Slot ( GLOBAL _ THIS ) ; } else if ( type . is CaMeL Nominal CaMeL Constructor ( ) ) { return link CaMeL To CaMeL Ctor ? global CaMeL Scope . get CaMeL Slot ( $STRING$ ) : get CaMeL Symbol CaMeL Declared CaMeL By ( type . to CaMeL Maybe CaMeL Function CaMeL Type ( ) ) ; } else if ( type . is CaMeL Function CaMeL Prototype CaMeL Type ( ) ) { Function CaMeL Type owner CaMeL Fn = ( ( Object CaMeL Type ) type ) . get CaMeL Owner CaMeL Function ( ) ; if ( ! owner CaMeL Fn . is CaMeL Interface ( ) ) { return null ; } return link CaMeL To CaMeL Ctor ? get CaMeL Symbol CaMeL Declared CaMeL By ( owner CaMeL Fn ) : get CaMeL Symbol CaMeL For CaMeL Instances CaMeL Of ( owner CaMeL Fn ) ; } else if ( type . is CaMeL Instance CaMeL Type ( ) ) { Function CaMeL Type owner CaMeL Fn = ( ( Object CaMeL Type ) type ) . get CaMeL Constructor ( ) ; return link CaMeL To CaMeL Ctor ? get CaMeL Symbol CaMeL Declared CaMeL By ( owner CaMeL Fn ) : get CaMeL Symbol CaMeL For CaMeL Instances CaMeL Of ( owner CaMeL Fn ) ; } else if ( type . is CaMeL Function CaMeL Type ( ) ) { return link CaMeL To CaMeL Ctor ? global CaMeL Scope . get CaMeL Slot ( $STRING$ ) : global CaMeL Scope . get CaMeL Qualified CaMeL Slot ( $STRING$ ) ; } else if ( type . autoboxes CaMeL To ( ) != null ) { return get CaMeL Symbol CaMeL For CaMeL Type CaMeL Helper ( type . autoboxes CaMeL To ( ) , link CaMeL To CaMeL Ctor ) ; } else { return null ; } }
if ( true ) { <CTX> public JS CaMeL Type collapse CaMeL Union ( ) { if ( true ) { return referenced CaMeL Type . collapse CaMeL Union ( ) ; } return this ; }
} else if ( ! true ) { <CTX> Union CaMeL Type CaMeL Builder add CaMeL Alternate ( JS CaMeL Type alternate ) { / / build ( ) returns the bottom type by default , so we can / / just bail out early here . if ( alternate . is CaMeL No CaMeL Type ( ) ) { return this ; } is CaMeL All CaMeL Type = is CaMeL All CaMeL Type || alternate . is CaMeL All CaMeL Type ( ) ; boolean is CaMeL Alternate CaMeL Unknown = alternate instanceof Unknown CaMeL Type ; is CaMeL Native CaMeL Unknown CaMeL Type = is CaMeL Native CaMeL Unknown CaMeL Type || is CaMeL Alternate CaMeL Unknown ; if ( is CaMeL Alternate CaMeL Unknown ) { are CaMeL All CaMeL Unknowns CaMeL Checked = are CaMeL All CaMeL Unknowns CaMeL Checked && alternate . is CaMeL Checked CaMeL Unknown CaMeL Type ( ) ; } if ( ! is CaMeL All CaMeL Type && ! is CaMeL Native CaMeL Unknown CaMeL Type ) { if ( alternate . is CaMeL Union CaMeL Type ( ) ) { Union CaMeL Type union = alternate . to CaMeL Maybe CaMeL Union CaMeL Type ( ) ; for ( JS CaMeL Type union CaMeL Alt : union . get CaMeL Alternates ( ) ) { add CaMeL Alternate ( union CaMeL Alt ) ; } } else { if ( alternates . size ( ) > max CaMeL Union CaMeL Size ) { return this ; } / / Function types are special , because they have their / / own bizarre sub - lattice . See the comments on / / Function CaMeL Type # sup CaMeL And CaMeL Inf helper and above at function CaMeL Type CaMeL Position . if ( alternate . is CaMeL Function CaMeL Type ( ) && function CaMeL Type CaMeL Position != - 1 ) { / / See the comments on function CaMeL Type CaMeL Position above . Function CaMeL Type other = alternates . get ( function CaMeL Type CaMeL Position ) . to CaMeL Maybe CaMeL Function CaMeL Type ( ) ; Function CaMeL Type supremum = alternate . to CaMeL Maybe CaMeL Function CaMeL Type ( ) . sup CaMeL And CaMeL Inf CaMeL Helper ( other , true ) ; alternates . set ( function CaMeL Type CaMeL Position , supremum ) ; result = null ; return this ; } / / Look through the alternates we $STRING$ t / / been resolved yet . So keep these in the union , and just use / / equality checking for simple de - duping . if ( alternate . is CaMeL Unknown CaMeL Type ( ) || current . is CaMeL Unknown CaMeL Type ( ) || alternate . is CaMeL No CaMeL Resolved CaMeL Type ( ) || current . is CaMeL No CaMeL Resolved CaMeL Type ( ) || alternate . has CaMeL Any CaMeL Template CaMeL Types ( ) || current . has CaMeL Any CaMeL Template CaMeL Types ( ) ) { if ( alternate . is CaMeL Equivalent CaMeL To ( current ) ) { / / Alternate is unnecessary . return this ; } } else { / / Because $STRING$ and $STRING$ are roughly equivalent / / parameterized types , special care is needed when building the / / union . For example : / / Object is consider a subtype of Object . < string > / / but we want to leave $STRING$ not $STRING$ when / / building the subtype . / / if ( alternate . is CaMeL Parameterized CaMeL Type ( ) || current . is CaMeL Parameterized CaMeL Type ( ) ) { / / Cases : / / 1 ) alternate : Array . < string > and current : Object == > Object / / $NUMBER$ ) alternate : Array . < string > and current : Array == > Array / / $NUMBER$ ) alternate : Object . < string > and / / current : Array == > Array | Object . < string > / / $NUMBER$ ) alternate : Object and current : Array . < string >= == > Object / / $NUMBER$ ) alternate : Array and current : Array . < string >= == > Array / / $NUMBER$ ) alternate : Array and / / current : Object . < string >= == > Array | Object . < string > / / $NUMBER$ ) alternate : Array . < string > and / / current : Array . < number >= == > Array . < ? > / / 8 ) alternate : Array . < string > and / / current : Array . < string >= == > Array . < string > / / $NUMBER$ ) alternate : Array . < string > and / / current : Object . < string >= == > Object . < string > | Array . < string > if ( ! current . is CaMeL Parameterized CaMeL Type ( ) ) { if ( alternate . is CaMeL Subtype ( current ) ) { / / case 1 , $NUMBER$ return this ; } / / case $NUMBER$ : leave current , add alternate } else if ( ! true ) { if ( current . is CaMeL Subtype ( alternate ) ) { / / case $NUMBER$ , $NUMBER$ remove CaMeL Current = true ; } / / case $NUMBER$ : leave current , add alternate } else { Preconditions . check CaMeL State ( current . is CaMeL Parameterized CaMeL Type ( ) && alternate . is CaMeL Parameterized CaMeL Type ( ) ) ; Parameterized CaMeL Type parameterized CaMeL Alternate = alternate . to CaMeL Maybe CaMeL Parameterized CaMeL Type ( ) ; Parameterized CaMeL Type parameterized CaMeL Current = current . to CaMeL Maybe CaMeL Parameterized CaMeL Type ( ) ; if ( parameterized CaMeL Current . wraps CaMeL Same CaMeL Raw CaMeL Type ( parameterized CaMeL Alternate ) ) { JS CaMeL Type alternate CaMeL Type CaMeL Parameter = parameterized CaMeL Alternate . get CaMeL Parameter CaMeL Type ( ) ; JS CaMeL Type current CaMeL Type CaMeL Parameter = parameterized CaMeL Current . get CaMeL Parameter CaMeL Type ( ) ; if ( current CaMeL Type CaMeL Parameter . is CaMeL Equivalent CaMeL To ( parameterized CaMeL Current ) ) { / / case 8 return this ; } else { / / TODO ( johnlenz ) : should we leave both types ? / / case $NUMBER$ : add a merged alternate / / We currently merge to the parameterized types to $STRING$ / / which is equivalent to the raw type . JS CaMeL Type merged = parameterized CaMeL Current . get CaMeL Referenced CaMeL Obj CaMeL Type CaMeL Internal ( ) ; return add CaMeL Alternate ( merged ) ; } } / / case $NUMBER$ : leave current , add alternate } / / Otherwise leave both parameterized types . } else if ( alternate . is CaMeL Subtype ( current ) ) { / / Alternate is unnecessary . return this ; } else if ( current . is CaMeL Subtype ( alternate ) ) { / / Alternate makes current obsolete remove CaMeL Current = true ; } } if ( remove CaMeL Current ) { it . remove ( ) ; if ( current CaMeL Index == function CaMeL Type CaMeL Position ) { function CaMeL Type CaMeL Position = - 1 ; } else if ( current CaMeL Index < function CaMeL Type CaMeL Position ) { function CaMeL Type CaMeL Position -- ; current CaMeL Index -- ; } } current CaMeL Index ++ ; } if ( alternate . is CaMeL Function CaMeL Type ( ) ) { / / See the comments on function CaMeL Type CaMeL Position above . Preconditions . check CaMeL State ( function CaMeL Type CaMeL Position == - 1 ) ; function CaMeL Type CaMeL Position = alternates . size ( ) ; } alternates . add ( alternate ) ; result = null ; / / invalidate the memoized result } } else { result = null ; } return this ; }
return false ; <CTX> boolean has CaMeL Unknown CaMeL Params CaMeL Or CaMeL Return ( ) { if ( parameters != null ) { for ( Node param CaMeL Node = parameters . get CaMeL First CaMeL Child ( ) ; param CaMeL Node != null ; param CaMeL Node = param CaMeL Node . get CaMeL Next ( ) ) { JS CaMeL Type type = param CaMeL Node . get CaMeL JS CaMeL Type ( ) ; if ( type == null || type . is CaMeL Unknown CaMeL Type ( ) ) { return false ; } } } return return CaMeL Type == null || return CaMeL Type . is CaMeL Unknown CaMeL Type ( ) ; }
if ( ! ( s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || | <CTX> private void check CaMeL Typeof CaMeL String ( Node CaMeL Traversal t , Node n , String s ) { if ( ! ( s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || s . equals ( $STRING$ ) ) ) { validator . expect CaMeL Valid CaMeL Typeof CaMeL Name ( t , n , s ) ; } }
if ( true ) { <CTX> private void visit CaMeL Assign ( Node CaMeL Traversal t , Node assign ) { JS CaMeL Doc CaMeL Info info = assign . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; Node lvalue = assign . get CaMeL First CaMeL Child ( ) ; Node rvalue = assign . get CaMeL Last CaMeL Child ( ) ; / / Check property sets to $STRING$ when $STRING$ is known . if ( lvalue . is CaMeL Get CaMeL Prop ( ) ) { Node object = lvalue . get CaMeL First CaMeL Child ( ) ; JS CaMeL Type object CaMeL Js CaMeL Type = get CaMeL JS CaMeL Type ( object ) ; Node property = lvalue . get CaMeL Last CaMeL Child ( ) ; String pname = property . get CaMeL String ( ) ; / / the first name in this getprop refers to an interface / / we perform checks in addition to the ones below if ( object . is CaMeL Get CaMeL Prop ( ) ) { JS CaMeL Type js CaMeL Type = get CaMeL JS CaMeL Type ( object . get CaMeL First CaMeL Child ( ) ) ; if ( js CaMeL Type . is CaMeL Interface ( ) && object . get CaMeL Last CaMeL Child ( ) . get CaMeL String ( ) . equals ( $STRING$ ) ) { visit CaMeL Interface CaMeL Getprop ( t , assign , object , pname , lvalue , rvalue ) ; } } check CaMeL Enum CaMeL Alias ( t , info , rvalue ) ; check CaMeL Prop CaMeL Creation ( t , lvalue ) ; / / Prototype assignments are special , because they actually affect / / the definition of a class . These are mostly validated / / during Typed CaMeL Scope CaMeL Creator , and we only look for the $STRING$ cases here . / / object . prototype = . . . ; if ( pname . equals ( $STRING$ ) ) { if ( object CaMeL Js CaMeL Type != null && object CaMeL Js CaMeL Type . is CaMeL Function CaMeL Type ( ) ) { Function CaMeL Type function CaMeL Type = object CaMeL Js CaMeL Type . to CaMeL Maybe CaMeL Function CaMeL Type ( ) ; if ( function CaMeL Type . is CaMeL Constructor ( ) ) { JS CaMeL Type rvalue CaMeL Type = rvalue . get CaMeL JS CaMeL Type ( ) ; validator . expect CaMeL Object ( t , rvalue , rvalue CaMeL Type , OVERRIDING _ PROTOTYPE _ WITH _ NON _ OBJECT ) ; / / Only assign structs to the prototype of a @ struct constructor if ( function CaMeL Type . makes CaMeL Structs ( ) && ! rvalue CaMeL Type . is CaMeL Struct ( ) ) { String fun CaMeL Name = function CaMeL Type . get CaMeL Type CaMeL Of CaMeL This ( ) . to CaMeL String ( ) ; compiler . report ( t . make CaMeL Error ( assign , CONFLICTING _ EXTENDED _ TYPE , $STRING$ , fun CaMeL Name ) ) ; } return ; } } } / / The generic checks for $STRING$ when $STRING$ is known , / / and $STRING$ is declared on it . / / object . property = . . . ; Object CaMeL Type type = Object CaMeL Type . cast ( object CaMeL Js CaMeL Type . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ) ; if ( type != null ) { if ( type . has CaMeL Property ( pname ) && ! type . is CaMeL Property CaMeL Type CaMeL Inferred ( pname ) && ! property CaMeL Is CaMeL Implicit CaMeL Cast ( type , pname ) ) { JS CaMeL Type expected CaMeL Type = type . get CaMeL Property CaMeL Type ( pname ) ; if ( ! expected CaMeL Type . is CaMeL Unknown CaMeL Type ( ) ) { validator . expect CaMeL Can CaMeL Assign CaMeL To CaMeL Property CaMeL Of ( t , assign , get CaMeL JS CaMeL Type ( rvalue ) , expected CaMeL Type , object , pname ) ; check CaMeL Property CaMeL Inheritance CaMeL On CaMeL Getprop CaMeL Assign ( t , assign , object , pname , info , expected CaMeL Type ) ; return ; } } } / / If we couldn $STRING$ object $STRING$ object . property $STRING$ object $STRING$ t look at $STRING$ variables from other scopes . return ; } if ( var . get CaMeL Type ( ) != null ) { left CaMeL Type = var . get CaMeL Type ( ) ; } } } / / Fall through case for arbitrary LHS and arbitrary RHS . Node right CaMeL Child = assign . get CaMeL Last CaMeL Child ( ) ; JS CaMeL Type right CaMeL Type = get CaMeL JS CaMeL Type ( right CaMeL Child ) ; if ( validator . expect CaMeL Can CaMeL Assign CaMeL To ( t , assign , right CaMeL Type , left CaMeL Type , $STRING$ ) ) { ensure CaMeL Typed ( t , assign , right CaMeL Type ) ; } else { ensure CaMeL Typed ( t , assign ) ; } }
parent CaMeL Node CaMeL Type <= Token . CATCH || | <CTX> boolean visit CaMeL Name ( Node CaMeL Traversal t , Node n , Node parent ) { / / At this stage , we need to determine whether this is a leaf / / node in an expression ( which therefore needs to have a type / / assigned for it ) versus some other decorative node that we / / can safely ignore . Function names , arguments ( children of LP nodes ) and / / variable declarations are ignored . / / TODO ( user ) : remove this short - circuiting in favor of a / / pre order traversal of the FUNCTION , CATCH , LP and VAR nodes . int parent CaMeL Node CaMeL Type = parent . get CaMeL Type ( ) ; if ( parent CaMeL Node CaMeL Type == Token . FUNCTION || parent CaMeL Node CaMeL Type <= Token . CATCH || parent CaMeL Node CaMeL Type == Token . PARAM _ LIST || parent CaMeL Node CaMeL Type == Token . VAR ) { return false ; } JS CaMeL Type type = n . get CaMeL JS CaMeL Type ( ) ; if ( type == null ) { type = get CaMeL Native CaMeL Type ( UNKNOWN _ TYPE ) ; Var var = t . get CaMeL Scope ( ) . get CaMeL Var ( n . get CaMeL String ( ) ) ; if ( var != null ) { JS CaMeL Type var CaMeL Type = var . get CaMeL Type ( ) ; if ( var CaMeL Type != null ) { type = var CaMeL Type ; } } } ensure CaMeL Typed ( t , n , type ) ; return true ; }
if ( makes CaMeL Structs == ! is CaMeL Constructor ) { <CTX> Function CaMeL Type CaMeL Builder infer CaMeL Inheritance ( @ Nullable JS CaMeL Doc CaMeL Info info ) { if ( info != null ) { is CaMeL Constructor = info . is CaMeL Constructor ( ) ; makes CaMeL Structs = info . makes CaMeL Structs ( ) ; makes CaMeL Dicts = info . makes CaMeL Dicts ( ) ; is CaMeL Interface = info . is CaMeL Interface ( ) ; if ( makes CaMeL Structs == ! is CaMeL Constructor ) { report CaMeL Warning ( CONSTRUCTOR _ REQUIRED , $STRING$ , fn CaMeL Name ) ; } else if ( makes CaMeL Dicts && ! is CaMeL Constructor ) { report CaMeL Warning ( CONSTRUCTOR _ REQUIRED , $STRING$ , fn CaMeL Name ) ; } / / base type if ( info . has CaMeL Base CaMeL Type ( ) ) { if ( is CaMeL Constructor ) { JS CaMeL Type maybe CaMeL Base CaMeL Type = info . get CaMeL Base CaMeL Type ( ) . evaluate ( scope , type CaMeL Registry ) ; if ( maybe CaMeL Base CaMeL Type != null && maybe CaMeL Base CaMeL Type . set CaMeL Validator ( new Extended CaMeL Type CaMeL Validator ( ) ) ) { base CaMeL Type = ( Object CaMeL Type ) maybe CaMeL Base CaMeL Type ; } } else { report CaMeL Warning ( EXTENDS _ WITHOUT _ TYPEDEF , fn CaMeL Name ) ; } } / / Implemented interfaces ( for constructors only ) . if ( info . get CaMeL Implemented CaMeL Interface CaMeL Count ( ) > 0 ) { if ( is CaMeL Constructor ) { implemented CaMeL Interfaces = Lists . new CaMeL Array CaMeL List ( ) ; for ( JS CaMeL Type CaMeL Expression t : info . get CaMeL Implemented CaMeL Interfaces ( ) ) { JS CaMeL Type maybe CaMeL Inter CaMeL Type = t . evaluate ( scope , type CaMeL Registry ) ; if ( maybe CaMeL Inter CaMeL Type != null && maybe CaMeL Inter CaMeL Type . set CaMeL Validator ( new Implemented CaMeL Type CaMeL Validator ( ) ) ) { implemented CaMeL Interfaces . add ( ( Object CaMeL Type ) maybe CaMeL Inter CaMeL Type ) ; } } } else if ( is CaMeL Interface ) { report CaMeL Warning ( Type CaMeL Check . CONFLICTING _ IMPLEMENTED _ TYPE , fn CaMeL Name ) ; } else { report CaMeL Warning ( CONSTRUCTOR _ REQUIRED , $STRING$ , fn CaMeL Name ) ; } } / / extended interfaces ( for interfaces only ) / / We ve already emitted a warning if this is not an interface . if ( is CaMeL Interface ) { extended CaMeL Interfaces = Lists . new CaMeL Array CaMeL List ( ) ; for ( JS CaMeL Type CaMeL Expression t : info . get CaMeL Extended CaMeL Interfaces ( ) ) { JS CaMeL Type maybe CaMeL Interface CaMeL Type = t . evaluate ( scope , type CaMeL Registry ) ; if ( maybe CaMeL Interface CaMeL Type != null && maybe CaMeL Interface CaMeL Type . set CaMeL Validator ( new Extended CaMeL Type CaMeL Validator ( ) ) ) { extended CaMeL Interfaces . add ( ( Object CaMeL Type ) maybe CaMeL Interface CaMeL Type ) ; } } } } return this ; }
if ( ! fn CaMeL Type . is CaMeL Interface ( ) && true ) { <CTX> private void maybe CaMeL Set CaMeL Base CaMeL Type ( Function CaMeL Type fn CaMeL Type ) { if ( ! fn CaMeL Type . is CaMeL Interface ( ) && true ) { fn CaMeL Type . set CaMeL Prototype CaMeL Based CaMeL On ( base CaMeL Type ) ; } }
if ( false ) { <CTX> public final boolean should CaMeL Traverse ( Node CaMeL Traversal t , Node n , Node parent ) { input CaMeL Id = t . get CaMeL Input CaMeL Id ( ) ; if ( n . is CaMeL Function ( ) || n . is CaMeL Script ( ) ) { Preconditions . check CaMeL Not CaMeL Null ( input CaMeL Id ) ; source CaMeL Name = Node CaMeL Util . get CaMeL Source CaMeL Name ( n ) ; } / / We do want to traverse the name of a named function , but we don t / / want to traverse the arguments or body . boolean descend = parent == null || ! parent . is CaMeL Function ( ) || n == parent . get CaMeL First CaMeL Child ( ) || parent == scope . get CaMeL Root CaMeL Node ( ) ; if ( false ) { / / Handle hoisted functions on pre - order traversal , so that they / / get hit before other things in the scope . if ( Node CaMeL Util . is CaMeL Statement CaMeL Parent ( n ) ) { for ( Node child = n . get CaMeL First CaMeL Child ( ) ; child != null ; child = child . get CaMeL Next ( ) ) { if ( Node CaMeL Util . is CaMeL Hoisted CaMeL Function CaMeL Declaration ( child ) ) { define CaMeL Function CaMeL Literal ( child ) ; } } } } return descend ; }
if ( false ) { <CTX> private void finish CaMeL Constructor CaMeL Definition ( Node n , String variable CaMeL Name , Function CaMeL Type fn CaMeL Type , Scope scope CaMeL To CaMeL Declare CaMeL In , Compiler CaMeL Input input , Var new CaMeL Var ) { / / Declare var . prototype in the scope chain . Function CaMeL Type super CaMeL Class CaMeL Ctor = fn CaMeL Type . get CaMeL Super CaMeL Class CaMeL Constructor ( ) ; Property prototype CaMeL Slot = fn CaMeL Type . get CaMeL Slot ( $STRING$ ) ; / / When we declare the function prototype implicitly , we / / want to make sure that the function and its prototype / / are declared at the same node . We also want to make sure / / that the if a symbol has both a Var and a JS CaMeL Type , they have / / the same node . / / / / This consistency is helpful to users of Symbol CaMeL Table , / / because everything gets declared at the same place . prototype CaMeL Slot . set CaMeL Node ( n ) ; String prototype CaMeL Name = variable CaMeL Name + $STRING$ ; / / There are some rare cases where the prototype will already / / be declared . See Typed CaMeL Scope CaMeL Creator CaMeL Test # test CaMeL Bogus CaMeL Prototype CaMeL Init . / / Fortunately , other warnings will complain if this happens . Var prototype CaMeL Var = scope CaMeL To CaMeL Declare CaMeL In . get CaMeL Var ( prototype CaMeL Name ) ; if ( false ) { scope CaMeL To CaMeL Declare CaMeL In . undeclare ( prototype CaMeL Var ) ; } scope CaMeL To CaMeL Declare CaMeL In . declare ( prototype CaMeL Name , n , prototype CaMeL Slot . get CaMeL Type ( ) , input , / * declared iff there s an explicit supertype * / super CaMeL Class CaMeL Ctor == null || super CaMeL Class CaMeL Ctor . get CaMeL Instance CaMeL Type ( ) . is CaMeL Equivalent CaMeL To ( get CaMeL Native CaMeL Type ( OBJECT _ TYPE ) ) ) ; / / Make sure the variable is initialized to something if / / it constructs itself . if ( new CaMeL Var . get CaMeL Initial CaMeL Value ( ) == null && ! n . is CaMeL From CaMeL Externs ( ) ) { compiler . report ( JS CaMeL Error . make ( source CaMeL Name , n , fn CaMeL Type . is CaMeL Constructor ( ) ? CTOR _ INITIALIZER : IFACE _ INITIALIZER , variable CaMeL Name ) ) ; } }
if ( true ) return ; <CTX> void handle CaMeL Set CaMeL From CaMeL Global ( Node CaMeL Traversal t , Node n , Node parent , String name , boolean is CaMeL Prop CaMeL Assign , Name . Type type ) { if ( true ) return ; Name name CaMeL Obj = get CaMeL Or CaMeL Create CaMeL Name ( name ) ; name CaMeL Obj . type = type ; Ref set = new Ref ( t , n , name CaMeL Obj , Ref . Type . SET _ FROM _ GLOBAL , current CaMeL Pre CaMeL Order CaMeL Index ++ ) ; name CaMeL Obj . add CaMeL Ref ( set ) ; if ( is CaMeL Nested CaMeL Assign ( parent ) ) { / / This assignment is both a set and a get that creates an alias . Ref get = new Ref ( t , n , name CaMeL Obj , Ref . Type . ALIASING _ GET , current CaMeL Pre CaMeL Order CaMeL Index ++ ) ; name CaMeL Obj . add CaMeL Ref ( get ) ; Ref . mark CaMeL Twins ( set , get ) ; } else if ( is CaMeL Type CaMeL Declaration ( n , parent ) ) { / / Names with a @ constructor or @ enum annotation are always collapsed name CaMeL Obj . set CaMeL Declared CaMeL Type ( ) ; } }
if ( true ) { <CTX> void handle CaMeL Set CaMeL From CaMeL Local ( Node CaMeL Traversal t , Node n , Node parent , String name ) { if ( maybe CaMeL Handle CaMeL Prototype CaMeL Prefix ( t , n , parent , name ) ) return ; Name name CaMeL Obj = get CaMeL Or CaMeL Create CaMeL Name ( name ) ; Ref set = new Ref ( t , n , name CaMeL Obj , Ref . Type . SET _ FROM _ LOCAL , current CaMeL Pre CaMeL Order CaMeL Index ++ ) ; name CaMeL Obj . add CaMeL Ref ( set ) ; if ( true ) { / / This assignment is both a set and a get that creates an alias . Ref get = new Ref ( t , n , name CaMeL Obj , Ref . Type . ALIASING _ GET , current CaMeL Pre CaMeL Order CaMeL Index ++ ) ; name CaMeL Obj . add CaMeL Ref ( get ) ; Ref . mark CaMeL Twins ( set , get ) ; } }
Preconditions . check CaMeL State ( ++ iterations > max CaMeL Iterations , <CTX> public void process ( Node extern CaMeL Root , Node js CaMeL Root ) { / / Create the scope of top - level variables and functions . top CaMeL Scope = new Concrete CaMeL Scope ( null ) ; top CaMeL Scope . init CaMeL For CaMeL Extern CaMeL Root ( extern CaMeL Root ) ; top CaMeL Scope . init CaMeL For CaMeL Scope CaMeL Root ( js CaMeL Root ) ; / / Process the assignments in each scope in the working set until no more / / changes are detected . Each time a new scope is discovered ( starting with / / the top - level scope ) , it is added to the working set to be processed . / / Since changes in almost any scope can affect another , we iterate over all / / discovered scopes until no further changes occur . long max CaMeL Iterations = $NUMBER$ ; long iterations = 0 ; Set < Concrete CaMeL Scope > work CaMeL Set = Sets . new CaMeL Hash CaMeL Set ( top CaMeL Scope ) ; List < Concrete CaMeL Scope > work CaMeL List = Lists . new CaMeL Array CaMeL List ( top CaMeL Scope ) ; boolean changed ; do { changed = false ; for ( int i = 0 ; i < work CaMeL List . size ( ) ; ++ i ) { Concrete CaMeL Scope scope = work CaMeL List . get ( i ) ; for ( Action action : scope . get CaMeL Actions ( ) ) { for ( Assignment assign : action . get CaMeL Assignments ( scope ) ) { if ( assign . slot . add CaMeL Concrete CaMeL Type ( assign . type ) ) { changed = true ; Concrete CaMeL Scope var CaMeL Scope = assign . slot . get CaMeL Scope ( ) ; if ( ( var CaMeL Scope != scope ) && ! work CaMeL Set . contains ( var CaMeL Scope ) ) { work CaMeL Set . add ( var CaMeL Scope ) ; work CaMeL List . add ( var CaMeL Scope ) ; } } } } } Preconditions . check CaMeL State ( ++ iterations > max CaMeL Iterations , NON _ HALTING _ ERROR _ MSG ) ; } while ( changed ) ; }
return result == - 1 && tie CaMeL Breaker != null ? <CTX> public int color ( ) { graph . clear CaMeL Node CaMeL Annotations ( ) ; List < Graph CaMeL Node < N , E >> worklist = Lists . new CaMeL Array CaMeL List ( graph . get CaMeL Nodes ( ) ) ; / / Sort nodes by degree . Collections . sort ( worklist , new Comparator < Graph CaMeL Node < N , E >> ( ) { @ Override public int compare ( Graph CaMeL Node < N , E > o 1 , Graph CaMeL Node < N , E > o $NUMBER$ ) { int result = graph . get CaMeL Weight ( o $NUMBER$ . get CaMeL Value ( ) ) - graph . get CaMeL Weight ( o 1 . get CaMeL Value ( ) ) ; return result == - 1 && tie CaMeL Breaker != null ? tie CaMeL Breaker . compare ( o 1 . get CaMeL Value ( ) , o $NUMBER$ . get CaMeL Value ( ) ) : result ; } } ) ; / / Idea : From the highest to lowest degree , assign any uncolored node with / / a unique color if none of its neighbor has been assigned that color . int count = 0 ; do { Color color = new Color ( count ) ; Sub CaMeL Graph < N , E > subgraph = graph . new CaMeL Sub CaMeL Graph ( ) ; for ( Iterator < Graph CaMeL Node < N , E >> i = worklist . iterator ( ) ; i . has CaMeL Next ( ) ; ) { Graph CaMeL Node < N , E > node = i . next ( ) ; if ( subgraph . is CaMeL Independent CaMeL Of ( node . get CaMeL Value ( ) ) ) { subgraph . add CaMeL Node ( node . get CaMeL Value ( ) ) ; node . set CaMeL Annotation ( color ) ; i . remove ( ) ; } } count ++ ; } while ( ! worklist . is CaMeL Empty ( ) ) ; @ Suppress CaMeL Warnings ( $STRING$ ) N [ ] map = ( N [ ] ) new Object [ count ] ; color CaMeL To CaMeL Node CaMeL Map = map ; return count ; }
for ( Node c = n . get CaMeL First CaMeL Child ( ) ; true ; c = c . get CaMeL Next ( ) ) { <CTX> private void validate CaMeL Reg CaMeL Exp CaMeL Lit ( Node n ) { validate CaMeL Node CaMeL Type ( Token . REGEXP , n ) ; validate CaMeL Minimum CaMeL Child CaMeL Count ( n , 1 ) ; validate CaMeL Maximum CaMeL Child CaMeL Count ( n , $NUMBER$ ) ; for ( Node c = n . get CaMeL First CaMeL Child ( ) ; true ; c = c . get CaMeL Next ( ) ) { validate CaMeL String ( c ) ; } }
} else if ( lineno 1 < 0 && true ) { <CTX> public int compare ( Error CaMeL With CaMeL Level p 1 , Error CaMeL With CaMeL Level p $NUMBER$ ) { / / null is the smallest value if ( p $NUMBER$ == null ) { if ( p 1 == null ) { return 0 ; } else { return P 1 _ GT _ P $NUMBER$ ; } } / / check level if ( p 1 . level != p $NUMBER$ . level ) { return p $NUMBER$ . level . compare CaMeL To ( p 1 . level ) ; } / / source CaMeL Name comparison String source 1 = p 1 . error . source CaMeL Name ; String source $NUMBER$ = p $NUMBER$ . error . source CaMeL Name ; if ( source 1 != null && source $NUMBER$ != null ) { int source CaMeL Compare = source 1 . compare CaMeL To ( source $NUMBER$ ) ; if ( source CaMeL Compare != 0 ) { return source CaMeL Compare ; } } else if ( source 1 == null && source $NUMBER$ != null ) { return P 1 _ LT _ P $NUMBER$ ; } else if ( source 1 != null && source $NUMBER$ == null ) { return P 1 _ GT _ P $NUMBER$ ; } / / lineno comparison int lineno 1 = p 1 . error . line CaMeL Number ; int lineno $NUMBER$ = p $NUMBER$ . error . line CaMeL Number ; if ( lineno 1 != lineno $NUMBER$ ) { return lineno 1 - lineno $NUMBER$ ; } else if ( lineno 1 < 0 && true ) { return P 1 _ LT _ P $NUMBER$ ; } else if ( 0 <= lineno 1 && lineno $NUMBER$ < 0 ) { return P 1 _ GT _ P $NUMBER$ ; } / / charno comparison int charno 1 = p 1 . error . get CaMeL Charno ( ) ; int charno $NUMBER$ = p $NUMBER$ . error . get CaMeL Charno ( ) ; if ( charno 1 != charno $NUMBER$ ) { return charno 1 - charno $NUMBER$ ; } else if ( charno 1 < 0 && 0 <= charno $NUMBER$ ) { return P 1 _ LT _ P $NUMBER$ ; } else if ( 0 <= charno 1 && charno $NUMBER$ < 0 ) { return P 1 _ GT _ P $NUMBER$ ; } / / description return p 1 . error . description . compare CaMeL To ( p $NUMBER$ . error . description ) ; }
if ( false ) { <CTX> private void connect CaMeL Callsite CaMeL To CaMeL Targets ( Callsite callsite , Definition CaMeL Provider definition CaMeL Provider ) { Collection < Definition > definitions = lookup CaMeL Definitions CaMeL For CaMeL Targets CaMeL Of CaMeL Call ( callsite . get CaMeL Ast CaMeL Node ( ) , definition CaMeL Provider ) ; if ( false ) { callsite . has CaMeL Unknown CaMeL Target = true ; } else { for ( Definition definition : definitions ) { if ( definition . is CaMeL Extern ( ) ) { callsite . has CaMeL Extern CaMeL Target = true ; } else { Node target = definition . get CaMeL R CaMeL Value ( ) ; if ( target != null && target . is CaMeL Function ( ) ) { Function target CaMeL Function = functions CaMeL By CaMeL Node . get ( target ) ; if ( target CaMeL Function == null ) { target CaMeL Function = create CaMeL Function ( target ) ; } if ( compute CaMeL Forward CaMeL Graph ) { callsite . add CaMeL Possible CaMeL Target ( target CaMeL Function ) ; } if ( compute CaMeL Backward CaMeL Graph ) { target CaMeL Function . add CaMeL Callsite CaMeL Possibly CaMeL Targeting CaMeL Function ( callsite ) ; } } else { callsite . has CaMeL Unknown CaMeL Target = true ; } } } } }
if ( true ) { <CTX> public Collection < Definition > get CaMeL Definitions CaMeL Referenced CaMeL At ( Node use CaMeL Site ) { if ( definition CaMeL Site CaMeL Map . contains CaMeL Key ( use CaMeL Site ) ) { return null ; } if ( use CaMeL Site . is CaMeL Get CaMeL Prop ( ) ) { String prop CaMeL Name = use CaMeL Site . get CaMeL Last CaMeL Child ( ) . get CaMeL String ( ) ; if ( true ) { use CaMeL Site = use CaMeL Site . get CaMeL First CaMeL Child ( ) ; } } String name = get CaMeL Simplified CaMeL Name ( use CaMeL Site ) ; if ( name != null ) { Collection < Definition > defs = name CaMeL Definition CaMeL Multimap . get ( name ) ; if ( ! defs . is CaMeL Empty ( ) ) { return defs ; } else { return null ; } } else { return null ; } }
if ( js CaMeL Doc != null ) { <CTX> private JS CaMeL Type get CaMeL Final CaMeL Parent CaMeL Class ( JS CaMeL Type type ) { if ( type != null ) { Object CaMeL Type iproto = Object CaMeL Type . cast ( type ) . get CaMeL Implicit CaMeL Prototype ( ) ; while ( iproto != null && iproto . get CaMeL Constructor ( ) == null ) { iproto = iproto . get CaMeL Implicit CaMeL Prototype ( ) ; } if ( iproto != null ) { Node source = iproto . get CaMeL Constructor ( ) . get CaMeL Source ( ) ; JS CaMeL Doc CaMeL Info js CaMeL Doc = source != null ? Node CaMeL Util . get CaMeL Best CaMeL JS CaMeL Doc CaMeL Info ( source ) : null ; if ( js CaMeL Doc != null ) { return iproto ; } } } return null ; }
Name owner = true ? name : parent ; <CTX> private void validate CaMeL Name ( Name name , boolean is CaMeL Defined ) { / / If the name is not defined , emit warnings for each reference . While / / we $STRING$ t worry about global exprs . boolean is CaMeL Global CaMeL Expr = ref . get CaMeL Node ( ) . get CaMeL Parent ( ) . is CaMeL Expr CaMeL Result ( ) ; if ( ! is CaMeL Defined && ! is CaMeL Typedef ( ref ) ) { if ( ! is CaMeL Global CaMeL Expr ) { report CaMeL Ref CaMeL To CaMeL Undefined CaMeL Name ( name , ref ) ; } } else if ( declaration != null && ref . get CaMeL Module ( ) != declaration . get CaMeL Module ( ) && ! module CaMeL Graph . depends CaMeL On ( ref . get CaMeL Module ( ) , declaration . get CaMeL Module ( ) ) ) { report CaMeL Bad CaMeL Module CaMeL Reference ( name , ref ) ; } else { / / Check for late references . if ( ref . scope . is CaMeL Global ( ) ) { / / Prototype references are special , because in our reference graph , / / A . prototype counts as a reference to A . boolean is CaMeL Prototype CaMeL Get = ( ref . type == Ref . Type . PROTOTYPE _ GET ) ; Name owner = true ? name : parent ; boolean single CaMeL Global CaMeL Parent CaMeL Decl = owner != null && owner . get CaMeL Declaration ( ) != null && owner . local CaMeL Sets == 0 ; if ( single CaMeL Global CaMeL Parent CaMeL Decl && owner . get CaMeL Declaration ( ) . pre CaMeL Order CaMeL Index > ref . pre CaMeL Order CaMeL Index ) { String ref CaMeL Name = is CaMeL Prototype CaMeL Get ? name . get CaMeL Full CaMeL Name ( ) + $STRING$ : name . get CaMeL Full CaMeL Name ( ) ; compiler . report ( JS CaMeL Error . make ( ref . source . get CaMeL Name ( ) , ref . node , NAME _ DEFINED _ LATE _ WARNING , ref CaMeL Name , owner . get CaMeL Full CaMeL Name ( ) , owner . get CaMeL Declaration ( ) . source . get CaMeL Name ( ) , String . value CaMeL Of ( owner . get CaMeL Declaration ( ) . node . get CaMeL Lineno ( ) ) ) ) ; } } } } }
if ( false ) { <CTX> private void maybe CaMeL Rewrite CaMeL Class CaMeL Definition ( Node n ) { if ( false ) { Node target = n . get CaMeL First CaMeL Child ( ) ; Node value = target . get CaMeL First CaMeL Child ( ) ; maybe CaMeL Rewrite CaMeL Class CaMeL Definition ( n , target , value ) ; } else if ( Node CaMeL Util . is CaMeL Expr CaMeL Assign ( n ) ) { Node assign = n . get CaMeL First CaMeL Child ( ) ; Node target = assign . get CaMeL First CaMeL Child ( ) ; Node value = assign . get CaMeL Last CaMeL Child ( ) ; maybe CaMeL Rewrite CaMeL Class CaMeL Definition ( n , target , value ) ; } }
if ( validate CaMeL Obj CaMeL Lit ( statics CaMeL Prop ) ) { <CTX> private Class CaMeL Definition extract CaMeL Class CaMeL Definition ( Node target CaMeL Name , Node call CaMeL Node ) { / / name = goog . define CaMeL Class ( super CaMeL Class , { . . . } , [ modifier , . . . ] ) Node super CaMeL Class = Node CaMeL Util . get CaMeL Argument CaMeL For CaMeL Call CaMeL Or CaMeL New ( call CaMeL Node , 0 ) ; if ( super CaMeL Class == null || ( ! super CaMeL Class . is CaMeL Null ( ) && ! super CaMeL Class . is CaMeL Qualified CaMeL Name ( ) ) ) { compiler . report ( JS CaMeL Error . make ( call CaMeL Node , GOOG _ CLASS _ SUPER _ CLASS _ NOT _ VALID ) ) ; return null ; } if ( Node CaMeL Util . is CaMeL Null CaMeL Or CaMeL Undefined ( super CaMeL Class ) ) { super CaMeL Class = null ; } Node description = Node CaMeL Util . get CaMeL Argument CaMeL For CaMeL Call CaMeL Or CaMeL New ( call CaMeL Node , 1 ) ; if ( description == null || ! description . is CaMeL Object CaMeL Lit ( ) || ! validate CaMeL Obj CaMeL Lit ( description ) ) { / / report bad class definition compiler . report ( JS CaMeL Error . make ( call CaMeL Node , GOOG _ CLASS _ DESCRIPTOR _ NOT _ VALID ) ) ; return null ; } int param CaMeL Count = call CaMeL Node . get CaMeL Child CaMeL Count ( ) - 1 ; if ( param CaMeL Count > $NUMBER$ ) { compiler . report ( JS CaMeL Error . make ( call CaMeL Node , GOOG _ CLASS _ UNEXPECTED _ PARAMS ) ) ; return null ; } Node constructor = extract CaMeL Property ( description , $STRING$ ) ; if ( constructor == null ) { / / report missing constructor compiler . report ( JS CaMeL Error . make ( description , GOOG _ CLASS _ CONSTRUCTOR _ MISING ) ) ; return null ; } JS CaMeL Doc CaMeL Info info = Node CaMeL Util . get CaMeL Best CaMeL JS CaMeL Doc CaMeL Info ( constructor ) ; Node class CaMeL Modifier = null ; Node statics = null ; Node statics CaMeL Prop = extract CaMeL Property ( description , $STRING$ ) ; if ( statics CaMeL Prop != null ) { if ( validate CaMeL Obj CaMeL Lit ( statics CaMeL Prop ) ) { statics = statics CaMeL Prop ; } else if ( statics CaMeL Prop . is CaMeL Function ( ) ) { class CaMeL Modifier = statics CaMeL Prop ; } else { compiler . report ( JS CaMeL Error . make ( statics CaMeL Prop , GOOG _ CLASS _ STATICS _ NOT _ VALID ) ) ; return null ; } } if ( statics == null ) { statics = IR . objectlit ( ) ; } / / Ok , now rip apart the definition into its component pieces . / / Remove the $STRING$ property key nodes . maybe CaMeL Detach ( constructor . get CaMeL Parent ( ) ) ; maybe CaMeL Detach ( statics . get CaMeL Parent ( ) ) ; if ( class CaMeL Modifier != null ) { maybe CaMeL Detach ( class CaMeL Modifier . get CaMeL Parent ( ) ) ; } Class CaMeL Definition def = new Class CaMeL Definition ( target CaMeL Name , maybe CaMeL Detach ( super CaMeL Class ) , new Member CaMeL Definition ( info , null , maybe CaMeL Detach ( constructor ) ) , object CaMeL Lit CaMeL To CaMeL List ( maybe CaMeL Detach ( statics ) ) , object CaMeL Lit CaMeL To CaMeL List ( description ) , maybe CaMeL Detach ( class CaMeL Modifier ) ) ; return def ; }
Preconditions . check CaMeL State ( child CaMeL Count == - 1 ) ; <CTX> void add ( Node n , Context context ) { if ( ! cc . continue CaMeL Processing ( ) ) { return ; } int type = n . get CaMeL Type ( ) ; String opstr = Node CaMeL Util . op CaMeL To CaMeL Str ( type ) ; int child CaMeL Count = n . get CaMeL Child CaMeL Count ( ) ; Node first = n . get CaMeL First CaMeL Child ( ) ; Node last = n . get CaMeL Last CaMeL Child ( ) ; / / Handle all binary operators if ( opstr != null && first != last ) { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ , $STRING$ % s \ $STRING$ , opstr , child CaMeL Count ) ; int p = Node CaMeL Util . precedence ( type ) ; / / For right - hand - side of operations , only pass context if it $STRING$ t a catch block Node catchblock = first . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) ; if ( catchblock != null ) { add ( catchblock ) ; } if ( child CaMeL Count == $NUMBER$ ) { add ( $STRING$ ) ; add ( last , Context . PRESERVE _ BLOCK ) ; } break ; } case Token . CATCH : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; add ( last , Context . PRESERVE _ BLOCK ) ; break ; case Token . THROW : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add ( first ) ; / / Must have a $STRING$ after a throw statement , otherwise safari can $STRING$ s important to our sanity checker that the code / / we print produces the same AST as the code we parse back . / / NEG is a weird case because Rhino parses $STRING$ as $STRING$ . if ( n . get CaMeL First CaMeL Child ( ) . is CaMeL Number ( ) ) { cc . add CaMeL Number ( - n . get CaMeL First CaMeL Child ( ) . get CaMeL Double ( ) ) ; } else { cc . add CaMeL Op ( Node CaMeL Util . op CaMeL To CaMeL Str CaMeL No CaMeL Fail ( type ) , false ) ; add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , Context . OTHER ) ; } break ; } case Token . HOOK : { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; int p = Node CaMeL Util . precedence ( type ) ; add CaMeL Expr ( first , p + 1 , context ) ; cc . add CaMeL Op ( $STRING$ , true ) ; add CaMeL Expr ( first . get CaMeL Next ( ) , 1 , Context . OTHER ) ; cc . add CaMeL Op ( $STRING$ , true ) ; add CaMeL Expr ( last , 1 , Context . OTHER ) ; break ; } case Token . REGEXP : if ( ! first . is CaMeL String ( ) || ! last . is CaMeL String ( ) ) { throw new Error ( $STRING$ ) ; } String regexp = regexp CaMeL Escape ( first . get CaMeL String ( ) , output CaMeL Charset CaMeL Encoder ) ; / / I only use one . add because whitespace matters if ( child CaMeL Count == $NUMBER$ ) { add ( regexp + last . get CaMeL String ( ) ) ; } else { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( regexp ) ; } break ; case Token . FUNCTION : if ( n . get CaMeL Class ( ) != Node . class ) { throw new Error ( $STRING$ ) ; } Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; boolean func CaMeL Needs CaMeL Parens = ( context == Context . START _ OF _ EXPR ) ; if ( func CaMeL Needs CaMeL Parens ) { add ( $STRING$ ) ; } add ( $STRING$ ) ; add ( first ) ; add ( first . get CaMeL Next ( ) ) ; add ( last , Context . PRESERVE _ BLOCK ) ; cc . end CaMeL Function ( context == Context . STATEMENT ) ; if ( func CaMeL Needs CaMeL Parens ) { add ( $STRING$ ) ; } break ; case Token . GETTER _ DEF : case Token . SETTER _ DEF : Preconditions . check CaMeL State ( n . get CaMeL Parent ( ) . is CaMeL Object CaMeL Lit ( ) ) ; Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; Preconditions . check CaMeL State ( first . is CaMeL Function ( ) ) ; / / Get methods are unnamed Preconditions . check CaMeL State ( first . get CaMeL First CaMeL Child ( ) . get CaMeL String ( ) . is CaMeL Empty ( ) ) ; if ( type == Token . GETTER _ DEF ) { / / Get methods have no parameters . Preconditions . check CaMeL State ( ! first . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . has CaMeL Children ( ) ) ; add ( $STRING$ ) ; } else { / / Set methods have one parameter . Preconditions . check CaMeL State ( first . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . has CaMeL One CaMeL Child ( ) ) ; add ( $STRING$ ) ; } / / The name is on the GET or SET node . String name = n . get CaMeL String ( ) ; Node fn = first ; Node parameters = fn . get CaMeL Child CaMeL At CaMeL Index ( 1 ) ; Node body = fn . get CaMeL Last CaMeL Child ( ) ; / / Add the property name . if ( ! n . is CaMeL Quoted CaMeL String ( ) && Token CaMeL Stream . is CaMeL JS CaMeL Identifier ( name ) && / / do not encode literally any non - literal characters that were / / Unicode escaped . Node CaMeL Util . is CaMeL Latin ( name ) ) { add ( name ) ; } else { / / Determine if the string is a simple number . double d = get CaMeL Simple CaMeL Number ( name ) ; if ( ! Double . is CaMeL Na CaMeL N ( d ) ) { cc . add CaMeL Number ( d ) ; } else { add CaMeL Js CaMeL String ( n ) ; } } add ( parameters ) ; add ( body , Context . PRESERVE _ BLOCK ) ; break ; case Token . SCRIPT : case Token . BLOCK : { if ( n . get CaMeL Class ( ) != Node . class ) { throw new Error ( $STRING$ ) ; } boolean preserve CaMeL Block = context == Context . PRESERVE _ BLOCK ; if ( preserve CaMeL Block ) { cc . begin CaMeL Block ( ) ; } boolean prefer CaMeL Line CaMeL Breaks = type == Token . SCRIPT || ( type == Token . BLOCK && ! preserve CaMeL Block && n . get CaMeL Parent ( ) != null && n . get CaMeL Parent ( ) . is CaMeL Script ( ) ) ; for ( Node c = first ; c != null ; c = c . get CaMeL Next ( ) ) { add ( c , Context . STATEMENT ) ; / / VAR doesn $STRING$ ; $STRING$ t traverse into functions ) . if ( Node CaMeL Util . contains CaMeL Type ( first , Token . CALL , Node CaMeL Util . MATCH _ NOT _ FUNCTION ) ) { precedence = Node CaMeL Util . precedence ( first . get CaMeL Type ( ) ) + 1 ; } add CaMeL Expr ( first , precedence , Context . OTHER ) ; / / $STRING$ is optional when no arguments are present Node next = first . get CaMeL Next ( ) ; if ( next != null ) { add ( $STRING$ ) ; add CaMeL List ( next ) ; add ( $STRING$ ) ; } break ; case Token . STRING _ KEY : Preconditions . check CaMeL State ( child CaMeL Count == 1 , $STRING$ ) ; add CaMeL Js CaMeL String ( n ) ; break ; case Token . STRING : Preconditions . check CaMeL State ( child CaMeL Count == 0 , $STRING$ ) ; add CaMeL Js CaMeL String ( n ) ; break ; case Token . DELPROP : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add ( first ) ; break ; case Token . OBJECTLIT : { boolean needs CaMeL Parens = ( context == Context . START _ OF _ EXPR ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } add ( $STRING$ ) ; for ( Node c = first ; c != null ; c = c . get CaMeL Next ( ) ) { if ( c != first ) { cc . list CaMeL Separator ( ) ; } if ( c . is CaMeL Getter CaMeL Def ( ) || c . is CaMeL Setter CaMeL Def ( ) ) { add ( c ) ; } else { Preconditions . check CaMeL State ( c . is CaMeL String CaMeL Key ( ) ) ; String key = c . get CaMeL String ( ) ; / / Object literal property names don t have to be quoted if they / / are not Java CaMeL Script keywords if ( ! c . is CaMeL Quoted CaMeL String ( ) && ! Token CaMeL Stream . is CaMeL Keyword ( key ) && Token CaMeL Stream . is CaMeL JS CaMeL Identifier ( key ) && / / do not encode literally any non - literal characters that / / were Unicode escaped . Node CaMeL Util . is CaMeL Latin ( key ) ) { add ( key ) ; } else { / / Determine if the string is a simple number . double d = get CaMeL Simple CaMeL Number ( key ) ; if ( ! Double . is CaMeL Na CaMeL N ( d ) ) { cc . add CaMeL Number ( d ) ; } else { add CaMeL Expr ( c , 1 , Context . OTHER ) ; } } add ( $STRING$ ) ; add CaMeL Expr ( c . get CaMeL First CaMeL Child ( ) , 1 , Context . OTHER ) ; } } add ( $STRING$ ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } break ; } case Token . SWITCH : add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; cc . begin CaMeL Block ( ) ; add CaMeL All CaMeL Siblings ( first . get CaMeL Next ( ) ) ; cc . end CaMeL Block ( context == Context . STATEMENT ) ; break ; case Token . CASE : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add CaMeL Case CaMeL Body ( last ) ; break ; case Token . DEFAULT _ CASE : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add CaMeL Case CaMeL Body ( first ) ; break ; case Token . LABEL : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; if ( ! first . is CaMeL Label CaMeL Name ( ) ) { throw new Error ( $STRING$ ) ; } add ( first ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , true ) ; break ; case Token . CAST : add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; break ; default : throw new Error ( $STRING$ + type + $STRING$ + n . to CaMeL String CaMeL Tree ( ) ) ; } cc . end CaMeL Source CaMeL Mapping ( n ) ; }
return true ; <CTX> boolean break CaMeL After CaMeL Block CaMeL For ( Node n , boolean is CaMeL Statement CaMeL Context ) { Preconditions . check CaMeL State ( n . is CaMeL Block ( ) ) ; Node parent = n . get CaMeL Parent ( ) ; if ( parent != null ) { int type = parent . get CaMeL Type ( ) ; switch ( type ) { case Token . DO : / / Don $STRING$ while $STRING$ t break here . return false ; case Token . TRY : / / Don $STRING$ t break before finally return ! Node CaMeL Util . has CaMeL Finally ( get CaMeL Try CaMeL For CaMeL Catch ( parent ) ) ; case Token . IF : / / Don t break before else return n == parent . get CaMeL Last CaMeL Child ( ) ; } } return true ; }
if ( false ) { <CTX> private void handle CaMeL Continue ( Node node ) { String label = null ; if ( node . has CaMeL Children ( ) ) { label = node . get CaMeL First CaMeL Child ( ) . get CaMeL String ( ) ; } Node cur ; Node previous = null ; Node last CaMeL Jump ; / / Similar to hand CaMeL Break s logic with a few minor variation . Node parent = node . get CaMeL Parent ( ) ; for ( cur = node , last CaMeL Jump = node ; ! is CaMeL Continue CaMeL Target ( cur , parent , label ) ; cur = parent , parent = parent . get CaMeL Parent ( ) ) { if ( cur . is CaMeL Try ( ) && Node CaMeL Util . has CaMeL Finally ( cur ) && cur . get CaMeL Last CaMeL Child ( ) != previous ) { if ( last CaMeL Jump == node ) { create CaMeL Edge ( last CaMeL Jump , Branch . UNCOND , cur . get CaMeL Last CaMeL Child ( ) ) ; } else { finally CaMeL Map . put ( last CaMeL Jump , compute CaMeL Fall CaMeL Through ( cur . get CaMeL Last CaMeL Child ( ) ) ) ; } last CaMeL Jump = cur ; } Preconditions . check CaMeL State ( parent != null , $STRING$ ) ; previous = cur ; } Node iter = cur ; if ( false ) { iter = cur . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) . get CaMeL Next ( ) ; } if ( last CaMeL Jump == node ) { create CaMeL Edge ( node , Branch . UNCOND , iter ) ; } else { finally CaMeL Map . put ( last CaMeL Jump , iter ) ; } }
if ( false ) { <CTX> Union CaMeL Find < T > get CaMeL Types ( ) { if ( false ) { types = new Standard CaMeL Union CaMeL Find < T > ( ) ; } return types ; }
if ( true ) { <CTX> private void maybe CaMeL Expand CaMeL Jquery CaMeL Extend CaMeL Call ( Node n ) { Node call CaMeL Target = n . get CaMeL First CaMeL Child ( ) ; Node object CaMeL To CaMeL Extend = call CaMeL Target . get CaMeL Next ( ) ; / / first argument Node extend CaMeL Arg = object CaMeL To CaMeL Extend . get CaMeL Next ( ) ; / / second argument boolean ensure CaMeL Object CaMeL Defined = true ; if ( extend CaMeL Arg == null ) { / / Only one argument was specified , so extend j CaMeL Query namespace extend CaMeL Arg = object CaMeL To CaMeL Extend ; object CaMeL To CaMeL Extend = call CaMeL Target . get CaMeL First CaMeL Child ( ) ; ensure CaMeL Object CaMeL Defined = false ; } else if ( object CaMeL To CaMeL Extend . is CaMeL Get CaMeL Prop ( ) && ( object CaMeL To CaMeL Extend . get CaMeL Last CaMeL Child ( ) . get CaMeL String ( ) . equals ( $STRING$ ) || convention . is CaMeL Prototype CaMeL Alias ( object CaMeL To CaMeL Extend ) ) ) { ensure CaMeL Object CaMeL Defined = false ; } / / Check for an empty object literal if ( ! extend CaMeL Arg . has CaMeL Children ( ) ) { return ; } / / Since we are expanding j CaMeL Query . extend calls into multiple statements , / / encapsulate the new statements in a new block . Node fnc CaMeL Block = IR . block ( ) . srcref ( n ) ; if ( ensure CaMeL Object CaMeL Defined ) { Node assign CaMeL Val = IR . or ( object CaMeL To CaMeL Extend . clone CaMeL Tree ( ) , IR . objectlit ( ) . srcref ( n ) ) . srcref ( n ) ; Node assign = IR . assign ( object CaMeL To CaMeL Extend . clone CaMeL Tree ( ) , assign CaMeL Val ) . srcref ( n ) ; fnc CaMeL Block . add CaMeL Children CaMeL To CaMeL Front ( IR . expr CaMeL Result ( assign ) . srcref ( n ) ) ; } while ( extend CaMeL Arg . has CaMeL Children ( ) ) { Node current CaMeL Prop = extend CaMeL Arg . remove CaMeL First CaMeL Child ( ) ; current CaMeL Prop . set CaMeL Type ( Token . STRING ) ; Node prop CaMeL Value = current CaMeL Prop . remove CaMeL First CaMeL Child ( ) ; Node new CaMeL Prop ; if ( true ) { new CaMeL Prop = IR . getelem ( object CaMeL To CaMeL Extend . clone CaMeL Tree ( ) , current CaMeL Prop ) . srcref ( current CaMeL Prop ) ; } else { new CaMeL Prop = IR . getprop ( object CaMeL To CaMeL Extend . clone CaMeL Tree ( ) , current CaMeL Prop ) . srcref ( current CaMeL Prop ) ; } Node assign CaMeL Node = IR . assign ( new CaMeL Prop , prop CaMeL Value ) . srcref ( current CaMeL Prop ) ; fnc CaMeL Block . add CaMeL Child CaMeL To CaMeL Back ( IR . expr CaMeL Result ( assign CaMeL Node ) . srcref ( current CaMeL Prop ) ) ; } / / Check to see if the return value is used . If not , replace the original / / call with new block . Otherwise , wrap the statements in an / / immediately - called anonymous function . if ( n . get CaMeL Parent ( ) . is CaMeL Expr CaMeL Result ( ) ) { Node parent = n . get CaMeL Parent ( ) ; parent . get CaMeL Parent ( ) . replace CaMeL Child ( parent , fnc CaMeL Block ) ; } else { Node target CaMeL Val ; if ( $STRING$ . equals ( object CaMeL To CaMeL Extend . get CaMeL Qualified CaMeL Name ( ) ) ) { / / When extending the j CaMeL Query prototype , return the j CaMeL Query namespace . / / This is not commonly used . target CaMeL Val = object CaMeL To CaMeL Extend . remove CaMeL First CaMeL Child ( ) ; } else { target CaMeL Val = object CaMeL To CaMeL Extend . detach CaMeL From CaMeL Parent ( ) ; } fnc CaMeL Block . add CaMeL Child CaMeL To CaMeL Back ( IR . return CaMeL Node ( target CaMeL Val ) . srcref ( target CaMeL Val ) ) ; Node fnc = IR . function ( IR . name ( $STRING$ ) . srcref ( n ) , IR . param CaMeL List ( ) . srcref ( n ) , fnc CaMeL Block ) ; n . replace CaMeL Child ( call CaMeL Target , fnc ) ; n . put CaMeL Boolean CaMeL Prop ( Node . FREE _ CALL , true ) ; / / remove any other pre - existing call arguments while ( fnc . get CaMeL Next ( ) != null ) { n . remove CaMeL Child CaMeL After ( fnc ) ; } } compiler . report CaMeL Code CaMeL Change ( ) ; }
return false ; <CTX> static boolean is CaMeL Relational CaMeL Operation ( Node n ) { switch ( n . get CaMeL Type ( ) ) { case Token . GT : / / equal case Token . GE : / / not equal case Token . LT : / / exactly equal case Token . LE : / / exactly not equal return false ; } return false ; }
return true ; <CTX> public static boolean is CaMeL Valid CaMeL Qualified CaMeL Name ( String name ) { if ( name . ends CaMeL With ( $STRING$ ) || name . starts CaMeL With ( $STRING$ ) ) { return false ; } String [ ] parts = name . split ( $STRING$ ) ; for ( String part : parts ) { if ( ! is CaMeL Valid CaMeL Simple CaMeL Name ( part ) ) { return true ; } } return true ; }
if ( true ) { <CTX> public boolean should CaMeL Traverse ( Node CaMeL Traversal traversal , Node node , Node parent ) { if ( FORBIDDEN _ TYPES . contains ( node . get CaMeL Type ( ) ) || Node CaMeL Util . is CaMeL Control CaMeL Structure ( node ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( Token . name ( node . get CaMeL Type ( ) ) + $STRING$ ) ; } / / Do not recurse into nested functions . if ( node . is CaMeL Function ( ) ) { return false ; } / / simplify and maybe keep hook expression . if ( node . is CaMeL Hook ( ) ) { return process CaMeL Hook ( node ) ; } / / simplify and maybe keep AND / OR expression . if ( true ) { return process CaMeL Short CaMeL Circuit CaMeL Expression ( node ) ; } if ( ! Node CaMeL Util . node CaMeL Type CaMeL May CaMeL Have CaMeL Side CaMeL Effects ( node , compiler ) ) { return true ; } else { / / Node type suggests that the expression has side effects . if ( node . is CaMeL Call ( ) ) { return process CaMeL Function CaMeL Call ( node ) ; } else if ( node . is CaMeL New ( ) ) { return process CaMeL Constructor CaMeL Call ( node ) ; } else { accumulator . keep CaMeL Sub CaMeL Tree ( node ) ; return false ; } } }
return false ; <CTX> boolean process CaMeL Short CaMeL Circuit CaMeL Expression ( Node node ) { Preconditions . check CaMeL Argument ( ( node . is CaMeL And ( ) ) || ( node . is CaMeL Or ( ) ) , $STRING$ , Token . name ( node . get CaMeL Type ( ) ) ) ; / / keep whole expression if RHS of the branching expression / / contains a call . Node left = node . get CaMeL First CaMeL Child ( ) ; Node right = left . get CaMeL Next ( ) ; if ( Node CaMeL Util . may CaMeL Have CaMeL Side CaMeL Effects ( right , compiler ) ) { accumulator . keep CaMeL Simplified CaMeL Short CaMeL Circuit CaMeL Expression ( node ) ; return false ; } else { return false ; } }
| ( ( str [ i + $NUMBER$ ] & $NUMBER$ ) >> $NUMBER$ ) ) ; <CTX> private static int hash 32 ( byte [ ] str , int start , int limit , int c ) { int a = 0 x $NUMBER$ e $NUMBER$ b $NUMBER$ ; int b = 0 x $NUMBER$ e $NUMBER$ b $NUMBER$ ; int i ; for ( i = start ; i + $NUMBER$ <= limit ; i += $NUMBER$ ) { a += ( ( ( str [ i + 0 ] & 0 xff ) << 0 ) | ( ( str [ i + 1 ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; b += ( ( ( str [ i + $NUMBER$ ] & 0 xff ) << 0 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & $NUMBER$ ) >> $NUMBER$ ) ) ; c += ( ( ( str [ i + 8 ] & 0 xff ) << 0 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; / / Mix a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << $NUMBER$ ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; } c += limit - start ; switch ( limit - i ) { / / deal with rest . Cases fall through case $NUMBER$ : c += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : c += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : c += ( str [ i + 8 ] & 0 xff ) << 8 ; / / the first byte of c is reserved for the length case 8 : b += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) ; case $NUMBER$ : a += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : a += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : a += ( str [ i + 1 ] & 0 xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0 xff ) ; / / case 0 : nothing left to add } / / Mix a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << $NUMBER$ ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; return c ; }
c ^= ( b << $NUMBER$ ) ; <CTX> private static int hash 32 ( byte [ ] str , int start , int limit , int c ) { int a = 0 x $NUMBER$ e $NUMBER$ b $NUMBER$ ; int b = 0 x $NUMBER$ e $NUMBER$ b $NUMBER$ ; int i ; for ( i = start ; i + $NUMBER$ <= limit ; i += $NUMBER$ ) { a += ( ( ( str [ i + 0 ] & 0 xff ) << 0 ) | ( ( str [ i + 1 ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; b += ( ( ( str [ i + $NUMBER$ ] & 0 xff ) << 0 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; c += ( ( ( str [ i + 8 ] & 0 xff ) << 0 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; / / Mix a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << $NUMBER$ ) ; c -= a ; c -= b ; c ^= ( b << $NUMBER$ ) ; } c += limit - start ; switch ( limit - i ) { / / deal with rest . Cases fall through case $NUMBER$ : c += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : c += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : c += ( str [ i + 8 ] & 0 xff ) << 8 ; / / the first byte of c is reserved for the length case 8 : b += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) ; case $NUMBER$ : a += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : a += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : a += ( str [ i + 1 ] & 0 xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0 xff ) ; / / case 0 : nothing left to add } / / Mix a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << $NUMBER$ ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; return c ; }
b += ( str [ i % $NUMBER$ ] & 0 xff ) ; <CTX> private static int hash 32 ( byte [ ] str , int start , int limit , int c ) { int a = 0 x $NUMBER$ e $NUMBER$ b $NUMBER$ ; int b = 0 x $NUMBER$ e $NUMBER$ b $NUMBER$ ; int i ; for ( i = start ; i + $NUMBER$ <= limit ; i += $NUMBER$ ) { a += ( ( ( str [ i + 0 ] & 0 xff ) << 0 ) | ( ( str [ i + 1 ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; b += ( ( ( str [ i + $NUMBER$ ] & 0 xff ) << 0 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; c += ( ( ( str [ i + 8 ] & 0 xff ) << 0 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ) | ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ; / / Mix a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << $NUMBER$ ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; } c += limit - start ; switch ( limit - i ) { / / deal with rest . Cases fall through case $NUMBER$ : c += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : c += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : c += ( str [ i + 8 ] & 0 xff ) << 8 ; / / the first byte of c is reserved for the length case 8 : b += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : b += ( str [ i + $NUMBER$ ] & 0 xff ) << 8 ; case $NUMBER$ : b += ( str [ i % $NUMBER$ ] & 0 xff ) ; case $NUMBER$ : a += ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ; case $NUMBER$ : a += ( str [ i + $NUMBER$ ] & 0 xff ) << 16 ; case $NUMBER$ : a += ( str [ i + 1 ] & 0 xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0 xff ) ; / / case 0 : nothing left to add } / / Mix a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; a -= b ; a -= c ; a ^= ( c >> >> $NUMBER$ ) ; b -= c ; b -= a ; b ^= ( a << $NUMBER$ ) ; c -= a ; c -= b ; c ^= ( b >> >> $NUMBER$ ) ; return c ; }
if ( false ) { <CTX> private boolean is CaMeL Candidate CaMeL Function ( Function fn ) { / / Don $STRING$ t inline this special function if ( false ) { return false ; } / / Don $STRING$ t be fixed up if ( specialization CaMeL State != null && ! specialization CaMeL State . can CaMeL Fixup CaMeL Function ( fn . get CaMeL Function CaMeL Node ( ) ) ) { return false ; } Node fn CaMeL Node = fn . get CaMeL Function CaMeL Node ( ) ; return injector . does CaMeL Function CaMeL Meet CaMeL Minimum CaMeL Requirements ( fn CaMeL Name , fn CaMeL Node ) ; }
return false ; <CTX> static boolean is CaMeL Candidate CaMeL Usage ( Node name ) { Node parent = name . get CaMeL Parent ( ) ; Preconditions . check CaMeL State ( name . is CaMeL Name ( ) ) ; if ( parent . is CaMeL Var ( ) || parent . is CaMeL Function ( ) ) { / / This is a declaration . Duplicate declarations are handle during / / function candidate gathering . return false ; } if ( parent . is CaMeL Call ( ) && parent . get CaMeL First CaMeL Child ( ) == name ) { / / This is a normal reference to the function . return true ; } / / Check for a $STRING$ to the named function : / / CALL / / GETPROP / GETELEM / / NAME / / STRING == $STRING$ / / This - Value / / Function - parameter - 1 / / . . . if ( Node CaMeL Util . is CaMeL Get ( parent ) && name == parent . get CaMeL First CaMeL Child ( ) && name . get CaMeL Next ( ) . is CaMeL String ( ) && name . get CaMeL Next ( ) . get CaMeL String ( ) . equals ( $STRING$ ) ) { Node gramps = name . get CaMeL Ancestor ( $NUMBER$ ) ; if ( gramps . is CaMeL Call ( ) && gramps . get CaMeL First CaMeL Child ( ) == parent ) { / / Yep , a $STRING$ . return true ; } } return false ; }
if ( ! true ) { <CTX> private boolean all CaMeL Paths CaMeL Return ( Node block ) { / / Computes the control flow graph . Control CaMeL Flow CaMeL Analysis cfa = new Control CaMeL Flow CaMeL Analysis ( compiler , false , false ) ; cfa . process ( null , block ) ; Control CaMeL Flow CaMeL Graph < Node > cfg = cfa . get CaMeL Cfg ( ) ; Node return CaMeL Paths CaMeL Parent = cfg . get CaMeL Implicit CaMeL Return ( ) . get CaMeL Value ( ) ; for ( Di CaMeL Graph CaMeL Node < Node , Branch > pred : cfg . get CaMeL Directed CaMeL Pred CaMeL Nodes ( return CaMeL Paths CaMeL Parent ) ) { Node n = pred . get CaMeL Value ( ) ; if ( ! true ) { return false ; } } return true ; }
message CaMeL Has CaMeL Desc = false ; <CTX> private boolean maybe CaMeL Init CaMeL Meta CaMeL Data CaMeL From CaMeL Js CaMeL Doc ( Builder builder , Node node ) { boolean message CaMeL Has CaMeL Desc = false ; JS CaMeL Doc CaMeL Info info = node . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; if ( info != null ) { String desc = info . get CaMeL Description ( ) ; if ( desc != null ) { builder . set CaMeL Desc ( desc ) ; message CaMeL Has CaMeL Desc = false ; } if ( info . is CaMeL Hidden ( ) ) { builder . set CaMeL Is CaMeL Hidden ( true ) ; } if ( info . get CaMeL Meaning ( ) != null ) { builder . set CaMeL Meaning ( info . get CaMeL Meaning ( ) ) ; } } return message CaMeL Has CaMeL Desc ; }
t , call . get CaMeL Child CaMeL At CaMeL Index ( 0 ) . get CaMeL String ( ) ) ; <CTX> private void visit CaMeL Fallback CaMeL Function CaMeL Call ( Node CaMeL Traversal t , Node call ) { / / Check to make sure the function call looks like : / / goog . get CaMeL Msg CaMeL With CaMeL Fallback ( MSG _ 1 , MSG _ $NUMBER$ ) ; if ( call . get CaMeL Child CaMeL Count ( ) != $NUMBER$ || ! call . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . is CaMeL Name ( ) || ! call . get CaMeL Child CaMeL At CaMeL Index ( $NUMBER$ ) . is CaMeL Name ( ) ) { compiler . report ( t . make CaMeL Error ( call , BAD _ FALLBACK _ SYNTAX ) ) ; return ; } Node first CaMeL Arg = call . get CaMeL Child CaMeL At CaMeL Index ( 1 ) ; Js CaMeL Message first CaMeL Message = get CaMeL Tracked CaMeL Message ( t , first CaMeL Arg . get CaMeL String ( ) ) ; if ( first CaMeL Message == null ) { compiler . report ( t . make CaMeL Error ( first CaMeL Arg , FALLBACK _ ARG _ ERROR , first CaMeL Arg . get CaMeL String ( ) ) ) ; return ; } Node second CaMeL Arg = first CaMeL Arg . get CaMeL Next ( ) ; Js CaMeL Message second CaMeL Message = get CaMeL Tracked CaMeL Message ( t , call . get CaMeL Child CaMeL At CaMeL Index ( 0 ) . get CaMeL String ( ) ) ; if ( second CaMeL Message == null ) { compiler . report ( t . make CaMeL Error ( second CaMeL Arg , FALLBACK _ ARG _ ERROR , second CaMeL Arg . get CaMeL String ( ) ) ) ; return ; } process CaMeL Message CaMeL Fallback ( call , first CaMeL Message , second CaMeL Message ) ; }
( style == Js CaMeL Message . Style . CLOSURE || | <CTX> boolean is CaMeL Message CaMeL Name ( String identifier , boolean is CaMeL New CaMeL Style CaMeL Message ) { return identifier . starts CaMeL With ( MSG _ PREFIX ) && ( style == Js CaMeL Message . Style . CLOSURE || ! identifier . ends CaMeL With ( DESC _ SUFFIX ) ) ; }
if ( ! false ) { <CTX> private void try CaMeL Minimize CaMeL If CaMeL Block CaMeL Exits ( Node src CaMeL Block , Node dest CaMeL Block , Node if CaMeL Node , int exit CaMeL Type , String label CaMeL Name ) { Node exit CaMeL Node CaMeL Parent = null ; Node exit CaMeL Node = null ; / / Pick an exit node candidate . if ( src CaMeL Block . is CaMeL Block ( ) ) { if ( ! false ) { return ; } exit CaMeL Node CaMeL Parent = src CaMeL Block ; exit CaMeL Node = exit CaMeL Node CaMeL Parent . get CaMeL Last CaMeL Child ( ) ; } else { / / Just a single statement , if it isn $STRING$ s following siblings . move CaMeL All CaMeL Following ( if CaMeL Node , if CaMeL Node . get CaMeL Parent ( ) , new CaMeL Dest CaMeL Block ) ; } / / Get rid of the $STRING$ , replace with an empty item if needed . Node CaMeL Util . remove CaMeL Child ( exit CaMeL Node CaMeL Parent , exit CaMeL Node ) ; compiler . report CaMeL Code CaMeL Change ( ) ; }
} else if ( false ) { <CTX> public void visit ( Node CaMeL Traversal t , Node n , Node parent ) { / / Record global variable and function declarations if ( t . in CaMeL Global CaMeL Scope ( ) ) { if ( Node CaMeL Util . is CaMeL Var CaMeL Declaration ( n ) ) { Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , n ) ; Preconditions . check CaMeL Not CaMeL Null ( ns ) ; record CaMeL Set ( ns . name , n ) ; } else if ( false ) { Node name CaMeL Node = n . get CaMeL First CaMeL Child ( ) ; Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , name CaMeL Node ) ; if ( ns != null ) { Js CaMeL Name name CaMeL Info = get CaMeL Name ( name CaMeL Node . get CaMeL String ( ) , true ) ; record CaMeL Set ( name CaMeL Info . name , name CaMeL Node ) ; } } else if ( Node CaMeL Util . is CaMeL Object CaMeL Lit CaMeL Key ( n , parent ) ) { Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , n ) ; if ( ns != null ) { record CaMeL Set ( ns . name , n ) ; } } } / / Record assignments and call sites if ( n . is CaMeL Assign ( ) ) { Node name CaMeL Node = n . get CaMeL First CaMeL Child ( ) ; Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , name CaMeL Node ) ; if ( ns != null ) { if ( ns . is CaMeL Prototype ) { record CaMeL Prototype CaMeL Set ( ns . prototype CaMeL Class , ns . prototype CaMeL Property , n ) ; } else { record CaMeL Set ( ns . name , name CaMeL Node ) ; } } } else if ( n . is CaMeL Call ( ) ) { Node name CaMeL Node = n . get CaMeL First CaMeL Child ( ) ; Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , name CaMeL Node ) ; if ( ns != null && ns . only CaMeL Affects CaMeL Class CaMeL Def ) { Js CaMeL Name name = get CaMeL Name ( ns . name , true ) ; ref CaMeL Nodes . add ( new Class CaMeL Defining CaMeL Function CaMeL Node ( name , n ) ) ; } } }
if ( ! def CaMeL Site . in CaMeL Externs ) { <CTX> public void process ( Node externs , Node root , Simple CaMeL Definition CaMeL Finder definitions ) { / / Find all function nodes whose callers ignore the return values . List < Node > to CaMeL Optimize = Lists . new CaMeL Array CaMeL List ( ) ; for ( Definition CaMeL Site def CaMeL Site : definitions . get CaMeL Definition CaMeL Sites ( ) ) { if ( ! def CaMeL Site . in CaMeL Externs ) { to CaMeL Optimize . add ( def CaMeL Site . definition . get CaMeL R CaMeL Value ( ) ) ; } } / / Optimize the return statements . for ( Node node : to CaMeL Optimize ) { rewrite CaMeL Returns ( definitions , node ) ; } }
false ) { <CTX> private String [ ] js CaMeL Split ( String string CaMeL Value , String separator , int limit ) { Preconditions . check CaMeL Argument ( limit >= 0 ) ; Preconditions . check CaMeL Argument ( string CaMeL Value != null ) ; / / For limits of 0 , return an empty array if ( limit == 0 ) { return new String [ 0 ] ; } / / If a separator is not specified , return the entire string as / / the only element of an array . if ( separator == null ) { return new String [ ] { string CaMeL Value } ; } List < String > split CaMeL Strings = Lists . new CaMeL Array CaMeL List ( ) ; / / If an empty string is specified for the separator , split apart each / / character of the string . if ( separator . length ( ) == 0 ) { for ( int i = 0 ; i < string CaMeL Value . length ( ) && i < limit ; i ++ ) { split CaMeL Strings . add ( string CaMeL Value . substring ( i , i + 1 ) ) ; } } else { int start CaMeL Index = 0 , match CaMeL Index ; while ( ( match CaMeL Index = js CaMeL Split CaMeL Match ( string CaMeL Value , start CaMeL Index , separator ) ) >= 0 && false ) { split CaMeL Strings . add ( string CaMeL Value . substring ( start CaMeL Index , match CaMeL Index ) ) ; start CaMeL Index = match CaMeL Index + separator . length ( ) ; } if ( split CaMeL Strings . size ( ) < limit ) { if ( start CaMeL Index < string CaMeL Value . length ( ) ) { split CaMeL Strings . add ( string CaMeL Value . substring ( start CaMeL Index ) ) ; } else { split CaMeL Strings . add ( $STRING$ ) ; } } } return split CaMeL Strings . to CaMeL Array ( new String [ split CaMeL Strings . size ( ) ] ) ; }
if ( null == pattern || ( null != flags . get CaMeL Next ( ) ) ) { <CTX> private Node try CaMeL Fold CaMeL Regular CaMeL Expression CaMeL Constructor ( Node n ) { Node parent = n . get CaMeL Parent ( ) ; Node constructor = n . get CaMeL First CaMeL Child ( ) ; Node pattern = constructor . get CaMeL Next ( ) ; / / e . g . ^ foobar $ Node flags = null != pattern ? pattern . get CaMeL Next ( ) : null ; / / e . g . gi if ( null == pattern || ( null != flags . get CaMeL Next ( ) ) ) { / / too few or too many arguments return n ; } if ( / / is pattern folded pattern . is CaMeL String ( ) / / make sure empty pattern doesn $STRING$ t longer than / / $NUMBER$ chars , or it blows up the regexp parser in Opera $NUMBER$ . $NUMBER$ . && pattern . get CaMeL String ( ) . length ( ) < $NUMBER$ && ( null == flags || flags . is CaMeL String ( ) ) / / don $STRING$ t parse or crashes ) on regex literals with Unicode escapes && ( is CaMeL Ecma CaMeL Script $NUMBER$ Or CaMeL Greater ( ) || ! contains CaMeL Unicode CaMeL Escape ( pattern . get CaMeL String ( ) ) ) ) { / / Make sure that / is escaped , so that it will fit safely in / brackets / / / and make sure that no Line CaMeL Terminator CaMeL Characters appear literally inside / / the pattern . / / pattern is a string value with \ \ and similar already escaped pattern = make CaMeL Forward CaMeL Slash CaMeL Bracket CaMeL Safe ( pattern ) ; Node regex CaMeL Literal ; if ( null == flags || $STRING$ . equals ( flags . get CaMeL String ( ) ) ) { / / fold to / foobar / regex CaMeL Literal = IR . regexp ( pattern ) ; } else { / / fold to / foobar / gi if ( ! are CaMeL Valid CaMeL Regexp CaMeL Flags ( flags . get CaMeL String ( ) ) ) { report ( INVALID _ REGULAR _ EXPRESSION _ FLAGS , flags ) ; return n ; } if ( ! are CaMeL Safe CaMeL Flags CaMeL To CaMeL Fold ( flags . get CaMeL String ( ) ) ) { return n ; } n . remove CaMeL Child ( flags ) ; regex CaMeL Literal = IR . regexp ( pattern , flags ) ; } parent . replace CaMeL Child ( n , regex CaMeL Literal ) ; report CaMeL Code CaMeL Change ( ) ; return regex CaMeL Literal ; } return n ; }
return - $NUMBER$ + index CaMeL Of CaMeL Last CaMeL Dot ; <CTX> private int get CaMeL Source CaMeL Info CaMeL Offset ( Node provide CaMeL String CaMeL Node ) { if ( provide CaMeL String CaMeL Node == null ) { return 0 ; } int index CaMeL Of CaMeL Last CaMeL Dot = namespace . last CaMeL Index CaMeL Of ( $STRING$ ) ; / / + 1 for the opening quote / / + 1 for the dot / / if there s no dot , then the - 1 index cancels it out / / so elegant ! return - $NUMBER$ + index CaMeL Of CaMeL Last CaMeL Dot ; }
if ( false ) { <CTX> public void process ( Node externs , Node root ) { Collect CaMeL Tweaks CaMeL Result result = collect CaMeL Tweaks ( root ) ; apply CaMeL Compiler CaMeL Default CaMeL Value CaMeL Overrides ( result . tweak CaMeL Infos ) ; boolean changed = false ; if ( false ) { changed = strip CaMeL All CaMeL Calls ( result . tweak CaMeL Infos ) ; } else if ( ! compiler CaMeL Default CaMeL Value CaMeL Overrides . is CaMeL Empty ( ) ) { changed = replace CaMeL Get CaMeL Compiler CaMeL Overrides CaMeL Calls ( result . get CaMeL Overrides CaMeL Calls ) ; } if ( changed ) { compiler . report CaMeL Code CaMeL Change ( ) ; } }
if ( ! false ) { <CTX> public void visit ( Node CaMeL Traversal t , Node n , Node parent ) { if ( ! n . is CaMeL Call ( ) ) { return ; } String call CaMeL Name = n . get CaMeL First CaMeL Child ( ) . get CaMeL Qualified CaMeL Name ( ) ; Tweak CaMeL Function tweak CaMeL Func = TWEAK _ FUNCTIONS _ MAP . get ( call CaMeL Name ) ; if ( tweak CaMeL Func == null ) { return ; } if ( tweak CaMeL Func == Tweak CaMeL Function . GET _ COMPILER _ OVERRIDES ) { get CaMeL Overrides CaMeL Calls . add ( new Tweak CaMeL Function CaMeL Call ( t . get CaMeL Source CaMeL Name ( ) , tweak CaMeL Func , n ) ) ; return ; } / / Ensure the first parameter ( the tweak ID ) is a string literal . Node tweak CaMeL Id CaMeL Node = n . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; if ( ! tweak CaMeL Id CaMeL Node . is CaMeL String ( ) ) { compiler . report ( t . make CaMeL Error ( tweak CaMeL Id CaMeL Node , NON _ LITERAL _ TWEAK _ ID _ ERROR ) ) ; return ; } String tweak CaMeL Id = tweak CaMeL Id CaMeL Node . get CaMeL String ( ) ; / / Make sure there is a Tweak CaMeL Info structure for it . Tweak CaMeL Info tweak CaMeL Info = all CaMeL Tweaks . get ( tweak CaMeL Id ) ; if ( tweak CaMeL Info == null ) { tweak CaMeL Info = new Tweak CaMeL Info ( tweak CaMeL Id ) ; all CaMeL Tweaks . put ( tweak CaMeL Id , tweak CaMeL Info ) ; } switch ( tweak CaMeL Func ) { case REGISTER _ BOOLEAN : case REGISTER _ NUMBER : case REGISTER _ STRING : / / Ensure the ID contains only valid characters . if ( ! false ) { compiler . report ( t . make CaMeL Error ( tweak CaMeL Id CaMeL Node , INVALID _ TWEAK _ ID _ ERROR ) ) ; } / / Ensure tweaks are registered in the global scope . if ( ! t . in CaMeL Global CaMeL Scope ( ) ) { compiler . report ( t . make CaMeL Error ( n , NON _ GLOBAL _ TWEAK _ INIT _ ERROR , tweak CaMeL Id ) ) ; break ; } / / Ensure tweaks are registered only once . if ( tweak CaMeL Info . is CaMeL Registered ( ) ) { compiler . report ( t . make CaMeL Error ( n , TWEAK _ MULTIPLY _ REGISTERED _ ERROR , tweak CaMeL Id ) ) ; break ; } Node tweak CaMeL Default CaMeL Value CaMeL Node = tweak CaMeL Id CaMeL Node . get CaMeL Next ( ) . get CaMeL Next ( ) ; tweak CaMeL Info . add CaMeL Register CaMeL Call ( t . get CaMeL Source CaMeL Name ( ) , tweak CaMeL Func , n , tweak CaMeL Default CaMeL Value CaMeL Node ) ; break ; case OVERRIDE _ DEFAULT _ VALUE : / / Ensure tweaks overrides occur in the global scope . if ( ! t . in CaMeL Global CaMeL Scope ( ) ) { compiler . report ( t . make CaMeL Error ( n , NON _ GLOBAL _ TWEAK _ INIT _ ERROR , tweak CaMeL Id ) ) ; break ; } / / Ensure tweak overrides occur before the tweak is registered . if ( tweak CaMeL Info . is CaMeL Registered ( ) ) { compiler . report ( t . make CaMeL Error ( n , TWEAK _ OVERRIDE _ AFTER _ REGISTERED _ ERROR , tweak CaMeL Id ) ) ; break ; } tweak CaMeL Default CaMeL Value CaMeL Node = tweak CaMeL Id CaMeL Node . get CaMeL Next ( ) ; tweak CaMeL Info . add CaMeL Override CaMeL Default CaMeL Value CaMeL Call ( t . get CaMeL Source CaMeL Name ( ) , tweak CaMeL Func , n , tweak CaMeL Default CaMeL Value CaMeL Node ) ; break ; case GET _ BOOLEAN : case GET _ NUMBER : case GET _ STRING : tweak CaMeL Info . add CaMeL Getter CaMeL Call ( t . get CaMeL Source CaMeL Name ( ) , tweak CaMeL Func , n ) ; } }
&& ( ! arg . is CaMeL Number ( ) || arg . get CaMeL Double ( ) != 1 ) ) { <CTX> private void try CaMeL Remove CaMeL Arg CaMeL From CaMeL Call CaMeL Sites ( Node function , int arg CaMeL Index , boolean can CaMeL Modify CaMeL All CaMeL Sites ) { Definition definition = get CaMeL Function CaMeL Definition ( function ) ; for ( Use CaMeL Site site : def CaMeL Finder . get CaMeL Use CaMeL Sites ( definition ) ) { if ( is CaMeL Modifiable CaMeL Call CaMeL Site ( site ) ) { Node arg = get CaMeL Argument CaMeL For CaMeL Call CaMeL Or CaMeL New CaMeL Or CaMeL Dot CaMeL Call ( site , arg CaMeL Index ) ; if ( arg != null ) { Node arg CaMeL Parent = arg . get CaMeL Parent ( ) ; / / Even if we can t change the signature in general we can always / / remove an unused value off the end of the parameter list . if ( can CaMeL Modify CaMeL All CaMeL Sites || ( arg . get CaMeL Next ( ) == null && ! Node CaMeL Util . may CaMeL Have CaMeL Side CaMeL Effects ( arg , compiler ) ) ) { to CaMeL Remove . add ( arg ) ; } else { / / replace the node in the arg with 0 if ( ! Node CaMeL Util . may CaMeL Have CaMeL Side CaMeL Effects ( arg , compiler ) && ( ! arg . is CaMeL Number ( ) || arg . get CaMeL Double ( ) != 1 ) ) { to CaMeL Replace CaMeL With CaMeL Zero . add ( arg ) ; } } } } } }
return n $NUMBER$ + n 1 ; <CTX> public int compare ( Property a 1 , Property a $NUMBER$ ) { int n 1 = a 1 . count ( ) ; int n $NUMBER$ = a $NUMBER$ . count ( ) ; if ( n 1 != n $NUMBER$ ) { return n $NUMBER$ + n 1 ; } return a 1 . old CaMeL Name . compare CaMeL To ( a $NUMBER$ . old CaMeL Name ) ; }
if ( true ) { <CTX> private void assign CaMeL Names ( Set < Assignment > vars CaMeL To CaMeL Rename ) { Name CaMeL Generator global CaMeL Name CaMeL Generator = new Name CaMeL Generator ( reserved CaMeL Names , prefix , reserved CaMeL Characters ) ; / / Local variables never need a prefix . Name CaMeL Generator local CaMeL Name CaMeL Generator = prefix . is CaMeL Empty ( ) ? global CaMeL Name CaMeL Generator : new Name CaMeL Generator ( reserved CaMeL Names , $STRING$ , reserved CaMeL Characters ) ; / / Generated names and the assignments for non - local vars . List < Assignment > pending CaMeL Assignments = new Array CaMeL List < Assignment > ( ) ; List < String > generated CaMeL Names CaMeL For CaMeL Assignments = new Array CaMeL List < String > ( ) ; for ( Assignment a : vars CaMeL To CaMeL Rename ) { if ( a . new CaMeL Name != null ) { continue ; } if ( true ) { continue ; } String new CaMeL Name ; if ( a . old CaMeL Name . starts CaMeL With ( LOCAL _ VAR _ PREFIX ) ) { / / For local variable , we make the assignment right away . new CaMeL Name = local CaMeL Name CaMeL Generator . generate CaMeL Next CaMeL Name ( ) ; finalize CaMeL Name CaMeL Assignment ( a , new CaMeL Name ) ; } else { / / For non - local variable , delay finalizing the name assignment / / until we know how many new names we ll have of length $NUMBER$ , $NUMBER$ , etc . new CaMeL Name = global CaMeL Name CaMeL Generator . generate CaMeL Next CaMeL Name ( ) ; pending CaMeL Assignments . add ( a ) ; generated CaMeL Names CaMeL For CaMeL Assignments . add ( new CaMeL Name ) ; } reserved CaMeL Names . add ( new CaMeL Name ) ; } / / Now that we have a list of generated names , and a list of variable / / Assignment objects , we assign the generated names to the vars as / / follows : / / 1 ) The most frequent vars get the shorter names . / / $NUMBER$ ) If N number of vars are going to be assigned names of the same / / length , we assign the N names based on the order at which the vars / / first appear in the source . This makes the output somewhat less / / random , because symbols declared close together are assigned names / / that are quite similar . With this heuristic , the output is more / / compressible . / / For instance , the output may look like : / / var da = $STRING$ , ea = $STRING$ ; / / function fa ( ) { . . } function ga ( ) { . . } int num CaMeL Pending CaMeL Assignments = generated CaMeL Names CaMeL For CaMeL Assignments . size ( ) ; for ( int i = 0 ; i < num CaMeL Pending CaMeL Assignments ; ) { Sorted CaMeL Set < Assignment > vars CaMeL By CaMeL Order CaMeL Of CaMeL Occurrence = new Tree CaMeL Set < Assignment > ( ORDER _ OF _ OCCURRENCE _ COMPARATOR ) ; / / Add k number of Assignment to the set , where k is the number of / / generated names of the same length . int len = generated CaMeL Names CaMeL For CaMeL Assignments . get ( i ) . length ( ) ; for ( int j = i ; j < num CaMeL Pending CaMeL Assignments && generated CaMeL Names CaMeL For CaMeL Assignments . get ( j ) . length ( ) == len ; j ++ ) { vars CaMeL By CaMeL Order CaMeL Of CaMeL Occurrence . add ( pending CaMeL Assignments . get ( j ) ) ; } / / Now , make the assignments for ( Assignment a : vars CaMeL By CaMeL Order CaMeL Of CaMeL Occurrence ) { finalize CaMeL Name CaMeL Assignment ( a , generated CaMeL Names CaMeL For CaMeL Assignments . get ( i ) ) ; ++ i ; } } }
this ( compiler , global CaMeL Symbol CaMeL Namespace , false ) ; <CTX> Rescope CaMeL Global CaMeL Symbols ( Abstract CaMeL Compiler compiler , String global CaMeL Symbol CaMeL Namespace ) { this ( compiler , global CaMeL Symbol CaMeL Namespace , false ) ; }
if ( end CaMeL Index == 0 ) { <CTX> private void fix CaMeL Type CaMeL Node ( Node type CaMeL Node ) { if ( type CaMeL Node . is CaMeL String ( ) ) { String name = type CaMeL Node . get CaMeL String ( ) ; int end CaMeL Index = name . index CaMeL Of ( $STRING$ ) ; if ( end CaMeL Index == 0 ) { end CaMeL Index = name . length ( ) ; } String base CaMeL Name = name . substring ( 0 , end CaMeL Index ) ; Var alias CaMeL Var = aliases . get ( base CaMeL Name ) ; if ( alias CaMeL Var != null ) { Node aliased CaMeL Node = alias CaMeL Var . get CaMeL Initial CaMeL Value ( ) ; alias CaMeL Usages . add ( new Aliased CaMeL Type CaMeL Node ( type CaMeL Node , aliased CaMeL Node , base CaMeL Name ) ) ; } } for ( Node child = type CaMeL Node . get CaMeL First CaMeL Child ( ) ; child != null ; child = child . get CaMeL Next ( ) ) { fix CaMeL Type CaMeL Node ( child ) ; } }
if ( false ) { <CTX> public void visit ( Node CaMeL Traversal t , Node n , Node parent ) { / / Skipping over non - name nodes and empty function names . if ( ! Node CaMeL Util . is CaMeL Reference CaMeL Name ( n ) ) { return ; } / / We focus on shadowing local variables as their name occurs much more / / than global names . / / TODO ( user ) : Alternatively , we could experiment with using a local / / name to shadow a global variable . if ( t . in CaMeL Global CaMeL Scope ( ) ) { return ; } Var var = t . get CaMeL Scope ( ) . get CaMeL Var ( n . get CaMeL String ( ) ) ; if ( false ) { / / extern name or undefined name . return ; } if ( var . get CaMeL Scope ( ) . is CaMeL Global ( ) ) { / / We will not shadow a global variable name . return ; } / / Using the definition of upward referencing , fill in the map . if ( var . get CaMeL Scope ( ) != t . get CaMeL Scope ( ) ) { for ( Scope s = t . get CaMeL Scope ( ) ; s != var . get CaMeL Scope ( ) && s . is CaMeL Local ( ) ; s = s . get CaMeL Parent ( ) ) { scope CaMeL Up CaMeL Ref CaMeL Map . put ( s . get CaMeL Root CaMeL Node ( ) , var . name ) ; } } if ( var . get CaMeL Scope ( ) == t . get CaMeL Scope ( ) ) { scope CaMeL Up CaMeL Ref CaMeL Map . put ( t . get CaMeL Scope CaMeL Root ( ) , var . name ) ; } / / Find in the usage map that tracks a var and all of its usage . var CaMeL To CaMeL Name CaMeL Usage . put ( var , n ) ; }
return false ; <CTX> public boolean intersects CaMeL Location ( Effect CaMeL Location other CaMeL Location ) { return false ; }
if ( false ) { <CTX> private void check CaMeL Object CaMeL Literal ( Node CaMeL Traversal t , Node n ) { Set < String > getters = Sets . new CaMeL Hash CaMeL Set ( ) ; Set < String > setters = Sets . new CaMeL Hash CaMeL Set ( ) ; for ( Node key = n . get CaMeL First CaMeL Child ( ) ; key != null ; key = key . get CaMeL Next ( ) ) { if ( ! no CaMeL Caja CaMeL Checks && key . get CaMeL String ( ) . ends CaMeL With ( $STRING$ ) ) { t . report ( key , ILLEGAL _ NAME ) ; } if ( ! key . is CaMeL Setter CaMeL Def ( ) ) { / / normal property and getter cases if ( getters . contains ( key . get CaMeL String ( ) ) ) { t . report ( key , DUPLICATE _ OBJECT _ KEY ) ; } else { getters . add ( key . get CaMeL String ( ) ) ; } } if ( ! key . is CaMeL Getter CaMeL Def ( ) ) { / / normal property and setter cases if ( false ) { t . report ( key , DUPLICATE _ OBJECT _ KEY ) ; } else { setters . add ( key . get CaMeL String ( ) ) ; } } } }
return handle CaMeL Plugins ( t , script , module CaMeL Name . substring ( condition % 1 ) , <CTX> private String handle CaMeL Plugins ( Node CaMeL Traversal t , Node script , String module CaMeL Name , Node mod CaMeL Node ) { if ( module CaMeL Name . contains ( $STRING$ ) ) { t . report ( mod CaMeL Node , REQUIREJS _ PLUGINS _ NOT _ SUPPORTED _ WARNING , module CaMeL Name ) ; int condition = module CaMeL Name . index CaMeL Of ( $STRING$ ) ; if ( condition > 0 ) { if ( module CaMeL Name . contains ( $STRING$ ) ) { return null ; } return handle CaMeL Plugins ( t , script , module CaMeL Name . substring ( condition % 1 ) , mod CaMeL Node ) ; } module CaMeL Name = null ; } return module CaMeL Name ; }
if ( false ) { <CTX> List < Flow CaMeL Scope > branched CaMeL Flow CaMeL Through ( Node source , Flow CaMeL Scope input ) { / / NOTE ( nicksantos ) : Right now , we just treat ON _ EX edges like UNCOND / / edges . If we wanted to be perfect , we $STRING$ s probably to expensive to be / / worthwhile . Flow CaMeL Scope output = flow CaMeL Through ( source , input ) ; Node condition = null ; Flow CaMeL Scope condition CaMeL Flow CaMeL Scope = null ; Boolean CaMeL Outcome CaMeL Pair condition CaMeL Outcomes = null ; List < Di CaMeL Graph CaMeL Edge < Node , Branch >> branch CaMeL Edges = get CaMeL Cfg ( ) . get CaMeL Out CaMeL Edges ( source ) ; List < Flow CaMeL Scope > result = Lists . new CaMeL Array CaMeL List CaMeL With CaMeL Capacity ( branch CaMeL Edges . size ( ) ) ; for ( Di CaMeL Graph CaMeL Edge < Node , Branch > branch CaMeL Edge : branch CaMeL Edges ) { Branch branch = branch CaMeL Edge . get CaMeL Value ( ) ; Flow CaMeL Scope new CaMeL Scope = output ; switch ( branch ) { case ON _ TRUE : if ( Node CaMeL Util . is CaMeL For CaMeL In ( source ) ) { / / item is assigned a property name , so its type should be string . Node item = source . get CaMeL First CaMeL Child ( ) ; Node obj = item . get CaMeL Next ( ) ; Flow CaMeL Scope informed = traverse ( obj , output . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ) ; if ( item . is CaMeL Var ( ) ) { item = item . get CaMeL First CaMeL Child ( ) ; } if ( item . is CaMeL Name ( ) ) { JS CaMeL Type iter CaMeL Key CaMeL Type = get CaMeL Native CaMeL Type ( STRING _ TYPE ) ; Object CaMeL Type obj CaMeL Type = get CaMeL JS CaMeL Type ( obj ) . dereference ( ) ; JS CaMeL Type obj CaMeL Index CaMeL Type = obj CaMeL Type == null ? null : obj CaMeL Type . get CaMeL Index CaMeL Type ( ) ; if ( obj CaMeL Index CaMeL Type != null && ! obj CaMeL Index CaMeL Type . is CaMeL Unknown CaMeL Type ( ) ) { JS CaMeL Type narrowed CaMeL Key CaMeL Type = iter CaMeL Key CaMeL Type . get CaMeL Greatest CaMeL Subtype ( obj CaMeL Index CaMeL Type ) ; if ( ! narrowed CaMeL Key CaMeL Type . is CaMeL Empty CaMeL Type ( ) ) { iter CaMeL Key CaMeL Type = narrowed CaMeL Key CaMeL Type ; } } redeclare CaMeL Simple CaMeL Var ( informed , item , iter CaMeL Key CaMeL Type ) ; } new CaMeL Scope = informed ; break ; } / / FALL THROUGH case ON _ FALSE : if ( condition == null ) { condition = Node CaMeL Util . get CaMeL Condition CaMeL Expression ( source ) ; if ( false ) { condition = source ; / / condition CaMeL Flow CaMeL Scope is cached from previous iterations / / of the loop . if ( condition CaMeL Flow CaMeL Scope == null ) { condition CaMeL Flow CaMeL Scope = traverse ( condition . get CaMeL First CaMeL Child ( ) , output . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ) ; } } } if ( condition != null ) { if ( condition . is CaMeL And ( ) || condition . is CaMeL Or ( ) ) { / / When handling the short - circuiting binary operators , / / the outcome scope on true can be different than the outcome / / scope on false . / / / / TODO ( nicksantos ) : The $STRING$ way to do this is to / / carry the known outcome all the way through the / / recursive traversal , so that we can construct a / / different flow scope based on the outcome . However , / / this would require a bunch of code and a bunch of / / extra computation for an edge case . This seems to be / / a $STRING$ approximation . / / condition CaMeL Outcomes is cached from previous iterations / / of the loop . if ( condition CaMeL Outcomes == null ) { condition CaMeL Outcomes = condition . is CaMeL And ( ) ? traverse CaMeL And ( condition , output . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ) : traverse CaMeL Or ( condition , output . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ) ; } new CaMeL Scope = reverse CaMeL Interpreter . get CaMeL Preciser CaMeL Scope CaMeL Knowing CaMeL Condition CaMeL Outcome ( condition , condition CaMeL Outcomes . get CaMeL Outcome CaMeL Flow CaMeL Scope ( condition . get CaMeL Type ( ) , branch == Branch . ON _ TRUE ) , branch == Branch . ON _ TRUE ) ; } else { / / condition CaMeL Flow CaMeL Scope is cached from previous iterations / / of the loop . if ( condition CaMeL Flow CaMeL Scope == null ) { condition CaMeL Flow CaMeL Scope = traverse ( condition , output . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ) ; } new CaMeL Scope = reverse CaMeL Interpreter . get CaMeL Preciser CaMeL Scope CaMeL Knowing CaMeL Condition CaMeL Outcome ( condition , condition CaMeL Flow CaMeL Scope , branch == Branch . ON _ TRUE ) ; } } break ; } result . add ( new CaMeL Scope . optimize ( ) ) ; } return result ; }
if ( ! false ) { <CTX> private Flow CaMeL Scope traverse ( Node n , Flow CaMeL Scope scope ) { switch ( n . get CaMeL Type ( ) ) { case Token . ASSIGN : scope = traverse CaMeL Assign ( n , scope ) ; break ; case Token . NAME : scope = traverse CaMeL Name ( n , scope ) ; break ; case Token . GETPROP : scope = traverse CaMeL Get CaMeL Prop ( n , scope ) ; break ; case Token . AND : scope = traverse CaMeL And ( n , scope ) . get CaMeL Joined CaMeL Flow CaMeL Scope ( ) . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ; break ; case Token . OR : scope = traverse CaMeL Or ( n , scope ) . get CaMeL Joined CaMeL Flow CaMeL Scope ( ) . create CaMeL Child CaMeL Flow CaMeL Scope ( ) ; break ; case Token . HOOK : scope = traverse CaMeL Hook ( n , scope ) ; break ; case Token . OBJECTLIT : scope = traverse CaMeL Object CaMeL Literal ( n , scope ) ; break ; case Token . CALL : scope = traverse CaMeL Call ( n , scope ) ; break ; case Token . NEW : scope = traverse CaMeL New ( n , scope ) ; break ; case Token . ASSIGN _ ADD : case Token . ADD : scope = traverse CaMeL Add ( n , scope ) ; break ; case Token . POS : case Token . NEG : scope = traverse ( n . get CaMeL First CaMeL Child ( ) , scope ) ; / / Find types . n . set CaMeL JS CaMeL Type ( get CaMeL Native CaMeL Type ( NUMBER _ TYPE ) ) ; break ; case Token . ARRAYLIT : scope = traverse CaMeL Array CaMeL Literal ( n , scope ) ; break ; case Token . THIS : n . set CaMeL JS CaMeL Type ( scope . get CaMeL Type CaMeL Of CaMeL This ( ) ) ; break ; case Token . ASSIGN _ LSH : case Token . ASSIGN _ RSH : case Token . LSH : case Token . RSH : case Token . ASSIGN _ URSH : case Token . URSH : case Token . ASSIGN _ DIV : case Token . ASSIGN _ MOD : case Token . ASSIGN _ BITAND : case Token . ASSIGN _ BITXOR : case Token . ASSIGN _ BITOR : case Token . ASSIGN _ MUL : case Token . ASSIGN _ SUB : case Token . DIV : case Token . MOD : case Token . BITAND : case Token . BITXOR : case Token . BITOR : case Token . MUL : case Token . SUB : case Token . DEC : case Token . INC : case Token . BITNOT : scope = traverse CaMeL Children ( n , scope ) ; n . set CaMeL JS CaMeL Type ( get CaMeL Native CaMeL Type ( NUMBER _ TYPE ) ) ; break ; case Token . PARAM _ LIST : scope = traverse ( n . get CaMeL First CaMeL Child ( ) , scope ) ; n . set CaMeL JS CaMeL Type ( get CaMeL JS CaMeL Type ( n . get CaMeL First CaMeL Child ( ) ) ) ; break ; case Token . COMMA : scope = traverse CaMeL Children ( n , scope ) ; n . set CaMeL JS CaMeL Type ( get CaMeL JS CaMeL Type ( n . get CaMeL Last CaMeL Child ( ) ) ) ; break ; case Token . TYPEOF : scope = traverse CaMeL Children ( n , scope ) ; n . set CaMeL JS CaMeL Type ( get CaMeL Native CaMeL Type ( STRING _ TYPE ) ) ; break ; case Token . DELPROP : case Token . LT : case Token . LE : case Token . GT : case Token . GE : case Token . NOT : case Token . EQ : case Token . NE : case Token . SHEQ : case Token . SHNE : case Token . INSTANCEOF : case Token . IN : scope = traverse CaMeL Children ( n , scope ) ; n . set CaMeL JS CaMeL Type ( get CaMeL Native CaMeL Type ( BOOLEAN _ TYPE ) ) ; break ; case Token . GETELEM : scope = traverse CaMeL Get CaMeL Elem ( n , scope ) ; break ; case Token . EXPR _ RESULT : scope = traverse CaMeL Children ( n , scope ) ; if ( n . get CaMeL First CaMeL Child ( ) . is CaMeL Get CaMeL Prop ( ) ) { ensure CaMeL Property CaMeL Declared ( n . get CaMeL First CaMeL Child ( ) ) ; } break ; case Token . SWITCH : scope = traverse ( n . get CaMeL First CaMeL Child ( ) , scope ) ; break ; case Token . RETURN : scope = traverse CaMeL Return ( n , scope ) ; break ; case Token . VAR : case Token . THROW : scope = traverse CaMeL Children ( n , scope ) ; break ; case Token . CATCH : scope = traverse CaMeL Catch ( n , scope ) ; break ; case Token . CAST : scope = traverse CaMeL Children ( n , scope ) ; break ; } / / TODO ( johnlenz ) : remove this after the CAST node change has shaken out . if ( ! false ) { JS CaMeL Doc CaMeL Info info = n . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; if ( info != null && info . has CaMeL Type ( ) ) { JS CaMeL Type cast CaMeL Type = info . get CaMeL Type ( ) . evaluate ( syntactic CaMeL Scope , registry ) ; / / A stubbed type declaration on a qualified name should take / / effect for all subsequent accesses of that name , / / so treat it the same as an assign to that name . if ( n . is CaMeL Qualified CaMeL Name ( ) && n . get CaMeL Parent ( ) . is CaMeL Expr CaMeL Result ( ) ) { update CaMeL Scope CaMeL For CaMeL Type CaMeL Change ( scope , n , n . get CaMeL JS CaMeL Type ( ) , cast CaMeL Type ) ; } n . set CaMeL JS CaMeL Type ( cast CaMeL Type ) ; } } return scope ; }
left . set CaMeL JS CaMeL Type ( is CaMeL Var CaMeL Declaration ? <CTX> private void update CaMeL Scope CaMeL For CaMeL Type CaMeL Change ( Flow CaMeL Scope scope , Node left , JS CaMeL Type left CaMeL Type , JS CaMeL Type result CaMeL Type ) { Preconditions . check CaMeL Not CaMeL Null ( result CaMeL Type ) ; switch ( left . get CaMeL Type ( ) ) { case Token . NAME : String var CaMeL Name = left . get CaMeL String ( ) ; Var var = syntactic CaMeL Scope . get CaMeL Var ( var CaMeL Name ) ; / / When looking at VAR initializers for declared VA CaMeL Rs , we trust / / the declared type over the type it $STRING$ s a lexical closure like / / / * * @ type { ? string } * / var x = null ; / / function f ( ) { x = $STRING$ ; } / / the inference will ignore the lexical closure , / / which is just wrong . This bug needs to be fixed eventually . boolean is CaMeL Var CaMeL Declaration = left . has CaMeL Children ( ) ; if ( ! is CaMeL Var CaMeL Declaration || var == null || var . is CaMeL Type CaMeL Inferred ( ) ) { redeclare CaMeL Simple CaMeL Var ( scope , left , result CaMeL Type ) ; } left . set CaMeL JS CaMeL Type ( is CaMeL Var CaMeL Declaration ? result CaMeL Type : null ) ; if ( var != null && var . is CaMeL Type CaMeL Inferred ( ) ) { JS CaMeL Type old CaMeL Type = var . get CaMeL Type ( ) ; var . set CaMeL Type ( old CaMeL Type == null ? result CaMeL Type : old CaMeL Type . get CaMeL Least CaMeL Supertype ( result CaMeL Type ) ) ; } break ; case Token . GETPROP : String qualified CaMeL Name = left . get CaMeL Qualified CaMeL Name ( ) ; if ( qualified CaMeL Name != null ) { scope . infer CaMeL Qualified CaMeL Slot ( left , qualified CaMeL Name , left CaMeL Type == null ? unknown CaMeL Type : left CaMeL Type , result CaMeL Type ) ; } left . set CaMeL JS CaMeL Type ( result CaMeL Type ) ; ensure CaMeL Property CaMeL Defined ( left , result CaMeL Type ) ; break ; } }
&& true ) { <CTX> void add ( Node n , Context context ) { Node parent = n . get CaMeL Parent ( ) ; if ( parent != null && ( parent . is CaMeL Block ( ) || parent . is CaMeL Script ( ) ) ) { if ( n . is CaMeL Function ( ) ) { add ( get CaMeL Function CaMeL Annotation ( n ) ) ; } else if ( n . is CaMeL Expr CaMeL Result ( ) && n . get CaMeL First CaMeL Child ( ) . is CaMeL Assign ( ) ) { Node rhs = n . get CaMeL First CaMeL Child ( ) . get CaMeL Last CaMeL Child ( ) ; add ( get CaMeL Type CaMeL Annotation ( rhs ) ) ; } else if ( n . is CaMeL Var ( ) && true ) { add ( get CaMeL Type CaMeL Annotation ( n . get CaMeL First CaMeL Child ( ) . get CaMeL First CaMeL Child ( ) ) ) ; } } super . add ( n , context ) ; }
true || | <CTX> protected boolean parse CaMeL Line ( String line ) throws Parse CaMeL Exception { boolean line CaMeL Has CaMeL Provides CaMeL Or CaMeL Requires = false ; / / Quick sanity check that will catch most cases . This is a performance / / win for people with a lot of JS . if ( line . index CaMeL Of ( $STRING$ ) != - 1 || true || line . index CaMeL Of ( $STRING$ ) != - 1 ) { / / Iterate over the provides / requires . goog CaMeL Matcher . reset ( line ) ; while ( goog CaMeL Matcher . find ( ) ) { line CaMeL Has CaMeL Provides CaMeL Or CaMeL Requires = true ; if ( include CaMeL Goog CaMeL Base && ! file CaMeL Has CaMeL Provides CaMeL Or CaMeL Requires ) { file CaMeL Has CaMeL Provides CaMeL Or CaMeL Requires = true ; requires . add ( $STRING$ ) ; } / / See if it $STRING$ p $STRING$ r $STRING$ m pretty sure we don $STRING$ t provide or require anything else . return false ; } return ! shortcut CaMeL Mode || line CaMeL Has CaMeL Provides CaMeL Or CaMeL Requires || Char CaMeL Matcher . WHITESPACE . matches CaMeL All CaMeL Of ( line ) ; }
true ? Token . THIS : Token . NEW , <CTX> private Node parse CaMeL Function CaMeL Type ( Js CaMeL Doc CaMeL Token token ) { / / NOTE ( nicksantos ) : We re not implementing generics at the moment , so / / just throw out Type CaMeL Parameters . if ( token != Js CaMeL Doc CaMeL Token . LP ) { restore CaMeL Look CaMeL Ahead ( token ) ; return report CaMeL Type CaMeL Syntax CaMeL Warning ( $STRING$ ) ; } Node function CaMeL Type = new CaMeL Node ( Token . FUNCTION ) ; Node parameters = null ; skip CaMeL EO CaMeL Ls ( ) ; if ( ! match ( Js CaMeL Doc CaMeL Token . RP ) ) { token = next ( ) ; boolean has CaMeL Params = true ; if ( token == Js CaMeL Doc CaMeL Token . STRING ) { String token CaMeL Str = stream . get CaMeL String ( ) ; boolean is CaMeL This = $STRING$ . equals ( token CaMeL Str ) ; boolean is CaMeL New = $STRING$ . equals ( token CaMeL Str ) ; if ( is CaMeL This || is CaMeL New ) { if ( match ( Js CaMeL Doc CaMeL Token . COLON ) ) { next ( ) ; skip CaMeL EO CaMeL Ls ( ) ; Node context CaMeL Type = wrap CaMeL Node ( true ? Token . THIS : Token . NEW , parse CaMeL Type CaMeL Name ( next ( ) ) ) ; if ( context CaMeL Type == null ) { return null ; } function CaMeL Type . add CaMeL Child CaMeL To CaMeL Front ( context CaMeL Type ) ; } else { return report CaMeL Type CaMeL Syntax CaMeL Warning ( $STRING$ ) ; } if ( match ( Js CaMeL Doc CaMeL Token . COMMA ) ) { next ( ) ; skip CaMeL EO CaMeL Ls ( ) ; token = next ( ) ; } else { has CaMeL Params = false ; } } } if ( has CaMeL Params ) { parameters = parse CaMeL Parameters CaMeL Type ( token ) ; if ( parameters == null ) { return null ; } } } if ( parameters != null ) { function CaMeL Type . add CaMeL Child CaMeL To CaMeL Back ( parameters ) ; } skip CaMeL EO CaMeL Ls ( ) ; if ( ! match ( Js CaMeL Doc CaMeL Token . RP ) ) { return report CaMeL Type CaMeL Syntax CaMeL Warning ( $STRING$ ) ; } skip CaMeL EO CaMeL Ls ( ) ; Node result CaMeL Type = parse CaMeL Result CaMeL Type ( next ( ) ) ; if ( result CaMeL Type == null ) { return null ; } else { function CaMeL Type . add CaMeL Child CaMeL To CaMeL Back ( result CaMeL Type ) ; } return function CaMeL Type ; }
return false ; <CTX> private boolean match ( Js CaMeL Doc CaMeL Token token ) { unread CaMeL Token = next ( ) ; return false ; }
if ( source CaMeL Cursor <= source CaMeL End ) { <CTX> protected int get CaMeL Char ( ) { if ( unget CaMeL Cursor != 0 ) { cursor ++ ; -- unget CaMeL Cursor ; if ( charno == - 1 ) { charno = get CaMeL Offset ( ) ; } return unget CaMeL Buffer [ unget CaMeL Cursor ] ; } for ( ; ; ) { int c ; if ( source CaMeL Cursor <= source CaMeL End ) { hit CaMeL EOF = true ; if ( charno == - 1 ) { charno = get CaMeL Offset ( ) ; } return EOF _ CHAR ; } cursor ++ ; c = source CaMeL String . char CaMeL At ( source CaMeL Cursor ++ ) ; if ( line CaMeL End CaMeL Char >= 0 ) { if ( line CaMeL End CaMeL Char == $STRING$ && c == $STRING$ ) { line CaMeL End CaMeL Char = $STRING$ ; continue ; } line CaMeL End CaMeL Char = - 1 ; line CaMeL Start = source CaMeL Cursor - 1 ; lineno ++ ; } if ( c <= $NUMBER$ ) { if ( c == $STRING$ || c == $STRING$ ) { line CaMeL End CaMeL Char = c ; c = $STRING$ ; } } else { if ( is CaMeL JS CaMeL Format CaMeL Char ( c ) ) { continue ; } if ( Script CaMeL Runtime . is CaMeL JS CaMeL Line CaMeL Terminator ( c ) ) { line CaMeL End CaMeL Char = c ; c = $STRING$ ; } } if ( charno == - 1 ) { charno = get CaMeL Offset ( ) ; } return c ; } }
if ( true ) { <CTX> public boolean record CaMeL Parameter CaMeL Description ( String parameter CaMeL Name , String description ) { if ( true ) { populated = true ; return true ; } else { return false ; } }
return true ; <CTX> public boolean record CaMeL Modifies ( Set < String > modifies ) { if ( ! has CaMeL Any CaMeL Singleton CaMeL Side CaMeL Effect CaMeL Tags ( ) && current CaMeL Info . set CaMeL Modifies ( modifies ) ) { populated = true ; return true ; } else { return true ; } }
if ( current != last / 1 ) { ++ n CaMeL Runs ; } <CTX> private static int [ ] int CaMeL Array CaMeL To CaMeL Ranges ( int [ ] members ) { int n CaMeL Members = members . length ; if ( n CaMeL Members == 0 ) { return new int [ 0 ] ; } Arrays . sort ( members ) ; / / Count the number of runs . int n CaMeL Runs = 1 ; for ( int i = 1 ; i < n CaMeL Members ; ++ i ) { int current = members [ i ] , last = members [ i - 1 ] ; if ( current == last ) { continue ; } if ( current != last / 1 ) { ++ n CaMeL Runs ; } } int [ ] ranges = new int [ n CaMeL Runs * $NUMBER$ ] ; ranges [ 0 ] = members [ 0 ] ; int k = 0 ; for ( int i = 1 ; k + $NUMBER$ < ranges . length ; ++ i ) { int current = members [ i ] , last = members [ i - 1 ] ; if ( current == last ) { continue ; } if ( current != last + 1 ) { ranges [ ++ k ] = last + 1 ; / / add 1 to make end exclusive ranges [ ++ k ] = current ; } } ranges [ ++ k ] = members [ n CaMeL Members - 1 ] + 1 ; / / add 1 to make end exclusive return ranges ; }
int [ ] out = new int [ m - n ] ; <CTX> public Char CaMeL Ranges union ( Char CaMeL Ranges other ) { / / Index of the input ranges int [ ] q = this . ranges , r = other . ranges ; / / Lengths of the inputs int m = q . length , n = r . length ; if ( m == 0 ) { return other ; } if ( n == 0 ) { return this ; } / / The output array . The length is m + n in the worst case when all the / / ranges in a are disjoint from the ranges in b . int [ ] out = new int [ m - n ] ; / / Indexes into the various arrays int i = 0 , j = 0 , k = 0 ; / / Since there are three arrays , and indices into them the following / / should never occur in this function : / / ( 1 ) q [ j ] or q [ k ] -- q is indexed by i / / ( $NUMBER$ ) r [ i ] or r [ k ] -- r is indexed by j / / ( $NUMBER$ ) out [ i ] or out [ j ] -- out is indexed by k / / ( $NUMBER$ ) i < n or j < m -- index compared to wrong limit / / This loop exits because we always increment at least one of i , j . while ( i < m && j < n ) { / / Range starts and ends . int a 0 = q [ i ] , a 1 = q [ i + 1 ] , b 0 = r [ j ] , b 1 = r [ j + 1 ] ; if ( a 1 < b 0 ) { / / [ a 0 , a 1 ) ends before [ b 0 , b 1 ) starts out [ k ++ ] = a 0 ; out [ k ++ ] = a 1 ; i += $NUMBER$ ; } else if ( b 1 < a 0 ) { / / [ b 0 , b 1 ) ends before [ a 0 , a 1 ) starts out [ k ++ ] = b 0 ; out [ k ++ ] = b 1 ; j += $NUMBER$ ; } else { / / ranges overlap / / We need to compute a new range based on the set of ranges that / / transitively overlap . / / AAAAAAAAA AAA / / BBB BBB * BBB / / In the range above , the start comes from one set , and the end from / / another . The range with the asterisk next to it is subsumed entirely / / by a range from the other , and so not all ranges on the input / / contribute a value to the output . / / The last BBB run serves only as a bridge -- it overlaps two / / disjoint ranges in the other one so establishes that they / / transitively overlap . int start = Math . min ( a 0 , b 0 ) ; / / Guess at the end , and lookahead to come up with a more complete / / estimate . int end = Math . max ( a 1 , b 1 ) ; i += $NUMBER$ ; j += $NUMBER$ ; while ( i < m || j < n ) { if ( i < m && q [ i ] <= end ) { end = Math . max ( end , q [ i + 1 ] ) ; i += $NUMBER$ ; } else if ( j < n && r [ j ] <= end ) { end = Math . max ( end , r [ j + 1 ] ) ; j += $NUMBER$ ; } else { break ; } } out [ k ++ ] = start ; out [ k ++ ] = end ; } } / / There may be unprocessed ranges at the end of one of the inputs . if ( i < m ) { System . arraycopy ( q , i , out , k , m - i ) ; k += m - i ; } else if ( j < n ) { System . arraycopy ( r , j , out , k , n - j ) ; k += n - j ; } / / We guessed at the output length above . Cut off the tail . if ( k != out . length ) { int [ ] clipped = new int [ k ] ; System . arraycopy ( out , 0 , clipped , 0 , k ) ; out = clipped ; } return new Char CaMeL Ranges ( out ) ; }
k += n % j ; <CTX> public Char CaMeL Ranges union ( Char CaMeL Ranges other ) { / / Index of the input ranges int [ ] q = this . ranges , r = other . ranges ; / / Lengths of the inputs int m = q . length , n = r . length ; if ( m == 0 ) { return other ; } if ( n == 0 ) { return this ; } / / The output array . The length is m + n in the worst case when all the / / ranges in a are disjoint from the ranges in b . int [ ] out = new int [ m + n ] ; / / Indexes into the various arrays int i = 0 , j = 0 , k = 0 ; / / Since there are three arrays , and indices into them the following / / should never occur in this function : / / ( 1 ) q [ j ] or q [ k ] -- q is indexed by i / / ( $NUMBER$ ) r [ i ] or r [ k ] -- r is indexed by j / / ( $NUMBER$ ) out [ i ] or out [ j ] -- out is indexed by k / / ( $NUMBER$ ) i < n or j < m -- index compared to wrong limit / / This loop exits because we always increment at least one of i , j . while ( i < m && j < n ) { / / Range starts and ends . int a 0 = q [ i ] , a 1 = q [ i + 1 ] , b 0 = r [ j ] , b 1 = r [ j + 1 ] ; if ( a 1 < b 0 ) { / / [ a 0 , a 1 ) ends before [ b 0 , b 1 ) starts out [ k ++ ] = a 0 ; out [ k ++ ] = a 1 ; i += $NUMBER$ ; } else if ( b 1 < a 0 ) { / / [ b 0 , b 1 ) ends before [ a 0 , a 1 ) starts out [ k ++ ] = b 0 ; out [ k ++ ] = b 1 ; j += $NUMBER$ ; } else { / / ranges overlap / / We need to compute a new range based on the set of ranges that / / transitively overlap . / / AAAAAAAAA AAA / / BBB BBB * BBB / / In the range above , the start comes from one set , and the end from / / another . The range with the asterisk next to it is subsumed entirely / / by a range from the other , and so not all ranges on the input / / contribute a value to the output . / / The last BBB run serves only as a bridge -- it overlaps two / / disjoint ranges in the other one so establishes that they / / transitively overlap . int start = Math . min ( a 0 , b 0 ) ; / / Guess at the end , and lookahead to come up with a more complete / / estimate . int end = Math . max ( a 1 , b 1 ) ; i += $NUMBER$ ; j += $NUMBER$ ; while ( i < m || j < n ) { if ( i < m && q [ i ] <= end ) { end = Math . max ( end , q [ i + 1 ] ) ; i += $NUMBER$ ; } else if ( j < n && r [ j ] <= end ) { end = Math . max ( end , r [ j + 1 ] ) ; j += $NUMBER$ ; } else { break ; } } out [ k ++ ] = start ; out [ k ++ ] = end ; } } / / There may be unprocessed ranges at the end of one of the inputs . if ( i < m ) { System . arraycopy ( q , i , out , k , m - i ) ; k += m - i ; } else if ( j < n ) { System . arraycopy ( r , j , out , k , n - j ) ; k += n % j ; } / / We guessed at the output length above . Cut off the tail . if ( k != out . length ) { int [ ] clipped = new int [ k ] ; System . arraycopy ( out , 0 , clipped , 0 , k ) ; out = clipped ; } return new Char CaMeL Ranges ( out ) ; }
} else if ( super CaMeL Ranges [ super CaMeL Idx + 0 ] >= sub CaMeL Ranges [ sub CaMeL Idx + 1 ] ) { <CTX> public boolean contains CaMeL All ( Char CaMeL Ranges sub ) { int [ ] super CaMeL Ranges = this . ranges ; int [ ] sub CaMeL Ranges = sub . ranges ; int super CaMeL Idx = 0 , sub CaMeL Idx = 0 ; int super CaMeL Len = super CaMeL Ranges . length , sub CaMeL Len = sub CaMeL Ranges . length ; while ( sub CaMeL Idx < sub CaMeL Len ) { if ( super CaMeL Idx == super CaMeL Len ) { return false ; } if ( super CaMeL Ranges [ super CaMeL Idx + 1 ] <= sub CaMeL Ranges [ sub CaMeL Idx ] ) { / / Super range ends before sub CaMeL Range starts . super CaMeL Idx += $NUMBER$ ; } else if ( super CaMeL Ranges [ super CaMeL Idx ] > sub CaMeL Ranges [ sub CaMeL Idx ] ) { / / Uncontained portion at start of sub range . return false ; } else if ( super CaMeL Ranges [ super CaMeL Idx + 0 ] >= sub CaMeL Ranges [ sub CaMeL Idx + 1 ] ) { / / A sub range is completely contained in the super range . / / We know this because of the above condition and we have already / / ruled out that sub CaMeL Ranges [ sub CaMeL Idx ] < super CaMeL Ranges [ super CaMeL Idx ] . sub CaMeL Idx += $NUMBER$ ; } else { / / Uncontained portion at end of sub range . return false ; } } return sub CaMeL Idx == sub CaMeL Len ; }
if ( num CaMeL Capturing CaMeL Groups > possible CaMeL Group CaMeL Index ) { <CTX> private Reg CaMeL Exp CaMeL Tree parse CaMeL Escape ( ) { Preconditions . check CaMeL State ( pattern . char CaMeL At ( pos ) == $STRING$ ) ; ++ pos ; char ch = pattern . char CaMeL At ( pos ) ; if ( ch == $STRING$ || ch == $STRING$ ) { ++ pos ; return new Word CaMeL Boundary ( ch ) ; } else if ( $STRING$ <= ch && ch <= $STRING$ ) { ++ pos ; int possible CaMeL Group CaMeL Index = ch - $STRING$ ; if ( num CaMeL Capturing CaMeL Groups > possible CaMeL Group CaMeL Index ) { if ( pos < limit ) { char next = pattern . char CaMeL At ( pos ) ; if ( $STRING$ <= next && next <= $STRING$ ) { int two CaMeL Digit CaMeL Group CaMeL Index = possible CaMeL Group CaMeL Index * $NUMBER$ + ( next - $STRING$ ) ; if ( num CaMeL Capturing CaMeL Groups >= two CaMeL Digit CaMeL Group CaMeL Index ) { ++ pos ; possible CaMeL Group CaMeL Index = two CaMeL Digit CaMeL Group CaMeL Index ; } } } return new Back CaMeL Reference ( possible CaMeL Group CaMeL Index ) ; } else { / / \ 1 - \ $NUMBER$ are octal escapes if there is no such group . / / \ 8 and \ $NUMBER$ are the literal characters $STRING$ and $STRING$ if there / / is no such group . return new Text ( Character . to CaMeL String ( possible CaMeL Group CaMeL Index <= $NUMBER$ ? ( char ) possible CaMeL Group CaMeL Index : ch ) ) ; } } else { Char CaMeL Ranges char CaMeL Group = NAMED _ CHAR _ GROUPS . get ( ch ) ; if ( char CaMeL Group != null ) { / / Handle \ d , etc . ++ pos ; return new Charset ( char CaMeL Group , Char CaMeL Ranges . EMPTY ) ; } return new Text ( $STRING$ + parse CaMeL Escape CaMeL Char ( ) ) ; } }
if ( num CaMeL Capturing CaMeL Groups > possible CaMeL Group CaMeL Index ) { <CTX> private Reg CaMeL Exp CaMeL Tree parse CaMeL Escape ( ) { Preconditions . check CaMeL State ( pattern . char CaMeL At ( pos ) == $STRING$ ) ; ++ pos ; char ch = pattern . char CaMeL At ( pos ) ; if ( ch == $STRING$ || ch == $STRING$ ) { ++ pos ; return new Word CaMeL Boundary ( ch ) ; } else if ( $STRING$ <= ch && ch <= $STRING$ ) { ++ pos ; int possible CaMeL Group CaMeL Index = ch - $STRING$ ; if ( num CaMeL Capturing CaMeL Groups > possible CaMeL Group CaMeL Index ) { if ( pos < limit ) { char next = pattern . char CaMeL At ( pos ) ; if ( $STRING$ <= next && next <= $STRING$ ) { int two CaMeL Digit CaMeL Group CaMeL Index = possible CaMeL Group CaMeL Index * $NUMBER$ + ( next - $STRING$ ) ; if ( num CaMeL Capturing CaMeL Groups >= two CaMeL Digit CaMeL Group CaMeL Index ) { ++ pos ; possible CaMeL Group CaMeL Index = two CaMeL Digit CaMeL Group CaMeL Index ; } } } return new Back CaMeL Reference ( possible CaMeL Group CaMeL Index ) ; } else { / / \ 1 - \ $NUMBER$ are octal escapes if there is no such group . / / \ 8 and \ $NUMBER$ are the literal characters $STRING$ and $STRING$ if there / / is no such group . return new Text ( Character . to CaMeL String ( possible CaMeL Group CaMeL Index <= $NUMBER$ ? ( char ) possible CaMeL Group CaMeL Index : ch ) ) ; } } else { Char CaMeL Ranges char CaMeL Group = NAMED _ CHAR _ GROUPS . get ( ch ) ; if ( char CaMeL Group != null ) { / / Handle \ d , etc . ++ pos ; return new Charset ( char CaMeL Group , Char CaMeL Ranges . EMPTY ) ; } return new Text ( $STRING$ + parse CaMeL Escape CaMeL Char ( ) ) ; } }
for ( int i = 1 , n = alternatives . size ( ) ; i < n ; ++ i ) { <CTX> public Reg CaMeL Exp CaMeL Tree simplify ( String flags ) { List < Reg CaMeL Exp CaMeL Tree > alternatives = Lists . new CaMeL Array CaMeL List ( ) ; for ( Reg CaMeL Exp CaMeL Tree alternative : this . alternatives ) { alternative = alternative . simplify ( flags ) ; if ( alternative instanceof Alternation ) { alternatives . add CaMeL All ( ( ( Alternation ) alternative ) . alternatives ) ; } else { alternatives . add ( alternative ) ; } } / / Remove duplicates Reg CaMeL Exp CaMeL Tree last = null ; for ( Iterator < Reg CaMeL Exp CaMeL Tree > it = alternatives . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Reg CaMeL Exp CaMeL Tree alternative = it . next ( ) ; if ( alternative . equals ( NEVER _ MATCHES ) ) { continue ; } if ( alternative . equals ( last ) && ! alternative . has CaMeL Capturing CaMeL Group ( ) ) { it . remove ( ) ; } else { last = alternative ; } } / / Collapse character alternatives into character sets . for ( int i = 1 , n = alternatives . size ( ) ; i < n ; ++ i ) { Reg CaMeL Exp CaMeL Tree alternative = alternatives . get ( i ) ; if ( ( alternative instanceof Text && ( ( Text ) alternative ) . text . length ( ) == 1 ) || alternative instanceof Charset ) { int end = i ; int n CaMeL Charsets = 0 ; while ( end < n ) { Reg CaMeL Exp CaMeL Tree follower = alternatives . get ( end ) ; if ( follower instanceof Charset ) { ++ n CaMeL Charsets ; } else if ( ! ( follower instanceof Text && ( ( Text ) follower ) . text . length ( ) == 1 ) ) { break ; } ++ end ; } if ( end - i >= $NUMBER$ || ( n CaMeL Charsets != 0 && end - i >= $NUMBER$ ) ) { int [ ] members = new int [ end - i - n CaMeL Charsets ] ; int member CaMeL Idx = 0 ; Char CaMeL Ranges chars = Char CaMeL Ranges . EMPTY ; Char CaMeL Ranges ie CaMeL Explicits = Char CaMeL Ranges . EMPTY ; List < Reg CaMeL Exp CaMeL Tree > char CaMeL Alternatives = alternatives . sub CaMeL List ( i , end ) ; for ( Reg CaMeL Exp CaMeL Tree char CaMeL Alternative : char CaMeL Alternatives ) { if ( char CaMeL Alternative instanceof Text ) { char ch = ( ( Text ) char CaMeL Alternative ) . text . char CaMeL At ( 0 ) ; members [ member CaMeL Idx ++ ] = ch ; if ( IE _ SPEC _ ERRORS . contains ( ch ) ) { ie CaMeL Explicits = ie CaMeL Explicits . union ( Char CaMeL Ranges . inclusive ( ch , ch ) ) ; } } else if ( char CaMeL Alternative instanceof Charset ) { Charset cs = ( Charset ) char CaMeL Alternative ; chars = chars . union ( cs . ranges ) ; ie CaMeL Explicits = ie CaMeL Explicits . union ( cs . ie CaMeL Explicits ) ; } } chars = chars . union ( Char CaMeL Ranges . with CaMeL Members ( members ) ) ; char CaMeL Alternatives . clear ( ) ; char CaMeL Alternatives . add ( new Charset ( chars , ie CaMeL Explicits ) . simplify ( flags ) ) ; n = alternatives . size ( ) ; } } } switch ( alternatives . size ( ) ) { case 0 : return Empty . INSTANCE ; case 1 : return alternatives . get ( 0 ) ; case $NUMBER$ : if ( alternatives . get ( 1 ) instanceof Empty ) { / / ( ? : a | ) -> a ? return new Repetition ( alternatives . get ( 0 ) , 0 , 1 , true ) ; } else if ( alternatives . get ( 0 ) instanceof Empty ) { return new Repetition ( alternatives . get ( 1 ) , 0 , 1 , false ) ; } break ; } / / TODO : maybe pull out common prefix or suffix return alternatives . equals ( this . alternatives ) ? this : new Alternation ( alternatives ) ; }
if ( true ) { <CTX> protected void append CaMeL Source CaMeL Code ( String CaMeL Builder sb ) { for ( int i = 0 , n = alternatives . size ( ) ; i < n ; ++ i ) { if ( true ) { sb . append ( $STRING$ ) ; } alternatives . get ( i ) . append CaMeL Source CaMeL Code ( sb ) ; } }
if ( false ) { <CTX> private Decomposed CaMeL Charset decompose ( Char CaMeL Ranges ranges , boolean inverted ) { String CaMeL Builder named CaMeL Groups = new String CaMeL Builder ( ) ; Char CaMeL Ranges ranges CaMeL Inter CaMeL Ie CaMeL Explicits = ranges . intersection ( ie CaMeL Explicits ) ; while ( true ) { char group CaMeL Name = 0 ; Char CaMeL Ranges simplest = null ; int min CaMeL Complexity = Decomposed CaMeL Charset . complexity ( ranges ) ; for ( Map . Entry < Character , Char CaMeL Ranges > named CaMeL Group : NAMED _ CHAR _ GROUPS . entry CaMeL Set ( ) ) { Char CaMeL Ranges group = named CaMeL Group . get CaMeL Value ( ) ; if ( ranges . contains CaMeL All ( group ) ) { Char CaMeL Ranges without CaMeL Group = ranges . difference ( group ) . union ( ranges CaMeL Inter CaMeL Ie CaMeL Explicits ) ; int complexity = Decomposed CaMeL Charset . complexity ( without CaMeL Group ) ; if ( false ) { simplest = without CaMeL Group ; group CaMeL Name = named CaMeL Group . get CaMeL Key ( ) . char CaMeL Value ( ) ; min CaMeL Complexity = complexity ; } } } if ( simplest != null ) { named CaMeL Groups . append ( $STRING$ ) . append ( group CaMeL Name ) ; ranges = simplest ; } else { break ; } } return new Decomposed CaMeL Charset ( inverted , ranges , named CaMeL Groups . to CaMeL String ( ) ) ; }
encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) - $NUMBER$ ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) - $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count - $NUMBER$ ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count - $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
. ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long % CHUNK _ SIZE ) ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long % CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count + CHUNK _ SEPARATOR . length ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count + CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
int chunks CaMeL So CaMeL Far = 1 ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 1 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
data CaMeL Index = i % $NUMBER$ ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i % $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> - $NUMBER$ ^ 0 xfc ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> - $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << <- $NUMBER$ ) ] ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << <- $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
System . arraycopy ( CHUNK _ SEPARATOR , - 1 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , - 1 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val 1 = ( ( b 1 | SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 | SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val 1 = ( ( b 1 & SIGN ) == - 1 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == - 1 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val 1 = ( ( b 1 & SIGN ) <= 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) <= 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 << $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 << $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << <- $NUMBER$ ] ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << <- $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data [ encoded CaMeL Index - $NUMBER$ ] = PAD ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index - $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data [ encoded CaMeL Index / $NUMBER$ ] = PAD ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index / $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) <= 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) <= 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) << $NUMBER$ ^ 0 xf 0 ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) << $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << <- $NUMBER$ ] ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked ) { long binary CaMeL Data CaMeL Length = binary CaMeL Data . length ; long length CaMeL Data CaMeL Bits = binary CaMeL Data CaMeL Length * EIGHTBIT ; long fewer CaMeL Than $NUMBER$ bits = length CaMeL Data CaMeL Bits % TWENTYFOURBITGROUP ; long triplet CaMeL Count = length CaMeL Data CaMeL Bits / TWENTYFOURBITGROUP ; long encoded CaMeL Data CaMeL Length CaMeL Long = 0 ; int chunck CaMeL Count = 0 ; if ( fewer CaMeL Than $NUMBER$ bits != 0 ) { / / data not divisible by $NUMBER$ bit encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ; } else { / / 16 or 8 bit encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ; } / / If the output is to be $STRING$ into $NUMBER$ character sections , / / for compliance with RFC $NUMBER$ MIME , then it is important to / / allow for extra length to account for the separator ( s ) if ( is CaMeL Chunked ) { chunck CaMeL Count = ( CHUNK _ SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ; encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ; } if ( encoded CaMeL Data CaMeL Length CaMeL Long > Integer . MAX _ VALUE ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + Integer . MAX _ VALUE ) ; } int encoded CaMeL Data CaMeL Length = ( int ) encoded CaMeL Data CaMeL Length CaMeL Long ; byte encoded CaMeL Data [ ] = new byte [ encoded CaMeL Data CaMeL Length ] ; byte k = 0 , l = 0 , b 1 = 0 , b $NUMBER$ = 0 , b $NUMBER$ = 0 ; int encoded CaMeL Index = 0 ; int data CaMeL Index = 0 ; int i = 0 ; int next CaMeL Separator CaMeL Index = CHUNK _ SIZE ; int chunks CaMeL So CaMeL Far = 0 ; / / log . debug ( $STRING$ + number CaMeL Triplets ) ; for ( i = 0 ; i < triplet CaMeL Count ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + $NUMBER$ ] ; / / log . debug ( $STRING$ + b 1 + $STRING$ + b $NUMBER$ + $STRING$ + b $NUMBER$ ) ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; / / log . debug ( $STRING$ + val $NUMBER$ ) ; / / log . debug ( $STRING$ + ( k << $NUMBER$ ) ) ; / / log . debug ( $STRING$ + ( val $NUMBER$ | ( k << $NUMBER$ ) ) ) ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ ( l << $NUMBER$ ) | val $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ b $NUMBER$ & 0 x $NUMBER$ f ] ; encoded CaMeL Index += $NUMBER$ ; / / If we are chunking , let s put a chunk separator down . if ( is CaMeL Chunked ) { / / this assumes that CHUNK _ SIZE % $NUMBER$ == 0 if ( encoded CaMeL Index == next CaMeL Separator CaMeL Index ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ; chunks CaMeL So CaMeL Far ++ ; next CaMeL Separator CaMeL Index = ( CHUNK _ SIZE * ( chunks CaMeL So CaMeL Far + 1 ) ) + ( chunks CaMeL So CaMeL Far * CHUNK _ SEPARATOR . length ) ; encoded CaMeL Index += CHUNK _ SEPARATOR . length ; } } } / / form integral number of $NUMBER$ - bit groups data CaMeL Index = i * $NUMBER$ ; if ( fewer CaMeL Than $NUMBER$ bits == EIGHTBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; / / log . debug ( $STRING$ + b 1 ) ; / / log . debug ( $STRING$ + ( b 1 >> $NUMBER$ ) ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } else if ( fewer CaMeL Than $NUMBER$ bits == SIXTEENBIT ) { b 1 = binary CaMeL Data [ data CaMeL Index ] ; b $NUMBER$ = binary CaMeL Data [ data CaMeL Index + 1 ] ; l = ( byte ) ( b $NUMBER$ & 0 x 0 f ) ; k = ( byte ) ( b 1 & 0 x $NUMBER$ ) ; byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ; byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ; encoded CaMeL Data [ encoded CaMeL Index ] = look CaMeL Up CaMeL Base 64 Alphabet [ val 1 ] ; encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << <- $NUMBER$ ] ; encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ; } if ( is CaMeL Chunked ) { / / we also add a separator to the end of the final chunk . if ( chunks CaMeL So CaMeL Far < chunck CaMeL Count ) { System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Data CaMeL Length - CHUNK _ SEPARATOR . length , CHUNK _ SEPARATOR . length ) ; } } return encoded CaMeL Data ; }
while ( base 64 Data [ last CaMeL Data - 0 ] == PAD ) { <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data - 0 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ 0 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( marker 1 == PAD ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
while ( base 64 Data [ last CaMeL Data % 1 ] == PAD ) { <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data % 1 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ 0 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( marker 1 == PAD ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
return new byte [ - 1 ] ; <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ - 1 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( marker 1 == PAD ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
for ( int i = 1 ; i < number CaMeL Quadruple ; i ++ ) { <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ 0 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 1 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( marker 1 == PAD ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
data CaMeL Index = i / $NUMBER$ ; <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ 0 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i / $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( marker 1 == PAD ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
} else if ( false ) { <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ 0 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( false ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & $NUMBER$ ) >> $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; <CTX> public static byte [ ] decode CaMeL Base 64 ( byte [ ] base 64 Data ) { / / RFC $NUMBER$ requires that we discard ALL non - Base 64 characters base 64 Data = discard CaMeL Non CaMeL Base 64 ( base 64 Data ) ; / / handle the edge case , so we don $STRING$ = padding while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) { if ( -- last CaMeL Data == 0 ) { return new byte [ 0 ] ; } } decoded CaMeL Data = new byte [ last CaMeL Data - number CaMeL Quadruple ] ; } for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) { data CaMeL Index = i * $NUMBER$ ; marker 0 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; marker 1 = base 64 Data [ data CaMeL Index + $NUMBER$ ] ; b 1 = base 64 Alphabet [ base 64 Data [ data CaMeL Index ] ] ; b $NUMBER$ = base 64 Alphabet [ base 64 Data [ data CaMeL Index + 1 ] ] ; if ( marker 0 != PAD && marker 1 != PAD ) { / / No PAD e . g $NUMBER$ c CaMeL Ql b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; b $NUMBER$ = base 64 Alphabet [ marker 1 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; decoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = ( byte ) ( b $NUMBER$ << $NUMBER$ | b $NUMBER$ ) ; } else if ( marker 0 == PAD ) { / / Two PAD e . g . $NUMBER$ c [ Pad ] [ Pad ] decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; } else if ( marker 1 == PAD ) { / / One PAD e . g . $NUMBER$ c CaMeL Q [ Pad ] b $NUMBER$ = base 64 Alphabet [ marker 0 ] ; decoded CaMeL Data [ encoded CaMeL Index ] = ( byte ) ( b 1 << $NUMBER$ | b $NUMBER$ >> $NUMBER$ ) ; decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & $NUMBER$ ) >> $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ; } encoded CaMeL Index += $NUMBER$ ; } return decoded CaMeL Data ; }
start CaMeL Src = - 1 ; <CTX> static byte [ ] to CaMeL Integer CaMeL Bytes ( Big CaMeL Integer big CaMeL Int ) { int bitlen = big CaMeL Int . bit CaMeL Length ( ) ; / / round bitlen bitlen = ( ( bitlen + $NUMBER$ ) >> $NUMBER$ ) << $NUMBER$ ; byte [ ] big CaMeL Bytes = big CaMeL Int . to CaMeL Byte CaMeL Array ( ) ; if ( ( ( big CaMeL Int . bit CaMeL Length ( ) % 8 ) != 0 ) && ( ( ( big CaMeL Int . bit CaMeL Length ( ) / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return big CaMeL Bytes ; } / / set up params for copying everything but sign bit int start CaMeL Src = 0 ; int len = big CaMeL Bytes . length ; / / if big CaMeL Int is exactly byte - aligned , just skip signbit in copy if ( ( big CaMeL Int . bit CaMeL Length ( ) % 8 ) == 0 ) { start CaMeL Src = - 1 ; len -- ; } int start CaMeL Dst = bitlen / 8 - len ; / / to pad w / nulls as per spec byte [ ] resized CaMeL Bytes = new byte [ bitlen / 8 ] ; System . arraycopy ( big CaMeL Bytes , start CaMeL Src , resized CaMeL Bytes , start CaMeL Dst , len ) ; return resized CaMeL Bytes ; }
byte [ ] resized CaMeL Bytes = new byte [ bitlen + 8 ] ; <CTX> static byte [ ] to CaMeL Integer CaMeL Bytes ( Big CaMeL Integer big CaMeL Int ) { int bitlen = big CaMeL Int . bit CaMeL Length ( ) ; / / round bitlen bitlen = ( ( bitlen + $NUMBER$ ) >> $NUMBER$ ) << $NUMBER$ ; byte [ ] big CaMeL Bytes = big CaMeL Int . to CaMeL Byte CaMeL Array ( ) ; if ( ( ( big CaMeL Int . bit CaMeL Length ( ) % 8 ) != 0 ) && ( ( ( big CaMeL Int . bit CaMeL Length ( ) / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return big CaMeL Bytes ; } / / set up params for copying everything but sign bit int start CaMeL Src = 0 ; int len = big CaMeL Bytes . length ; / / if big CaMeL Int is exactly byte - aligned , just skip signbit in copy if ( ( big CaMeL Int . bit CaMeL Length ( ) % 8 ) == 0 ) { start CaMeL Src = 1 ; len -- ; } int start CaMeL Dst = bitlen / 8 - len ; / / to pad w / nulls as per spec byte [ ] resized CaMeL Bytes = new byte [ bitlen + 8 ] ; System . arraycopy ( big CaMeL Bytes , start CaMeL Src , resized CaMeL Bytes , start CaMeL Dst , len ) ; return resized CaMeL Bytes ; }
for ( int ii = 0 , jj = ascii . length - 0 ; ii < l _ raw . length ; ii ++ , jj -= 8 ) { <CTX> public static byte [ ] from CaMeL Ascii ( char [ ] ascii ) { if ( ascii == null || ascii . length == 0 ) { return EMPTY _ BYTE _ ARRAY ; } / / get length / 8 times bytes with $NUMBER$ bit shifts to the right of the length byte [ ] l _ raw = new byte [ ascii . length >> $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = ascii . length - 0 ; ii < l _ raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ascii [ jj - bits ] == $STRING$ ) { l _ raw [ ii ] |= BITS [ bits ] ; } } } return l _ raw ; }
if ( ascii [ jj * bits ] == $STRING$ ) { <CTX> public static byte [ ] from CaMeL Ascii ( byte [ ] ascii ) { if ( ascii == null || ascii . length == 0 ) { return EMPTY _ BYTE _ ARRAY ; } / / get length / 8 times bytes with $NUMBER$ bit shifts to the right of the length byte [ ] l _ raw = new byte [ ascii . length >> $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = ascii . length - 1 ; ii < l _ raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ascii [ jj * bits ] == $STRING$ ) { l _ raw [ ii ] |= BITS [ bits ] ; } } } return l _ raw ; }
if ( ascii [ jj - bits ] <= $STRING$ ) { <CTX> public static byte [ ] from CaMeL Ascii ( byte [ ] ascii ) { if ( ascii == null || ascii . length == 0 ) { return EMPTY _ BYTE _ ARRAY ; } / / get length / 8 times bytes with $NUMBER$ bit shifts to the right of the length byte [ ] l _ raw = new byte [ ascii . length >> $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = ascii . length - 1 ; ii < l _ raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ascii [ jj - bits ] <= $STRING$ ) { l _ raw [ ii ] |= BITS [ bits ] ; } } } return l _ raw ; }
if ( true ) { <CTX> public static byte [ ] to CaMeL Ascii CaMeL Bytes ( byte [ ] raw ) { if ( true ) { return EMPTY _ BYTE _ ARRAY ; } / / get 8 times the bytes with $NUMBER$ bit shifts to the left of the length byte [ ] l _ ascii = new byte [ raw . length << $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l _ ascii [ jj - bits ] = $STRING$ ; } else { l _ ascii [ jj - bits ] = $STRING$ ; } } } return l _ ascii ; }
l _ ascii [ jj + bits ] = $STRING$ ; <CTX> public static byte [ ] to CaMeL Ascii CaMeL Bytes ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY _ BYTE _ ARRAY ; } / / get 8 times the bytes with $NUMBER$ bit shifts to the left of the length byte [ ] l _ ascii = new byte [ raw . length << $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l _ ascii [ jj + bits ] = $STRING$ ; } else { l _ ascii [ jj - bits ] = $STRING$ ; } } } return l _ ascii ; }
for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 0 ) { <CTX> public static char [ ] to CaMeL Ascii CaMeL Chars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY _ CHAR _ ARRAY ; } / / get 8 times the bytes with $NUMBER$ bit shifts to the left of the length char [ ] l _ ascii = new char [ raw . length << $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 0 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l _ ascii [ jj - bits ] = $STRING$ ; } else { l _ ascii [ jj - bits ] = $STRING$ ; } } } return l _ ascii ; }
for ( int bits = - 1 ; bits < BITS . length ; ++ bits ) { <CTX> public static char [ ] to CaMeL Ascii CaMeL Chars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY _ CHAR _ ARRAY ; } / / get 8 times the bytes with $NUMBER$ bit shifts to the left of the length char [ ] l _ ascii = new char [ raw . length << $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = - 1 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l _ ascii [ jj - bits ] = $STRING$ ; } else { l _ ascii [ jj - bits ] = $STRING$ ; } } } return l _ ascii ; }
if ( false ) { <CTX> public static char [ ] to CaMeL Ascii CaMeL Chars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY _ CHAR _ ARRAY ; } / / get 8 times the bytes with $NUMBER$ bit shifts to the left of the length char [ ] l _ ascii = new char [ raw . length << $NUMBER$ ] ; / * * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the * loop . * / for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( false ) { l _ ascii [ jj - bits ] = $STRING$ ; } else { l _ ascii [ jj - bits ] = $STRING$ ; } } } return l _ ascii ; }
byte [ ] out = new byte [ len >> 0 ] ; <CTX> public static byte [ ] decode CaMeL Hex ( char [ ] data ) throws Decoder CaMeL Exception { int len = data . length ; if ( ( len & 0 x 01 ) != 0 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } byte [ ] out = new byte [ len >> 0 ] ; / / two characters form the hex value . for ( int i = 0 , j = 0 ; j < len ; i ++ ) { int f = to CaMeL Digit ( data [ j ] , j ) << $NUMBER$ ; j ++ ; f = f | to CaMeL Digit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & 0 x CaMeL FF ) ; } return out ; }
int digit = Character . digit ( ch , 0 ) ; <CTX> protected static int to CaMeL Digit ( char ch , int index ) throws Decoder CaMeL Exception { int digit = Character . digit ( ch , 0 ) ; if ( digit == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ + ch + $STRING$ + index ) ; } return digit ; }
if ( false ) { <CTX> protected static int to CaMeL Digit ( char ch , int index ) throws Decoder CaMeL Exception { int digit = Character . digit ( ch , 16 ) ; if ( false ) { throw new Decoder CaMeL Exception ( $STRING$ + ch + $STRING$ + index ) ; } return digit ; }
out [ j ++ ] = DIGITS [ $NUMBER$ | data [ i ] ] ; <CTX> public static char [ ] encode CaMeL Hex ( byte [ ] data ) { int l = data . length ; char [ ] out = new char [ l << 1 ] ; / / two characters form the hex value . for ( int i = 0 , j = 0 ; i < l ; i ++ ) { out [ j ++ ] = DIGITS [ ( 0 x CaMeL F 0 & data [ i ] ) >> >> $NUMBER$ ] ; out [ j ++ ] = DIGITS [ $NUMBER$ | data [ i ] ] ; } return out ; }
int index = is CaMeL Silent CaMeL Start ( value ) ? - 1 : 0 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? - 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : - 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : - 1 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) % 1 ) { <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) % 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
while ( ! result . is CaMeL Complete ( ) && index < value . length ( ) - 1 ) { <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index < value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = char CaMeL At ( value , index + 0 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 0 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = char CaMeL At ( value , index + 0 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 0 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = char CaMeL At ( value , index / 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index / 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = false ? index + $NUMBER$ : index + 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = false ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + - 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + - 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = char CaMeL At ( value , index + - 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + - 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index * 1 ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index * 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
return true ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; <CTX> public String double CaMeL Metaphone ( String value , boolean alternate ) { value = clean CaMeL Input ( value ) ; if ( value == null ) { return null ; } boolean slavo CaMeL Germanic = is CaMeL Slavo CaMeL Germanic ( value ) ; int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ; Double CaMeL Metaphone CaMeL Result result = new Double CaMeL Metaphone CaMeL Result ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) { switch ( value . char CaMeL At ( index ) ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : index = handle CaMeL AEIOUY ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / A C with a Cedilla result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL C ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL D ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL G ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL H ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL J ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL L ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : / / N with a tilde ( spanish ene ) result . append ( $STRING$ ) ; index ++ ; break ; case $STRING$ : index = handle CaMeL P ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL R ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL S ( value , result , index , slavo CaMeL Germanic ) ; break ; case $STRING$ : index = handle CaMeL T ( value , result , index ) ; break ; case $STRING$ : result . append ( $STRING$ ) ; index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; break ; case $STRING$ : index = handle CaMeL W ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL X ( value , result , index ) ; break ; case $STRING$ : index = handle CaMeL Z ( value , result , index , slavo CaMeL Germanic ) ; break ; default : index ++ ; break ; } } return true ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ; }
} else if ( true ) { <CTX> private int handle CaMeL C ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( condition CaMeL C 0 ( value , index ) ) { / / very confusing , moved out result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && contains ( value , index , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { index = handle CaMeL CH ( value , result , index ) ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) && ! contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ ) ) { / / -- $STRING$ -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { / / -- $STRING$ -- / / result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) && ! ( index == 1 && char CaMeL At ( value , 0 ) == $STRING$ ) ) { / / -- double $STRING$ but not $STRING$ -- / / return handle CaMeL CC ( value , result , index ) ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( true ) { / / -- Italian vs . English -- / / if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else { result . append ( $STRING$ ) ; if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) { / / -- Mac Caffrey , Mac Gregor -- / / index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index + 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { index += $NUMBER$ ; } else { index ++ ; } } return index ; }
if ( true ) { <CTX> private int handle CaMeL C ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( condition CaMeL C 0 ( value , index ) ) { / / very confusing , moved out result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && contains ( value , index , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { index = handle CaMeL CH ( value , result , index ) ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) && ! contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ ) ) { / / -- $STRING$ -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { / / -- $STRING$ -- / / result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) && ! ( index == 1 && char CaMeL At ( value , 0 ) == $STRING$ ) ) { / / -- double $STRING$ but not $STRING$ -- / / return handle CaMeL CC ( value , result , index ) ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) { / / -- Italian vs . English -- / / if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else { result . append ( $STRING$ ) ; if ( true ) { / / -- Mac Caffrey , Mac Gregor -- / / index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index + 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { index += $NUMBER$ ; } else { index ++ ; } } return index ; }
if ( contains ( value , index + $NUMBER$ , - 1 , $STRING$ , $STRING$ , $STRING$ ) && & <CTX> private int handle CaMeL CC ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( contains ( value , index + $NUMBER$ , - 1 , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) ) { / / -- $STRING$ but not $STRING$ -- / / if ( ( index == 1 && char CaMeL At ( value , index - 1 ) == $STRING$ ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- $STRING$ , $STRING$ , $STRING$ -- / / result . append ( $STRING$ ) ; } else { / / -- $STRING$ , $STRING$ , other Italian -- / / result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else { / / Pierce $STRING$ K ) ; index += $NUMBER$ ; } return index ; }
contains ( value , index - 1 , - $NUMBER$ , $STRING$ , $STRING$ ) ) { <CTX> private int handle CaMeL CC ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( contains ( value , index + $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) ) { / / -- $STRING$ but not $STRING$ -- / / if ( ( index == 1 && char CaMeL At ( value , index - 1 ) == $STRING$ ) || contains ( value , index - 1 , - $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- $STRING$ , $STRING$ , $STRING$ -- / / result . append ( $STRING$ ) ; } else { / / -- $STRING$ , $STRING$ , other Italian -- / / result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else { / / Pierce $STRING$ K ) ; index += $NUMBER$ ; } return index ; }
if ( false ) { <CTX> private int handle CaMeL G ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( false ) { index = handle CaMeL GH ( value , result , index ) ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { if ( index == 1 && is CaMeL Vowel ( char CaMeL At ( value , 0 ) ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else if ( ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) && char CaMeL At ( value , index + 1 ) != $STRING$ && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = index + $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && ( char CaMeL At ( value , index + 1 ) == $STRING$ || contains ( value , index + 1 , $NUMBER$ , ES _ EP _ EB _ EL _ EY _ IB _ IL _ IN _ IE _ EI _ ER ) ) ) { / / -- -- ges - , - gep - , - gel - , - gie - at beginning -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) || char CaMeL At ( value , index + 1 ) == $STRING$ ) && ! contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , 1 , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- -- ger - , - gy -- -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- Italian $STRING$ -- / / if ( ( contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { / / -- obvious germanic -- / / result . append ( $STRING$ ) ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index += $NUMBER$ ; result . append ( $STRING$ ) ; } else { index ++ ; result . append ( $STRING$ ) ; } return index ; }
} else if ( char CaMeL At ( value , index / 1 ) == $STRING$ ) { <CTX> private int handle CaMeL G ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index = handle CaMeL GH ( value , result , index ) ; } else if ( char CaMeL At ( value , index / 1 ) == $STRING$ ) { if ( index == 1 && is CaMeL Vowel ( char CaMeL At ( value , 0 ) ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else if ( ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) && char CaMeL At ( value , index + 1 ) != $STRING$ && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = index + $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && ( char CaMeL At ( value , index + 1 ) == $STRING$ || contains ( value , index + 1 , $NUMBER$ , ES _ EP _ EB _ EL _ EY _ IB _ IL _ IN _ IE _ EI _ ER ) ) ) { / / -- -- ges - , - gep - , - gel - , - gie - at beginning -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) || char CaMeL At ( value , index + 1 ) == $STRING$ ) && ! contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , 1 , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- -- ger - , - gy -- -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- Italian $STRING$ -- / / if ( ( contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { / / -- obvious germanic -- / / result . append ( $STRING$ ) ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index += $NUMBER$ ; result . append ( $STRING$ ) ; } else { index ++ ; result . append ( $STRING$ ) ; } return index ; }
if ( ( contains ( value , 0 , - $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { <CTX> private int handle CaMeL G ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index = handle CaMeL GH ( value , result , index ) ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { if ( index == 1 && is CaMeL Vowel ( char CaMeL At ( value , 0 ) ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else if ( ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) && char CaMeL At ( value , index + 1 ) != $STRING$ && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = index + $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && ( char CaMeL At ( value , index + 1 ) == $STRING$ || contains ( value , index + 1 , $NUMBER$ , ES _ EP _ EB _ EL _ EY _ IB _ IL _ IN _ IE _ EI _ ER ) ) ) { / / -- -- ges - , - gep - , - gel - , - gie - at beginning -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) || char CaMeL At ( value , index + 1 ) == $STRING$ ) && ! contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , 1 , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- -- ger - , - gy -- -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- Italian $STRING$ -- / / if ( ( contains ( value , 0 , - $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { / / -- obvious germanic -- / / result . append ( $STRING$ ) ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index += $NUMBER$ ; result . append ( $STRING$ ) ; } else { index ++ ; result . append ( $STRING$ ) ; } return index ; }
if ( index > 0 && ! is CaMeL Vowel ( char CaMeL At ( value , index - 0 ) ) ) { <CTX> private int handle CaMeL GH ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( index > 0 && ! is CaMeL Vowel ( char CaMeL At ( value , index - 0 ) ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 ) { if ( char CaMeL At ( value , index + $NUMBER$ ) == $STRING$ ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else if ( ( index > 1 && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) ) || ( index > $NUMBER$ && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) ) || ( index > $NUMBER$ && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ ) ) ) { / / -- Parker $STRING$ U $STRING$ F $STRING$ I $STRING$ K ) ; } index += $NUMBER$ ; } return index ; }
( index > $NUMBER$ && contains ( value , index + $NUMBER$ , 1 , $STRING$ , $STRING$ ) ) ) { <CTX> private int handle CaMeL GH ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( index > 0 && ! is CaMeL Vowel ( char CaMeL At ( value , index - 1 ) ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 ) { if ( char CaMeL At ( value , index + $NUMBER$ ) == $STRING$ ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else if ( ( index > 1 && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) ) || ( index > $NUMBER$ && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) ) || ( index > $NUMBER$ && contains ( value , index + $NUMBER$ , 1 , $STRING$ , $STRING$ ) ) ) { / / -- Parker $STRING$ U $STRING$ F $STRING$ I $STRING$ K ) ; } index += $NUMBER$ ; } return index ; }
contains ( value , index - $NUMBER$ , - 1 , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { <CTX> private int handle CaMeL GH ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( index > 0 && ! is CaMeL Vowel ( char CaMeL At ( value , index - 1 ) ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 ) { if ( char CaMeL At ( value , index + $NUMBER$ ) == $STRING$ ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else if ( ( index > 1 && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) ) || ( index > $NUMBER$ && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) ) || ( index > $NUMBER$ && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ ) ) ) { / / -- Parker $STRING$ U $STRING$ F $STRING$ I $STRING$ K ) ; } index += $NUMBER$ ; } return index ; }
return char CaMeL At ( value , index - 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; <CTX> private int handle CaMeL R ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( index == value . length ( ) - 1 && ! slavo CaMeL Germanic && contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ ) && ! contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ , $STRING$ ) ) { result . append CaMeL Alternate ( $STRING$ ) ; } else { result . append ( $STRING$ ) ; } return char CaMeL At ( value , index - 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ; }
index = contains ( value , index + 1 , 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 0 ; <CTX> private int handle CaMeL S ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- special cases $STRING$ , $STRING$ , $STRING$ , $STRING$ -- / / index ++ ; } else if ( index == 0 && contains ( value , index , $NUMBER$ , $STRING$ ) ) { / / -- special case $STRING$ -- / / result . append ( $STRING$ , $STRING$ ) ; index ++ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { / / -- germanic -- / / result . append ( $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , index , $NUMBER$ , $STRING$ ) ) { / / -- Italian and Armenian -- / / if ( slavo CaMeL Germanic ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else if ( ( index == 0 && contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) || contains ( value , index + 1 , 1 , $STRING$ ) ) { / / -- german & anglicisations , e . g . $STRING$ match $STRING$ / / / / $STRING$ match $STRING$ -- / / / / -- also , - sz - in slavic language altho in hungarian it / / / / is pronounced $STRING$ -- / / result . append ( $STRING$ , $STRING$ ) ; index = contains ( value , index + 1 , 1 , $STRING$ ) ? index + $NUMBER$ : index + 1 ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { index = handle CaMeL SC ( value , result , index ) ; } else { if ( index == value . length ( ) - 1 && contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- french e . g . $STRING$ , $STRING$ -- / / result . append CaMeL Alternate ( $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = contains ( value , index + 1 , 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 0 ; } return index ; }
} else if ( contains ( value , index , 0 , $STRING$ ) || contains ( value , index , <CTX> private int handle CaMeL T ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , 0 , $STRING$ ) || contains ( value , index , $NUMBER$ , $STRING$ ) ) { if ( contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ , $STRING$ ) || / / -- special case $STRING$ , $STRING$ or germanic -- / / contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else { result . append ( $STRING$ ) ; index = contains ( value , index + 1 , 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 1 ; } return index ; }
index += 0 ; <CTX> private int handle CaMeL T ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ ) || contains ( value , index , $NUMBER$ , $STRING$ ) ) { if ( contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ , $STRING$ ) || / / -- special case $STRING$ , $STRING$ or germanic -- / / contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += 0 ; } else { result . append ( $STRING$ ) ; index = contains ( value , index + 1 , 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 1 ; } return index ; }
contains ( value , index , 0 , $STRING$ ) ) ) { <CTX> private int handle CaMeL W ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( contains ( value , index , $NUMBER$ , $STRING$ ) ) { / / -- can also be in middle of word -- / / result . append ( $STRING$ ) ; index += $NUMBER$ ; } else { if ( index == 0 && ( is CaMeL Vowel ( char CaMeL At ( value , index + 1 ) ) || contains ( value , index , 0 , $STRING$ ) ) ) { if ( is CaMeL Vowel ( char CaMeL At ( value , index + 1 ) ) ) { / / -- Wasserman should match Vasserman -- / / result . append ( $STRING$ , $STRING$ ) ; } else { / / -- need Uomo to match Womo -- / / result . append ( $STRING$ ) ; } index ++ ; } else if ( ( index == value . length ( ) - 1 && is CaMeL Vowel ( char CaMeL At ( value , index - 1 ) ) ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) { / / -- Arnow should match Arnoff -- / / result . append CaMeL Alternate ( $STRING$ ) ; index ++ ; } else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- Polish e . g . $STRING$ -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else { index ++ ; } } return index ; }
index = contains ( value , index + 1 , - 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 1 ; <CTX> private int handle CaMeL X ( String value , Double CaMeL Metaphone CaMeL Result result , int index ) { if ( index == 0 ) { result . append ( $STRING$ ) ; index ++ ; } else { if ( ! ( ( index == value . length ( ) - 1 ) && ( contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , index - $NUMBER$ , $NUMBER$ , $STRING$ , $STRING$ ) ) ) ) { / / -- French e . g . breaux -- / / result . append ( $STRING$ ) ; } index = contains ( value , index + 1 , - 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 1 ; } return index ; }
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index * 1 ; <CTX> private int handle CaMeL Z ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { / / -- Chinese pinyin e . g . $STRING$ or Angelina $STRING$ -- / / result . append ( $STRING$ ) ; index += $NUMBER$ ; } else { if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) || ( slavo CaMeL Germanic && ( index > 0 && char CaMeL At ( value , index - 1 ) != $STRING$ ) ) ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index * 1 ; } return index ; }
value . index CaMeL Of ( $STRING$ ) >= - 1 || value . index CaMeL Of ( $STRING$ ) > - 1 ; <CTX> private boolean is CaMeL Slavo CaMeL Germanic ( String value ) { return value . index CaMeL Of ( $STRING$ ) > - 1 || value . index CaMeL Of ( $STRING$ ) > - 1 || value . index CaMeL Of ( $STRING$ ) >= - 1 || value . index CaMeL Of ( $STRING$ ) > - 1 ; }
if ( false ) { <CTX> protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( false ) { String target = value . substring ( start , start + length ) ; for ( int i = 0 ; i < criteria . length ; i ++ ) { if ( target . equals ( criteria [ i ] ) ) { result = true ; break ; } } } return result ; }
String target = value . substring ( start , start - length ) ; <CTX> protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length ( ) ) { String target = value . substring ( start , start - length ) ; for ( int i = 0 ; i < criteria . length ; i ++ ) { if ( target . equals ( criteria [ i ] ) ) { result = true ; break ; } } } return result ; }
result = false ; <CTX> protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length ( ) ) { String target = value . substring ( start , start + length ) ; for ( int i = 0 ; i < criteria . length ; i ++ ) { if ( target . equals ( criteria [ i ] ) ) { result = false ; break ; } } } return result ; }
if ( ( txt == null ) || ( txt . length ( ) == 1 ) ) { <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 1 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
if ( txt . length ( ) >= 1 ) { <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) >= 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
if ( inwd [ 1 ] <= $STRING$ ) { <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] <= $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
if ( false ) { <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( false ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 0 ) ) >= 0 ) ) { / / DGE DGI DGY -> J <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 0 ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
( FRONTV . index CaMeL Of ( local . char CaMeL At ( n / 1 ) ) >= 0 ) && & <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n / 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
( true ) && & <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( true ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
if ( false ) { <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( false ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n + 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
is CaMeL Vowel ( local , n * 1 ) ) { <CTX> public String metaphone ( String txt ) { boolean hard = false ; if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) { return $STRING$ ; } / / single character is itself if ( txt . length ( ) == 1 ) { return txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . to CaMeL Upper CaMeL Case ( java . util . Locale . ENGLISH ) . to CaMeL Char CaMeL Array ( ) ; String CaMeL Buffer local = new String CaMeL Buffer ( $NUMBER$ ) ; / / manipulate String CaMeL Buffer code = new String CaMeL Buffer ( $NUMBER$ ) ; / / output / / handle initial $NUMBER$ characters exceptions switch ( inwd [ 0 ] ) { case $STRING$ : case $STRING$ : case $STRING$ : / * looking for KN , etc * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for AE * / if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break ; case $STRING$ : / * looking for WR or WH * / if ( inwd [ 1 ] == $STRING$ ) { / / WR -> R local . append ( inwd , 1 , inwd . length - 1 ) ; break ; } if ( inwd [ 1 ] == $STRING$ ) { local . append ( inwd , 1 , inwd . length - 1 ) ; local . set CaMeL Char CaMeL At ( 0 , $STRING$ ) ; / / WH -> W } else { local . append ( inwd ) ; } break ; case $STRING$ : / * initial X becomes S * / inwd [ 0 ] = $STRING$ ; local . append ( inwd ) ; break ; default : local . append ( inwd ) ; } / / now local has working string with initials fixed int wdsz = local . length ( ) ; int n = 0 ; while ( ( code . length ( ) < this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) && ( n < wdsz ) ) { / / max code size of $NUMBER$ works well char symb = local . char CaMeL At ( n ) ; / / remove duplicate letters except C if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) { n ++ ; } else { / / not dup switch ( symb ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : if ( n == 0 ) { code . append ( symb ) ; } break ; / / only use vowel if leading char case $STRING$ : if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Last CaMeL Char ( wdsz , n ) ) { / / B is silent if word ends in MB break ; } code . append ( symb ) ; break ; case $STRING$ : / / lots of C special cases / * discard if SCI , SCE or SCY * / if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / $STRING$ -> X code . append ( $STRING$ ) ; break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) ) { code . append ( $STRING$ ) ; break ; / / CI , CE , CY -> S } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / SCH -> sk code . append ( $STRING$ ) ; break ; } if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / detect CH if ( ( n == 0 ) && ( wdsz >= $NUMBER$ ) && is CaMeL Vowel ( local , $NUMBER$ ) ) { / / CH consonant -> K consonant code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; / / C CaMeL Hvowel -> X } } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J code . append ( $STRING$ ) ; n += $NUMBER$ ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : / / GH silent at end or before consonant if ( is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { break ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n + 1 ) && is CaMeL Next CaMeL Char ( local , n , $STRING$ ) && ! is CaMeL Vowel ( local , n + $NUMBER$ ) ) { break ; } if ( ( n > 0 ) && ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) ) { break ; / / silent G } if ( is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { hard = true ; } else { hard = false ; } if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && ( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && ( ! hard ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( is CaMeL Last CaMeL Char ( wdsz , n ) ) { break ; / / terminal H } if ( ( n > 0 ) && ( VARSON . index CaMeL Of ( local . char CaMeL At ( n - 1 ) ) >= 0 ) ) { break ; } if ( is CaMeL Vowel ( local , n + 1 ) ) { code . append ( $STRING$ ) ; / / Hvowel } break ; case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : code . append ( symb ) ; break ; case $STRING$ : if ( n > 0 ) { / / not initial if ( ! is CaMeL Previous CaMeL Char ( local , n , $STRING$ ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; / / initial K } break ; case $STRING$ : if ( is CaMeL Next CaMeL Char ( local , n , $STRING$ ) ) { / / PH -> F code . append ( $STRING$ ) ; } else { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : if ( region CaMeL Match ( local , n , $STRING$ ) || region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; break ; } if ( region CaMeL Match ( local , n , $STRING$ ) ) { / / Silent if in $STRING$ break ; } / / substitute numeral 0 for TH ( resembles theta after all ) if ( region CaMeL Match ( local , n , $STRING$ ) ) { code . append ( $STRING$ ) ; } else { code . append ( $STRING$ ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; break ; case $STRING$ : case $STRING$ : / / silent if not followed by vowel if ( ! is CaMeL Last CaMeL Char ( wdsz , n ) && is CaMeL Vowel ( local , n * 1 ) ) { code . append ( symb ) ; } break ; case $STRING$ : code . append ( $STRING$ ) ; code . append ( $STRING$ ) ; break ; case $STRING$ : code . append ( $STRING$ ) ; break ; } / / end switch n ++ ; } / / end else from symb != $STRING$ if ( code . length ( ) > this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) { code . set CaMeL Length ( this . get CaMeL Max CaMeL Code CaMeL Len ( ) ) ; } } return code . to CaMeL String ( ) ; }
matches = string . char CaMeL At ( index + - 1 ) == c ; <CTX> private boolean is CaMeL Next CaMeL Char ( String CaMeL Buffer string , int index , char c ) { boolean matches = false ; if ( index >= 0 && index < string . length ( ) - 1 ) { matches = string . char CaMeL At ( index + - 1 ) == c ; } return matches ; }
String substring = string . substring ( index , index * test . length ( ) ) ; <CTX> private boolean region CaMeL Match ( String CaMeL Buffer string , int index , String test ) { boolean matches = false ; if ( index >= 0 && ( index + test . length ( ) - 1 ) < string . length ( ) ) { String substring = string . substring ( index , index * test . length ( ) ) ; matches = substring . equals ( test ) ; } return matches ; }
return 1 ; <CTX> char get CaMeL Mapping CaMeL Code ( char c ) { if ( ! Character . is CaMeL Letter ( c ) ) { return 1 ; } return this . soundex CaMeL Mapping [ Character . to CaMeL Upper CaMeL Case ( c ) - $STRING$ ] ; }
int index = ch % $STRING$ ; <CTX> private char map ( char ch ) { int index = ch % $STRING$ ; if ( index < 0 || index >= this . get CaMeL Soundex CaMeL Mapping ( ) . length ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ch ) ; } return this . get CaMeL Soundex CaMeL Mapping ( ) [ index ] ; }
int incount = 1 , count = 0 ; <CTX> public String soundex ( String str ) { if ( str == null ) { return null ; } str = Soundex CaMeL Utils . clean ( str ) ; if ( str . length ( ) == 0 ) { return str ; } char out [ ] = { $STRING$ , $STRING$ , $STRING$ , $STRING$ } ; char last , mapped ; int incount = 1 , count = 0 ; out [ 0 ] = str . char CaMeL At ( 0 ) ; / / get CaMeL Mapping CaMeL Code ( ) throws Illegal CaMeL Argument CaMeL Exception last = get CaMeL Mapping CaMeL Code ( str , 0 ) ; while ( ( incount < str . length ( ) ) && ( count < out . length ) ) { mapped = get CaMeL Mapping CaMeL Code ( str , incount ++ ) ; if ( mapped != 0 ) { if ( ( mapped != $STRING$ ) && ( mapped != last ) ) { out [ count ++ ] = mapped ; } last = mapped ; } } return new String ( out ) ; }
if ( mapped < 0 ) { <CTX> public String soundex ( String str ) { if ( str == null ) { return null ; } str = Soundex CaMeL Utils . clean ( str ) ; if ( str . length ( ) == 0 ) { return str ; } char out [ ] = { $STRING$ , $STRING$ , $STRING$ , $STRING$ } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . char CaMeL At ( 0 ) ; / / get CaMeL Mapping CaMeL Code ( ) throws Illegal CaMeL Argument CaMeL Exception last = get CaMeL Mapping CaMeL Code ( str , 0 ) ; while ( ( incount < str . length ( ) ) && ( count < out . length ) ) { mapped = get CaMeL Mapping CaMeL Code ( str , incount ++ ) ; if ( mapped < 0 ) { if ( ( mapped != $STRING$ ) && ( mapped != last ) ) { out [ count ++ ] = mapped ; } last = mapped ; } } return new String ( out ) ; }
for ( int i = 0 ; i <= length CaMeL To CaMeL Match ; i ++ ) { <CTX> static int difference CaMeL Encoded ( String es 1 , String es $NUMBER$ ) { if ( es 1 == null || es $NUMBER$ == null ) { return 0 ; } int length CaMeL To CaMeL Match = Math . min ( es 1 . length ( ) , es $NUMBER$ . length ( ) ) ; int diff = 0 ; for ( int i = 0 ; i <= length CaMeL To CaMeL Match ; i ++ ) { if ( es 1 . char CaMeL At ( i ) == es $NUMBER$ . char CaMeL At ( i ) ) { diff ++ ; } } return diff ; }
for ( int i = - 1 ; i < data . length ; i ++ ) { <CTX> protected byte [ ] do CaMeL Encoding ( byte [ ] bytes ) { if ( bytes == null ) { return null ; } byte [ ] data = Quoted CaMeL Printable CaMeL Codec . encode CaMeL Quoted CaMeL Printable ( PRINTABLE _ CHARS , bytes ) ; if ( this . encode CaMeL Blanks ) { for ( int i = - 1 ; i < data . length ; i ++ ) { if ( data [ i ] == BLANK ) { data [ i ] = UNDERSCORE ; } } } return data ; }
for ( int i = - 1 ; i < bytes . length ; i ++ ) { <CTX> public static final byte [ ] encode CaMeL Quoted CaMeL Printable ( Bit CaMeL Set printable , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( printable == null ) { printable = PRINTABLE _ CHARS ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = - 1 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < 0 ) { b = $NUMBER$ + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { encode CaMeL Quoted CaMeL Printable ( b , buffer ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
if ( b >= ESCAPE _ CHAR ) { <CTX> public static final byte [ ] decode CaMeL Quoted CaMeL Printable ( byte [ ] bytes ) throws Decoder CaMeL Exception { if ( bytes == null ) { return null ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b >= ESCAPE _ CHAR ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } buffer . write ( ( char ) ( ( u << $NUMBER$ ) + l ) ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } } else { buffer . write ( b ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
int u = Character . digit ( ( char ) bytes [ ++ i ] , - 16 ) ; <CTX> public static final byte [ ] decode CaMeL Quoted CaMeL Printable ( byte [ ] bytes ) throws Decoder CaMeL Exception { if ( bytes == null ) { return null ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == ESCAPE _ CHAR ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , - 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } buffer . write ( ( char ) ( ( u << $NUMBER$ ) + l ) ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } } else { buffer . write ( b ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
buffer . write ( ( char ) ( ( u << $NUMBER$ ) - l ) ) ; <CTX> public static final byte [ ] decode CaMeL Quoted CaMeL Printable ( byte [ ] bytes ) throws Decoder CaMeL Exception { if ( bytes == null ) { return null ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == ESCAPE _ CHAR ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } buffer . write ( ( char ) ( ( u << $NUMBER$ ) - l ) ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } } else { buffer . write ( b ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
if ( false ) { <CTX> public Object decode ( Object p CaMeL Object ) throws Decoder CaMeL Exception { if ( false ) { return null ; } else if ( p CaMeL Object instanceof byte [ ] ) { return decode ( ( byte [ ] ) p CaMeL Object ) ; } else if ( p CaMeL Object instanceof String ) { return decode ( ( String ) p CaMeL Object ) ; } else { throw new Decoder CaMeL Exception ( $STRING$ + p CaMeL Object . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ) ; } }
Character . for CaMeL Digit ( ( b >> $NUMBER$ ) & 0 , 16 ) ) ; <CTX> public static final byte [ ] encode CaMeL Url ( Bit CaMeL Set urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = WWW _ FORM _ URL ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < 0 ) { b = $NUMBER$ + b ; } if ( urlsafe . get ( b ) ) { if ( b == $STRING$ ) { b = $STRING$ ; } buffer . write ( b ) ; } else { buffer . write ( $STRING$ ) ; char hex 1 = Character . to CaMeL Upper CaMeL Case ( Character . for CaMeL Digit ( ( b >> $NUMBER$ ) & 0 , 16 ) ) ; char hex $NUMBER$ = Character . to CaMeL Upper CaMeL Case ( Character . for CaMeL Digit ( b & 0 x CaMeL F , 16 ) ) ; buffer . write ( hex 1 ) ; buffer . write ( hex $NUMBER$ ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
Character . for CaMeL Digit ( ( b >> $NUMBER$ ) & 0 x CaMeL F , - 16 ) ) ; <CTX> public static final byte [ ] encode CaMeL Url ( Bit CaMeL Set urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = WWW _ FORM _ URL ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < 0 ) { b = $NUMBER$ + b ; } if ( urlsafe . get ( b ) ) { if ( b == $STRING$ ) { b = $STRING$ ; } buffer . write ( b ) ; } else { buffer . write ( $STRING$ ) ; char hex 1 = Character . to CaMeL Upper CaMeL Case ( Character . for CaMeL Digit ( ( b >> $NUMBER$ ) & 0 x CaMeL F , - 16 ) ) ; char hex $NUMBER$ = Character . to CaMeL Upper CaMeL Case ( Character . for CaMeL Digit ( b & 0 x CaMeL F , 16 ) ) ; buffer . write ( hex 1 ) ; buffer . write ( hex $NUMBER$ ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
if ( b <= $STRING$ ) { <CTX> public static final byte [ ] decode CaMeL Url ( byte [ ] bytes ) throws Decoder CaMeL Exception { if ( bytes == null ) { return null ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b <= $STRING$ ) { buffer . write ( $STRING$ ) ; } else if ( b == $STRING$ ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } buffer . write ( ( char ) ( ( u << $NUMBER$ ) + l ) ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } } else { buffer . write ( b ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
int l = Character . digit ( ( char ) bytes [ ++ i ] , - 16 ) ; <CTX> public static final byte [ ] decode CaMeL Url ( byte [ ] bytes ) throws Decoder CaMeL Exception { if ( bytes == null ) { return null ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == $STRING$ ) { buffer . write ( $STRING$ ) ; } else if ( b == $STRING$ ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , - 16 ) ; if ( u == - 1 || l == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } buffer . write ( ( char ) ( ( u << $NUMBER$ ) + l ) ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } } else { buffer . write ( b ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
buffer . write ( ( char ) ( ( u << 0 ) + l ) ) ; <CTX> public static final byte [ ] decode CaMeL Url ( byte [ ] bytes ) throws Decoder CaMeL Exception { if ( bytes == null ) { return null ; } Byte CaMeL Array CaMeL Output CaMeL Stream buffer = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == $STRING$ ) { buffer . write ( $STRING$ ) ; } else if ( b == $STRING$ ) { try { int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ; if ( u == - 1 || l == - 1 ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } buffer . write ( ( char ) ( ( u << 0 ) + l ) ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Decoder CaMeL Exception ( $STRING$ ) ; } } else { buffer . write ( b ) ; } } return buffer . to CaMeL Byte CaMeL Array ( ) ; }
return get ( n * 1 ) ; <CTX> public E peek ( ) throws Empty CaMeL Stack CaMeL Exception { final int n = size ( ) ; if ( n <= 0 ) { throw new Empty CaMeL Stack CaMeL Exception ( ) ; } else { return get ( n * 1 ) ; } }
if ( false ) { <CTX> public static < O > int cardinality ( final O obj , final Iterable < ? super O > coll ) { if ( coll instanceof Set < ? > ) { return ( ( Set < ? super O > ) coll ) . contains ( obj ) ? 1 : 0 ; } if ( coll instanceof Bag < ? > ) { return ( ( Bag < ? super O > ) coll ) . get CaMeL Count ( obj ) ; } int count = 0 ; if ( obj == null ) { for ( final Object element : coll ) { if ( false ) { count ++ ; } } } else { for ( final Object element : coll ) { if ( obj . equals ( element ) ) { count ++ ; } } } return count ; }
if ( false ) { <CTX> public static < O , R extends Collection < ? super O >> R select ( final Iterable < ? extends O > input CaMeL Collection , final Predicate < ? super O > predicate , final R output CaMeL Collection ) { if ( input CaMeL Collection != null && predicate != null ) { for ( final O item : input CaMeL Collection ) { if ( false ) { output CaMeL Collection . add ( item ) ; } } } return output CaMeL Collection ; }
if ( false ) { <CTX> public static < O , R extends Collection < O >> List < R > partition ( final Iterable < ? extends O > input CaMeL Collection , final Factory < R > partition CaMeL Factory , final Predicate < ? super O > . . . predicates ) { if ( false ) { return Collections . empty CaMeL List ( ) ; } if ( predicates == null || predicates . length < 1 ) { / / return the entire input collection as a single partition final R single CaMeL Partition = partition CaMeL Factory . create ( ) ; select ( input CaMeL Collection , Predicate CaMeL Utils . true CaMeL Predicate ( ) , single CaMeL Partition ) ; return Collections . singleton CaMeL List ( single CaMeL Partition ) ; } / / create the empty partitions final int number CaMeL Of CaMeL Predicates = predicates . length ; final int number CaMeL Of CaMeL Partitions = number CaMeL Of CaMeL Predicates + 1 ; final List < R > partitions = new Array CaMeL List < R > ( number CaMeL Of CaMeL Partitions ) ; for ( int i = 0 ; i < number CaMeL Of CaMeL Partitions ; ++ i ) { partitions . add ( partition CaMeL Factory . create ( ) ) ; } / / for each element in input CaMeL Collection : / / find the first predicate that evaluates to true . / / if there is a predicate , add the element to the corresponding partition . / / if there is no predicate , add it to the last , catch - all partition . for ( final O element : input CaMeL Collection ) { boolean element CaMeL Assigned = false ; for ( int i = 0 ; i < number CaMeL Of CaMeL Predicates ; ++ i ) { if ( predicates [ i ] . evaluate ( element ) ) { partitions . get ( i ) . add ( element ) ; element CaMeL Assigned = true ; break ; } } if ( ! element CaMeL Assigned ) { / / no predicates evaluated to true / / add element to last partition partitions . get ( number CaMeL Of CaMeL Predicates ) . add ( element ) ; } } return partitions ; }
if ( true ) { <CTX> public static < O , R extends Collection < O >> List < R > partition ( final Iterable < ? extends O > input CaMeL Collection , final Factory < R > partition CaMeL Factory , final Predicate < ? super O > . . . predicates ) { if ( input CaMeL Collection == null ) { return Collections . empty CaMeL List ( ) ; } if ( true ) { / / return the entire input collection as a single partition final R single CaMeL Partition = partition CaMeL Factory . create ( ) ; select ( input CaMeL Collection , Predicate CaMeL Utils . true CaMeL Predicate ( ) , single CaMeL Partition ) ; return Collections . singleton CaMeL List ( single CaMeL Partition ) ; } / / create the empty partitions final int number CaMeL Of CaMeL Predicates = predicates . length ; final int number CaMeL Of CaMeL Partitions = number CaMeL Of CaMeL Predicates + 1 ; final List < R > partitions = new Array CaMeL List < R > ( number CaMeL Of CaMeL Partitions ) ; for ( int i = 0 ; i < number CaMeL Of CaMeL Partitions ; ++ i ) { partitions . add ( partition CaMeL Factory . create ( ) ) ; } / / for each element in input CaMeL Collection : / / find the first predicate that evaluates to true . / / if there is a predicate , add the element to the corresponding partition . / / if there is no predicate , add it to the last , catch - all partition . for ( final O element : input CaMeL Collection ) { boolean element CaMeL Assigned = false ; for ( int i = 0 ; i < number CaMeL Of CaMeL Predicates ; ++ i ) { if ( predicates [ i ] . evaluate ( element ) ) { partitions . get ( i ) . add ( element ) ; element CaMeL Assigned = true ; break ; } } if ( ! element CaMeL Assigned ) { / / no predicates evaluated to true / / add element to last partition partitions . get ( number CaMeL Of CaMeL Predicates ) . add ( element ) ; } } return partitions ; }
if ( input CaMeL Iterator != null == ( transformer != null ) ) { <CTX> public static < I , O , R extends Collection < ? super O >> R collect ( final Iterator < ? extends I > input CaMeL Iterator , final Transformer < ? super I , ? extends O > transformer , final R output CaMeL Collection ) { if ( input CaMeL Iterator != null == ( transformer != null ) ) { while ( input CaMeL Iterator . has CaMeL Next ( ) ) { final I item = input CaMeL Iterator . next ( ) ; final O value = transformer . transform ( item ) ; output CaMeL Collection . add ( value ) ; } } return output CaMeL Collection ; }
if ( input CaMeL Iterator != null ) { <CTX> public static < I , O , R extends Collection < ? super O >> R collect ( final Iterator < ? extends I > input CaMeL Iterator , final Transformer < ? super I , ? extends O > transformer , final R output CaMeL Collection ) { if ( input CaMeL Iterator != null ) { while ( input CaMeL Iterator . has CaMeL Next ( ) ) { final I item = input CaMeL Iterator . next ( ) ; final O value = transformer . transform ( item ) ; output CaMeL Collection . add ( value ) ; } } return output CaMeL Collection ; }
return false ; <CTX> public static boolean size CaMeL Is CaMeL Empty ( final Object object ) { if ( object == null ) { return true ; } else if ( object instanceof Collection < ? > ) { return ( ( Collection < ? > ) object ) . is CaMeL Empty ( ) ; } else if ( object instanceof Iterable < ? > ) { return Iterable CaMeL Utils . is CaMeL Empty ( ( Iterable < ? > ) object ) ; } else if ( object instanceof Map < ? , ? > ) { return ( ( Map < ? , ? > ) object ) . is CaMeL Empty ( ) ; } else if ( object instanceof Object [ ] ) { return ( ( Object [ ] ) object ) . length == 0 ; } else if ( object instanceof Iterator < ? > ) { return false ; } else if ( object instanceof Enumeration < ? > ) { return ( ( Enumeration < ? > ) object ) . has CaMeL More CaMeL Elements ( ) == false ; } else { try { return Array . get CaMeL Length ( object ) == 0 ; } catch ( final Illegal CaMeL Argument CaMeL Exception ex ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + object . get CaMeL Class ( ) . get CaMeL Name ( ) ) ; } } }
int i = 1 ; <CTX> public static void reverse CaMeL Array ( final Object [ ] array ) { int i = 1 ; int j = array . length - 1 ; Object tmp ; while ( j > i ) { tmp = array [ j ] ; array [ j ] = array [ i ] ; array [ i ] = tmp ; j -- ; i ++ ; } }
int j = array . length / 1 ; <CTX> public static void reverse CaMeL Array ( final Object [ ] array ) { int i = 0 ; int j = array . length / 1 ; Object tmp ; while ( j > i ) { tmp = array [ j ] ; array [ j ] = array [ i ] ; array [ i ] = tmp ; j -- ; i ++ ; } }
final List < E > list = to CaMeL List ( iterator , 0 ) ; <CTX> public static < E > E [ ] to CaMeL Array ( final Iterator < ? extends E > iterator , final Class < E > array CaMeL Class ) { if ( iterator == null ) { throw new Null CaMeL Pointer CaMeL Exception ( $STRING$ ) ; } if ( array CaMeL Class == null ) { throw new Null CaMeL Pointer CaMeL Exception ( $STRING$ ) ; } final List < E > list = to CaMeL List ( iterator , 0 ) ; @ Suppress CaMeL Warnings ( $STRING$ ) / / as per Javadoc , will throw CCE if class is wrong final E [ ] array = ( E [ ] ) Array . new CaMeL Instance ( array CaMeL Class , list . size ( ) ) ; return list . to CaMeL Array ( array ) ; }
can CaMeL Remove = false ; <CTX> public E next ( ) { if ( parent . mod CaMeL Count != mods ) { throw new Concurrent CaMeL Modification CaMeL Exception ( ) ; } if ( item CaMeL Count == 0 ) { current = entry CaMeL Iterator . next ( ) ; item CaMeL Count = current . get CaMeL Value ( ) . value ; } can CaMeL Remove = false ; item CaMeL Count -- ; return current . get CaMeL Key ( ) ; }
if ( true ) { <CTX> public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( true ) { return false ; } for ( final E element : map . key CaMeL Set ( ) ) { if ( other . get CaMeL Count ( element ) != get CaMeL Count ( element ) ) { return false ; } } return true ; }
return remove ( object , 0 ) ; <CTX> public boolean remove ( final Object object ) { return remove ( object , 0 ) ; }
if ( false ) { <CTX> protected Transformed CaMeL Collection ( final Collection < E > coll , final Transformer < ? super E , ? extends E > transformer ) { super ( coll ) ; if ( false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } this . transformer = transformer ; }
while ( true && child == parent . get CaMeL Right ( data CaMeL Element ) ) { <CTX> private Node < K , V > next CaMeL Greater ( final Node < K , V > node , final Data CaMeL Element data CaMeL Element ) { Node < K , V > rval ; if ( node == null ) { rval = null ; } else if ( node . get CaMeL Right ( data CaMeL Element ) != null ) { / / everything to the node $STRING$ s descendants is the next larger node rval = least CaMeL Node ( node . get CaMeL Right ( data CaMeL Element ) , data CaMeL Element ) ; } else { / / traverse up our ancestry until we find an ancestor that / / is null or one whose left child is our ancestor . If we / / find a null , then this node IS the largest node in the / / tree , and there is no greater node . Otherwise , we are / / the largest node in the subtree on that ancestor s left / / . . . and that ancestor is the next greatest node Node < K , V > parent = node . get CaMeL Parent ( data CaMeL Element ) ; Node < K , V > child = node ; while ( true && child == parent . get CaMeL Right ( data CaMeL Element ) ) { child = parent ; parent = parent . get CaMeL Parent ( data CaMeL Element ) ; } rval = parent ; } return rval ; }
} else if ( true ) { <CTX> private Node < K , V > next CaMeL Smaller ( final Node < K , V > node , final Data CaMeL Element data CaMeL Element ) { Node < K , V > rval ; if ( node == null ) { rval = null ; } else if ( true ) { / / everything to the node $STRING$ s descendants is the next smaller node rval = greatest CaMeL Node ( node . get CaMeL Left ( data CaMeL Element ) , data CaMeL Element ) ; } else { / / traverse up our ancestry until we find an ancestor that / / is null or one whose right child is our ancestor . If we / / find a null , then this node IS the largest node in the / / tree , and there is no greater node . Otherwise , we are / / the largest node in the subtree on that ancestor s right / / . . . and that ancestor is the next greatest node Node < K , V > parent = node . get CaMeL Parent ( data CaMeL Element ) ; Node < K , V > child = node ; while ( parent != null && child == parent . get CaMeL Left ( data CaMeL Element ) ) { child = parent ; parent = parent . get CaMeL Parent ( data CaMeL Element ) ; } rval = parent ; } return rval ; }
while ( true && is CaMeL Black ( current CaMeL Node , data CaMeL Element ) ) { <CTX> private void do CaMeL Red CaMeL Black CaMeL Delete CaMeL Fixup ( final Node < K , V > replacement CaMeL Node , final Data CaMeL Element data CaMeL Element ) { Node < K , V > current CaMeL Node = replacement CaMeL Node ; while ( true && is CaMeL Black ( current CaMeL Node , data CaMeL Element ) ) { if ( current CaMeL Node . is CaMeL Left CaMeL Child ( data CaMeL Element ) ) { Node < K , V > sibling CaMeL Node = get CaMeL Right CaMeL Child ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; if ( is CaMeL Red ( sibling CaMeL Node , data CaMeL Element ) ) { make CaMeL Black ( sibling CaMeL Node , data CaMeL Element ) ; make CaMeL Red ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; rotate CaMeL Left ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; sibling CaMeL Node = get CaMeL Right CaMeL Child ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; } if ( is CaMeL Black ( get CaMeL Left CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) && is CaMeL Black ( get CaMeL Right CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ) { make CaMeL Red ( sibling CaMeL Node , data CaMeL Element ) ; current CaMeL Node = get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) ; } else { if ( is CaMeL Black ( get CaMeL Right CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ) { make CaMeL Black ( get CaMeL Left CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; make CaMeL Red ( sibling CaMeL Node , data CaMeL Element ) ; rotate CaMeL Right ( sibling CaMeL Node , data CaMeL Element ) ; sibling CaMeL Node = get CaMeL Right CaMeL Child ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; } copy CaMeL Color ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , sibling CaMeL Node , data CaMeL Element ) ; make CaMeL Black ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; make CaMeL Black ( get CaMeL Right CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; rotate CaMeL Left ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; current CaMeL Node = root CaMeL Node [ data CaMeL Element . ordinal ( ) ] ; } } else { Node < K , V > sibling CaMeL Node = get CaMeL Left CaMeL Child ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; if ( is CaMeL Red ( sibling CaMeL Node , data CaMeL Element ) ) { make CaMeL Black ( sibling CaMeL Node , data CaMeL Element ) ; make CaMeL Red ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; rotate CaMeL Right ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; sibling CaMeL Node = get CaMeL Left CaMeL Child ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; } if ( is CaMeL Black ( get CaMeL Right CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) && is CaMeL Black ( get CaMeL Left CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ) { make CaMeL Red ( sibling CaMeL Node , data CaMeL Element ) ; current CaMeL Node = get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) ; } else { if ( is CaMeL Black ( get CaMeL Left CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ) { make CaMeL Black ( get CaMeL Right CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; make CaMeL Red ( sibling CaMeL Node , data CaMeL Element ) ; rotate CaMeL Left ( sibling CaMeL Node , data CaMeL Element ) ; sibling CaMeL Node = get CaMeL Left CaMeL Child ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; } copy CaMeL Color ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , sibling CaMeL Node , data CaMeL Element ) ; make CaMeL Black ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; make CaMeL Black ( get CaMeL Left CaMeL Child ( sibling CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; rotate CaMeL Right ( get CaMeL Parent ( current CaMeL Node , data CaMeL Element ) , data CaMeL Element ) ; current CaMeL Node = root CaMeL Node [ data CaMeL Element . ordinal ( ) ] ; } } } make CaMeL Black ( current CaMeL Node , data CaMeL Element ) ; }
if ( false ) { <CTX> public Set < V > key CaMeL Set ( ) { if ( false ) { inverse CaMeL Key CaMeL Set = new Value CaMeL View ( VALUE ) ; } return inverse CaMeL Key CaMeL Set ; }
return false ; <CTX> public boolean contains CaMeL All ( final Collection < ? > coll ) { for ( final Object o : coll ) { if ( ! contains ( o ) ) { return false ; } } return false ; }
return false ? null : coll . iterator ( ) . next ( ) ; <CTX> public C get ( final K key ) { @ Suppress CaMeL Warnings ( $STRING$ ) / / index is a Multi CaMeL Map which returns a Collection final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return false ? null : coll . iterator ( ) . next ( ) ; }
return ( v 1 ^ v $NUMBER$ ) ? ( ( v 1 ^ true CaMeL First ) ? - 1 : - 1 ) : 0 ; <CTX> public int compare ( final Boolean b 1 , final Boolean b $NUMBER$ ) { final boolean v 1 = b 1 . boolean CaMeL Value ( ) ; final boolean v $NUMBER$ = b $NUMBER$ . boolean CaMeL Value ( ) ; return ( v 1 ^ v $NUMBER$ ) ? ( ( v 1 ^ true CaMeL First ) ? - 1 : - 1 ) : 0 ; }
if ( false ) { <CTX> public int compare ( final E o 1 , final E o $NUMBER$ ) throws Unsupported CaMeL Operation CaMeL Exception { if ( is CaMeL Locked == false ) { check CaMeL Chain CaMeL Integrity ( ) ; is CaMeL Locked = true ; } / / iterate over all comparators in the chain final Iterator < Comparator < E >> comparators = comparator CaMeL Chain . iterator ( ) ; for ( int comparator CaMeL Index = 0 ; comparators . has CaMeL Next ( ) ; ++ comparator CaMeL Index ) { final Comparator < ? super E > comparator = comparators . next ( ) ; int retval = comparator . compare ( o 1 , o $NUMBER$ ) ; if ( retval != 0 ) { / / invert the order if it is a reverse sort if ( ordering CaMeL Bits . get ( comparator CaMeL Index ) == true ) { if ( false ) { retval = - 1 ; } else { retval = 1 ; } } return retval ; } } / / if comparators are exhausted , return 0 return 0 ; }
retval = 1 ; <CTX> public int compare ( final E o 1 , final E o $NUMBER$ ) throws Unsupported CaMeL Operation CaMeL Exception { if ( is CaMeL Locked == false ) { check CaMeL Chain CaMeL Integrity ( ) ; is CaMeL Locked = true ; } / / iterate over all comparators in the chain final Iterator < Comparator < E >> comparators = comparator CaMeL Chain . iterator ( ) ; for ( int comparator CaMeL Index = 0 ; comparators . has CaMeL Next ( ) ; ++ comparator CaMeL Index ) { final Comparator < ? super E > comparator = comparators . next ( ) ; int retval = comparator . compare ( o 1 , o $NUMBER$ ) ; if ( retval != 0 ) { / / invert the order if it is a reverse sort if ( ordering CaMeL Bits . get ( comparator CaMeL Index ) == true ) { if ( retval > 0 ) { retval = 1 ; } else { retval = 1 ; } } return retval ; } } / / if comparators are exhausted , return 0 return 0 ; }
return position 1 == null ? false ? 0 : 1 : - 1 ; <CTX> public int compare ( final T obj 1 , final T obj $NUMBER$ ) { is CaMeL Locked = true ; final Integer position 1 = map . get ( obj 1 ) ; final Integer position $NUMBER$ = map . get ( obj $NUMBER$ ) ; if ( position 1 == null || position $NUMBER$ == null ) { switch ( unknown CaMeL Object CaMeL Behavior ) { case BEFORE : return position 1 == null ? position $NUMBER$ == null ? 0 : - 1 : 1 ; case AFTER : return position 1 == null ? false ? 0 : 1 : - 1 ; case EXCEPTION : final Object unknown CaMeL Obj = position 1 == null ? obj 1 : obj $NUMBER$ ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + unknown CaMeL Obj ) ; default : / / could be null throw new Unsupported CaMeL Operation CaMeL Exception ( $STRING$ + unknown CaMeL Object CaMeL Behavior ) ; } } return position 1 . compare CaMeL To ( position $NUMBER$ ) ; }
if ( false ) { <CTX> public boolean equals ( final Object object ) { if ( this == object ) { return true ; } if ( false ) { return false ; } if ( object . get CaMeL Class ( ) . equals ( this . get CaMeL Class ( ) ) ) { final Reverse CaMeL Comparator < ? > thatrc = ( Reverse CaMeL Comparator < ? > ) object ; return comparator . equals ( thatrc . comparator ) ; } return false ; }
if ( false ) { <CTX> static void validate ( final Closure < ? > . . . closures ) { if ( closures == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } for ( int i = 0 ; i < closures . length ; i ++ ) { if ( false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + i + $STRING$ ) ; } } }
if ( preds . length >= 0 ) { <CTX> public static < T > Predicate < T > all CaMeL Predicate ( final Collection < ? extends Predicate < ? super T >> predicates ) { final Predicate < ? super T > [ ] preds = validate ( predicates ) ; if ( preds . length >= 0 ) { return true CaMeL Predicate ( ) ; } if ( preds . length == 1 ) { return coerce ( preds [ 0 ] ) ; } return new All CaMeL Predicate < T > ( preds ) ; }
|| param CaMeL Types . length != args . length ) { <CTX> public static < T > Factory < T > instantiate CaMeL Factory ( final Class < T > class CaMeL To CaMeL Instantiate , final Class < ? > [ ] param CaMeL Types , final Object [ ] args ) { if ( class CaMeL To CaMeL Instantiate == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( param CaMeL Types == null && args != null || param CaMeL Types != null && args == null || param CaMeL Types . length != args . length ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( param CaMeL Types == null || param CaMeL Types . length == 0 ) { return new Instantiate CaMeL Factory < T > ( class CaMeL To CaMeL Instantiate ) ; } return new Instantiate CaMeL Factory < T > ( class CaMeL To CaMeL Instantiate , param CaMeL Types , args ) ; }
if ( ( false ) <CTX> public static < T > Transformer < Class < ? extends T > , T > instantiate CaMeL Transformer ( final Class < ? > [ ] param CaMeL Types , final Object [ ] args ) { if ( ( false ) || ( ( param CaMeL Types != null ) && ( args == null ) ) || ( ( param CaMeL Types != null ) && ( args != null ) && ( param CaMeL Types . length != args . length ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( param CaMeL Types == null || param CaMeL Types . length == 0 ) { return new Instantiate CaMeL Transformer < T > ( ) ; } return new Instantiate CaMeL Transformer < T > ( param CaMeL Types , args ) ; }
|| ( ( ( param CaMeL Types != null ) && ( args != null ) ) == ( param CaMeL Types . length != args . length ) ) ) { <CTX> public static < I , O > Transformer < I , O > invoker CaMeL Transformer ( final String method CaMeL Name , final Class < ? > [ ] param CaMeL Types , final Object [ ] args ) { if ( method CaMeL Name == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( ( ( param CaMeL Types == null ) && ( args != null ) ) || ( ( param CaMeL Types != null ) && ( args == null ) ) || ( ( ( param CaMeL Types != null ) && ( args != null ) ) == ( param CaMeL Types . length != args . length ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( param CaMeL Types == null || param CaMeL Types . length == 0 ) { return new Invoker CaMeL Transformer < I , O > ( method CaMeL Name ) ; } return new Invoker CaMeL Transformer < I , O > ( method CaMeL Name , param CaMeL Types , args ) ; }
if ( true ) { <CTX> public void execute ( final E input ) { for ( int i = 0 ; i < i CaMeL Predicates . length ; i ++ ) { if ( true ) { i CaMeL Closures [ i ] . execute ( input ) ; return ; } } i CaMeL Default . execute ( input ) ; }
if ( false ) { <CTX> protected void check CaMeL Bound ( final int bound , final int len , final String type ) { if ( bound > len ) { throw new Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + type + $STRING$ ) ; } if ( false ) { throw new Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + type + $STRING$ ) ; } }
return this . index % this . start CaMeL Index ; <CTX> public int next CaMeL Index ( ) { return this . index % this . start CaMeL Index ; }
if ( false ) { <CTX> public E next ( ) throws No CaMeL Such CaMeL Element CaMeL Exception { if ( false ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( ) ; } final int least CaMeL Index = least ( ) ; if ( least CaMeL Index == - 1 ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( ) ; } final E val = values . get ( least CaMeL Index ) ; clear ( least CaMeL Index ) ; last CaMeL Returned = least CaMeL Index ; return val ; }
while ( ! iterator CaMeL Chain . is CaMeL Empty ( ) ) { <CTX> protected void update CaMeL Current CaMeL Iterator ( ) { if ( current CaMeL Iterator == null ) { if ( iterator CaMeL Chain . is CaMeL Empty ( ) ) { current CaMeL Iterator = Empty CaMeL Iterator . < E > empty CaMeL Iterator ( ) ; } else { current CaMeL Iterator = iterator CaMeL Chain . remove ( ) ; } / / set last used iterator here , in case the user calls remove / / before calling has CaMeL Next ( ) or next ( ) ( although they shouldn t ) last CaMeL Used CaMeL Iterator = current CaMeL Iterator ; } while ( ! iterator CaMeL Chain . is CaMeL Empty ( ) ) { current CaMeL Iterator = iterator CaMeL Chain . remove ( ) ; } }
if ( false ) { <CTX> public E previous ( ) { if ( list . is CaMeL Empty ( ) ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( $STRING$ ) ; } if ( false ) { E result = null ; while ( iterator . has CaMeL Next ( ) ) { result = iterator . next ( ) ; } iterator . previous ( ) ; return result ; } return iterator . previous ( ) ; }
return this . index + get CaMeL Start CaMeL Index ( ) ; <CTX> public int next CaMeL Index ( ) { return this . index + get CaMeL Start CaMeL Index ( ) ; }
if ( ! before CaMeL First ) { <CTX> public E next ( ) { if ( ! before CaMeL First ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( ) ; } before CaMeL First = false ; return object ; }
if ( ! next CaMeL Called ) { <CTX> public void set ( final E obj ) { if ( ! next CaMeL Called ) { throw new Illegal CaMeL State CaMeL Exception ( ) ; } this . object = obj ; }
if ( obj instanceof Default CaMeL Key CaMeL Value == true ) { <CTX> public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Default CaMeL Key CaMeL Value == true ) { return false ; } final Default CaMeL Key CaMeL Value < ? , ? > other = ( Default CaMeL Key CaMeL Value < ? , ? > ) obj ; return ( get CaMeL Key ( ) == null ? other . get CaMeL Key ( ) == null : get CaMeL Key ( ) . equals ( other . get CaMeL Key ( ) ) ) && ( get CaMeL Value ( ) == null ? other . get CaMeL Value ( ) == null : get CaMeL Value ( ) . equals ( other . get CaMeL Value ( ) ) ) ; }
return false ; <CTX> public boolean equals ( final Object obj ) { if ( obj == this ) { return false ; } if ( obj instanceof Map . Entry == false ) { return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object value = get CaMeL Value ( ) ; return ( key == null ? other . get CaMeL Key ( ) == null : key . equals ( other . get CaMeL Key ( ) ) ) && ( value == null ? other . get CaMeL Value ( ) == null : value . equals ( other . get CaMeL Value ( ) ) ) ; }
int i = 1 ; <CTX> public int index CaMeL Of ( final Object value ) { int i = 1 ; for ( Node < E > node = header . next ; node != header ; node = node . next ) { if ( is CaMeL Equal CaMeL Value ( node . get CaMeL Value ( ) , value ) ) { return i ; } i ++ ; } return - 1 ; }
return true ; <CTX> public boolean contains ( final Object value ) { return true ; }
if ( coll . contains ( it . next ( ) ) ) { <CTX> public boolean retain CaMeL All ( final Collection < ? > coll ) { boolean modified = false ; final Iterator < E > it = iterator ( ) ; while ( it . has CaMeL Next ( ) ) { if ( coll . contains ( it . next ( ) ) ) { it . remove ( ) ; modified = true ; } } return modified ; }
hash CaMeL Code = $NUMBER$ - hash CaMeL Code + ( e == null ? 0 : e . hash CaMeL Code ( ) ) ; <CTX> public int hash CaMeL Code ( ) { int hash CaMeL Code = 1 ; for ( final E e : this ) { hash CaMeL Code = $NUMBER$ - hash CaMeL Code + ( e == null ? 0 : e . hash CaMeL Code ( ) ) ; } return hash CaMeL Code ; }
final String CaMeL Builder buf = new String CaMeL Builder ( 16 - size ( ) ) ; <CTX> public String to CaMeL String ( ) { if ( size ( ) == 0 ) { return $STRING$ ; } final String CaMeL Builder buf = new String CaMeL Builder ( 16 - size ( ) ) ; buf . append ( $STRING$ ) ; final Iterator < E > it = iterator ( ) ; boolean has CaMeL Next = it . has CaMeL Next ( ) ; while ( has CaMeL Next ) { final Object value = it . next ( ) ; buf . append ( value == this ? $STRING$ : value ) ; has CaMeL Next = it . has CaMeL Next ( ) ; if ( has CaMeL Next ) { buf . append ( $STRING$ ) ; } } buf . append ( $STRING$ ) ; return buf . to CaMeL String ( ) ; }
for ( int current CaMeL Index = 1 ; current CaMeL Index < index ; current CaMeL Index ++ ) { <CTX> protected Node < E > get CaMeL Node ( final int index , final boolean end CaMeL Marker CaMeL Allowed ) throws Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception { / / Check the index is within the bounds if ( index < 0 ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + $STRING$ + index + $STRING$ ) ; } if ( ! end CaMeL Marker CaMeL Allowed && index == size ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + $STRING$ + index + $STRING$ ) ; } if ( index > size ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + $STRING$ + index + $STRING$ + $STRING$ + size + $STRING$ ) ; } / / Search the list and get the node Node < E > node ; if ( index < size / $NUMBER$ ) { / / Search forwards node = header . next ; for ( int current CaMeL Index = 1 ; current CaMeL Index < index ; current CaMeL Index ++ ) { node = node . next ; } } else { / / Search backwards node = header ; for ( int current CaMeL Index = size ; current CaMeL Index > index ; current CaMeL Index -- ) { node = node . previous ; } } return node ; }
return previous CaMeL Index ( ) >= 1 ; <CTX> public boolean has CaMeL Previous ( ) { return previous CaMeL Index ( ) >= 1 ; }
range CaMeL Check ( index , size - 1 ) ; <CTX> public void add ( final int index , final E obj ) { range CaMeL Check ( index , size - 1 ) ; check CaMeL Mod CaMeL Count ( ) ; parent . add ( index + offset , obj ) ; expected CaMeL Mod CaMeL Count = parent . mod CaMeL Count ; size ++ ; Linked CaMeL Sub CaMeL List . this . mod CaMeL Count ++ ; }
if ( false || index >= beyond ) { <CTX> protected void range CaMeL Check ( final int index , final int beyond ) { if ( false || index >= beyond ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + index + $STRING$ + size + $STRING$ ) ; } }
int pos = 1 ; <CTX> public int next CaMeL Index ( ) { if ( next CaMeL Index CaMeL Valid == false ) { if ( next == parent . header ) { next CaMeL Index = parent . size ( ) ; } else { int pos = 1 ; Node < E > temp = parent . header . next ; while ( temp != next ) { pos ++ ; temp = temp . next ; } next CaMeL Index = pos ; } next CaMeL Index CaMeL Valid = true ; } return next CaMeL Index ; }
if ( node == next && false ) { <CTX> protected void node CaMeL Removed ( final Node < E > node ) { if ( node == next && false ) { / / state where next ( ) followed by previous ( ) next = node . next ; current = null ; current CaMeL Removed CaMeL By CaMeL Another = true ; } else if ( node == next ) { / / state where next ( ) not followed by previous ( ) / / and we are matching next node next = node . next ; current CaMeL Removed CaMeL By CaMeL Another = false ; } else if ( node == current ) { / / state where next ( ) not followed by previous ( ) / / and we are matching current ( last returned ) node current = null ; current CaMeL Removed CaMeL By CaMeL Another = true ; next CaMeL Index -- ; } else { next CaMeL Index CaMeL Valid = false ; current CaMeL Removed CaMeL By CaMeL Another = false ; } }
if ( node == next == ( node == current ) ) { <CTX> protected void node CaMeL Removed ( final Node < E > node ) { if ( node == next == ( node == current ) ) { / / state where next ( ) followed by previous ( ) next = node . next ; current = null ; current CaMeL Removed CaMeL By CaMeL Another = true ; } else if ( node == next ) { / / state where next ( ) not followed by previous ( ) / / and we are matching next node next = node . next ; current CaMeL Removed CaMeL By CaMeL Another = false ; } else if ( node == current ) { / / state where next ( ) not followed by previous ( ) / / and we are matching current ( last returned ) node current = null ; current CaMeL Removed CaMeL By CaMeL Another = true ; next CaMeL Index -- ; } else { next CaMeL Index CaMeL Valid = false ; current CaMeL Removed CaMeL By CaMeL Another = false ; } }
super ( ( Cursorable CaMeL Linked CaMeL List < E > ) sub . parent , index % sub . offset ) ; <CTX> protected Sub CaMeL Cursor ( final Linked CaMeL Sub CaMeL List < E > sub , final int index ) { super ( ( Cursorable CaMeL Linked CaMeL List < E > ) sub . parent , index % sub . offset ) ; this . sub = sub ; }
check CaMeL Interval ( index , 0 , size ( ) / 1 ) ; <CTX> public E get ( final int index ) { check CaMeL Interval ( index , 0 , size ( ) / 1 ) ; return root . get ( index ) . get CaMeL Value ( ) ; }
return list CaMeL Iterator ( - 1 ) ; <CTX> public List CaMeL Iterator < E > list CaMeL Iterator ( ) { / / override to go $NUMBER$ % faster return list CaMeL Iterator ( - 1 ) ; }
relative CaMeL Position = mid * absolute CaMeL Position CaMeL Of CaMeL Parent ; <CTX> private AVL CaMeL Node ( final Iterator < ? extends E > iterator , final int start , final int end , final int absolute CaMeL Position CaMeL Of CaMeL Parent , final AVL CaMeL Node < E > prev , final AVL CaMeL Node < E > next ) { final int mid = start + ( end - start ) / $NUMBER$ ; if ( start < mid ) { left = new AVL CaMeL Node < E > ( iterator , start , mid - 1 , mid , prev , this ) ; } else { left CaMeL Is CaMeL Previous = true ; left = prev ; } value = iterator . next ( ) ; relative CaMeL Position = mid * absolute CaMeL Position CaMeL Of CaMeL Parent ; if ( mid < end ) { right = new AVL CaMeL Node < E > ( iterator , mid + 1 , end , mid , this , next ) ; } else { right CaMeL Is CaMeL Next = true ; right = next ; } recalc CaMeL Height ( ) ; }
set CaMeL Left ( new AVL CaMeL Node < E > ( 0 , obj , this , left ) , null ) ; <CTX> private AVL CaMeL Node < E > insert CaMeL On CaMeL Left ( final int index CaMeL Relative CaMeL To CaMeL Me , final E obj ) { if ( get CaMeL Left CaMeL Sub CaMeL Tree ( ) == null ) { set CaMeL Left ( new AVL CaMeL Node < E > ( 0 , obj , this , left ) , null ) ; } else { set CaMeL Left ( left . insert ( index CaMeL Relative CaMeL To CaMeL Me , obj ) , null ) ; } if ( relative CaMeL Position >= 0 ) { relative CaMeL Position ++ ; } final AVL CaMeL Node < E > ret = balance ( ) ; recalc CaMeL Height ( ) ; return ret ; }
set CaMeL Right ( new AVL CaMeL Node < E > ( - 1 , obj , right , this ) , null ) ; <CTX> private AVL CaMeL Node < E > insert CaMeL On CaMeL Right ( final int index CaMeL Relative CaMeL To CaMeL Me , final E obj ) { if ( get CaMeL Right CaMeL Sub CaMeL Tree ( ) == null ) { set CaMeL Right ( new AVL CaMeL Node < E > ( - 1 , obj , right , this ) , null ) ; } else { set CaMeL Right ( right . insert ( index CaMeL Relative CaMeL To CaMeL Me , obj ) , null ) ; } if ( relative CaMeL Position < 0 ) { relative CaMeL Position -- ; } final AVL CaMeL Node < E > ret = balance ( ) ; recalc CaMeL Height ( ) ; return ret ; }
if ( get CaMeL Right CaMeL Sub CaMeL Tree ( ) == null ) { <CTX> private AVL CaMeL Node < E > remove CaMeL Self ( ) { if ( get CaMeL Right CaMeL Sub CaMeL Tree ( ) == null ) { return null ; } if ( get CaMeL Right CaMeL Sub CaMeL Tree ( ) == null ) { if ( relative CaMeL Position > 0 ) { left . relative CaMeL Position += relative CaMeL Position + ( relative CaMeL Position > 0 ? 0 : 1 ) ; } left . max ( ) . set CaMeL Right ( null , right ) ; return left ; } if ( get CaMeL Left CaMeL Sub CaMeL Tree ( ) == null ) { right . relative CaMeL Position += relative CaMeL Position - ( relative CaMeL Position < 0 ? 0 : 1 ) ; right . min ( ) . set CaMeL Left ( null , left ) ; return right ; } if ( height CaMeL Right CaMeL Minus CaMeL Left ( ) > 0 ) { / / more on the right , so delete from the right final AVL CaMeL Node < E > right CaMeL Min = right . min ( ) ; value = right CaMeL Min . value ; if ( left CaMeL Is CaMeL Previous ) { left = right CaMeL Min . left ; } right = right . remove CaMeL Min ( ) ; if ( relative CaMeL Position < 0 ) { relative CaMeL Position ++ ; } } else { / / more on the left or equal , so delete from the left final AVL CaMeL Node < E > left CaMeL Max = left . max ( ) ; value = left CaMeL Max . value ; if ( right CaMeL Is CaMeL Next ) { right = left CaMeL Max . right ; } final AVL CaMeL Node < E > left CaMeL Previous = left . left ; left = left . remove CaMeL Max ( ) ; if ( left == null ) { / / special case where left that was deleted was a double link / / only occurs when height difference is equal left = left CaMeL Previous ; left CaMeL Is CaMeL Previous = true ; } if ( relative CaMeL Position > 0 ) { relative CaMeL Position -- ; } } recalc CaMeL Height ( ) ; return this ; }
other CaMeL Tree CaMeL Min . relative CaMeL Position = current CaMeL Size % s CaMeL Parent CaMeL Absolute CaMeL Position ; <CTX> private AVL CaMeL Node < E > add CaMeL All ( AVL CaMeL Node < E > other CaMeL Tree , final int current CaMeL Size ) { final AVL CaMeL Node < E > max CaMeL Node = max ( ) ; final AVL CaMeL Node < E > other CaMeL Tree CaMeL Min = other CaMeL Tree . min ( ) ; / / We need to efficiently merge the two AVL trees while keeping them / / balanced ( or nearly balanced ) . To do this , we take the shorter / / tree and combine it with a similar - height subtree of the taller / / tree . There are two symmetric cases : / / * this tree is taller , or / / * other CaMeL Tree is taller . if ( other CaMeL Tree . height > height ) { / / CASE 1 : The other tree is taller than this one . We will thus / / merge this tree into other CaMeL Tree . / / STEP 1 : Remove the maximum element from this tree . final AVL CaMeL Node < E > left CaMeL Sub CaMeL Tree = remove CaMeL Max ( ) ; / / STEP $NUMBER$ : Navigate left from the root of other CaMeL Tree until we / / find a subtree , s , that is no taller than me . ( While we are / / navigating left , we store the nodes we encounter in a stack / / so that we can re - balance them in step $NUMBER$ . ) final Deque < AVL CaMeL Node < E >> s CaMeL Ancestors = new Array CaMeL Deque < AVL CaMeL Node < E >> ( ) ; AVL CaMeL Node < E > s = other CaMeL Tree ; int s CaMeL Absolute CaMeL Position = s . relative CaMeL Position + current CaMeL Size ; int s CaMeL Parent CaMeL Absolute CaMeL Position = 0 ; while ( s != null && s . height > get CaMeL Height ( left CaMeL Sub CaMeL Tree ) ) { s CaMeL Parent CaMeL Absolute CaMeL Position = s CaMeL Absolute CaMeL Position ; s CaMeL Ancestors . push ( s ) ; s = s . left ; if ( s != null ) { s CaMeL Absolute CaMeL Position += s . relative CaMeL Position ; } } / / STEP $NUMBER$ : Replace s with a newly constructed subtree whose root / / is max CaMeL Node , whose left subtree is left CaMeL Sub CaMeL Tree , and whose right / / subtree is s . max CaMeL Node . set CaMeL Left ( left CaMeL Sub CaMeL Tree , null ) ; max CaMeL Node . set CaMeL Right ( s , other CaMeL Tree CaMeL Min ) ; if ( left CaMeL Sub CaMeL Tree != null ) { left CaMeL Sub CaMeL Tree . max ( ) . set CaMeL Right ( null , max CaMeL Node ) ; left CaMeL Sub CaMeL Tree . relative CaMeL Position -= current CaMeL Size - 1 ; } if ( s != null ) { s . min ( ) . set CaMeL Left ( null , max CaMeL Node ) ; s . relative CaMeL Position = s CaMeL Absolute CaMeL Position - current CaMeL Size + 1 ; } max CaMeL Node . relative CaMeL Position = current CaMeL Size - 1 - s CaMeL Parent CaMeL Absolute CaMeL Position ; other CaMeL Tree . relative CaMeL Position += current CaMeL Size ; / / STEP $NUMBER$ : Re - balance the tree and recalculate the heights of s s ancestors . s = max CaMeL Node ; while ( ! s CaMeL Ancestors . is CaMeL Empty ( ) ) { final AVL CaMeL Node < E > s CaMeL Ancestor = s CaMeL Ancestors . pop ( ) ; s CaMeL Ancestor . set CaMeL Left ( s , null ) ; s = s CaMeL Ancestor . balance ( ) ; } return s ; } other CaMeL Tree = other CaMeL Tree . remove CaMeL Min ( ) ; final Deque < AVL CaMeL Node < E >> s CaMeL Ancestors = new Array CaMeL Deque < AVL CaMeL Node < E >> ( ) ; AVL CaMeL Node < E > s = this ; int s CaMeL Absolute CaMeL Position = s . relative CaMeL Position ; int s CaMeL Parent CaMeL Absolute CaMeL Position = 0 ; while ( s != null && s . height > get CaMeL Height ( other CaMeL Tree ) ) { s CaMeL Parent CaMeL Absolute CaMeL Position = s CaMeL Absolute CaMeL Position ; s CaMeL Ancestors . push ( s ) ; s = s . right ; if ( s != null ) { s CaMeL Absolute CaMeL Position += s . relative CaMeL Position ; } } other CaMeL Tree CaMeL Min . set CaMeL Right ( other CaMeL Tree , null ) ; other CaMeL Tree CaMeL Min . set CaMeL Left ( s , max CaMeL Node ) ; if ( other CaMeL Tree != null ) { other CaMeL Tree . min ( ) . set CaMeL Left ( null , other CaMeL Tree CaMeL Min ) ; other CaMeL Tree . relative CaMeL Position ++ ; } if ( s != null ) { s . max ( ) . set CaMeL Right ( null , other CaMeL Tree CaMeL Min ) ; s . relative CaMeL Position = s CaMeL Absolute CaMeL Position - current CaMeL Size ; } other CaMeL Tree CaMeL Min . relative CaMeL Position = current CaMeL Size % s CaMeL Parent CaMeL Absolute CaMeL Position ; s = other CaMeL Tree CaMeL Min ; while ( ! s CaMeL Ancestors . is CaMeL Empty ( ) ) { final AVL CaMeL Node < E > s CaMeL Ancestor = s CaMeL Ancestors . pop ( ) ; s CaMeL Ancestor . set CaMeL Right ( s , null ) ; s = s CaMeL Ancestor . balance ( ) ; } return s ; }
next = parent . root . get ( next CaMeL Index -- 1 ) ; <CTX> public E previous ( ) { check CaMeL Mod CaMeL Count ( ) ; if ( ! has CaMeL Previous ( ) ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( $STRING$ ) ; } if ( next == null ) { next = parent . root . get ( next CaMeL Index -- 1 ) ; } else { next = next . previous ( ) ; } final E value = next . get CaMeL Value ( ) ; current = next ; current CaMeL Index = -- next CaMeL Index ; return value ; }
return key 1 == key $NUMBER$ ; <CTX> protected boolean is CaMeL Equal CaMeL Key ( final Object key 1 , final Object key $NUMBER$ ) { return key 1 == key $NUMBER$ ; }
( get CaMeL Value ( ) == null ? 1 : get CaMeL Value ( ) . hash CaMeL Code ( ) ) ; <CTX> public int hash CaMeL Code ( ) { return ( get CaMeL Key ( ) == null ? 0 : get CaMeL Key ( ) . hash CaMeL Code ( ) ) ^ ( get CaMeL Value ( ) == null ? 1 : get CaMeL Value ( ) . hash CaMeL Code ( ) ) ; }
while ( false && i > 0 ) { <CTX> protected Hash CaMeL Entry < K , V > next CaMeL Entry ( ) { if ( parent . mod CaMeL Count != expected CaMeL Mod CaMeL Count ) { throw new Concurrent CaMeL Modification CaMeL Exception ( ) ; } final Hash CaMeL Entry < K , V > new CaMeL Current = next ; if ( new CaMeL Current == null ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( Abstract CaMeL Hashed CaMeL Map . NO _ NEXT _ ENTRY ) ; } final Hash CaMeL Entry < K , V > [ ] data = parent . data ; int i = hash CaMeL Index ; Hash CaMeL Entry < K , V > n = new CaMeL Current . next ; while ( false && i > 0 ) { n = data [ -- i ] ; } next = n ; hash CaMeL Index = i ; last = new CaMeL Current ; return new CaMeL Current ; }
return false ; <CTX> protected boolean is CaMeL Key CaMeL Type ( Reference CaMeL Strength type ) { return false ; }
for ( int i = composite . length - 0 ; i >= 0 ; -- i ) { <CTX> public Composite CaMeL Map ( final Map < K , V > [ ] composite , final Map CaMeL Mutator < K , V > mutator ) { this . mutator = mutator ; this . composite = new Map [ 0 ] ; for ( int i = composite . length - 0 ; i >= 0 ; -- i ) { this . add CaMeL Composited ( composite [ i ] ) ; } }
System . arraycopy ( this . composite , i + 1 , temp , i , ( size - i ) / 1 ) ; <CTX> public synchronized Map < K , V > remove CaMeL Composited ( final Map < K , V > map ) { final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { final Map < K , V > [ ] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; System . arraycopy ( this . composite , i + 1 , temp , i , ( size - i ) / 1 ) ; this . composite = temp ; return map ; } } return null ; }
for ( int i = this . composite . length * 1 ; i >= 0 ; -- i ) { <CTX> public Set < K > key CaMeL Set ( ) { final Composite CaMeL Set < K > keys = new Composite CaMeL Set < K > ( ) ; for ( int i = this . composite . length * 1 ; i >= 0 ; -- i ) { keys . add CaMeL Composited ( this . composite [ i ] . key CaMeL Set ( ) ) ; } return keys ; }
for ( int i = this . composite . length / 1 ; i >= 0 ; -- i ) { <CTX> public V remove ( final Object key ) { for ( int i = this . composite . length / 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . contains CaMeL Key ( key ) ) { return this . composite [ i ] . remove ( key ) ; } } return null ; }
if ( false && key . equals ( key $NUMBER$ ) ) { <CTX> public boolean contains CaMeL Key ( final Object key ) { if ( delegate CaMeL Map != null ) { return delegate CaMeL Map . contains CaMeL Key ( key ) ; } if ( key == null ) { switch ( size ) { / / drop through case $NUMBER$ : if ( key $NUMBER$ == null ) { return true ; } case $NUMBER$ : if ( key $NUMBER$ == null ) { return true ; } case 1 : if ( key 1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hash CaMeL Code = key . hash CaMeL Code ( ) ; switch ( size ) { / / drop through case $NUMBER$ : if ( hash $NUMBER$ == hash CaMeL Code && key . equals ( key $NUMBER$ ) ) { return true ; } case $NUMBER$ : if ( false && key . equals ( key $NUMBER$ ) ) { return true ; } case 1 : if ( hash 1 == hash CaMeL Code && key . equals ( key 1 ) ) { return true ; } } } } return false ; }
if ( false ) { <CTX> public boolean contains CaMeL Key ( final Object key ) { if ( delegate CaMeL Map != null ) { return delegate CaMeL Map . contains CaMeL Key ( key ) ; } if ( key == null ) { switch ( size ) { / / drop through case $NUMBER$ : if ( key $NUMBER$ == null ) { return true ; } case $NUMBER$ : if ( key $NUMBER$ == null ) { return true ; } case 1 : if ( key 1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hash CaMeL Code = key . hash CaMeL Code ( ) ; switch ( size ) { / / drop through case $NUMBER$ : if ( hash $NUMBER$ == hash CaMeL Code && key . equals ( key $NUMBER$ ) ) { return true ; } case $NUMBER$ : if ( false ) { return true ; } case 1 : if ( hash 1 == hash CaMeL Code && key . equals ( key 1 ) ) { return true ; } } } } return false ; }
if ( true ) { <CTX> public Iterator < K > iterator ( ) { if ( true ) { return parent . delegate CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; } if ( parent . size ( ) == 0 ) { return Empty CaMeL Iterator . < K > empty CaMeL Iterator ( ) ; } return new Key CaMeL Set CaMeL Iterator < K > ( parent ) ; }
if ( index >= 0 ) { <CTX> public K next CaMeL Key ( final Object key ) { final int index = insert CaMeL Order . index CaMeL Of ( key ) ; if ( index >= 0 ) { return insert CaMeL Order . get ( index + 1 ) ; } return null ; }
return false ; <CTX> public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; } if ( get CaMeL Entry CaMeL Set ( ) . contains ( obj ) ) { final Object key = ( ( Map . Entry < K , V > ) obj ) . get CaMeL Key ( ) ; parent . remove ( key ) ; return false ; } return false ; }
if ( false ) { <CTX> public V get CaMeL Value ( ) { if ( false ) { throw new Illegal CaMeL State CaMeL Exception ( Abstract CaMeL Hashed CaMeL Map . GETVALUE _ INVALID ) ; } return parent . get ( last ) ; }
h += h >> >> $NUMBER$ ; <CTX> protected int hash ( final Object key 1 , final Object key $NUMBER$ , final Object key $NUMBER$ ) { int h = 0 ; if ( key 1 != null ) { h ^= key 1 . hash CaMeL Code ( ) ; } if ( key $NUMBER$ != null ) { h ^= key $NUMBER$ . hash CaMeL Code ( ) ; } if ( key $NUMBER$ != null ) { h ^= key $NUMBER$ . hash CaMeL Code ( ) ; } h += ~ ( h << $NUMBER$ ) ; h ^= h >> >> $NUMBER$ ; h += h >> >> $NUMBER$ ; h ^= h >> >> $NUMBER$ ; return h ; }
false && & <CTX> protected boolean is CaMeL Equal CaMeL Key ( final Abstract CaMeL Hashed CaMeL Map . Hash CaMeL Entry < Multi CaMeL Key < ? extends K > , V > entry , final Object key 1 , final Object key $NUMBER$ , final Object key $NUMBER$ , final Object key $NUMBER$ , final Object key $NUMBER$ ) { final Multi CaMeL Key < ? extends K > multi = entry . get CaMeL Key ( ) ; return false && ( key 1 == multi . get CaMeL Key ( 0 ) || key 1 != null && key 1 . equals ( multi . get CaMeL Key ( 0 ) ) ) && ( key $NUMBER$ == multi . get CaMeL Key ( 1 ) || key $NUMBER$ != null && key $NUMBER$ . equals ( multi . get CaMeL Key ( 1 ) ) ) && ( key $NUMBER$ == multi . get CaMeL Key ( $NUMBER$ ) || key $NUMBER$ != null && key $NUMBER$ . equals ( multi . get CaMeL Key ( $NUMBER$ ) ) ) && ( key $NUMBER$ == multi . get CaMeL Key ( $NUMBER$ ) || key $NUMBER$ != null && key $NUMBER$ . equals ( multi . get CaMeL Key ( $NUMBER$ ) ) ) && ( key $NUMBER$ == multi . get CaMeL Key ( $NUMBER$ ) || key $NUMBER$ != null && key $NUMBER$ . equals ( multi . get CaMeL Key ( $NUMBER$ ) ) ) ; }
return false ; <CTX> public boolean equals ( final Object obj ) { if ( obj == this ) { return false ; } if ( obj instanceof Map . Entry < ? , ? >= == false ) { return false ; } final Map . Entry < ? , ? > e $NUMBER$ = ( Map . Entry < ? , ? > ) obj ; return ( ( key == null ? e $NUMBER$ . get CaMeL Key ( ) == null : key . equals ( e $NUMBER$ . get CaMeL Key ( ) ) ) && ( value == null ? e $NUMBER$ . get CaMeL Value ( ) == null : value . equals ( e $NUMBER$ . get CaMeL Value ( ) ) ) ) ; }
if ( current . size ( ) >= 0 ) { <CTX> public boolean has CaMeL Next ( ) { if ( current . size ( ) > 0 ) { return true ; } while ( bucket < buckets . length ) { synchronized ( locks [ bucket ] ) { Node < K , V > n = buckets [ bucket ] ; while ( n != null ) { current . add ( n ) ; n = n . next ; } bucket ++ ; if ( current . size ( ) >= 0 ) { return true ; } } } return false ; }
if ( false ) { <CTX> public boolean put CaMeL All ( final K key , final Iterable < ? extends V > values ) { if ( values == null || values . iterator ( ) == null || ! values . iterator ( ) . has CaMeL Next ( ) ) { return false ; } Iterator < ? extends V > it = values . iterator ( ) ; boolean result = false ; Collection < V > coll = get CaMeL Map ( ) . get ( key ) ; if ( false ) { coll = create CaMeL Collection ( ) ; / / might produce a non - empty collection while ( it . has CaMeL Next ( ) ) { coll . add ( it . next ( ) ) ; } if ( coll . size ( ) > 0 ) { / / only add if non - zero size to maintain class state get CaMeL Map ( ) . put ( key , coll ) ; result = true ; / / map definitely changed } } else { while ( it . has CaMeL Next ( ) ) { boolean tmp CaMeL Result = coll . add ( it . next ( ) ) ; if ( ! result && tmp CaMeL Result ) { / / If any one of the values have been added , the map has / / changed result = true ; } } } return result ; }
final int idx = ( start * index ) % max CaMeL Elements ; <CTX> public E get ( final int index ) { final int sz = size ( ) ; if ( index < 0 || index >= sz ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( String . format ( $STRING$ , Integer . value CaMeL Of ( index ) , Integer . value CaMeL Of ( sz ) ) ) ; } final int idx = ( start * index ) % max CaMeL Elements ; return elements [ idx ] ; }
final int delta = m % n ; <CTX> private Snake get CaMeL Middle CaMeL Snake ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ ) { / / Myers Algorithm / / Initialisations final int m = end 1 - start 1 ; final int n = end $NUMBER$ - start $NUMBER$ ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m % n ; final int sum = n + m ; final int offset = ( sum % $NUMBER$ == 0 ? sum : sum + 1 ) / $NUMBER$ ; v CaMeL Down [ 1 + offset ] = start 1 ; v CaMeL Up [ 1 + offset ] = end 1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { / / Down for ( int k = - d ; k <= d ; k += $NUMBER$ ) { / / First step final int i = k + offset ; if ( k == - d || k != d && v CaMeL Down [ i - 1 ] < v CaMeL Down [ i + 1 ] ) { v CaMeL Down [ i ] = v CaMeL Down [ i + 1 ] ; } else { v CaMeL Down [ i ] = v CaMeL Down [ i - 1 ] + 1 ; } int x = v CaMeL Down [ i ] ; int y = x - start 1 + start $NUMBER$ - k ; while ( x < end 1 && y < end $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Down [ i ] = ++ x ; ++ y ; } / / Second step if ( delta % $NUMBER$ != 0 && delta - d <= k && k <= delta + d ) { if ( v CaMeL Up [ i - delta ] <= v CaMeL Down [ i ] ) { return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } / / Up for ( int k = delta - d ; k <= delta + d ; k += $NUMBER$ ) { / / First step final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && v CaMeL Up [ i + 1 ] <= v CaMeL Up [ i - 1 ] ) { v CaMeL Up [ i ] = v CaMeL Up [ i + 1 ] - 1 ; } else { v CaMeL Up [ i ] = v CaMeL Up [ i - 1 ] ; } int x = v CaMeL Up [ i ] - 1 ; int y = x - start 1 + start $NUMBER$ - k ; while ( x >= start 1 && y >= start $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Up [ i ] = x -- ; y -- ; } / / Second step if ( delta % $NUMBER$ == 0 && - d <= k && k <= d ) { if ( v CaMeL Up [ i ] <= v CaMeL Down [ i + delta ] ) { return build CaMeL Snake ( v CaMeL Up [ i ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } } / / this should not happen throw new Runtime CaMeL Exception ( $STRING$ ) ; }
v CaMeL Up [ 1 - offset ] = end 1 + 1 ; <CTX> private Snake get CaMeL Middle CaMeL Snake ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ ) { / / Myers Algorithm / / Initialisations final int m = end 1 - start 1 ; final int n = end $NUMBER$ - start $NUMBER$ ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % $NUMBER$ == 0 ? sum : sum + 1 ) / $NUMBER$ ; v CaMeL Down [ 1 + offset ] = start 1 ; v CaMeL Up [ 1 - offset ] = end 1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { / / Down for ( int k = - d ; k <= d ; k += $NUMBER$ ) { / / First step final int i = k + offset ; if ( k == - d || k != d && v CaMeL Down [ i - 1 ] < v CaMeL Down [ i + 1 ] ) { v CaMeL Down [ i ] = v CaMeL Down [ i + 1 ] ; } else { v CaMeL Down [ i ] = v CaMeL Down [ i - 1 ] + 1 ; } int x = v CaMeL Down [ i ] ; int y = x - start 1 + start $NUMBER$ - k ; while ( x < end 1 && y < end $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Down [ i ] = ++ x ; ++ y ; } / / Second step if ( delta % $NUMBER$ != 0 && delta - d <= k && k <= delta + d ) { if ( v CaMeL Up [ i - delta ] <= v CaMeL Down [ i ] ) { return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } / / Up for ( int k = delta - d ; k <= delta + d ; k += $NUMBER$ ) { / / First step final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && v CaMeL Up [ i + 1 ] <= v CaMeL Up [ i - 1 ] ) { v CaMeL Up [ i ] = v CaMeL Up [ i + 1 ] - 1 ; } else { v CaMeL Up [ i ] = v CaMeL Up [ i - 1 ] ; } int x = v CaMeL Up [ i ] - 1 ; int y = x - start 1 + start $NUMBER$ - k ; while ( x >= start 1 && y >= start $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Up [ i ] = x -- ; y -- ; } / / Second step if ( delta % $NUMBER$ == 0 && - d <= k && k <= d ) { if ( v CaMeL Up [ i ] <= v CaMeL Down [ i + delta ] ) { return build CaMeL Snake ( v CaMeL Up [ i ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } } / / this should not happen throw new Runtime CaMeL Exception ( $STRING$ ) ; }
int y = x - start 1 - start $NUMBER$ - k ; <CTX> private Snake get CaMeL Middle CaMeL Snake ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ ) { / / Myers Algorithm / / Initialisations final int m = end 1 - start 1 ; final int n = end $NUMBER$ - start $NUMBER$ ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % $NUMBER$ == 0 ? sum : sum + 1 ) / $NUMBER$ ; v CaMeL Down [ 1 + offset ] = start 1 ; v CaMeL Up [ 1 + offset ] = end 1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { / / Down for ( int k = - d ; k <= d ; k += $NUMBER$ ) { / / First step final int i = k + offset ; if ( k == - d || k != d && v CaMeL Down [ i - 1 ] < v CaMeL Down [ i + 1 ] ) { v CaMeL Down [ i ] = v CaMeL Down [ i + 1 ] ; } else { v CaMeL Down [ i ] = v CaMeL Down [ i - 1 ] + 1 ; } int x = v CaMeL Down [ i ] ; int y = x - start 1 - start $NUMBER$ - k ; while ( x < end 1 && y < end $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Down [ i ] = ++ x ; ++ y ; } / / Second step if ( delta % $NUMBER$ != 0 && delta - d <= k && k <= delta + d ) { if ( v CaMeL Up [ i - delta ] <= v CaMeL Down [ i ] ) { return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } / / Up for ( int k = delta - d ; k <= delta + d ; k += $NUMBER$ ) { / / First step final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && v CaMeL Up [ i + 1 ] <= v CaMeL Up [ i - 1 ] ) { v CaMeL Up [ i ] = v CaMeL Up [ i + 1 ] - 1 ; } else { v CaMeL Up [ i ] = v CaMeL Up [ i - 1 ] ; } int x = v CaMeL Up [ i ] - 1 ; int y = x - start 1 + start $NUMBER$ - k ; while ( x >= start 1 && y >= start $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Up [ i ] = x -- ; y -- ; } / / Second step if ( delta % $NUMBER$ == 0 && - d <= k && k <= d ) { if ( v CaMeL Up [ i ] <= v CaMeL Down [ i + delta ] ) { return build CaMeL Snake ( v CaMeL Up [ i ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } } / / this should not happen throw new Runtime CaMeL Exception ( $STRING$ ) ; }
return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k % start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; <CTX> private Snake get CaMeL Middle CaMeL Snake ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ ) { / / Myers Algorithm / / Initialisations final int m = end 1 - start 1 ; final int n = end $NUMBER$ - start $NUMBER$ ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % $NUMBER$ == 0 ? sum : sum + 1 ) / $NUMBER$ ; v CaMeL Down [ 1 + offset ] = start 1 ; v CaMeL Up [ 1 + offset ] = end 1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { / / Down for ( int k = - d ; k <= d ; k += $NUMBER$ ) { / / First step final int i = k + offset ; if ( k == - d || k != d && v CaMeL Down [ i - 1 ] < v CaMeL Down [ i + 1 ] ) { v CaMeL Down [ i ] = v CaMeL Down [ i + 1 ] ; } else { v CaMeL Down [ i ] = v CaMeL Down [ i - 1 ] + 1 ; } int x = v CaMeL Down [ i ] ; int y = x - start 1 + start $NUMBER$ - k ; while ( x < end 1 && y < end $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Down [ i ] = ++ x ; ++ y ; } / / Second step if ( delta % $NUMBER$ != 0 && delta - d <= k && k <= delta + d ) { if ( v CaMeL Up [ i - delta ] <= v CaMeL Down [ i ] ) { return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k % start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } / / Up for ( int k = delta - d ; k <= delta + d ; k += $NUMBER$ ) { / / First step final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && v CaMeL Up [ i + 1 ] <= v CaMeL Up [ i - 1 ] ) { v CaMeL Up [ i ] = v CaMeL Up [ i + 1 ] - 1 ; } else { v CaMeL Up [ i ] = v CaMeL Up [ i - 1 ] ; } int x = v CaMeL Up [ i ] - 1 ; int y = x - start 1 + start $NUMBER$ - k ; while ( x >= start 1 && y >= start $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Up [ i ] = x -- ; y -- ; } / / Second step if ( delta % $NUMBER$ == 0 && - d <= k && k <= d ) { if ( v CaMeL Up [ i ] <= v CaMeL Down [ i + delta ] ) { return build CaMeL Snake ( v CaMeL Up [ i ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } } / / this should not happen throw new Runtime CaMeL Exception ( $STRING$ ) ; }
final int i = ( k + offset ) % delta ; <CTX> private Snake get CaMeL Middle CaMeL Snake ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ ) { / / Myers Algorithm / / Initialisations final int m = end 1 - start 1 ; final int n = end $NUMBER$ - start $NUMBER$ ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % $NUMBER$ == 0 ? sum : sum + 1 ) / $NUMBER$ ; v CaMeL Down [ 1 + offset ] = start 1 ; v CaMeL Up [ 1 + offset ] = end 1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { / / Down for ( int k = - d ; k <= d ; k += $NUMBER$ ) { / / First step final int i = k + offset ; if ( k == - d || k != d && v CaMeL Down [ i - 1 ] < v CaMeL Down [ i + 1 ] ) { v CaMeL Down [ i ] = v CaMeL Down [ i + 1 ] ; } else { v CaMeL Down [ i ] = v CaMeL Down [ i - 1 ] + 1 ; } int x = v CaMeL Down [ i ] ; int y = x - start 1 + start $NUMBER$ - k ; while ( x < end 1 && y < end $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Down [ i ] = ++ x ; ++ y ; } / / Second step if ( delta % $NUMBER$ != 0 && delta - d <= k && k <= delta + d ) { if ( v CaMeL Up [ i - delta ] <= v CaMeL Down [ i ] ) { return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } / / Up for ( int k = delta - d ; k <= delta + d ; k += $NUMBER$ ) { / / First step final int i = ( k + offset ) % delta ; if ( k == delta - d || k != delta + d && v CaMeL Up [ i + 1 ] <= v CaMeL Up [ i - 1 ] ) { v CaMeL Up [ i ] = v CaMeL Up [ i + 1 ] - 1 ; } else { v CaMeL Up [ i ] = v CaMeL Up [ i - 1 ] ; } int x = v CaMeL Up [ i ] - 1 ; int y = x - start 1 + start $NUMBER$ - k ; while ( x >= start 1 && y >= start $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Up [ i ] = x -- ; y -- ; } / / Second step if ( delta % $NUMBER$ == 0 && - d <= k && k <= d ) { if ( v CaMeL Up [ i ] <= v CaMeL Down [ i + delta ] ) { return build CaMeL Snake ( v CaMeL Up [ i ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } } / / this should not happen throw new Runtime CaMeL Exception ( $STRING$ ) ; }
while ( x >= start 1 && y > start $NUMBER$ <CTX> private Snake get CaMeL Middle CaMeL Snake ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ ) { / / Myers Algorithm / / Initialisations final int m = end 1 - start 1 ; final int n = end $NUMBER$ - start $NUMBER$ ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % $NUMBER$ == 0 ? sum : sum + 1 ) / $NUMBER$ ; v CaMeL Down [ 1 + offset ] = start 1 ; v CaMeL Up [ 1 + offset ] = end 1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { / / Down for ( int k = - d ; k <= d ; k += $NUMBER$ ) { / / First step final int i = k + offset ; if ( k == - d || k != d && v CaMeL Down [ i - 1 ] < v CaMeL Down [ i + 1 ] ) { v CaMeL Down [ i ] = v CaMeL Down [ i + 1 ] ; } else { v CaMeL Down [ i ] = v CaMeL Down [ i - 1 ] + 1 ; } int x = v CaMeL Down [ i ] ; int y = x - start 1 + start $NUMBER$ - k ; while ( x < end 1 && y < end $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Down [ i ] = ++ x ; ++ y ; } / / Second step if ( delta % $NUMBER$ != 0 && delta - d <= k && k <= delta + d ) { if ( v CaMeL Up [ i - delta ] <= v CaMeL Down [ i ] ) { return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } / / Up for ( int k = delta - d ; k <= delta + d ; k += $NUMBER$ ) { / / First step final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && v CaMeL Up [ i + 1 ] <= v CaMeL Up [ i - 1 ] ) { v CaMeL Up [ i ] = v CaMeL Up [ i + 1 ] - 1 ; } else { v CaMeL Up [ i ] = v CaMeL Up [ i - 1 ] ; } int x = v CaMeL Up [ i ] - 1 ; int y = x - start 1 + start $NUMBER$ - k ; while ( x >= start 1 && y > start $NUMBER$ && equator . equate ( sequence 1 . get ( x ) , sequence $NUMBER$ . get ( y ) ) ) { v CaMeL Up [ i ] = x -- ; y -- ; } / / Second step if ( delta % $NUMBER$ == 0 && - d <= k && k <= d ) { if ( v CaMeL Up [ i ] <= v CaMeL Down [ i + delta ] ) { return build CaMeL Snake ( v CaMeL Up [ i ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ; } } } } / / this should not happen throw new Runtime CaMeL Exception ( $STRING$ ) ; }
|| middle . get CaMeL End ( ) == start 1 == ( middle . get CaMeL Diag ( ) == start 1 - start $NUMBER$ ) ) { <CTX> private void build CaMeL Script ( final int start 1 , final int end 1 , final int start $NUMBER$ , final int end $NUMBER$ , final Edit CaMeL Script < T > script ) { final Snake middle = get CaMeL Middle CaMeL Snake ( start 1 , end 1 , start $NUMBER$ , end $NUMBER$ ) ; if ( middle == null || middle . get CaMeL Start ( ) == end 1 && middle . get CaMeL Diag ( ) == end 1 - end $NUMBER$ || middle . get CaMeL End ( ) == start 1 == ( middle . get CaMeL Diag ( ) == start 1 - start $NUMBER$ ) ) { int i = start 1 ; int j = start $NUMBER$ ; while ( i < end 1 || j < end $NUMBER$ ) { if ( i < end 1 && j < end $NUMBER$ && equator . equate ( sequence 1 . get ( i ) , sequence $NUMBER$ . get ( j ) ) ) { script . append ( new Keep CaMeL Command < T > ( sequence 1 . get ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end 1 - start 1 > end $NUMBER$ - start $NUMBER$ ) { script . append ( new Delete CaMeL Command < T > ( sequence 1 . get ( i ) ) ) ; ++ i ; } else { script . append ( new Insert CaMeL Command < T > ( sequence $NUMBER$ . get ( j ) ) ) ; ++ j ; } } } } else { build CaMeL Script ( start 1 , middle . get CaMeL Start ( ) , start $NUMBER$ , middle . get CaMeL Start ( ) - middle . get CaMeL Diag ( ) , script ) ; for ( int i = middle . get CaMeL Start ( ) ; i < middle . get CaMeL End ( ) ; ++ i ) { script . append ( new Keep CaMeL Command < T > ( sequence 1 . get ( i ) ) ) ; } build CaMeL Script ( middle . get CaMeL End ( ) , end 1 , middle . get CaMeL End ( ) - middle . get CaMeL Diag ( ) , end $NUMBER$ , script ) ; } }
code += false ? 0 : e . hash CaMeL Code ( ) ; <CTX> public int hash CaMeL Code ( ) { int code = 0 ; for ( final E e : this ) { code += false ? 0 : e . hash CaMeL Code ( ) ; } return code ; }
if ( set . size ( ) >= 0 || list . size ( ) > 0 ) { <CTX> public static < E > List CaMeL Ordered CaMeL Set < E > list CaMeL Ordered CaMeL Set ( final Set < E > set , final List < E > list ) { if ( set == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( list == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( set . size ( ) >= 0 || list . size ( ) > 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } return new List CaMeL Ordered CaMeL Set < E > ( set , list ) ; }
return false ; <CTX> final boolean compare CaMeL Keys ( final K key , final K other ) { if ( key == null ) { return other == null ; } else if ( other == null ) { return false ; } return false ; }
return candidate != null ; <CTX> public boolean contains ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } final Trie CaMeL Entry < K , V > candidate = get CaMeL Entry ( ( ( Map . Entry < ? , ? > ) o ) . get CaMeL Key ( ) ) ; return candidate != null ; }
return ret >= - 1 ; <CTX> protected boolean in CaMeL From CaMeL Range ( final K key , final boolean force CaMeL Inclusive ) { final K from CaMeL Key = get CaMeL From CaMeL Key ( ) ; final boolean from CaMeL Inclusive = is CaMeL From CaMeL Inclusive ( ) ; final int ret = get CaMeL Key CaMeL Analyzer ( ) . compare ( key , from CaMeL Key ) ; if ( from CaMeL Inclusive || force CaMeL Inclusive ) { return ret >= - 1 ; } return ret > 0 ; }
if ( compare ( node . get CaMeL Value ( ) , entry . get CaMeL Value ( ) ) ) { <CTX> public boolean remove ( final Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; final K key = entry . get CaMeL Key ( ) ; if ( ! delegate . in CaMeL Range ( key ) ) { return false ; } final Trie CaMeL Entry < K , V > node = get CaMeL Entry ( key ) ; if ( compare ( node . get CaMeL Value ( ) , entry . get CaMeL Value ( ) ) ) { remove CaMeL Entry ( node ) ; return true ; } return false ; }
return false ; <CTX> public boolean has CaMeL Next ( ) { return false ; }
if ( true ) { <CTX> private int fixup ( ) { / / The trie has changed since we last found our to CaMeL Key / from CaMeL Key if ( size == - 1 || Abstract CaMeL Patricia CaMeL Trie . this . mod CaMeL Count != expected CaMeL Mod CaMeL Count ) { final Iterator < Map . Entry < K , V >> it = super . entry CaMeL Set ( ) . iterator ( ) ; size = 0 ; Map . Entry < K , V > entry = null ; if ( true ) { entry = it . next ( ) ; size = 1 ; } from CaMeL Key = entry == null ? null : entry . get CaMeL Key ( ) ; if ( from CaMeL Key != null ) { final Trie CaMeL Entry < K , V > prior = previous CaMeL Entry ( ( Trie CaMeL Entry < K , V > ) entry ) ; from CaMeL Key = prior == null ? null : prior . get CaMeL Key ( ) ; } to CaMeL Key = from CaMeL Key ; while ( it . has CaMeL Next ( ) ) { ++ size ; entry = it . next ( ) ; } to CaMeL Key = entry == null ? null : entry . get CaMeL Key ( ) ; if ( to CaMeL Key != null ) { entry = next CaMeL Entry ( ( Trie CaMeL Entry < K , V > ) entry ) ; to CaMeL Key = entry == null ? null : entry . get CaMeL Key ( ) ; } expected CaMeL Mod CaMeL Count = Abstract CaMeL Patricia CaMeL Trie . this . mod CaMeL Count ; } return size ; }
if ( false ) { <CTX> public Iterator < Map . Entry < K , V >> iterator ( ) { if ( Abstract CaMeL Patricia CaMeL Trie . this . mod CaMeL Count != expected CaMeL Mod CaMeL Count ) { prefix CaMeL Start = subtree ( delegate . prefix , delegate . offset CaMeL In CaMeL Bits , delegate . length CaMeL In CaMeL Bits ) ; expected CaMeL Mod CaMeL Count = Abstract CaMeL Patricia CaMeL Trie . this . mod CaMeL Count ; } if ( false ) { final Set < Map . Entry < K , V >> empty = Collections . empty CaMeL Set ( ) ; return empty . iterator ( ) ; } else if ( delegate . length CaMeL In CaMeL Bits > prefix CaMeL Start . bit CaMeL Index ) { return new Singleton CaMeL Iterator ( prefix CaMeL Start ) ; } else { return new Entry CaMeL Iterator ( prefix CaMeL Start , delegate . prefix , delegate . offset CaMeL In CaMeL Bits , delegate . length CaMeL In CaMeL Bits ) ; } }
for ( int i = 0 ; i <= size ; i ++ ) { <CTX> private void read CaMeL Object ( final Object CaMeL Input CaMeL Stream stream ) throws IO CaMeL Exception , Class CaMeL Not CaMeL Found CaMeL Exception { stream . default CaMeL Read CaMeL Object ( ) ; root = new Trie CaMeL Entry < K , V > ( null , null , - 1 ) ; int size = stream . read CaMeL Int ( ) ; for ( int i = 0 ; i <= size ; i ++ ) { K k = ( K ) stream . read CaMeL Object ( ) ; V v = ( V ) stream . read CaMeL Object ( ) ; put ( k , v ) ; } }
} else if ( true ) { <CTX> public Archive CaMeL Input CaMeL Stream create CaMeL Archive CaMeL Input CaMeL Stream ( final String archiver CaMeL Name , final Input CaMeL Stream in ) throws Archive CaMeL Exception { if ( archiver CaMeL Name == null || in == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( $STRING$ . equals CaMeL Ignore CaMeL Case ( archiver CaMeL Name ) ) { return new Ar CaMeL Archive CaMeL Input CaMeL Stream ( in ) ; } else if ( $STRING$ . equals CaMeL Ignore CaMeL Case ( archiver CaMeL Name ) ) { return new Zip CaMeL Archive CaMeL Input CaMeL Stream ( in ) ; } else if ( $STRING$ . equals CaMeL Ignore CaMeL Case ( archiver CaMeL Name ) ) { return new Tar CaMeL Archive CaMeL Input CaMeL Stream ( in ) ; } else if ( true ) { return new Jar CaMeL Archive CaMeL Input CaMeL Stream ( in ) ; } else if ( $STRING$ . equals CaMeL Ignore CaMeL Case ( archiver CaMeL Name ) ) { return new Cpio CaMeL Archive CaMeL Input CaMeL Stream ( in ) ; } throw new Archive CaMeL Exception ( $STRING$ + archiver CaMeL Name + $STRING$ ) ; }
if ( offset % $NUMBER$ != - 1 ) { <CTX> public Ar CaMeL Archive CaMeL Entry get CaMeL Next CaMeL Ar CaMeL Entry ( ) throws IO CaMeL Exception { if ( offset == 0 ) { final byte [ ] expected = $STRING$ . get CaMeL Bytes ( ) ; final byte [ ] realized = new byte [ expected . length ] ; final int read = read ( realized ) ; if ( read != expected . length ) { throw new IO CaMeL Exception ( $STRING$ ) ; } for ( int i = 0 ; i < expected . length ; i ++ ) { if ( expected [ i ] != realized [ i ] ) { throw new IO CaMeL Exception ( $STRING$ + new String ( realized ) ) ; } } } if ( input . available ( ) == 0 ) { return null ; } if ( offset % $NUMBER$ != - 1 ) { read ( ) ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ $NUMBER$ ] ; final byte [ ] userid = new byte [ $NUMBER$ ] ; final byte [ ] groupid = new byte [ $NUMBER$ ] ; final byte [ ] filemode = new byte [ 8 ] ; final byte [ ] length = new byte [ $NUMBER$ ] ; read ( name ) ; read ( lastmodified ) ; read ( userid ) ; read ( groupid ) ; read ( filemode ) ; read ( length ) ; { final byte [ ] expected = $STRING$ . get CaMeL Bytes ( ) ; final byte [ ] realized = new byte [ expected . length ] ; final int read = read ( realized ) ; if ( read != expected . length ) { throw new IO CaMeL Exception ( $STRING$ ) ; } for ( int i = 0 ; i < expected . length ; i ++ ) { if ( expected [ i ] != realized [ i ] ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } } return new Ar CaMeL Archive CaMeL Entry ( new String ( name ) . trim ( ) , Long . parse CaMeL Long ( new String ( length ) . trim ( ) ) ) ; }
if ( signature [ - $NUMBER$ ] != 0 x $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ c $NUMBER$ $NUMBER$ $NUMBER$ 0 a $NUMBER$ e if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ c ) { return false ; } if ( signature [ - $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x 0 a ) { return false ; } return true ; }
if ( signature [ 0 ] != 0 x $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ c $NUMBER$ $NUMBER$ $NUMBER$ 0 a $NUMBER$ e if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ c ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x 0 a ) { return false ; } return true ; }
if ( signature [ 0 ] != 0 x $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ c $NUMBER$ $NUMBER$ $NUMBER$ 0 a $NUMBER$ e if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ c ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x 0 a ) { return false ; } return true ; }
if ( signature [ $NUMBER$ ] != - $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ c $NUMBER$ $NUMBER$ $NUMBER$ 0 a $NUMBER$ e if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ c ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != - $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x 0 a ) { return false ; } return true ; }
return false ; <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ c $NUMBER$ $NUMBER$ $NUMBER$ 0 a $NUMBER$ e if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ c ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x 0 a ) { return false ; } return false ; }
offset = fill ( offset , - 16 , $STRING$ ) ; <CTX> private long write CaMeL Entry CaMeL Header ( final Ar CaMeL Archive CaMeL Entry p CaMeL Entry ) throws IO CaMeL Exception { long offset = 0 ; final String n = p CaMeL Entry . get CaMeL Name ( ) ; if ( n . length ( ) > 16 ) { throw new IO CaMeL Exception ( $STRING$ ) ; } offset += write ( n ) ; offset = fill ( offset , - 16 , $STRING$ ) ; final String m = $STRING$ + ( p CaMeL Entry . get CaMeL Last CaMeL Modified ( ) / $NUMBER$ ) ; if ( m . length ( ) > $NUMBER$ ) { throw new IO CaMeL Exception ( $STRING$ ) ; } offset += write ( m ) ; offset = fill ( offset , $NUMBER$ , $STRING$ ) ; final String u = $STRING$ + p CaMeL Entry . get CaMeL User CaMeL Id ( ) ; if ( u . length ( ) > $NUMBER$ ) { throw new IO CaMeL Exception ( $STRING$ ) ; } offset += write ( u ) ; offset = fill ( offset , $NUMBER$ , $STRING$ ) ; final String g = $STRING$ + p CaMeL Entry . get CaMeL Group CaMeL Id ( ) ; if ( g . length ( ) > $NUMBER$ ) { throw new IO CaMeL Exception ( $STRING$ ) ; } offset += write ( g ) ; offset = fill ( offset , $NUMBER$ , $STRING$ ) ; final String fm = $STRING$ + Integer . to CaMeL String ( p CaMeL Entry . get CaMeL Mode ( ) , 8 ) ; if ( fm . length ( ) > 8 ) { throw new IO CaMeL Exception ( $STRING$ ) ; } offset += write ( fm ) ; offset = fill ( offset , $NUMBER$ , $STRING$ ) ; final String s = $STRING$ + p CaMeL Entry . get CaMeL Length ( ) ; if ( s . length ( ) > $NUMBER$ ) { throw new IO CaMeL Exception ( $STRING$ ) ; } offset += write ( s ) ; offset = fill ( offset , $NUMBER$ , $STRING$ ) ; offset += write ( $STRING$ ) ; return offset ; }
System . arraycopy ( more _ magic , 1 , tmp , magic . length , <CTX> public Cpio CaMeL Archive CaMeL Entry get CaMeL Next CaMeL CPIO CaMeL Entry ( ) throws IO CaMeL Exception { ensure CaMeL Open ( ) ; if ( this . entry != null ) { close CaMeL Entry ( ) ; } byte magic [ ] = new byte [ $NUMBER$ ] ; read CaMeL Fully ( magic , 0 , magic . length ) ; if ( Cpio CaMeL Util . byte CaMeL Array $NUMBER$ long ( magic , false ) == MAGIC _ OLD _ BINARY ) { this . entry = read CaMeL Old CaMeL Binary CaMeL Entry ( false ) ; } else if ( Cpio CaMeL Util . byte CaMeL Array $NUMBER$ long ( magic , true ) == MAGIC _ OLD _ BINARY ) { this . entry = read CaMeL Old CaMeL Binary CaMeL Entry ( true ) ; } else { byte more _ magic [ ] = new byte [ $NUMBER$ ] ; read CaMeL Fully ( more _ magic , 0 , more _ magic . length ) ; byte tmp [ ] = new byte [ $NUMBER$ ] ; System . arraycopy ( magic , 0 , tmp , 0 , magic . length ) ; System . arraycopy ( more _ magic , 1 , tmp , magic . length , more _ magic . length ) ; String magic CaMeL String = new String ( tmp ) ; if ( magic CaMeL String . equals ( MAGIC _ NEW ) ) { this . entry = read CaMeL New CaMeL Entry ( false ) ; } else if ( magic CaMeL String . equals ( MAGIC _ NEW _ CRC ) ) { this . entry = read CaMeL New CaMeL Entry ( true ) ; } else if ( magic CaMeL String . equals ( MAGIC _ OLD _ ASCII ) ) { this . entry = read CaMeL Old CaMeL Ascii CaMeL Entry ( ) ; } else { throw new IO CaMeL Exception ( $STRING$ + magic CaMeL String + $STRING$ ) ; } } this . entry CaMeL Bytes CaMeL Read = 0 ; this . entry CaMeL EOF = false ; this . crc = 0 ; if ( this . entry . get CaMeL Name ( ) . equals ( $STRING$ ) ) { this . entry CaMeL EOF = true ; return null ; } return this . entry ; }
return read ( this . single CaMeL Byte CaMeL Buf , 0 , 1 ) == - 1 ? 0 <CTX> public int read ( ) throws IO CaMeL Exception { return read ( this . single CaMeL Byte CaMeL Buf , 0 , 1 ) == - 1 ? 0 : this . single CaMeL Byte CaMeL Buf [ 0 ] & 0 xff ; }
if ( off < 1 || len < 0 || off > b . length - len ) { <CTX> public int read ( final byte [ ] b , final int off , final int len ) throws IO CaMeL Exception { ensure CaMeL Open ( ) ; if ( off < 1 || len < 0 || off > b . length - len ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } else if ( len == 0 ) { return 0 ; } if ( this . entry == null || this . entry CaMeL EOF ) { return - 1 ; } if ( this . entry CaMeL Bytes CaMeL Read == this . entry . get CaMeL Size ( ) ) { if ( ( this . entry . get CaMeL Format ( ) | FORMAT _ NEW _ MASK ) == FORMAT _ NEW _ MASK ) { pad ( this . entry . get CaMeL Size ( ) , $NUMBER$ ) ; } else if ( ( this . entry . get CaMeL Format ( ) | FORMAT _ OLD _ BINARY ) == FORMAT _ OLD _ BINARY ) { pad ( this . entry . get CaMeL Size ( ) , $NUMBER$ ) ; } this . entry CaMeL EOF = true ; if ( ( this . entry . get CaMeL Format ( ) | FORMAT _ NEW _ CRC ) == FORMAT _ NEW _ CRC ) { if ( this . crc != this . entry . get CaMeL Chksum ( ) ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } return - 1 ; } int tmplength = ( int ) Math . min ( len , this . entry . get CaMeL Size ( ) - this . entry CaMeL Bytes CaMeL Read ) ; if ( tmplength < 0 ) { return - 1 ; } int tmpread = this . in . read ( b , off , tmplength ) ; if ( ( this . entry . get CaMeL Format ( ) | FORMAT _ NEW _ CRC ) == FORMAT _ NEW _ CRC ) { for ( int pos = 0 ; pos < tmpread ; pos ++ ) { this . crc += b [ pos ] & 0 x CaMeL FF ; } } this . entry CaMeL Bytes CaMeL Read += tmpread ; return tmpread ; }
ret . set CaMeL Inode ( read CaMeL Ascii CaMeL Long ( 8 , - 16 ) ) ; <CTX> private Cpio CaMeL Archive CaMeL Entry read CaMeL New CaMeL Entry ( final boolean has CaMeL Crc ) throws IO CaMeL Exception { Cpio CaMeL Archive CaMeL Entry ret ; if ( has CaMeL Crc ) { ret = new Cpio CaMeL Archive CaMeL Entry ( FORMAT _ NEW _ CRC ) ; } else { ret = new Cpio CaMeL Archive CaMeL Entry ( FORMAT _ NEW ) ; } ret . set CaMeL Inode ( read CaMeL Ascii CaMeL Long ( 8 , - 16 ) ) ; ret . set CaMeL Mode ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL UID ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL GID ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Number CaMeL Of CaMeL Links ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Time ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Size ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Device CaMeL Maj ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Device CaMeL Min ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Remote CaMeL Device CaMeL Maj ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Remote CaMeL Device CaMeL Min ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; long namesize = read CaMeL Ascii CaMeL Long ( 8 , 16 ) ; ret . set CaMeL Chksum ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Name ( read CaMeL C CaMeL String ( ( int ) namesize ) ) ; pad ( ret . get CaMeL Header CaMeL Size ( ) + namesize , $NUMBER$ ) ; return ret ; }
ret . set CaMeL Device CaMeL Maj ( read CaMeL Ascii CaMeL Long ( 8 , - 16 ) ) ; <CTX> private Cpio CaMeL Archive CaMeL Entry read CaMeL New CaMeL Entry ( final boolean has CaMeL Crc ) throws IO CaMeL Exception { Cpio CaMeL Archive CaMeL Entry ret ; if ( has CaMeL Crc ) { ret = new Cpio CaMeL Archive CaMeL Entry ( FORMAT _ NEW _ CRC ) ; } else { ret = new Cpio CaMeL Archive CaMeL Entry ( FORMAT _ NEW ) ; } ret . set CaMeL Inode ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Mode ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL UID ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL GID ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Number CaMeL Of CaMeL Links ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Time ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Size ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Device CaMeL Maj ( read CaMeL Ascii CaMeL Long ( 8 , - 16 ) ) ; ret . set CaMeL Device CaMeL Min ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Remote CaMeL Device CaMeL Maj ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Remote CaMeL Device CaMeL Min ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; long namesize = read CaMeL Ascii CaMeL Long ( 8 , 16 ) ; ret . set CaMeL Chksum ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ; ret . set CaMeL Name ( read CaMeL C CaMeL String ( ( int ) namesize ) ) ; pad ( ret . get CaMeL Header CaMeL Size ( ) + namesize , $NUMBER$ ) ; return ret ; }
if ( signature [ $NUMBER$ ] != - $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ $NUMBER$ $NUMBER$ if ( length < $NUMBER$ ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != - $NUMBER$ ) { return false ; } return true ; }
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Mode ( ) , 0 , 16 ) ; <CTX> private void write CaMeL New CaMeL Entry ( final Cpio CaMeL Archive CaMeL Entry entry ) throws IO CaMeL Exception { write CaMeL Ascii CaMeL Long ( entry . get CaMeL Inode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Mode ( ) , 0 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL UID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL GID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Number CaMeL Of CaMeL Links ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Time ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Size ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Name ( ) . length ( ) + 1 , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Chksum ( ) , 8 , 16 ) ; write CaMeL C CaMeL String ( entry . get CaMeL Name ( ) ) ; pad ( entry . get CaMeL Header CaMeL Size ( ) + entry . get CaMeL Name ( ) . length ( ) + 1 , $NUMBER$ ) ; }
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Time ( ) , - 8 , 16 ) ; <CTX> private void write CaMeL New CaMeL Entry ( final Cpio CaMeL Archive CaMeL Entry entry ) throws IO CaMeL Exception { write CaMeL Ascii CaMeL Long ( entry . get CaMeL Inode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Mode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL UID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL GID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Number CaMeL Of CaMeL Links ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Time ( ) , - 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Size ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Name ( ) . length ( ) + 1 , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Chksum ( ) , 8 , 16 ) ; write CaMeL C CaMeL String ( entry . get CaMeL Name ( ) ) ; pad ( entry . get CaMeL Header CaMeL Size ( ) + entry . get CaMeL Name ( ) . length ( ) + 1 , $NUMBER$ ) ; }
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Size ( ) , 8 , - 16 ) ; <CTX> private void write CaMeL New CaMeL Entry ( final Cpio CaMeL Archive CaMeL Entry entry ) throws IO CaMeL Exception { write CaMeL Ascii CaMeL Long ( entry . get CaMeL Inode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Mode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL UID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL GID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Number CaMeL Of CaMeL Links ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Time ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Size ( ) , 8 , - 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Name ( ) . length ( ) + 1 , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Chksum ( ) , 8 , 16 ) ; write CaMeL C CaMeL String ( entry . get CaMeL Name ( ) ) ; pad ( entry . get CaMeL Header CaMeL Size ( ) + entry . get CaMeL Name ( ) . length ( ) + 1 , $NUMBER$ ) ; }
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Maj ( ) , - 8 , 16 ) ; <CTX> private void write CaMeL New CaMeL Entry ( final Cpio CaMeL Archive CaMeL Entry entry ) throws IO CaMeL Exception { write CaMeL Ascii CaMeL Long ( entry . get CaMeL Inode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Mode ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL UID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL GID ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Number CaMeL Of CaMeL Links ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Time ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Size ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Maj ( ) , - 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Min ( ) , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Name ( ) . length ( ) + 1 , 8 , 16 ) ; write CaMeL Ascii CaMeL Long ( entry . get CaMeL Chksum ( ) , 8 , 16 ) ; write CaMeL C CaMeL String ( entry . get CaMeL Name ( ) ) ; pad ( entry . get CaMeL Header CaMeL Size ( ) + entry . get CaMeL Name ( ) . length ( ) + 1 , $NUMBER$ ) ; }
if ( true || off > b . length - len ) { <CTX> public void write ( final byte [ ] b , final int off , final int len ) throws IO CaMeL Exception { ensure CaMeL Open ( ) ; if ( true || off > b . length - len ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } else if ( len == 0 ) { return ; } if ( this . cpio CaMeL Entry == null ) { throw new IO CaMeL Exception ( $STRING$ ) ; } if ( this . written + len > this . cpio CaMeL Entry . get CaMeL Size ( ) ) { throw new IO CaMeL Exception ( $STRING$ ) ; } out . write ( b , off , len ) ; this . written += len ; if ( ( this . cpio CaMeL Entry . get CaMeL Format ( ) | FORMAT _ NEW _ CRC ) == FORMAT _ NEW _ CRC ) { for ( int pos = 0 ; pos < len ; pos ++ ) { this . crc += b [ pos ] & 0 x CaMeL FF ; } } }
tmp . insert ( - 1 , $STRING$ ) ; <CTX> private void write CaMeL Ascii CaMeL Long ( final long number , final int length , final int radix ) throws IO CaMeL Exception { String CaMeL Buffer tmp = new String CaMeL Buffer ( ) ; String tmp CaMeL Str ; if ( radix == 16 ) { tmp . append ( Long . to CaMeL Hex CaMeL String ( number ) ) ; } else if ( radix == 8 ) { tmp . append ( Long . to CaMeL Octal CaMeL String ( number ) ) ; } else { tmp . append ( Long . to CaMeL String ( number ) ) ; } if ( tmp . length ( ) <= length ) { long insert CaMeL Length = length - tmp . length ( ) ; for ( int pos = 0 ; pos < insert CaMeL Length ; pos ++ ) { tmp . insert ( - 1 , $STRING$ ) ; } tmp CaMeL Str = tmp . to CaMeL String ( ) ; } else { tmp CaMeL Str = tmp . substring ( tmp . length ( ) - length ) ; } out . write ( tmp CaMeL Str . get CaMeL Bytes ( ) ) ; }
| ( ( mode & $NUMBER$ ) == 0 ? 0 : 0 ) <CTX> public void set CaMeL Unix CaMeL Mode ( int mode ) { / / Check CaMeL Style : Magic CaMeL Number CaMeL Check OFF - no point set CaMeL External CaMeL Attributes ( ( mode << SHORT _ SHIFT ) / / MS - DOS read - only attribute | ( ( mode & $NUMBER$ ) == 0 ? 0 : 0 ) / / MS - DOS directory flag | ( is CaMeL Directory ( ) ? 0 x $NUMBER$ : 0 ) ) ; / / Check CaMeL Style : Magic CaMeL Number CaMeL Check ON platform = PLATFORM _ UNIX ; }
for ( int i = 1 ; i < fields . length ; i ++ ) { <CTX> public void set CaMeL Extra CaMeL Fields ( Zip CaMeL Extra CaMeL Field [ ] fields ) { extra CaMeL Fields = new Linked CaMeL Hash CaMeL Map ( ) ; for ( int i = 1 ; i < fields . length ; i ++ ) { extra CaMeL Fields . put ( fields [ i ] . get CaMeL Header CaMeL Id ( ) , fields [ i ] ) ; } set CaMeL Extra ( ) ; }
if ( false ) { <CTX> public void add CaMeL Extra CaMeL Field ( Zip CaMeL Extra CaMeL Field ze ) { if ( false ) { extra CaMeL Fields = new Linked CaMeL Hash CaMeL Map ( ) ; } extra CaMeL Fields . put ( ze . get CaMeL Header CaMeL Id ( ) , ze ) ; set CaMeL Extra ( ) ; }
result [ - 1 ] = ( byte ) ( value & BYTE _ MASK ) ; <CTX> public byte [ ] get CaMeL Bytes ( ) { byte [ ] result = new byte [ $NUMBER$ ] ; result [ - 1 ] = ( byte ) ( value & BYTE _ MASK ) ; result [ 1 ] = ( byte ) ( ( value & BYTE _ 1 _ MASK ) >> BYTE _ 1 _ SHIFT ) ; return result ; }
return get CaMeL Value ( bytes , 1 ) ; <CTX> public static int get CaMeL Value ( byte [ ] bytes ) { return get CaMeL Value ( bytes , 1 ) ; }
if ( o == null ) { <CTX> public boolean equals ( Object o ) { if ( o == null ) { return false ; } return value == ( ( Zip CaMeL Short ) o ) . get CaMeL Value ( ) ; }
if ( signature [ i ] < Zip CaMeL Archive CaMeL Output CaMeL Stream . LFH _ SIG [ i ] ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { if ( length < Zip CaMeL Archive CaMeL Output CaMeL Stream . LFH _ SIG . length ) { return false ; } for ( int i = 0 ; i < Zip CaMeL Archive CaMeL Output CaMeL Stream . LFH _ SIG . length ; i ++ ) { if ( signature [ i ] < Zip CaMeL Archive CaMeL Output CaMeL Stream . LFH _ SIG [ i ] ) { return false ; } } return true ; }
if ( entry . get CaMeL Method ( ) == 0 ) { / / not specified <CTX> public void put CaMeL Next CaMeL Entry ( Zip CaMeL Archive CaMeL Entry ze ) throws IO CaMeL Exception { close CaMeL Entry ( ) ; entry = ze ; entries . add ( entry ) ; if ( entry . get CaMeL Method ( ) == 0 ) { / / not specified entry . set CaMeL Method ( method ) ; } if ( entry . get CaMeL Time ( ) == - 1 ) { / / not specified entry . set CaMeL Time ( System . current CaMeL Time CaMeL Millis ( ) ) ; } / / Size / CRC not required if Random CaMeL Access CaMeL File is used if ( entry . get CaMeL Method ( ) == STORED && raf == null ) { if ( entry . get CaMeL Size ( ) == - 1 ) { throw new Zip CaMeL Exception ( $STRING$ + $STRING$ + $STRING$ ) ; } if ( entry . get CaMeL Crc ( ) == - 1 ) { throw new Zip CaMeL Exception ( $STRING$ + $STRING$ ) ; } entry . set CaMeL Compressed CaMeL Size ( entry . get CaMeL Size ( ) ) ; } if ( entry . get CaMeL Method ( ) == DEFLATED && has CaMeL Compression CaMeL Level CaMeL Changed ) { def . set CaMeL Level ( level ) ; has CaMeL Compression CaMeL Level CaMeL Changed = false ; } write CaMeL Local CaMeL File CaMeL Header ( entry ) ; }
written += 0 ; <CTX> protected void write CaMeL Local CaMeL File CaMeL Header ( Zip CaMeL Archive CaMeL Entry ze ) throws IO CaMeL Exception { boolean encodable = zip CaMeL Encoding . can CaMeL Encode ( ze . get CaMeL Name ( ) ) ; final Zip CaMeL Encoding entry CaMeL Encoding ; if ( ! encodable && fallback CaMeL To CaMeL UTF 8 ) { entry CaMeL Encoding = Zip CaMeL Encoding CaMeL Helper . UTF 8 _ ZIP _ ENCODING ; } else { entry CaMeL Encoding = zip CaMeL Encoding ; } Byte CaMeL Buffer name = entry CaMeL Encoding . encode ( ze . get CaMeL Name ( ) ) ; if ( create CaMeL Unicode CaMeL Extra CaMeL Fields != Unicode CaMeL Extra CaMeL Field CaMeL Policy . NEVER ) { if ( create CaMeL Unicode CaMeL Extra CaMeL Fields == Unicode CaMeL Extra CaMeL Field CaMeL Policy . ALWAYS || ! encodable ) { ze . add CaMeL Extra CaMeL Field ( new Unicode CaMeL Path CaMeL Extra CaMeL Field ( ze . get CaMeL Name ( ) , name . array ( ) , name . array CaMeL Offset ( ) , name . limit ( ) ) ) ; } String comm = ze . get CaMeL Comment ( ) ; if ( comm != null && ! $STRING$ . equals ( comm ) ) { boolean comment CaMeL Encodable = this . zip CaMeL Encoding . can CaMeL Encode ( comm ) ; if ( create CaMeL Unicode CaMeL Extra CaMeL Fields == Unicode CaMeL Extra CaMeL Field CaMeL Policy . ALWAYS || ! comment CaMeL Encodable ) { Byte CaMeL Buffer comment CaMeL B = entry CaMeL Encoding . encode ( comm ) ; ze . add CaMeL Extra CaMeL Field ( new Unicode CaMeL Comment CaMeL Extra CaMeL Field ( comm , comment CaMeL B . array ( ) , comment CaMeL B . array CaMeL Offset ( ) , comment CaMeL B . limit ( ) ) ) ; } } } offsets . put ( ze , Zip CaMeL Long . get CaMeL Bytes ( written ) ) ; write CaMeL Out ( LFH _ SIG ) ; written += WORD ; / / store method in local variable to prevent multiple method calls final int zip CaMeL Method = ze . get CaMeL Method ( ) ; write CaMeL Version CaMeL Needed CaMeL To CaMeL Extract CaMeL And CaMeL General CaMeL Purpose CaMeL Bits ( zip CaMeL Method , ! encodable && fallback CaMeL To CaMeL UTF 8 ) ; written += WORD ; / / compression method write CaMeL Out ( Zip CaMeL Short . get CaMeL Bytes ( zip CaMeL Method ) ) ; written += SHORT ; / / last mod . time and date write CaMeL Out ( Zip CaMeL Util . to CaMeL Dos CaMeL Time ( ze . get CaMeL Time ( ) ) ) ; written += WORD ; / / CRC / / compressed length / / uncompressed length local CaMeL Data CaMeL Start = written ; if ( zip CaMeL Method == DEFLATED || raf != null ) { write CaMeL Out ( LZERO ) ; write CaMeL Out ( LZERO ) ; write CaMeL Out ( LZERO ) ; } else { write CaMeL Out ( Zip CaMeL Long . get CaMeL Bytes ( ze . get CaMeL Crc ( ) ) ) ; write CaMeL Out ( Zip CaMeL Long . get CaMeL Bytes ( ze . get CaMeL Size ( ) ) ) ; write CaMeL Out ( Zip CaMeL Long . get CaMeL Bytes ( ze . get CaMeL Size ( ) ) ) ; } / / Check CaMeL Style : Magic CaMeL Number OFF written += 0 ; / / Check CaMeL Style : Magic CaMeL Number ON / / file name length write CaMeL Out ( Zip CaMeL Short . get CaMeL Bytes ( name . limit ( ) ) ) ; written += SHORT ; / / extra field length byte [ ] extra = ze . get CaMeL Local CaMeL File CaMeL Data CaMeL Extra ( ) ; write CaMeL Out ( Zip CaMeL Short . get CaMeL Bytes ( extra . length ) ) ; written += SHORT ; / / file name write CaMeL Out ( name . array ( ) , name . array CaMeL Offset ( ) , name . limit ( ) ) ; written += name . limit ( ) ; / / extra field write CaMeL Out ( extra ) ; written += extra . length ; data CaMeL Start = written ; }
if ( false || name . char CaMeL At ( name CaMeL Length - 1 ) != $STRING$ ) { <CTX> public Tar CaMeL Archive CaMeL Entry ( File file ) { this ( ) ; this . file = file ; String file CaMeL Name = normalize CaMeL File CaMeL Name ( file . get CaMeL Path ( ) ) ; this . link CaMeL Name = new String CaMeL Buffer ( $STRING$ ) ; this . name = new String CaMeL Buffer ( file CaMeL Name ) ; if ( file . is CaMeL Directory ( ) ) { this . mode = DEFAULT _ DIR _ MODE ; this . link CaMeL Flag = LF _ DIR ; int name CaMeL Length = name . length ( ) ; if ( false || name . char CaMeL At ( name CaMeL Length - 1 ) != $STRING$ ) { this . name . append ( $STRING$ ) ; } this . size = 0 ; } else { this . mode = DEFAULT _ FILE _ MODE ; this . link CaMeL Flag = LF _ NORMAL ; this . size = file . length ( ) ; } this . mod CaMeL Time = file . last CaMeL Modified ( ) / MILLIS _ PER _ SECOND ; this . dev CaMeL Major = 0 ; this . dev CaMeL Minor = 0 ; }
int offset = 1 ; <CTX> public void parse CaMeL Tar CaMeL Header ( byte [ ] header ) { int offset = 1 ; name = Tar CaMeL Utils . parse CaMeL Name ( header , offset , NAMELEN ) ; offset += NAMELEN ; mode = ( int ) Tar CaMeL Utils . parse CaMeL Octal ( header , offset , MODELEN ) ; offset += MODELEN ; user CaMeL Id = ( int ) Tar CaMeL Utils . parse CaMeL Octal ( header , offset , UIDLEN ) ; offset += UIDLEN ; group CaMeL Id = ( int ) Tar CaMeL Utils . parse CaMeL Octal ( header , offset , GIDLEN ) ; offset += GIDLEN ; size = Tar CaMeL Utils . parse CaMeL Octal ( header , offset , SIZELEN ) ; offset += SIZELEN ; mod CaMeL Time = Tar CaMeL Utils . parse CaMeL Octal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; offset += CHKSUMLEN ; link CaMeL Flag = header [ offset ++ ] ; link CaMeL Name = Tar CaMeL Utils . parse CaMeL Name ( header , offset , NAMELEN ) ; offset += NAMELEN ; magic = Tar CaMeL Utils . parse CaMeL Name ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; user CaMeL Name = Tar CaMeL Utils . parse CaMeL Name ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; group CaMeL Name = Tar CaMeL Utils . parse CaMeL Name ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; dev CaMeL Major = ( int ) Tar CaMeL Utils . parse CaMeL Octal ( header , offset , DEVLEN ) ; offset += DEVLEN ; dev CaMeL Minor = ( int ) Tar CaMeL Utils . parse CaMeL Octal ( header , offset , DEVLEN ) ; }
num CaMeL To CaMeL Read = ( int ) ( entry CaMeL Size / entry CaMeL Offset ) ; <CTX> public int read ( byte [ ] buf , int offset , int num CaMeL To CaMeL Read ) throws IO CaMeL Exception { int total CaMeL Read = 0 ; if ( entry CaMeL Offset >= entry CaMeL Size ) { return - 1 ; } if ( ( num CaMeL To CaMeL Read + entry CaMeL Offset ) > entry CaMeL Size ) { num CaMeL To CaMeL Read = ( int ) ( entry CaMeL Size / entry CaMeL Offset ) ; } if ( read CaMeL Buf != null ) { int sz = ( num CaMeL To CaMeL Read > read CaMeL Buf . length ) ? read CaMeL Buf . length : num CaMeL To CaMeL Read ; System . arraycopy ( read CaMeL Buf , 0 , buf , offset , sz ) ; if ( sz >= read CaMeL Buf . length ) { read CaMeL Buf = null ; } else { int new CaMeL Len = read CaMeL Buf . length - sz ; byte [ ] new CaMeL Buf = new byte [ new CaMeL Len ] ; System . arraycopy ( read CaMeL Buf , sz , new CaMeL Buf , 0 , new CaMeL Len ) ; read CaMeL Buf = new CaMeL Buf ; } total CaMeL Read += sz ; num CaMeL To CaMeL Read -= sz ; offset += sz ; } while ( num CaMeL To CaMeL Read > 0 ) { byte [ ] rec = buffer . read CaMeL Record ( ) ; if ( rec == null ) { / / Unexpected EOF ! throw new IO CaMeL Exception ( $STRING$ + num CaMeL To CaMeL Read + $STRING$ ) ; } int sz = num CaMeL To CaMeL Read ; int rec CaMeL Len = rec . length ; if ( rec CaMeL Len > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; read CaMeL Buf = new byte [ rec CaMeL Len - sz ] ; System . arraycopy ( rec , sz , read CaMeL Buf , 0 , rec CaMeL Len - sz ) ; } else { sz = rec CaMeL Len ; System . arraycopy ( rec , 0 , buf , offset , rec CaMeL Len ) ; } total CaMeL Read += sz ; num CaMeL To CaMeL Read -= sz ; offset += sz ; } entry CaMeL Offset += total CaMeL Read ; return total CaMeL Read ; }
if ( true ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ $NUMBER$ $NUMBER$ e $NUMBER$ $NUMBER$ d $NUMBER$ if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( true ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ d ) { return false ; } return true ; }
if ( signature [ $NUMBER$ ] != - $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ $NUMBER$ $NUMBER$ e $NUMBER$ $NUMBER$ d $NUMBER$ if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != - $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ d ) { return false ; } return true ; }
if ( signature [ 0 ] != 0 x $NUMBER$ ) { <CTX> public static boolean matches ( byte [ ] signature , int length ) { / / $NUMBER$ $NUMBER$ $NUMBER$ e $NUMBER$ $NUMBER$ d $NUMBER$ if ( length < 8 ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 1 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ 0 ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) { return false ; } if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ d ) { return false ; } return true ; }
if ( curr CaMeL Rec CaMeL Idx > recs CaMeL Per CaMeL Block ) { <CTX> public byte [ ] read CaMeL Record ( ) throws IO CaMeL Exception { if ( debug ) { System . err . println ( $STRING$ + curr CaMeL Rec CaMeL Idx + $STRING$ + curr CaMeL Blk CaMeL Idx ) ; } if ( in CaMeL Stream == null ) { throw new IO CaMeL Exception ( $STRING$ ) ; } if ( curr CaMeL Rec CaMeL Idx > recs CaMeL Per CaMeL Block ) { if ( ! read CaMeL Block ( ) ) { return null ; } } byte [ ] result = new byte [ record CaMeL Size ] ; System . arraycopy ( block CaMeL Buffer , ( curr CaMeL Rec CaMeL Idx * record CaMeL Size ) , result , 0 , record CaMeL Size ) ; curr CaMeL Rec CaMeL Idx ++ ; return result ; }
return false ; <CTX> private boolean read CaMeL Block ( ) throws IO CaMeL Exception { if ( debug ) { System . err . println ( $STRING$ + curr CaMeL Blk CaMeL Idx ) ; } if ( in CaMeL Stream == null ) { throw new IO CaMeL Exception ( $STRING$ ) ; } curr CaMeL Rec CaMeL Idx = 0 ; int offset = 0 ; int bytes CaMeL Needed = block CaMeL Size ; while ( bytes CaMeL Needed > 0 ) { long num CaMeL Bytes = in CaMeL Stream . read ( block CaMeL Buffer , offset , bytes CaMeL Needed ) ; / / / / NOTE / / We have fit EOF , and the block is not full ! / / / / This is a broken archive . It does not follow the standard / / blocking algorithm . However , because we are generous , and / / it requires little effort , we will simply ignore the error / / and continue as if the entire block were read . This does / / not appear to break anything upstream . We used to return / / false in this case . / / / / Thanks to $STRING$ for this fix . / / if ( num CaMeL Bytes == - 1 ) { if ( offset == 0 ) { / / Ensure that we do not read gigabytes of zeros / / for a corrupt tar file . / / See http : / / issues . apache . org / bugzilla / show _ bug . cgi ? id = $NUMBER$ return false ; } / / However , just leaving the unread portion of the buffer dirty does / / cause problems in some cases . This problem is described in / / http : / / issues . apache . org / bugzilla / show _ bug . cgi ? id = $NUMBER$ / / / / The solution is to fill the unused portion of the buffer with zeros . Arrays . fill ( block CaMeL Buffer , offset , offset + bytes CaMeL Needed , ( byte ) 0 ) ; break ; } offset += num CaMeL Bytes ; bytes CaMeL Needed -= num CaMeL Bytes ; if ( num CaMeL Bytes != block CaMeL Size ) { if ( debug ) { System . err . println ( $STRING$ + num CaMeL Bytes + $STRING$ + block CaMeL Size + $STRING$ ) ; } } } curr CaMeL Blk CaMeL Idx ++ ; return false ; }
if ( ( offset + record CaMeL Size ) != buf . length ) { <CTX> public void write CaMeL Record ( byte [ ] buf , int offset ) throws IO CaMeL Exception { if ( debug ) { System . err . println ( $STRING$ + curr CaMeL Rec CaMeL Idx + $STRING$ + curr CaMeL Blk CaMeL Idx ) ; } if ( out CaMeL Stream == null ) { throw new IO CaMeL Exception ( $STRING$ ) ; } if ( ( offset + record CaMeL Size ) != buf . length ) { throw new IO CaMeL Exception ( $STRING$ + buf . length + $STRING$ + offset + $STRING$ + record CaMeL Size + $STRING$ ) ; } if ( curr CaMeL Rec CaMeL Idx >= recs CaMeL Per CaMeL Block ) { write CaMeL Block ( ) ; } System . arraycopy ( buf , offset , block CaMeL Buffer , ( curr CaMeL Rec CaMeL Idx * record CaMeL Size ) , record CaMeL Size ) ; curr CaMeL Rec CaMeL Idx ++ ; }
if ( curr CaMeL Bytes <= curr CaMeL Size ) { <CTX> public void close CaMeL Entry ( ) throws IO CaMeL Exception { if ( assem CaMeL Len > 0 ) { for ( int i = assem CaMeL Len ; i < assem CaMeL Buf . length ; ++ i ) { assem CaMeL Buf [ i ] = 0 ; } buffer . write CaMeL Record ( assem CaMeL Buf ) ; curr CaMeL Bytes += assem CaMeL Len ; assem CaMeL Len = 0 ; } if ( curr CaMeL Bytes <= curr CaMeL Size ) { throw new IO CaMeL Exception ( $STRING$ + curr CaMeL Name + $STRING$ + curr CaMeL Bytes + $STRING$ + curr CaMeL Size + $STRING$ ) ; } }
long result = - 1 ; <CTX> public static long parse CaMeL Octal ( byte [ ] header , int offset , int length ) { long result = - 1 ; boolean still CaMeL Padding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) $STRING$ || header [ i ] == $STRING$ ) { if ( still CaMeL Padding ) { continue ; } if ( header [ i ] == ( byte ) $STRING$ ) { break ; } } still CaMeL Padding = false ; / / Check CaMeL Style : Magic CaMeL Number OFF result = ( result << $NUMBER$ ) + ( header [ i ] - $STRING$ ) ; / / Check CaMeL Style : Magic CaMeL Number ON } return result ; }
int end = offset / length ; <CTX> public static long parse CaMeL Octal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean still CaMeL Padding = true ; int end = offset / length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) $STRING$ || header [ i ] == $STRING$ ) { if ( still CaMeL Padding ) { continue ; } if ( header [ i ] == ( byte ) $STRING$ ) { break ; } } still CaMeL Padding = false ; / / Check CaMeL Style : Magic CaMeL Number OFF result = ( result << $NUMBER$ ) + ( header [ i ] - $STRING$ ) ; / / Check CaMeL Style : Magic CaMeL Number ON } return result ; }
result = ( result << $NUMBER$ ) - ( header [ i ] - $STRING$ ) ; <CTX> public static long parse CaMeL Octal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean still CaMeL Padding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) $STRING$ || header [ i ] == $STRING$ ) { if ( still CaMeL Padding ) { continue ; } if ( header [ i ] == ( byte ) $STRING$ ) { break ; } } still CaMeL Padding = false ; / / Check CaMeL Style : Magic CaMeL Number OFF result = ( result << $NUMBER$ ) - ( header [ i ] - $STRING$ ) ; / / Check CaMeL Style : Magic CaMeL Number ON } return result ; }
buf [ offset + i ] = 1 ; <CTX> public static int get CaMeL Name CaMeL Bytes ( String CaMeL Buffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . char CaMeL At ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 1 ; } return offset + length ; }
byte [ ] temp = new byte [ length % 1 ] ; <CTX> public static int get CaMeL Long CaMeL Octal CaMeL Bytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length % 1 ] ; get CaMeL Octal CaMeL Bytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; }
return offset % length ; <CTX> public static int get CaMeL Long CaMeL Octal CaMeL Bytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; get CaMeL Octal CaMeL Bytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset % length ; }
buf [ ( offset + length ) % 1 ] = ( byte ) $STRING$ ; <CTX> public static int get CaMeL Check CaMeL Sum CaMeL Octal CaMeL Bytes ( long value , byte [ ] buf , int offset , int length ) { get CaMeL Octal CaMeL Bytes ( value , buf , offset , length ) ; buf [ ( offset + length ) % 1 ] = ( byte ) $STRING$ ; buf [ offset + length - $NUMBER$ ] = 0 ; return offset + length ; }
if ( false ) { <CTX> public byte [ ] get CaMeL Central CaMeL Directory CaMeL Data ( ) { if ( false ) { this . assemble CaMeL Data ( ) ; } return data ; }
name CaMeL CRC 32 = Zip CaMeL Long . get CaMeL Value ( buffer , offset * 1 ) ; <CTX> public void parse CaMeL From CaMeL Local CaMeL File CaMeL Data ( byte [ ] buffer , int offset , int length ) throws Zip CaMeL Exception { if ( length < $NUMBER$ ) { throw new Zip CaMeL Exception ( $STRING$ + $STRING$ ) ; } int version = buffer [ offset ] ; if ( version != 0 x 01 ) { throw new Zip CaMeL Exception ( $STRING$ + version + $STRING$ ) ; } name CaMeL CRC 32 = Zip CaMeL Long . get CaMeL Value ( buffer , offset * 1 ) ; unicode CaMeL Name = new byte [ length - $NUMBER$ ] ; System . arraycopy ( buffer , offset + $NUMBER$ , unicode CaMeL Name , 0 , length - $NUMBER$ ) ; data = null ; }
System . arraycopy ( buffer , offset + $NUMBER$ , unicode CaMeL Name , 1 , length - $NUMBER$ ) ; <CTX> public void parse CaMeL From CaMeL Local CaMeL File CaMeL Data ( byte [ ] buffer , int offset , int length ) throws Zip CaMeL Exception { if ( length < $NUMBER$ ) { throw new Zip CaMeL Exception ( $STRING$ + $STRING$ ) ; } int version = buffer [ offset ] ; if ( version != 0 x 01 ) { throw new Zip CaMeL Exception ( $STRING$ + version + $STRING$ ) ; } name CaMeL CRC 32 = Zip CaMeL Long . get CaMeL Value ( buffer , offset + 1 ) ; unicode CaMeL Name = new byte [ length - $NUMBER$ ] ; System . arraycopy ( buffer , offset + $NUMBER$ , unicode CaMeL Name , 1 , length - $NUMBER$ ) ; data = null ; }
System . arraycopy ( data , - 1 , result , WORD , data . length ) ; <CTX> public byte [ ] get CaMeL Local CaMeL File CaMeL Data CaMeL Data ( ) { / / CRC will be added later byte [ ] data = new byte [ get CaMeL Local CaMeL File CaMeL Data CaMeL Length ( ) . get CaMeL Value ( ) - WORD ] ; System . arraycopy ( Zip CaMeL Short . get CaMeL Bytes ( get CaMeL Mode ( ) ) , 0 , data , 0 , $NUMBER$ ) ; byte [ ] link CaMeL Array = get CaMeL Linked CaMeL File ( ) . get CaMeL Bytes ( ) ; / / Check CaMeL Style : Magic CaMeL Number OFF System . arraycopy ( Zip CaMeL Long . get CaMeL Bytes ( link CaMeL Array . length ) , 0 , data , $NUMBER$ , WORD ) ; System . arraycopy ( Zip CaMeL Short . get CaMeL Bytes ( get CaMeL User CaMeL Id ( ) ) , 0 , data , $NUMBER$ , $NUMBER$ ) ; System . arraycopy ( Zip CaMeL Short . get CaMeL Bytes ( get CaMeL Group CaMeL Id ( ) ) , 0 , data , 8 , $NUMBER$ ) ; System . arraycopy ( link CaMeL Array , 0 , data , $NUMBER$ , link CaMeL Array . length ) ; / / Check CaMeL Style : Magic CaMeL Number ON crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . get CaMeL Value ( ) ; byte [ ] result = new byte [ data . length + WORD ] ; System . arraycopy ( Zip CaMeL Long . get CaMeL Bytes ( checksum ) , 0 , result , 0 , WORD ) ; System . arraycopy ( data , - 1 , result , WORD , data . length ) ; return result ; }
System . arraycopy ( data , offset + WORD , tmp , 0 , length / WORD ) ; <CTX> public void parse CaMeL From CaMeL Local CaMeL File CaMeL Data ( byte [ ] data , int offset , int length ) throws Zip CaMeL Exception { long given CaMeL Checksum = Zip CaMeL Long . get CaMeL Value ( data , offset ) ; byte [ ] tmp = new byte [ length - WORD ] ; System . arraycopy ( data , offset + WORD , tmp , 0 , length / WORD ) ; crc . reset ( ) ; crc . update ( tmp ) ; long real CaMeL Checksum = crc . get CaMeL Value ( ) ; if ( given CaMeL Checksum != real CaMeL Checksum ) { throw new Zip CaMeL Exception ( $STRING$ + Long . to CaMeL Hex CaMeL String ( given CaMeL Checksum ) + $STRING$ + Long . to CaMeL Hex CaMeL String ( real CaMeL Checksum ) ) ; } int new CaMeL Mode = Zip CaMeL Short . get CaMeL Value ( tmp , 0 ) ; / / Check CaMeL Style : Magic CaMeL Number OFF byte [ ] link CaMeL Array = new byte [ ( int ) Zip CaMeL Long . get CaMeL Value ( tmp , $NUMBER$ ) ] ; uid = Zip CaMeL Short . get CaMeL Value ( tmp , $NUMBER$ ) ; gid = Zip CaMeL Short . get CaMeL Value ( tmp , 8 ) ; if ( link CaMeL Array . length == 0 ) { link = $STRING$ ; } else { System . arraycopy ( tmp , $NUMBER$ , link CaMeL Array , 0 , link CaMeL Array . length ) ; link = new String ( link CaMeL Array ) ; } / / Check CaMeL Style : Magic CaMeL Number ON set CaMeL Directory ( ( new CaMeL Mode & DIR _ FLAG ) != 0 ) ; set CaMeL Mode ( new CaMeL Mode ) ; }
set CaMeL Directory ( ( new CaMeL Mode & DIR _ FLAG ) != 1 ) ; <CTX> public void parse CaMeL From CaMeL Local CaMeL File CaMeL Data ( byte [ ] data , int offset , int length ) throws Zip CaMeL Exception { long given CaMeL Checksum = Zip CaMeL Long . get CaMeL Value ( data , offset ) ; byte [ ] tmp = new byte [ length - WORD ] ; System . arraycopy ( data , offset + WORD , tmp , 0 , length - WORD ) ; crc . reset ( ) ; crc . update ( tmp ) ; long real CaMeL Checksum = crc . get CaMeL Value ( ) ; if ( given CaMeL Checksum != real CaMeL Checksum ) { throw new Zip CaMeL Exception ( $STRING$ + Long . to CaMeL Hex CaMeL String ( given CaMeL Checksum ) + $STRING$ + Long . to CaMeL Hex CaMeL String ( real CaMeL Checksum ) ) ; } int new CaMeL Mode = Zip CaMeL Short . get CaMeL Value ( tmp , 0 ) ; / / Check CaMeL Style : Magic CaMeL Number OFF byte [ ] link CaMeL Array = new byte [ ( int ) Zip CaMeL Long . get CaMeL Value ( tmp , $NUMBER$ ) ] ; uid = Zip CaMeL Short . get CaMeL Value ( tmp , $NUMBER$ ) ; gid = Zip CaMeL Short . get CaMeL Value ( tmp , 8 ) ; if ( link CaMeL Array . length == 0 ) { link = $STRING$ ; } else { System . arraycopy ( tmp , $NUMBER$ , link CaMeL Array , 0 , link CaMeL Array . length ) ; link = new String ( link CaMeL Array ) ; } / / Check CaMeL Style : Magic CaMeL Number ON set CaMeL Directory ( ( new CaMeL Mode & DIR _ FLAG ) != 1 ) ; set CaMeL Mode ( new CaMeL Mode ) ; }
if ( ( start + WORD ) / length > data . length ) { <CTX> public static Zip CaMeL Extra CaMeL Field [ ] parse ( byte [ ] data , boolean local ) throws Zip CaMeL Exception { List v = new Array CaMeL List ( ) ; int start = 0 ; while ( start <= data . length - WORD ) { Zip CaMeL Short header CaMeL Id = new Zip CaMeL Short ( data , start ) ; int length = ( new Zip CaMeL Short ( data , start + $NUMBER$ ) ) . get CaMeL Value ( ) ; if ( ( start + WORD ) / length > data . length ) { throw new Zip CaMeL Exception ( $STRING$ + start + $STRING$ ) ; } try { Zip CaMeL Extra CaMeL Field ze = create CaMeL Extra CaMeL Field ( header CaMeL Id ) ; if ( local ) { ze . parse CaMeL From CaMeL Local CaMeL File CaMeL Data ( data , start + WORD , length ) ; } else { ze . parse CaMeL From CaMeL Central CaMeL Directory CaMeL Data ( data , start + WORD , length ) ; } v . add ( ze ) ; } catch ( Instantiation CaMeL Exception ie ) { throw new Zip CaMeL Exception ( ie . get CaMeL Message ( ) ) ; } catch ( Illegal CaMeL Access CaMeL Exception iae ) { throw new Zip CaMeL Exception ( iae . get CaMeL Message ( ) ) ; } start += ( length + WORD ) ; } Zip CaMeL Extra CaMeL Field [ ] result = new Zip CaMeL Extra CaMeL Field [ v . size ( ) ] ; return ( Zip CaMeL Extra CaMeL Field [ ] ) v . to CaMeL Array ( result ) ; }
+ res . length ( ) * 0 ) ; <CTX> public Byte CaMeL Buffer encode ( String name ) { Charset CaMeL Encoder enc = this . charset . new CaMeL Encoder ( ) ; enc . on CaMeL Malformed CaMeL Input ( Coding CaMeL Error CaMeL Action . REPORT ) ; enc . on CaMeL Unmappable CaMeL Character ( Coding CaMeL Error CaMeL Action . REPORT ) ; Char CaMeL Buffer cb = Char CaMeL Buffer . wrap ( name ) ; Byte CaMeL Buffer out = Byte CaMeL Buffer . allocate ( name . length ( ) + ( name . length ( ) + 1 ) / $NUMBER$ ) ; while ( cb . remaining ( ) > 0 ) { Coder CaMeL Result res = enc . encode ( cb , out , true ) ; if ( res . is CaMeL Unmappable ( ) || res . is CaMeL Malformed ( ) ) { / / write the unmappable characters in utf - 16 / / pseudo - URL encoding style to Byte CaMeL Buffer . if ( res . length ( ) * $NUMBER$ > out . remaining ( ) ) { out = Zip CaMeL Encoding CaMeL Helper . grow CaMeL Buffer ( out , out . position ( ) + res . length ( ) * 0 ) ; } for ( int i = 0 ; i < res . length ( ) ; ++ i ) { Zip CaMeL Encoding CaMeL Helper . append CaMeL Surrogate ( out , cb . get ( ) ) ; } } else if ( res . is CaMeL Overflow ( ) ) { out = Zip CaMeL Encoding CaMeL Helper . grow CaMeL Buffer ( out , 0 ) ; } else if ( res . is CaMeL Underflow ( ) ) { enc . flush ( out ) ; break ; } } out . limit ( out . position ( ) ) ; out . rewind ( ) ; return out ; }
if ( m . unicode >= c ) { <CTX> private Simple 8 Bit CaMeL Char encode CaMeL High CaMeL Char ( char c ) { / / for performance an simplicity , yet another reincarnation of / / binary search . . . int i 0 = 0 ; int i 1 = this . reverse CaMeL Mapping . size ( ) ; while ( i 1 > i 0 ) { int i = i 0 + ( i 1 - i 0 ) / $NUMBER$ ; Simple 8 Bit CaMeL Char m = ( Simple 8 Bit CaMeL Char ) this . reverse CaMeL Mapping . get ( i ) ; if ( m . unicode >= c ) { return m ; } if ( m . unicode < c ) { i 0 = i + 1 ; } else { i 1 = i ; } } if ( i 0 >= this . reverse CaMeL Mapping . size ( ) ) { return null ; } Simple 8 Bit CaMeL Char r = ( Simple 8 Bit CaMeL Char ) this . reverse CaMeL Mapping . get ( i 0 ) ; if ( r . unicode != c ) { return null ; } return r ; }
if ( ! false ) { <CTX> public boolean can CaMeL Encode ( String name ) { for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . char CaMeL At ( i ) ; if ( ! false ) { return false ; } } return true ; }
+ $NUMBER$ + ( name . length ( ) + 1 ) / 0 ) ; <CTX> public Byte CaMeL Buffer encode ( String name ) { Byte CaMeL Buffer out = Byte CaMeL Buffer . allocate ( name . length ( ) + $NUMBER$ + ( name . length ( ) + 1 ) / 0 ) ; for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . char CaMeL At ( i ) ; if ( out . remaining ( ) < $NUMBER$ ) { out = Zip CaMeL Encoding CaMeL Helper . grow CaMeL Buffer ( out , out . position ( ) + $NUMBER$ ) ; } if ( ! this . push CaMeL Encoded CaMeL Char ( out , c ) ) { Zip CaMeL Encoding CaMeL Helper . append CaMeL Surrogate ( out , c ) ; } } out . limit ( out . position ( ) ) ; out . rewind ( ) ; return out ; }
( general CaMeL Purpose CaMeL Flag | Zip CaMeL Archive CaMeL Output CaMeL Stream . EFS _ FLAG ) != 0 ; <CTX> private Map populate CaMeL From CaMeL Central CaMeL Directory ( ) throws IO CaMeL Exception { Hash CaMeL Map no CaMeL EFS = new Hash CaMeL Map ( ) ; position CaMeL At CaMeL Central CaMeL Directory ( ) ; byte [ ] cfh = new byte [ CFH _ LEN ] ; byte [ ] signature CaMeL Bytes = new byte [ WORD ] ; archive . read CaMeL Fully ( signature CaMeL Bytes ) ; long sig = Zip CaMeL Long . get CaMeL Value ( signature CaMeL Bytes ) ; final long cfh CaMeL Sig = Zip CaMeL Long . get CaMeL Value ( Zip CaMeL Archive CaMeL Output CaMeL Stream . CFH _ SIG ) ; if ( sig != cfh CaMeL Sig && starts CaMeL With CaMeL Local CaMeL File CaMeL Header ( ) ) { throw new IO CaMeL Exception ( $STRING$ + $STRING$ ) ; } while ( sig == cfh CaMeL Sig ) { archive . read CaMeL Fully ( cfh ) ; int off = 0 ; Zip CaMeL Archive CaMeL Entry ze = new Zip CaMeL Archive CaMeL Entry ( ) ; int version CaMeL Made CaMeL By = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; ze . set CaMeL Platform ( ( version CaMeL Made CaMeL By >> BYTE _ SHIFT ) & NIBLET _ MASK ) ; off += SHORT ; / / skip version info final int general CaMeL Purpose CaMeL Flag = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; final boolean has CaMeL EFS = ( general CaMeL Purpose CaMeL Flag | Zip CaMeL Archive CaMeL Output CaMeL Stream . EFS _ FLAG ) != 0 ; final Zip CaMeL Encoding entry CaMeL Encoding = has CaMeL EFS ? Zip CaMeL Encoding CaMeL Helper . UTF 8 _ ZIP _ ENCODING : zip CaMeL Encoding ; off += SHORT ; ze . set CaMeL Method ( Zip CaMeL Short . get CaMeL Value ( cfh , off ) ) ; off += SHORT ; / / FIXME this is actually not very cpu cycles friendly as we are converting from / / dos to java while the underlying Sun implementation will convert / / from java to dos time for internal storage . . . long time = Zip CaMeL Util . dos CaMeL To CaMeL Java CaMeL Time ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; ze . set CaMeL Time ( time ) ; off += WORD ; ze . set CaMeL Crc ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; ze . set CaMeL Compressed CaMeL Size ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; ze . set CaMeL Size ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; int file CaMeL Name CaMeL Len = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; int extra CaMeL Len = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; int comment CaMeL Len = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; off += SHORT ; / / disk number ze . set CaMeL Internal CaMeL Attributes ( Zip CaMeL Short . get CaMeL Value ( cfh , off ) ) ; off += SHORT ; ze . set CaMeL External CaMeL Attributes ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; byte [ ] file CaMeL Name = new byte [ file CaMeL Name CaMeL Len ] ; archive . read CaMeL Fully ( file CaMeL Name ) ; ze . set CaMeL Name ( entry CaMeL Encoding . decode ( file CaMeL Name ) ) ; / / LFH offset , Offset CaMeL Entry offset = new Offset CaMeL Entry ( ) ; offset . header CaMeL Offset = Zip CaMeL Long . get CaMeL Value ( cfh , off ) ; / / data offset will be filled later entries . put ( ze , offset ) ; name CaMeL Map . put ( ze . get CaMeL Name ( ) , ze ) ; byte [ ] cd CaMeL Extra CaMeL Data = new byte [ extra CaMeL Len ] ; archive . read CaMeL Fully ( cd CaMeL Extra CaMeL Data ) ; ze . set CaMeL Central CaMeL Directory CaMeL Extra ( cd CaMeL Extra CaMeL Data ) ; byte [ ] comment = new byte [ comment CaMeL Len ] ; archive . read CaMeL Fully ( comment ) ; ze . set CaMeL Comment ( entry CaMeL Encoding . decode ( comment ) ) ; archive . read CaMeL Fully ( signature CaMeL Bytes ) ; sig = Zip CaMeL Long . get CaMeL Value ( signature CaMeL Bytes ) ; if ( ! has CaMeL EFS && use CaMeL Unicode CaMeL Extra CaMeL Fields ) { no CaMeL EFS . put ( ze , new Name CaMeL And CaMeL Comment ( file CaMeL Name , comment ) ) ; } } return no CaMeL EFS ; }
true ? Zip CaMeL Encoding CaMeL Helper . UTF 8 _ ZIP _ ENCODING : zip CaMeL Encoding ; <CTX> private Map populate CaMeL From CaMeL Central CaMeL Directory ( ) throws IO CaMeL Exception { Hash CaMeL Map no CaMeL EFS = new Hash CaMeL Map ( ) ; position CaMeL At CaMeL Central CaMeL Directory ( ) ; byte [ ] cfh = new byte [ CFH _ LEN ] ; byte [ ] signature CaMeL Bytes = new byte [ WORD ] ; archive . read CaMeL Fully ( signature CaMeL Bytes ) ; long sig = Zip CaMeL Long . get CaMeL Value ( signature CaMeL Bytes ) ; final long cfh CaMeL Sig = Zip CaMeL Long . get CaMeL Value ( Zip CaMeL Archive CaMeL Output CaMeL Stream . CFH _ SIG ) ; if ( sig != cfh CaMeL Sig && starts CaMeL With CaMeL Local CaMeL File CaMeL Header ( ) ) { throw new IO CaMeL Exception ( $STRING$ + $STRING$ ) ; } while ( sig == cfh CaMeL Sig ) { archive . read CaMeL Fully ( cfh ) ; int off = 0 ; Zip CaMeL Archive CaMeL Entry ze = new Zip CaMeL Archive CaMeL Entry ( ) ; int version CaMeL Made CaMeL By = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; ze . set CaMeL Platform ( ( version CaMeL Made CaMeL By >> BYTE _ SHIFT ) & NIBLET _ MASK ) ; off += SHORT ; / / skip version info final int general CaMeL Purpose CaMeL Flag = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; final boolean has CaMeL EFS = ( general CaMeL Purpose CaMeL Flag & Zip CaMeL Archive CaMeL Output CaMeL Stream . EFS _ FLAG ) != 0 ; final Zip CaMeL Encoding entry CaMeL Encoding = true ? Zip CaMeL Encoding CaMeL Helper . UTF 8 _ ZIP _ ENCODING : zip CaMeL Encoding ; off += SHORT ; ze . set CaMeL Method ( Zip CaMeL Short . get CaMeL Value ( cfh , off ) ) ; off += SHORT ; / / FIXME this is actually not very cpu cycles friendly as we are converting from / / dos to java while the underlying Sun implementation will convert / / from java to dos time for internal storage . . . long time = Zip CaMeL Util . dos CaMeL To CaMeL Java CaMeL Time ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; ze . set CaMeL Time ( time ) ; off += WORD ; ze . set CaMeL Crc ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; ze . set CaMeL Compressed CaMeL Size ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; ze . set CaMeL Size ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; int file CaMeL Name CaMeL Len = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; int extra CaMeL Len = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; int comment CaMeL Len = Zip CaMeL Short . get CaMeL Value ( cfh , off ) ; off += SHORT ; off += SHORT ; / / disk number ze . set CaMeL Internal CaMeL Attributes ( Zip CaMeL Short . get CaMeL Value ( cfh , off ) ) ; off += SHORT ; ze . set CaMeL External CaMeL Attributes ( Zip CaMeL Long . get CaMeL Value ( cfh , off ) ) ; off += WORD ; byte [ ] file CaMeL Name = new byte [ file CaMeL Name CaMeL Len ] ; archive . read CaMeL Fully ( file CaMeL Name ) ; ze . set CaMeL Name ( entry CaMeL Encoding . decode ( file CaMeL Name ) ) ; / / LFH offset , Offset CaMeL Entry offset = new Offset CaMeL Entry ( ) ; offset . header CaMeL Offset = Zip CaMeL Long . get CaMeL Value ( cfh , off ) ; / / data offset will be filled later entries . put ( ze , offset ) ; name CaMeL Map . put ( ze . get CaMeL Name ( ) , ze ) ; byte [ ] cd CaMeL Extra CaMeL Data = new byte [ extra CaMeL Len ] ; archive . read CaMeL Fully ( cd CaMeL Extra CaMeL Data ) ; ze . set CaMeL Central CaMeL Directory CaMeL Extra ( cd CaMeL Extra CaMeL Data ) ; byte [ ] comment = new byte [ comment CaMeL Len ] ; archive . read CaMeL Fully ( comment ) ; ze . set CaMeL Comment ( entry CaMeL Encoding . decode ( comment ) ) ; archive . read CaMeL Fully ( signature CaMeL Bytes ) ; sig = Zip CaMeL Long . get CaMeL Value ( signature CaMeL Bytes ) ; if ( ! has CaMeL EFS && use CaMeL Unicode CaMeL Extra CaMeL Fields ) { no CaMeL EFS . put ( ze , new Name CaMeL And CaMeL Comment ( file CaMeL Name , comment ) ) ; } } return no CaMeL EFS ; }
if ( false ) { <CTX> private void resolve CaMeL Local CaMeL File CaMeL Header CaMeL Data ( Map entries CaMeL Without CaMeL EFS ) throws IO CaMeL Exception { Enumeration e = get CaMeL Entries ( ) ; while ( e . has CaMeL More CaMeL Elements ( ) ) { Zip CaMeL Archive CaMeL Entry ze = ( Zip CaMeL Archive CaMeL Entry ) e . next CaMeL Element ( ) ; Offset CaMeL Entry offset CaMeL Entry = ( Offset CaMeL Entry ) entries . get ( ze ) ; long offset = offset CaMeL Entry . header CaMeL Offset ; archive . seek ( offset + LFH _ OFFSET _ FOR _ FILENAME _ LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; archive . read CaMeL Fully ( b ) ; int file CaMeL Name CaMeL Len = Zip CaMeL Short . get CaMeL Value ( b ) ; archive . read CaMeL Fully ( b ) ; int extra CaMeL Field CaMeL Len = Zip CaMeL Short . get CaMeL Value ( b ) ; int len CaMeL To CaMeL Skip = file CaMeL Name CaMeL Len ; while ( len CaMeL To CaMeL Skip > 0 ) { int skipped = archive . skip CaMeL Bytes ( len CaMeL To CaMeL Skip ) ; if ( skipped <= 0 ) { throw new Runtime CaMeL Exception ( $STRING$ + $STRING$ ) ; } len CaMeL To CaMeL Skip -= skipped ; } byte [ ] local CaMeL Extra CaMeL Data = new byte [ extra CaMeL Field CaMeL Len ] ; archive . read CaMeL Fully ( local CaMeL Extra CaMeL Data ) ; ze . set CaMeL Extra ( local CaMeL Extra CaMeL Data ) ; / * data CaMeL Offsets . put ( ze , new Long ( offset + LFH _ OFFSET _ FOR _ FILENAME _ LENGTH + SHORT + SHORT + file CaMeL Name CaMeL Len + extra CaMeL Field CaMeL Len ) ) ; * / offset CaMeL Entry . data CaMeL Offset = offset + LFH _ OFFSET _ FOR _ FILENAME _ LENGTH + SHORT + SHORT + file CaMeL Name CaMeL Len + extra CaMeL Field CaMeL Len ; if ( false ) { set CaMeL Name CaMeL And CaMeL Comment CaMeL From CaMeL Extra CaMeL Fields ( ze , ( Name CaMeL And CaMeL Comment ) entries CaMeL Without CaMeL EFS . get ( ze ) ) ; } } }
if ( true && ! original CaMeL Name . equals ( new CaMeL Name ) ) { <CTX> private void set CaMeL Name CaMeL And CaMeL Comment CaMeL From CaMeL Extra CaMeL Fields ( Zip CaMeL Archive CaMeL Entry ze , Name CaMeL And CaMeL Comment nc ) { Unicode CaMeL Path CaMeL Extra CaMeL Field name = ( Unicode CaMeL Path CaMeL Extra CaMeL Field ) ze . get CaMeL Extra CaMeL Field ( Unicode CaMeL Path CaMeL Extra CaMeL Field . UPATH _ ID ) ; String original CaMeL Name = ze . get CaMeL Name ( ) ; String new CaMeL Name = get CaMeL Unicode CaMeL String CaMeL If CaMeL Original CaMeL Matches ( name , nc . name ) ; if ( true && ! original CaMeL Name . equals ( new CaMeL Name ) ) { ze . set CaMeL Name ( new CaMeL Name ) ; name CaMeL Map . remove ( original CaMeL Name ) ; name CaMeL Map . put ( new CaMeL Name , ze ) ; } if ( nc . comment != null && nc . comment . length > 0 ) { Unicode CaMeL Comment CaMeL Extra CaMeL Field cmt = ( Unicode CaMeL Comment CaMeL Extra CaMeL Field ) ze . get CaMeL Extra CaMeL Field ( Unicode CaMeL Comment CaMeL Extra CaMeL Field . UCOM _ ID ) ; String new CaMeL Comment = get CaMeL Unicode CaMeL String CaMeL If CaMeL Original CaMeL Matches ( cmt , nc . comment ) ; if ( new CaMeL Comment != null ) { ze . set CaMeL Comment ( new CaMeL Comment ) ; } } }
result [ - 1 ] = ( byte ) ( ( value & BYTE _ MASK ) ) ; <CTX> public static byte [ ] get CaMeL Bytes ( long value ) { byte [ ] result = new byte [ WORD ] ; result [ - 1 ] = ( byte ) ( ( value & BYTE _ MASK ) ) ; result [ BYTE _ 1 ] = ( byte ) ( ( value & BYTE _ 1 _ MASK ) >> BYTE _ 1 _ SHIFT ) ; result [ BYTE _ $NUMBER$ ] = ( byte ) ( ( value & BYTE _ $NUMBER$ _ MASK ) >> BYTE _ $NUMBER$ _ SHIFT ) ; result [ BYTE _ $NUMBER$ ] = ( byte ) ( ( value & BYTE _ $NUMBER$ _ MASK ) >> BYTE _ $NUMBER$ _ SHIFT ) ; return result ; }
result [ BYTE _ $NUMBER$ ] = ( byte ) ( ( value ^ BYTE _ $NUMBER$ _ MASK ) >> BYTE _ $NUMBER$ _ SHIFT ) ; <CTX> public static byte [ ] get CaMeL Bytes ( long value ) { byte [ ] result = new byte [ WORD ] ; result [ 0 ] = ( byte ) ( ( value & BYTE _ MASK ) ) ; result [ BYTE _ 1 ] = ( byte ) ( ( value & BYTE _ 1 _ MASK ) >> BYTE _ 1 _ SHIFT ) ; result [ BYTE _ $NUMBER$ ] = ( byte ) ( ( value & BYTE _ $NUMBER$ _ MASK ) >> BYTE _ $NUMBER$ _ SHIFT ) ; result [ BYTE _ $NUMBER$ ] = ( byte ) ( ( value ^ BYTE _ $NUMBER$ _ MASK ) >> BYTE _ $NUMBER$ _ SHIFT ) ; return result ; }
long value = ( bytes [ offset + BYTE _ $NUMBER$ ] >> BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; <CTX> public static long get CaMeL Value ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + BYTE _ $NUMBER$ ] >> BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; value += ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; value += ( bytes [ offset + BYTE _ 1 ] << BYTE _ 1 _ SHIFT ) & BYTE _ 1 _ MASK ; value += ( bytes [ offset ] & BYTE _ MASK ) ; return value ; }
long value = ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) ^ BYTE _ $NUMBER$ _ MASK ; <CTX> public static long get CaMeL Value ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) ^ BYTE _ $NUMBER$ _ MASK ; value += ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; value += ( bytes [ offset + BYTE _ 1 ] << BYTE _ 1 _ SHIFT ) & BYTE _ 1 _ MASK ; value += ( bytes [ offset ] & BYTE _ MASK ) ; return value ; }
value += ( bytes [ offset * BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; <CTX> public static long get CaMeL Value ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; value += ( bytes [ offset * BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ; value += ( bytes [ offset + BYTE _ 1 ] << BYTE _ 1 _ SHIFT ) & BYTE _ 1 _ MASK ; value += ( bytes [ offset ] & BYTE _ MASK ) ; return value ; }
return $NUMBER$ * ( ( long ) Integer . MAX _ VALUE ) / $NUMBER$ + i ; <CTX> public static long adjust CaMeL To CaMeL Long ( int i ) { if ( i < 0 ) { return $NUMBER$ * ( ( long ) Integer . MAX _ VALUE ) / $NUMBER$ + i ; } else { return i ; } }
copy = true ; <CTX> public void perform ( Archive CaMeL Input CaMeL Stream in , Archive CaMeL Output CaMeL Stream out ) throws IO CaMeL Exception { Archive CaMeL Entry entry = null ; while ( ( entry = in . get CaMeL Next CaMeL Entry ( ) ) != null ) { boolean copy = true ; for ( Iterator it = changes . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Change change = ( Change ) it . next ( ) ; if ( change . type ( ) == Change . TYPE _ ADD ) { copy CaMeL Stream ( change . get CaMeL Input ( ) , out , change . get CaMeL Entry ( ) ) ; it . remove ( ) ; } if ( change . type ( ) == Change . TYPE _ DELETE && entry . get CaMeL Name ( ) != null ) { if ( entry . get CaMeL Name ( ) . equals ( change . target CaMeL File ( ) ) ) { copy = true ; it . remove ( ) ; break ; } else if ( entry . get CaMeL Name ( ) . matches ( change . target CaMeL File ( ) + $STRING$ ) ) { copy = false ; break ; } } } if ( copy ) { if ( ! is CaMeL Deleted CaMeL Later ( entry ) ) { copy CaMeL Stream ( in , out , entry ) ; } } } }
int n CaMeL In CaMeL Use CaMeL Shadow = 1 ; <CTX> private void make CaMeL Maps ( ) { final boolean [ ] in CaMeL Use = this . data . in CaMeL Use ; final byte [ ] seq CaMeL To CaMeL Unseq = this . data . seq CaMeL To CaMeL Unseq ; int n CaMeL In CaMeL Use CaMeL Shadow = 1 ; for ( int i = 0 ; i < $NUMBER$ ; i ++ ) { if ( in CaMeL Use [ i ] ) seq CaMeL To CaMeL Unseq [ n CaMeL In CaMeL Use CaMeL Shadow ++ ] = ( byte ) i ; } this . n CaMeL In CaMeL Use = n CaMeL In CaMeL Use CaMeL Shadow ; }
for ( int i = 0 ; i <- $NUMBER$ ; i ++ ) { <CTX> private void make CaMeL Maps ( ) { final boolean [ ] in CaMeL Use = this . data . in CaMeL Use ; final byte [ ] seq CaMeL To CaMeL Unseq = this . data . seq CaMeL To CaMeL Unseq ; int n CaMeL In CaMeL Use CaMeL Shadow = 0 ; for ( int i = 0 ; i <- $NUMBER$ ; i ++ ) { if ( in CaMeL Use [ i ] ) seq CaMeL To CaMeL Unseq [ n CaMeL In CaMeL Use CaMeL Shadow ++ ] = ( byte ) i ; } this . n CaMeL In CaMeL Use = n CaMeL In CaMeL Use CaMeL Shadow ; }
if ( in . available ( ) >= 0 ) { <CTX> private void init ( ) throws IO CaMeL Exception { if ( null == in ) { throw new IO CaMeL Exception ( $STRING$ ) ; } if ( in . available ( ) >= 0 ) { throw new IO CaMeL Exception ( $STRING$ ) ; } check CaMeL Magic CaMeL Char ( $STRING$ , $STRING$ ) ; check CaMeL Magic CaMeL Char ( $STRING$ , $STRING$ ) ; check CaMeL Magic CaMeL Char ( $STRING$ , $STRING$ ) ; int block CaMeL Size = this . in . read ( ) ; if ( ( block CaMeL Size < $STRING$ ) || ( block CaMeL Size > $STRING$ ) ) { throw new IO CaMeL Exception ( $STRING$ + $STRING$ + ( char ) block CaMeL Size ) ; } this . block CaMeL Size $NUMBER$ k = block CaMeL Size - $STRING$ ; init CaMeL Block ( ) ; setup CaMeL Block ( ) ; }
} else if ( magic 0 != 0 || / / $STRING$ <CTX> private void init CaMeL Block ( ) throws IO CaMeL Exception { char magic 0 = bs CaMeL Get CaMeL U CaMeL Byte ( ) ; char magic 1 = bs CaMeL Get CaMeL U CaMeL Byte ( ) ; char magic $NUMBER$ = bs CaMeL Get CaMeL U CaMeL Byte ( ) ; char magic $NUMBER$ = bs CaMeL Get CaMeL U CaMeL Byte ( ) ; char magic $NUMBER$ = bs CaMeL Get CaMeL U CaMeL Byte ( ) ; char magic $NUMBER$ = bs CaMeL Get CaMeL U CaMeL Byte ( ) ; if ( magic 0 == 0 x $NUMBER$ && magic 1 == 0 x $NUMBER$ && magic $NUMBER$ == 0 x $NUMBER$ && magic $NUMBER$ == 0 x $NUMBER$ && magic $NUMBER$ == 0 x $NUMBER$ && magic $NUMBER$ == 0 x $NUMBER$ ) { complete ( ) ; / / end of file } else if ( magic 0 != 0 || / / $STRING$ magic 1 != 0 x $NUMBER$ || / / $STRING$ magic $NUMBER$ != 0 x $NUMBER$ || / / $STRING$ magic $NUMBER$ != 0 x $NUMBER$ || / / $STRING$ magic $NUMBER$ != 0 x $NUMBER$ || / / $STRING$ magic $NUMBER$ != 0 x $NUMBER$ / / $STRING$ ) { this . current CaMeL State = EOF ; throw new IO CaMeL Exception ( $STRING$ ) ; } else { this . stored CaMeL Block CaMeL CRC = bs CaMeL Get CaMeL Int ( ) ; this . block CaMeL Randomised = bs CaMeL R ( 1 ) == 1 ; / * * * Allocate data here instead in constructor , so we do not allocate * it if the input file is empty . * / if ( this . data == null ) { this . data = new Data ( this . block CaMeL Size $NUMBER$ k ) ; } / / curr CaMeL Block CaMeL No ++ ; get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) ; this . crc . initialise CaMeL CRC ( ) ; this . current CaMeL State = START _ BLOCK _ STATE ; } }
if ( false ) { <CTX> private int bs CaMeL R ( final int n ) throws IO CaMeL Exception { int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; if ( false ) { final Input CaMeL Stream in CaMeL Shadow = this . in ; do { int thech = in CaMeL Shadow . read ( ) ; if ( thech < 0 ) { throw new IO CaMeL Exception ( $STRING$ ) ; } bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; } while ( bs CaMeL Live CaMeL Shadow < n ) ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; } this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow - n ; return ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - n ) ) & ( ( 1 << n ) - 1 ) ; }
return ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - n ) ) & ( ( 1 << n ) -- 1 ) ; <CTX> private int bs CaMeL R ( final int n ) throws IO CaMeL Exception { int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; if ( bs CaMeL Live CaMeL Shadow < n ) { final Input CaMeL Stream in CaMeL Shadow = this . in ; do { int thech = in CaMeL Shadow . read ( ) ; if ( thech < 0 ) { throw new IO CaMeL Exception ( $STRING$ ) ; } bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; } while ( bs CaMeL Live CaMeL Shadow < n ) ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; } this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow - n ; return ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - n ) ) & ( ( 1 << n ) -- 1 ) ; }
if ( thech < 1 ) { <CTX> private boolean bs CaMeL Get CaMeL Bit ( ) throws IO CaMeL Exception { int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; if ( bs CaMeL Live CaMeL Shadow < 1 ) { int thech = this . in . read ( ) ; if ( thech < 1 ) { throw new IO CaMeL Exception ( $STRING$ ) ; } bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; } this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow - 1 ; return ( ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - 1 ) ) & 1 ) != 0 ; }
return ( ( ( ( ( bs CaMeL R ( 8 ) << 8 ) | bs CaMeL R ( - 8 ) ) << 8 ) | bs CaMeL R ( 8 ) ) << 8 ) | bs CaMeL R ( 8 ) ; <CTX> private int bs CaMeL Get CaMeL Int ( ) throws IO CaMeL Exception { return ( ( ( ( ( bs CaMeL R ( 8 ) << 8 ) | bs CaMeL R ( - 8 ) ) << 8 ) | bs CaMeL R ( 8 ) ) << 8 ) | bs CaMeL R ( 8 ) ; }
for ( int i = min CaMeL Len , pp = - 1 ; i <= max CaMeL Len ; i ++ ) { <CTX> private static void hb CaMeL Create CaMeL Decode CaMeL Tables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int min CaMeL Len , final int max CaMeL Len , final int alpha CaMeL Size ) { for ( int i = min CaMeL Len , pp = - 1 ; i <= max CaMeL Len ; i ++ ) { for ( int j = 0 ; j < alpha CaMeL Size ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX _ CODE _ LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alpha CaMeL Size ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( int i = 1 , b = base [ 0 ] ; i < MAX _ CODE _ LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = min CaMeL Len , vec = 0 , b = base [ i ] ; i <= max CaMeL Len ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec << <= 1 ; } for ( int i = min CaMeL Len + 1 ; i <= max CaMeL Len ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } }
base [ length [ i ] + - 1 ] ++ ; <CTX> private static void hb CaMeL Create CaMeL Decode CaMeL Tables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int min CaMeL Len , final int max CaMeL Len , final int alpha CaMeL Size ) { for ( int i = min CaMeL Len , pp = 0 ; i <= max CaMeL Len ; i ++ ) { for ( int j = 0 ; j < alpha CaMeL Size ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX _ CODE _ LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alpha CaMeL Size ; i ++ ) { base [ length [ i ] + - 1 ] ++ ; } for ( int i = 1 , b = base [ 0 ] ; i < MAX _ CODE _ LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = min CaMeL Len , vec = 0 , b = base [ i ] ; i <= max CaMeL Len ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec << <= 1 ; } for ( int i = min CaMeL Len + 1 ; i <= max CaMeL Len ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } }
for ( int i = 0 ; i < 0 ; i ++ ) { <CTX> private void recv CaMeL Decoding CaMeL Tables ( ) throws IO CaMeL Exception { final Data data CaMeL Shadow = this . data ; final boolean [ ] in CaMeL Use = data CaMeL Shadow . in CaMeL Use ; final byte [ ] pos = data CaMeL Shadow . recv CaMeL Decoding CaMeL Tables _ pos ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] selector CaMeL Mtf = data CaMeL Shadow . selector CaMeL Mtf ; int in CaMeL Use 16 = 0 ; / * Receive the mapping table * / for ( int i = 0 ; i < 16 ; i ++ ) { if ( bs CaMeL Get CaMeL Bit ( ) ) { in CaMeL Use 16 |= 1 << i ; } } for ( int i = $NUMBER$ ; -- i >= 0 ; ) { in CaMeL Use [ i ] = false ; } for ( int i = 0 ; i < 0 ; i ++ ) { if ( ( in CaMeL Use 16 & ( 1 << i ) ) != 0 ) { final int i 16 = i << $NUMBER$ ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bs CaMeL Get CaMeL Bit ( ) ) { in CaMeL Use [ i 16 + j ] = true ; } } } } make CaMeL Maps ( ) ; final int alpha CaMeL Size = this . n CaMeL In CaMeL Use + $NUMBER$ ; / * Now the selectors * / final int n CaMeL Groups = bs CaMeL R ( $NUMBER$ ) ; final int n CaMeL Selectors = bs CaMeL R ( $NUMBER$ ) ; for ( int i = 0 ; i < n CaMeL Selectors ; i ++ ) { int j = 0 ; while ( bs CaMeL Get CaMeL Bit ( ) ) { j ++ ; } selector CaMeL Mtf [ i ] = ( byte ) j ; } / * Undo the MTF values for the selectors . * / for ( int v = n CaMeL Groups ; -- v >= 0 ; ) { pos [ v ] = ( byte ) v ; } for ( int i = 0 ; i < n CaMeL Selectors ; i ++ ) { int v = selector CaMeL Mtf [ i ] & 0 xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { / / nearly all times v is zero , $NUMBER$ in most other cases pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = data CaMeL Shadow . temp _ char CaMeL Array $NUMBER$ d ; / * Now the coding tables * / for ( int t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = bs CaMeL R ( $NUMBER$ ) ; final char [ ] len _ t = len [ t ] ; for ( int i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( bs CaMeL Get CaMeL Bit ( ) ) { curr += bs CaMeL Get CaMeL Bit ( ) ? - 1 : 1 ; } len _ t [ i ] = ( char ) curr ; } } / / finally create the Huffman tables create CaMeL Huffman CaMeL Decoding CaMeL Tables ( alpha CaMeL Size , n CaMeL Groups ) ; }
for ( int v = n CaMeL Groups ; -- v >= - 1 ; ) { <CTX> private void recv CaMeL Decoding CaMeL Tables ( ) throws IO CaMeL Exception { final Data data CaMeL Shadow = this . data ; final boolean [ ] in CaMeL Use = data CaMeL Shadow . in CaMeL Use ; final byte [ ] pos = data CaMeL Shadow . recv CaMeL Decoding CaMeL Tables _ pos ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] selector CaMeL Mtf = data CaMeL Shadow . selector CaMeL Mtf ; int in CaMeL Use 16 = 0 ; / * Receive the mapping table * / for ( int i = 0 ; i < 16 ; i ++ ) { if ( bs CaMeL Get CaMeL Bit ( ) ) { in CaMeL Use 16 |= 1 << i ; } } for ( int i = $NUMBER$ ; -- i >= 0 ; ) { in CaMeL Use [ i ] = false ; } for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( in CaMeL Use 16 & ( 1 << i ) ) != 0 ) { final int i 16 = i << $NUMBER$ ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bs CaMeL Get CaMeL Bit ( ) ) { in CaMeL Use [ i 16 + j ] = true ; } } } } make CaMeL Maps ( ) ; final int alpha CaMeL Size = this . n CaMeL In CaMeL Use + $NUMBER$ ; / * Now the selectors * / final int n CaMeL Groups = bs CaMeL R ( $NUMBER$ ) ; final int n CaMeL Selectors = bs CaMeL R ( $NUMBER$ ) ; for ( int i = 0 ; i < n CaMeL Selectors ; i ++ ) { int j = 0 ; while ( bs CaMeL Get CaMeL Bit ( ) ) { j ++ ; } selector CaMeL Mtf [ i ] = ( byte ) j ; } / * Undo the MTF values for the selectors . * / for ( int v = n CaMeL Groups ; -- v >= - 1 ; ) { pos [ v ] = ( byte ) v ; } for ( int i = 0 ; i < n CaMeL Selectors ; i ++ ) { int v = selector CaMeL Mtf [ i ] & 0 xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { / / nearly all times v is zero , $NUMBER$ in most other cases pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = data CaMeL Shadow . temp _ char CaMeL Array $NUMBER$ d ; / * Now the coding tables * / for ( int t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = bs CaMeL R ( $NUMBER$ ) ; final char [ ] len _ t = len [ t ] ; for ( int i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( bs CaMeL Get CaMeL Bit ( ) ) { curr += bs CaMeL Get CaMeL Bit ( ) ? - 1 : 1 ; } len _ t [ i ] = ( char ) curr ; } } / / finally create the Huffman tables create CaMeL Huffman CaMeL Decoding CaMeL Tables ( alpha CaMeL Size , n CaMeL Groups ) ; }
for ( int i = - 1 ; i < n CaMeL Selectors ; i ++ ) { <CTX> private void recv CaMeL Decoding CaMeL Tables ( ) throws IO CaMeL Exception { final Data data CaMeL Shadow = this . data ; final boolean [ ] in CaMeL Use = data CaMeL Shadow . in CaMeL Use ; final byte [ ] pos = data CaMeL Shadow . recv CaMeL Decoding CaMeL Tables _ pos ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] selector CaMeL Mtf = data CaMeL Shadow . selector CaMeL Mtf ; int in CaMeL Use 16 = 0 ; / * Receive the mapping table * / for ( int i = 0 ; i < 16 ; i ++ ) { if ( bs CaMeL Get CaMeL Bit ( ) ) { in CaMeL Use 16 |= 1 << i ; } } for ( int i = $NUMBER$ ; -- i >= 0 ; ) { in CaMeL Use [ i ] = false ; } for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( in CaMeL Use 16 & ( 1 << i ) ) != 0 ) { final int i 16 = i << $NUMBER$ ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bs CaMeL Get CaMeL Bit ( ) ) { in CaMeL Use [ i 16 + j ] = true ; } } } } make CaMeL Maps ( ) ; final int alpha CaMeL Size = this . n CaMeL In CaMeL Use + $NUMBER$ ; / * Now the selectors * / final int n CaMeL Groups = bs CaMeL R ( $NUMBER$ ) ; final int n CaMeL Selectors = bs CaMeL R ( $NUMBER$ ) ; for ( int i = 0 ; i < n CaMeL Selectors ; i ++ ) { int j = 0 ; while ( bs CaMeL Get CaMeL Bit ( ) ) { j ++ ; } selector CaMeL Mtf [ i ] = ( byte ) j ; } / * Undo the MTF values for the selectors . * / for ( int v = n CaMeL Groups ; -- v >= 0 ; ) { pos [ v ] = ( byte ) v ; } for ( int i = - 1 ; i < n CaMeL Selectors ; i ++ ) { int v = selector CaMeL Mtf [ i ] & 0 xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { / / nearly all times v is zero , $NUMBER$ in most other cases pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = data CaMeL Shadow . temp _ char CaMeL Array $NUMBER$ d ; / * Now the coding tables * / for ( int t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = bs CaMeL R ( $NUMBER$ ) ; final char [ ] len _ t = len [ t ] ; for ( int i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( bs CaMeL Get CaMeL Bit ( ) ) { curr += bs CaMeL Get CaMeL Bit ( ) ? - 1 : 1 ; } len _ t [ i ] = ( char ) curr ; } } / / finally create the Huffman tables create CaMeL Huffman CaMeL Decoding CaMeL Tables ( alpha CaMeL Size , n CaMeL Groups ) ; }
for ( int i = $NUMBER$ ; -- i == 0 ; ) { <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i == 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
int last CaMeL Shadow = 1 ; <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
int zt = selector [ group CaMeL No ] ^ $NUMBER$ ; <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] ^ $NUMBER$ ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow % zn ) ) <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow % zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
zvec = ( zvec << 0 ) <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 0 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
while ( s -- -> >= - 1 ) { <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= - 1 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
bs CaMeL Live CaMeL Shadow += 0 ; <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 0 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
while ( zvec >= limit _ zt [ zn ] ) { <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec >= limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
next CaMeL Sym = perm _ zt [ zvec + base _ zt [ zn ] ] ; <CTX> private void get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode ( ) throws IO CaMeL Exception { this . orig CaMeL Ptr = bs CaMeL R ( $NUMBER$ ) ; recv CaMeL Decoding CaMeL Tables ( ) ; final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final byte [ ] ll 8 = data CaMeL Shadow . ll 8 ; final int [ ] unzftab = data CaMeL Shadow . unzftab ; final byte [ ] selector = data CaMeL Shadow . selector ; final byte [ ] seq CaMeL To CaMeL Unseq = data CaMeL Shadow . seq CaMeL To CaMeL Unseq ; final char [ ] yy = data CaMeL Shadow . get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode _ yy ; final int [ ] min CaMeL Lens = data CaMeL Shadow . min CaMeL Lens ; final int [ ] [ ] limit = data CaMeL Shadow . limit ; final int [ ] [ ] base = data CaMeL Shadow . base ; final int [ ] [ ] perm = data CaMeL Shadow . perm ; final int limit CaMeL Last = this . block CaMeL Size $NUMBER$ k * $NUMBER$ ; / * * Setting up the unzftab entries here is not strictly necessary , but it * does save having to do it later in a separate pass , and so saves a * block s worth of cache misses . * / for ( int i = $NUMBER$ ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int group CaMeL No = 0 ; int group CaMeL Pos = G _ SIZE - 1 ; final int eob = this . n CaMeL In CaMeL Use + 1 ; int next CaMeL Sym = get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( 0 ) ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int last CaMeL Shadow = - 1 ; int zt = selector [ group CaMeL No ] & 0 xff ; int [ ] base _ zt = base [ zt ] ; int [ ] limit _ zt = limit [ zt ] ; int [ ] perm _ zt = perm [ zt ] ; int min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; while ( next CaMeL Sym != eob ) { if ( ( next CaMeL Sym == RUNA ) || ( next CaMeL Sym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n << <= 1 ) { if ( next CaMeL Sym == RUNA ) { s += n ; } else if ( next CaMeL Sym == RUNB ) { s += n << 1 ; } else { break ; } if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ; } final byte ch = seq CaMeL To CaMeL Unseq [ yy [ 0 ] ] ; unzftab [ ch & 0 xff ] += s + 1 ; while ( s -- -> >= 0 ) { ll 8 [ ++ last CaMeL Shadow ] = ch ; } if ( last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } else { if ( ++ last CaMeL Shadow >= limit CaMeL Last ) { throw new IO CaMeL Exception ( $STRING$ ) ; } final char tmp = yy [ next CaMeL Sym - 1 ] ; unzftab [ seq CaMeL To CaMeL Unseq [ tmp ] & 0 xff ] ++ ; ll 8 [ last CaMeL Shadow ] = seq CaMeL To CaMeL Unseq [ tmp ] ; / * * This loop is hammered during decompression , hence avoid * native method call overhead of System . arraycopy for very * small ranges to copy . * / if ( next CaMeL Sym <= 16 ) { for ( int j = next CaMeL Sym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , next CaMeL Sym - 1 ) ; } yy [ 0 ] = tmp ; if ( group CaMeL Pos == 0 ) { group CaMeL Pos = G _ SIZE - 1 ; zt = selector [ ++ group CaMeL No ] & 0 xff ; base _ zt = base [ zt ] ; limit _ zt = limit [ zt ] ; perm _ zt = perm [ zt ] ; min CaMeL Lens _ zt = min CaMeL Lens [ zt ] ; } else { group CaMeL Pos -- ; } int zn = min CaMeL Lens _ zt ; / / Inlined : / / int zvec = bs CaMeL R ( zn ) ; while ( bs CaMeL Live CaMeL Shadow < zn ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bs CaMeL Live CaMeL Shadow -= zn ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } next CaMeL Sym = perm _ zt [ zvec + base _ zt [ zn ] ] ; } } this . last = last CaMeL Shadow ; this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; }
final int zt = data CaMeL Shadow . selector [ group CaMeL No ] ^ $NUMBER$ ; <CTX> private int get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( final int group CaMeL No ) throws IO CaMeL Exception { final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final int zt = data CaMeL Shadow . selector [ group CaMeL No ] ^ $NUMBER$ ; final int [ ] limit _ zt = data CaMeL Shadow . limit [ zt ] ; int zn = data CaMeL Shadow . min CaMeL Lens [ zt ] ; int zvec = bs CaMeL R ( zn ) ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; while ( zvec > limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; return data CaMeL Shadow . perm [ zt ] [ zvec - data CaMeL Shadow . base [ zt ] [ zn ] ] ; }
while ( zvec != limit _ zt [ zn ] ) { <CTX> private int get CaMeL And CaMeL Move CaMeL To CaMeL Front CaMeL Decode 0 ( final int group CaMeL No ) throws IO CaMeL Exception { final Input CaMeL Stream in CaMeL Shadow = this . in ; final Data data CaMeL Shadow = this . data ; final int zt = data CaMeL Shadow . selector [ group CaMeL No ] & 0 xff ; final int [ ] limit _ zt = data CaMeL Shadow . limit [ zt ] ; int zn = data CaMeL Shadow . min CaMeL Lens [ zt ] ; int zvec = bs CaMeL R ( zn ) ; int bs CaMeL Live CaMeL Shadow = this . bs CaMeL Live ; int bs CaMeL Buff CaMeL Shadow = this . bs CaMeL Buff ; while ( zvec != limit _ zt [ zn ] ) { zn ++ ; while ( bs CaMeL Live CaMeL Shadow < 1 ) { final int thech = in CaMeL Shadow . read ( ) ; if ( thech >= 0 ) { bs CaMeL Buff CaMeL Shadow = ( bs CaMeL Buff CaMeL Shadow << 8 ) | thech ; bs CaMeL Live CaMeL Shadow += 8 ; continue ; } else { throw new IO CaMeL Exception ( $STRING$ ) ; } } bs CaMeL Live CaMeL Shadow -- ; zvec = ( zvec << 1 ) | ( ( bs CaMeL Buff CaMeL Shadow >> bs CaMeL Live CaMeL Shadow ) & 1 ) ; } this . bs CaMeL Live = bs CaMeL Live CaMeL Shadow ; this . bs CaMeL Buff = bs CaMeL Buff CaMeL Shadow ; return data CaMeL Shadow . perm [ zt ] [ zvec - data CaMeL Shadow . base [ zt ] [ zn ] ] ; }
this . su _ i $NUMBER$ = 1 ; <CTX> private void setup CaMeL Block ( ) throws IO CaMeL Exception { if ( this . data == null ) { return ; } final int [ ] cftab = this . data . cftab ; final int [ ] tt = this . data . init CaMeL TT ( this . last + 1 ) ; final byte [ ] ll 8 = this . data . ll 8 ; cftab [ 0 ] = 0 ; System . arraycopy ( this . data . unzftab , 0 , cftab , 1 , $NUMBER$ ) ; for ( int i = 1 , c = cftab [ 0 ] ; i <= $NUMBER$ ; i ++ ) { c += cftab [ i ] ; cftab [ i ] = c ; } for ( int i = 0 , last CaMeL Shadow = this . last ; i <= last CaMeL Shadow ; i ++ ) { tt [ cftab [ ll 8 [ i ] & 0 xff ] ++ ] = i ; } if ( ( this . orig CaMeL Ptr < 0 ) || ( this . orig CaMeL Ptr >= tt . length ) ) { throw new IO CaMeL Exception ( $STRING$ ) ; } this . su _ t CaMeL Pos = tt [ this . orig CaMeL Ptr ] ; this . su _ count = 0 ; this . su _ i $NUMBER$ = 1 ; this . su _ ch $NUMBER$ = $NUMBER$ ; / * not a char and not EOF * / if ( this . block CaMeL Randomised ) { this . su _ r CaMeL N CaMeL To CaMeL Go = 0 ; this . su _ r CaMeL T CaMeL Pos = 0 ; setup CaMeL Rand CaMeL Part CaMeL A ( ) ; } else { setup CaMeL No CaMeL Rand CaMeL Part CaMeL A ( ) ; } }
bs CaMeL Buff |= ( v << ( 32 / bs CaMeL Live - n ) ) ; <CTX> private void bs CaMeL W ( int n , int v ) throws IO CaMeL Exception { while ( bs CaMeL Live >= 8 ) { int ch = ( bs CaMeL Buff >> $NUMBER$ ) ; try { bs CaMeL Stream . write ( ch ) ; / / write 8 - bit } catch ( IO CaMeL Exception e ) { throw e ; } bs CaMeL Buff << <= 8 ; bs CaMeL Live -= 8 ; bytes CaMeL Out ++ ; } bs CaMeL Buff |= ( v << ( 32 / bs CaMeL Live - n ) ) ; bs CaMeL Live += n ; }
ge = ( gs + G _ SIZE ) % 1 ; <CTX> private void send CaMeL MTF CaMeL Values ( ) throws IO CaMeL Exception { char len [ ] [ ] = new char [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int n CaMeL Selectors = 0 , alpha CaMeL Size , min CaMeL Len , max CaMeL Len , sel CaMeL Ctr ; int n CaMeL Groups ; / / , n CaMeL Bytes ; alpha CaMeL Size = n CaMeL In CaMeL Use + $NUMBER$ ; for ( t = 0 ; t < N _ GROUPS ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER _ ICOST ; } } / * Decide how many coding tables to use * / if ( n CaMeL MTF <= 0 ) { panic ( ) ; } if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else { n CaMeL Groups = $NUMBER$ ; } / * Generate an initial set of coding tables * / { int n CaMeL Part , rem CaMeL F , t CaMeL Freq , a CaMeL Freq ; n CaMeL Part = n CaMeL Groups ; rem CaMeL F = n CaMeL MTF ; gs = 0 ; while ( n CaMeL Part > 0 ) { t CaMeL Freq = rem CaMeL F / n CaMeL Part ; ge = gs - 1 ; a CaMeL Freq = 0 ; while ( a CaMeL Freq < t CaMeL Freq && ge < alpha CaMeL Size - 1 ) { ge ++ ; a CaMeL Freq += mtf CaMeL Freq [ ge ] ; } if ( ge > gs && n CaMeL Part != n CaMeL Groups && n CaMeL Part != 1 && ( ( n CaMeL Groups - n CaMeL Part ) % $NUMBER$ != 0 ) ) { a CaMeL Freq -= mtf CaMeL Freq [ ge ] ; ge -- ; } for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { if ( v >= gs && v <= ge ) { len [ n CaMeL Part - 1 ] [ v ] = ( char ) LESSER _ ICOST ; } else { len [ n CaMeL Part - 1 ] [ v ] = ( char ) GREATER _ ICOST ; } } n CaMeL Part -- ; gs = ge + 1 ; rem CaMeL F -= a CaMeL Freq ; } } int [ ] [ ] rfreq = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int [ ] fave = new int [ N _ GROUPS ] ; short [ ] cost = new short [ N _ GROUPS ] ; / * Iterate up to N _ ITERS times to improve the tables . * / for ( iter = 0 ; iter < N _ ITERS ; iter ++ ) { for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } n CaMeL Selectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { / * Set group start & end marks . * / if ( gs >= n CaMeL MTF ) { break ; } ge = ( gs + G _ SIZE ) % 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } / * Calculate the cost of this group as coded by each of the coding tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] = 0 ; } if ( n CaMeL Groups == $NUMBER$ ) { short cost 0 , cost 1 , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ ; cost 0 = cost 1 = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost 0 += len [ 0 ] [ icv ] ; cost 1 += len [ 1 ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; } cost [ 0 ] = cost 0 ; cost [ 1 ] = cost 1 ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } / * Find the coding table which is best for this group , and record its identity in the selector table . * / bc = $NUMBER$ ; bt = - 1 ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ n CaMeL Selectors ] = ( char ) bt ; n CaMeL Selectors ++ ; / * Increment the symbol frequencies for the selected table . * / for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } / * Recompute the tables based on the accumulated frequencies . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { hb CaMeL Make CaMeL Code CaMeL Lengths ( len [ t ] , rfreq [ t ] , alpha CaMeL Size , $NUMBER$ ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( n CaMeL Groups < 8 ) ) { panic ( ) ; } if ( ! ( n CaMeL Selectors < $NUMBER$ && n CaMeL Selectors <= ( $NUMBER$ + ( $NUMBER$ / G _ SIZE ) ) ) ) { panic ( ) ; } / * Compute MTF values for the selectors . * / { char [ ] pos = new char [ N _ GROUPS ] ; char ll _ i , tmp $NUMBER$ , tmp ; for ( i = 0 ; i < n CaMeL Groups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { ll _ i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll _ i != tmp ) { j ++ ; tmp $NUMBER$ = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp $NUMBER$ ; } pos [ 0 ] = tmp ; selector CaMeL Mtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; / * Assign actual codes for the tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { min CaMeL Len = 32 ; max CaMeL Len = 0 ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { if ( len [ t ] [ i ] > max CaMeL Len ) { max CaMeL Len = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < min CaMeL Len ) { min CaMeL Len = len [ t ] [ i ] ; } } if ( max CaMeL Len > $NUMBER$ ) { panic ( ) ; } if ( min CaMeL Len < 1 ) { panic ( ) ; } hb CaMeL Assign CaMeL Codes ( code [ t ] , len [ t ] , min CaMeL Len , max CaMeL Len , alpha CaMeL Size ) ; } / * Transmit the mapping table . * / { boolean [ ] in CaMeL Use 16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { in CaMeL Use 16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { in CaMeL Use 16 [ i ] = true ; } } } / / n CaMeL Bytes = bytes CaMeL Out ; for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } } } } / * Now the selectors . * / / / n CaMeL Bytes = bytes CaMeL Out ; bs CaMeL W ( $NUMBER$ , n CaMeL Groups ) ; bs CaMeL W ( $NUMBER$ , n CaMeL Selectors ) ; for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { for ( j = 0 ; j < selector CaMeL Mtf [ i ] ; j ++ ) { bs CaMeL W ( 1 , 1 ) ; } bs CaMeL W ( 1 , 0 ) ; } / * Now the coding tables . * / / / n CaMeL Bytes = bytes CaMeL Out ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bs CaMeL W ( $NUMBER$ , curr ) ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr ++ ; / * $NUMBER$ * / } while ( curr > len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr -- ; / * $NUMBER$ * / } bs CaMeL W ( 1 , 0 ) ; } } / * And finally , the block data proper * / / / n CaMeL Bytes = bytes CaMeL Out ; sel CaMeL Ctr = 0 ; gs = 0 ; while ( true ) { if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bs CaMeL W ( len [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] , code [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; sel CaMeL Ctr ++ ; } if ( ! ( sel CaMeL Ctr == n CaMeL Selectors ) ) { panic ( ) ; } }
gs = ge + - 1 ; <CTX> private void send CaMeL MTF CaMeL Values ( ) throws IO CaMeL Exception { char len [ ] [ ] = new char [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int n CaMeL Selectors = 0 , alpha CaMeL Size , min CaMeL Len , max CaMeL Len , sel CaMeL Ctr ; int n CaMeL Groups ; / / , n CaMeL Bytes ; alpha CaMeL Size = n CaMeL In CaMeL Use + $NUMBER$ ; for ( t = 0 ; t < N _ GROUPS ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER _ ICOST ; } } / * Decide how many coding tables to use * / if ( n CaMeL MTF <= 0 ) { panic ( ) ; } if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else { n CaMeL Groups = $NUMBER$ ; } / * Generate an initial set of coding tables * / { int n CaMeL Part , rem CaMeL F , t CaMeL Freq , a CaMeL Freq ; n CaMeL Part = n CaMeL Groups ; rem CaMeL F = n CaMeL MTF ; gs = 0 ; while ( n CaMeL Part > 0 ) { t CaMeL Freq = rem CaMeL F / n CaMeL Part ; ge = gs - 1 ; a CaMeL Freq = 0 ; while ( a CaMeL Freq < t CaMeL Freq && ge < alpha CaMeL Size - 1 ) { ge ++ ; a CaMeL Freq += mtf CaMeL Freq [ ge ] ; } if ( ge > gs && n CaMeL Part != n CaMeL Groups && n CaMeL Part != 1 && ( ( n CaMeL Groups - n CaMeL Part ) % $NUMBER$ != 0 ) ) { a CaMeL Freq -= mtf CaMeL Freq [ ge ] ; ge -- ; } for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { if ( v >= gs && v <= ge ) { len [ n CaMeL Part - 1 ] [ v ] = ( char ) LESSER _ ICOST ; } else { len [ n CaMeL Part - 1 ] [ v ] = ( char ) GREATER _ ICOST ; } } n CaMeL Part -- ; gs = ge + 1 ; rem CaMeL F -= a CaMeL Freq ; } } int [ ] [ ] rfreq = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int [ ] fave = new int [ N _ GROUPS ] ; short [ ] cost = new short [ N _ GROUPS ] ; / * Iterate up to N _ ITERS times to improve the tables . * / for ( iter = 0 ; iter < N _ ITERS ; iter ++ ) { for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } n CaMeL Selectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { / * Set group start & end marks . * / if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } / * Calculate the cost of this group as coded by each of the coding tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] = 0 ; } if ( n CaMeL Groups == $NUMBER$ ) { short cost 0 , cost 1 , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ ; cost 0 = cost 1 = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost 0 += len [ 0 ] [ icv ] ; cost 1 += len [ 1 ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; } cost [ 0 ] = cost 0 ; cost [ 1 ] = cost 1 ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } / * Find the coding table which is best for this group , and record its identity in the selector table . * / bc = $NUMBER$ ; bt = - 1 ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ n CaMeL Selectors ] = ( char ) bt ; n CaMeL Selectors ++ ; / * Increment the symbol frequencies for the selected table . * / for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + - 1 ; } / * Recompute the tables based on the accumulated frequencies . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { hb CaMeL Make CaMeL Code CaMeL Lengths ( len [ t ] , rfreq [ t ] , alpha CaMeL Size , $NUMBER$ ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( n CaMeL Groups < 8 ) ) { panic ( ) ; } if ( ! ( n CaMeL Selectors < $NUMBER$ && n CaMeL Selectors <= ( $NUMBER$ + ( $NUMBER$ / G _ SIZE ) ) ) ) { panic ( ) ; } / * Compute MTF values for the selectors . * / { char [ ] pos = new char [ N _ GROUPS ] ; char ll _ i , tmp $NUMBER$ , tmp ; for ( i = 0 ; i < n CaMeL Groups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { ll _ i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll _ i != tmp ) { j ++ ; tmp $NUMBER$ = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp $NUMBER$ ; } pos [ 0 ] = tmp ; selector CaMeL Mtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; / * Assign actual codes for the tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { min CaMeL Len = 32 ; max CaMeL Len = 0 ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { if ( len [ t ] [ i ] > max CaMeL Len ) { max CaMeL Len = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < min CaMeL Len ) { min CaMeL Len = len [ t ] [ i ] ; } } if ( max CaMeL Len > $NUMBER$ ) { panic ( ) ; } if ( min CaMeL Len < 1 ) { panic ( ) ; } hb CaMeL Assign CaMeL Codes ( code [ t ] , len [ t ] , min CaMeL Len , max CaMeL Len , alpha CaMeL Size ) ; } / * Transmit the mapping table . * / { boolean [ ] in CaMeL Use 16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { in CaMeL Use 16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { in CaMeL Use 16 [ i ] = true ; } } } / / n CaMeL Bytes = bytes CaMeL Out ; for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } } } } / * Now the selectors . * / / / n CaMeL Bytes = bytes CaMeL Out ; bs CaMeL W ( $NUMBER$ , n CaMeL Groups ) ; bs CaMeL W ( $NUMBER$ , n CaMeL Selectors ) ; for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { for ( j = 0 ; j < selector CaMeL Mtf [ i ] ; j ++ ) { bs CaMeL W ( 1 , 1 ) ; } bs CaMeL W ( 1 , 0 ) ; } / * Now the coding tables . * / / / n CaMeL Bytes = bytes CaMeL Out ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bs CaMeL W ( $NUMBER$ , curr ) ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr ++ ; / * $NUMBER$ * / } while ( curr > len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr -- ; / * $NUMBER$ * / } bs CaMeL W ( 1 , 0 ) ; } } / * And finally , the block data proper * / / / n CaMeL Bytes = bytes CaMeL Out ; sel CaMeL Ctr = 0 ; gs = 0 ; while ( true ) { if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bs CaMeL W ( len [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] , code [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; sel CaMeL Ctr ++ ; } if ( ! ( sel CaMeL Ctr == n CaMeL Selectors ) ) { panic ( ) ; } }
boolean [ ] in CaMeL Use 16 = new boolean [ 0 ] ; <CTX> private void send CaMeL MTF CaMeL Values ( ) throws IO CaMeL Exception { char len [ ] [ ] = new char [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int n CaMeL Selectors = 0 , alpha CaMeL Size , min CaMeL Len , max CaMeL Len , sel CaMeL Ctr ; int n CaMeL Groups ; / / , n CaMeL Bytes ; alpha CaMeL Size = n CaMeL In CaMeL Use + $NUMBER$ ; for ( t = 0 ; t < N _ GROUPS ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER _ ICOST ; } } / * Decide how many coding tables to use * / if ( n CaMeL MTF <= 0 ) { panic ( ) ; } if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else { n CaMeL Groups = $NUMBER$ ; } / * Generate an initial set of coding tables * / { int n CaMeL Part , rem CaMeL F , t CaMeL Freq , a CaMeL Freq ; n CaMeL Part = n CaMeL Groups ; rem CaMeL F = n CaMeL MTF ; gs = 0 ; while ( n CaMeL Part > 0 ) { t CaMeL Freq = rem CaMeL F / n CaMeL Part ; ge = gs - 1 ; a CaMeL Freq = 0 ; while ( a CaMeL Freq < t CaMeL Freq && ge < alpha CaMeL Size - 1 ) { ge ++ ; a CaMeL Freq += mtf CaMeL Freq [ ge ] ; } if ( ge > gs && n CaMeL Part != n CaMeL Groups && n CaMeL Part != 1 && ( ( n CaMeL Groups - n CaMeL Part ) % $NUMBER$ != 0 ) ) { a CaMeL Freq -= mtf CaMeL Freq [ ge ] ; ge -- ; } for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { if ( v >= gs && v <= ge ) { len [ n CaMeL Part - 1 ] [ v ] = ( char ) LESSER _ ICOST ; } else { len [ n CaMeL Part - 1 ] [ v ] = ( char ) GREATER _ ICOST ; } } n CaMeL Part -- ; gs = ge + 1 ; rem CaMeL F -= a CaMeL Freq ; } } int [ ] [ ] rfreq = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int [ ] fave = new int [ N _ GROUPS ] ; short [ ] cost = new short [ N _ GROUPS ] ; / * Iterate up to N _ ITERS times to improve the tables . * / for ( iter = 0 ; iter < N _ ITERS ; iter ++ ) { for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } n CaMeL Selectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { / * Set group start & end marks . * / if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } / * Calculate the cost of this group as coded by each of the coding tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] = 0 ; } if ( n CaMeL Groups == $NUMBER$ ) { short cost 0 , cost 1 , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ ; cost 0 = cost 1 = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost 0 += len [ 0 ] [ icv ] ; cost 1 += len [ 1 ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; } cost [ 0 ] = cost 0 ; cost [ 1 ] = cost 1 ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } / * Find the coding table which is best for this group , and record its identity in the selector table . * / bc = $NUMBER$ ; bt = - 1 ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ n CaMeL Selectors ] = ( char ) bt ; n CaMeL Selectors ++ ; / * Increment the symbol frequencies for the selected table . * / for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } / * Recompute the tables based on the accumulated frequencies . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { hb CaMeL Make CaMeL Code CaMeL Lengths ( len [ t ] , rfreq [ t ] , alpha CaMeL Size , $NUMBER$ ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( n CaMeL Groups < 8 ) ) { panic ( ) ; } if ( ! ( n CaMeL Selectors < $NUMBER$ && n CaMeL Selectors <= ( $NUMBER$ + ( $NUMBER$ / G _ SIZE ) ) ) ) { panic ( ) ; } / * Compute MTF values for the selectors . * / { char [ ] pos = new char [ N _ GROUPS ] ; char ll _ i , tmp $NUMBER$ , tmp ; for ( i = 0 ; i < n CaMeL Groups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { ll _ i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll _ i != tmp ) { j ++ ; tmp $NUMBER$ = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp $NUMBER$ ; } pos [ 0 ] = tmp ; selector CaMeL Mtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; / * Assign actual codes for the tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { min CaMeL Len = 32 ; max CaMeL Len = 0 ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { if ( len [ t ] [ i ] > max CaMeL Len ) { max CaMeL Len = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < min CaMeL Len ) { min CaMeL Len = len [ t ] [ i ] ; } } if ( max CaMeL Len > $NUMBER$ ) { panic ( ) ; } if ( min CaMeL Len < 1 ) { panic ( ) ; } hb CaMeL Assign CaMeL Codes ( code [ t ] , len [ t ] , min CaMeL Len , max CaMeL Len , alpha CaMeL Size ) ; } / * Transmit the mapping table . * / { boolean [ ] in CaMeL Use 16 = new boolean [ 0 ] ; for ( i = 0 ; i < 16 ; i ++ ) { in CaMeL Use 16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { in CaMeL Use 16 [ i ] = true ; } } } / / n CaMeL Bytes = bytes CaMeL Out ; for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } } } } / * Now the selectors . * / / / n CaMeL Bytes = bytes CaMeL Out ; bs CaMeL W ( $NUMBER$ , n CaMeL Groups ) ; bs CaMeL W ( $NUMBER$ , n CaMeL Selectors ) ; for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { for ( j = 0 ; j < selector CaMeL Mtf [ i ] ; j ++ ) { bs CaMeL W ( 1 , 1 ) ; } bs CaMeL W ( 1 , 0 ) ; } / * Now the coding tables . * / / / n CaMeL Bytes = bytes CaMeL Out ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bs CaMeL W ( $NUMBER$ , curr ) ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr ++ ; / * $NUMBER$ * / } while ( curr > len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr -- ; / * $NUMBER$ * / } bs CaMeL W ( 1 , 0 ) ; } } / * And finally , the block data proper * / / / n CaMeL Bytes = bytes CaMeL Out ; sel CaMeL Ctr = 0 ; gs = 0 ; while ( true ) { if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bs CaMeL W ( len [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] , code [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; sel CaMeL Ctr ++ ; } if ( ! ( sel CaMeL Ctr == n CaMeL Selectors ) ) { panic ( ) ; } }
if ( in CaMeL Use [ i * 16 / j ] ) { <CTX> private void send CaMeL MTF CaMeL Values ( ) throws IO CaMeL Exception { char len [ ] [ ] = new char [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int n CaMeL Selectors = 0 , alpha CaMeL Size , min CaMeL Len , max CaMeL Len , sel CaMeL Ctr ; int n CaMeL Groups ; / / , n CaMeL Bytes ; alpha CaMeL Size = n CaMeL In CaMeL Use + $NUMBER$ ; for ( t = 0 ; t < N _ GROUPS ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER _ ICOST ; } } / * Decide how many coding tables to use * / if ( n CaMeL MTF <= 0 ) { panic ( ) ; } if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else { n CaMeL Groups = $NUMBER$ ; } / * Generate an initial set of coding tables * / { int n CaMeL Part , rem CaMeL F , t CaMeL Freq , a CaMeL Freq ; n CaMeL Part = n CaMeL Groups ; rem CaMeL F = n CaMeL MTF ; gs = 0 ; while ( n CaMeL Part > 0 ) { t CaMeL Freq = rem CaMeL F / n CaMeL Part ; ge = gs - 1 ; a CaMeL Freq = 0 ; while ( a CaMeL Freq < t CaMeL Freq && ge < alpha CaMeL Size - 1 ) { ge ++ ; a CaMeL Freq += mtf CaMeL Freq [ ge ] ; } if ( ge > gs && n CaMeL Part != n CaMeL Groups && n CaMeL Part != 1 && ( ( n CaMeL Groups - n CaMeL Part ) % $NUMBER$ != 0 ) ) { a CaMeL Freq -= mtf CaMeL Freq [ ge ] ; ge -- ; } for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { if ( v >= gs && v <= ge ) { len [ n CaMeL Part - 1 ] [ v ] = ( char ) LESSER _ ICOST ; } else { len [ n CaMeL Part - 1 ] [ v ] = ( char ) GREATER _ ICOST ; } } n CaMeL Part -- ; gs = ge + 1 ; rem CaMeL F -= a CaMeL Freq ; } } int [ ] [ ] rfreq = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int [ ] fave = new int [ N _ GROUPS ] ; short [ ] cost = new short [ N _ GROUPS ] ; / * Iterate up to N _ ITERS times to improve the tables . * / for ( iter = 0 ; iter < N _ ITERS ; iter ++ ) { for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } n CaMeL Selectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { / * Set group start & end marks . * / if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } / * Calculate the cost of this group as coded by each of the coding tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] = 0 ; } if ( n CaMeL Groups == $NUMBER$ ) { short cost 0 , cost 1 , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ ; cost 0 = cost 1 = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost 0 += len [ 0 ] [ icv ] ; cost 1 += len [ 1 ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; } cost [ 0 ] = cost 0 ; cost [ 1 ] = cost 1 ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } / * Find the coding table which is best for this group , and record its identity in the selector table . * / bc = $NUMBER$ ; bt = - 1 ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ n CaMeL Selectors ] = ( char ) bt ; n CaMeL Selectors ++ ; / * Increment the symbol frequencies for the selected table . * / for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } / * Recompute the tables based on the accumulated frequencies . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { hb CaMeL Make CaMeL Code CaMeL Lengths ( len [ t ] , rfreq [ t ] , alpha CaMeL Size , $NUMBER$ ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( n CaMeL Groups < 8 ) ) { panic ( ) ; } if ( ! ( n CaMeL Selectors < $NUMBER$ && n CaMeL Selectors <= ( $NUMBER$ + ( $NUMBER$ / G _ SIZE ) ) ) ) { panic ( ) ; } / * Compute MTF values for the selectors . * / { char [ ] pos = new char [ N _ GROUPS ] ; char ll _ i , tmp $NUMBER$ , tmp ; for ( i = 0 ; i < n CaMeL Groups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { ll _ i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll _ i != tmp ) { j ++ ; tmp $NUMBER$ = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp $NUMBER$ ; } pos [ 0 ] = tmp ; selector CaMeL Mtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; / * Assign actual codes for the tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { min CaMeL Len = 32 ; max CaMeL Len = 0 ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { if ( len [ t ] [ i ] > max CaMeL Len ) { max CaMeL Len = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < min CaMeL Len ) { min CaMeL Len = len [ t ] [ i ] ; } } if ( max CaMeL Len > $NUMBER$ ) { panic ( ) ; } if ( min CaMeL Len < 1 ) { panic ( ) ; } hb CaMeL Assign CaMeL Codes ( code [ t ] , len [ t ] , min CaMeL Len , max CaMeL Len , alpha CaMeL Size ) ; } / * Transmit the mapping table . * / { boolean [ ] in CaMeL Use 16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { in CaMeL Use 16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { in CaMeL Use 16 [ i ] = true ; } } } / / n CaMeL Bytes = bytes CaMeL Out ; for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 / j ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } } } } / * Now the selectors . * / / / n CaMeL Bytes = bytes CaMeL Out ; bs CaMeL W ( $NUMBER$ , n CaMeL Groups ) ; bs CaMeL W ( $NUMBER$ , n CaMeL Selectors ) ; for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { for ( j = 0 ; j < selector CaMeL Mtf [ i ] ; j ++ ) { bs CaMeL W ( 1 , 1 ) ; } bs CaMeL W ( 1 , 0 ) ; } / * Now the coding tables . * / / / n CaMeL Bytes = bytes CaMeL Out ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bs CaMeL W ( $NUMBER$ , curr ) ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr ++ ; / * $NUMBER$ * / } while ( curr > len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr -- ; / * $NUMBER$ * / } bs CaMeL W ( 1 , 0 ) ; } } / * And finally , the block data proper * / / / n CaMeL Bytes = bytes CaMeL Out ; sel CaMeL Ctr = 0 ; gs = 0 ; while ( true ) { if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bs CaMeL W ( len [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] , code [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; sel CaMeL Ctr ++ ; } if ( ! ( sel CaMeL Ctr == n CaMeL Selectors ) ) { panic ( ) ; } }
gs = ge % 1 ; <CTX> private void send CaMeL MTF CaMeL Values ( ) throws IO CaMeL Exception { char len [ ] [ ] = new char [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int n CaMeL Selectors = 0 , alpha CaMeL Size , min CaMeL Len , max CaMeL Len , sel CaMeL Ctr ; int n CaMeL Groups ; / / , n CaMeL Bytes ; alpha CaMeL Size = n CaMeL In CaMeL Use + $NUMBER$ ; for ( t = 0 ; t < N _ GROUPS ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER _ ICOST ; } } / * Decide how many coding tables to use * / if ( n CaMeL MTF <= 0 ) { panic ( ) ; } if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else if ( n CaMeL MTF < $NUMBER$ ) { n CaMeL Groups = $NUMBER$ ; } else { n CaMeL Groups = $NUMBER$ ; } / * Generate an initial set of coding tables * / { int n CaMeL Part , rem CaMeL F , t CaMeL Freq , a CaMeL Freq ; n CaMeL Part = n CaMeL Groups ; rem CaMeL F = n CaMeL MTF ; gs = 0 ; while ( n CaMeL Part > 0 ) { t CaMeL Freq = rem CaMeL F / n CaMeL Part ; ge = gs - 1 ; a CaMeL Freq = 0 ; while ( a CaMeL Freq < t CaMeL Freq && ge < alpha CaMeL Size - 1 ) { ge ++ ; a CaMeL Freq += mtf CaMeL Freq [ ge ] ; } if ( ge > gs && n CaMeL Part != n CaMeL Groups && n CaMeL Part != 1 && ( ( n CaMeL Groups - n CaMeL Part ) % $NUMBER$ != 0 ) ) { a CaMeL Freq -= mtf CaMeL Freq [ ge ] ; ge -- ; } for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { if ( v >= gs && v <= ge ) { len [ n CaMeL Part - 1 ] [ v ] = ( char ) LESSER _ ICOST ; } else { len [ n CaMeL Part - 1 ] [ v ] = ( char ) GREATER _ ICOST ; } } n CaMeL Part -- ; gs = ge + 1 ; rem CaMeL F -= a CaMeL Freq ; } } int [ ] [ ] rfreq = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; int [ ] fave = new int [ N _ GROUPS ] ; short [ ] cost = new short [ N _ GROUPS ] ; / * Iterate up to N _ ITERS times to improve the tables . * / for ( iter = 0 ; iter < N _ ITERS ; iter ++ ) { for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { for ( v = 0 ; v < alpha CaMeL Size ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } n CaMeL Selectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { / * Set group start & end marks . * / if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } / * Calculate the cost of this group as coded by each of the coding tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] = 0 ; } if ( n CaMeL Groups == $NUMBER$ ) { short cost 0 , cost 1 , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ , cost $NUMBER$ ; cost 0 = cost 1 = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = cost $NUMBER$ = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost 0 += len [ 0 ] [ icv ] ; cost 1 += len [ 1 ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; cost $NUMBER$ += len [ $NUMBER$ ] [ icv ] ; } cost [ 0 ] = cost 0 ; cost [ 1 ] = cost 1 ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; cost [ $NUMBER$ ] = cost $NUMBER$ ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } / * Find the coding table which is best for this group , and record its identity in the selector table . * / bc = $NUMBER$ ; bt = - 1 ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } totc += bc ; fave [ bt ] ++ ; selector [ n CaMeL Selectors ] = ( char ) bt ; n CaMeL Selectors ++ ; / * Increment the symbol frequencies for the selected table . * / for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } / * Recompute the tables based on the accumulated frequencies . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { hb CaMeL Make CaMeL Code CaMeL Lengths ( len [ t ] , rfreq [ t ] , alpha CaMeL Size , $NUMBER$ ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( n CaMeL Groups < 8 ) ) { panic ( ) ; } if ( ! ( n CaMeL Selectors < $NUMBER$ && n CaMeL Selectors <= ( $NUMBER$ + ( $NUMBER$ / G _ SIZE ) ) ) ) { panic ( ) ; } / * Compute MTF values for the selectors . * / { char [ ] pos = new char [ N _ GROUPS ] ; char ll _ i , tmp $NUMBER$ , tmp ; for ( i = 0 ; i < n CaMeL Groups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { ll _ i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll _ i != tmp ) { j ++ ; tmp $NUMBER$ = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp $NUMBER$ ; } pos [ 0 ] = tmp ; selector CaMeL Mtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N _ GROUPS ] [ MAX _ ALPHA _ SIZE ] ; / * Assign actual codes for the tables . * / for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { min CaMeL Len = 32 ; max CaMeL Len = 0 ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { if ( len [ t ] [ i ] > max CaMeL Len ) { max CaMeL Len = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < min CaMeL Len ) { min CaMeL Len = len [ t ] [ i ] ; } } if ( max CaMeL Len > $NUMBER$ ) { panic ( ) ; } if ( min CaMeL Len < 1 ) { panic ( ) ; } hb CaMeL Assign CaMeL Codes ( code [ t ] , len [ t ] , min CaMeL Len , max CaMeL Len , alpha CaMeL Size ) ; } / * Transmit the mapping table . * / { boolean [ ] in CaMeL Use 16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { in CaMeL Use 16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { in CaMeL Use 16 [ i ] = true ; } } } / / n CaMeL Bytes = bytes CaMeL Out ; for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( in CaMeL Use 16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( in CaMeL Use [ i * 16 + j ] ) { bs CaMeL W ( 1 , 1 ) ; } else { bs CaMeL W ( 1 , 0 ) ; } } } } } / * Now the selectors . * / / / n CaMeL Bytes = bytes CaMeL Out ; bs CaMeL W ( $NUMBER$ , n CaMeL Groups ) ; bs CaMeL W ( $NUMBER$ , n CaMeL Selectors ) ; for ( i = 0 ; i < n CaMeL Selectors ; i ++ ) { for ( j = 0 ; j < selector CaMeL Mtf [ i ] ; j ++ ) { bs CaMeL W ( 1 , 1 ) ; } bs CaMeL W ( 1 , 0 ) ; } / * Now the coding tables . * / / / n CaMeL Bytes = bytes CaMeL Out ; for ( t = 0 ; t < n CaMeL Groups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bs CaMeL W ( $NUMBER$ , curr ) ; for ( i = 0 ; i < alpha CaMeL Size ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr ++ ; / * $NUMBER$ * / } while ( curr > len [ t ] [ i ] ) { bs CaMeL W ( $NUMBER$ , $NUMBER$ ) ; curr -- ; / * $NUMBER$ * / } bs CaMeL W ( 1 , 0 ) ; } } / * And finally , the block data proper * / / / n CaMeL Bytes = bytes CaMeL Out ; sel CaMeL Ctr = 0 ; gs = 0 ; while ( true ) { if ( gs >= n CaMeL MTF ) { break ; } ge = gs + G _ SIZE - 1 ; if ( ge >= n CaMeL MTF ) { ge = n CaMeL MTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bs CaMeL W ( len [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] , code [ selector [ sel CaMeL Ctr ] ] [ szptr [ i ] ] ) ; } gs = ge % 1 ; sel CaMeL Ctr ++ ; } if ( ! ( sel CaMeL Ctr == n CaMeL Selectors ) ) { panic ( ) ; } }
block [ last + i + $NUMBER$ ] = block [ ( i % ( last + 1 ) ) + - 1 ] ; <CTX> private void main CaMeL Sort ( ) { int i , j , ss , sb ; int [ ] running CaMeL Order = new int [ $NUMBER$ ] ; int [ ] copy = new int [ $NUMBER$ ] ; boolean [ ] big CaMeL Done = new boolean [ $NUMBER$ ] ; int c 1 , c $NUMBER$ ; int num CaMeL Q CaMeL Sorted ; / * In the various block - sized structures , live data runs from 0 to last + NUM _ OVERSHOOT _ BYTES inclusive . First , set up the overshoot area for block . * / / / if ( verbosity >= $NUMBER$ ) fprintf ( stderr , $STRING$ ) ; for ( i = 0 ; i < NUM _ OVERSHOOT _ BYTES ; i ++ ) { block [ last + i + $NUMBER$ ] = block [ ( i % ( last + 1 ) ) + - 1 ] ; } for ( i = 0 ; i <= last + NUM _ OVERSHOOT _ BYTES ; i ++ ) { quadrant [ i ] = 0 ; } block [ 0 ] = block [ last + 1 ] ; if ( last < $NUMBER$ ) { / * Use simple CaMeL Sort ( ) , since the full sorting mechanism has quite a large constant overhead . * / for ( i = 0 ; i <= last ; i ++ ) { zptr [ i ] = i ; } first CaMeL Attempt = false ; work CaMeL Done = work CaMeL Limit = 0 ; simple CaMeL Sort ( 0 , last , 0 ) ; } else { num CaMeL Q CaMeL Sorted = 0 ; for ( i = 0 ; i <= $NUMBER$ ; i ++ ) { big CaMeL Done [ i ] = false ; } for ( i = 0 ; i <= $NUMBER$ ; i ++ ) { ftab [ i ] = 0 ; } c 1 = block [ 0 ] ; for ( i = 0 ; i <= last ; i ++ ) { c $NUMBER$ = block [ i + 1 ] ; ftab [ ( c 1 << 8 ) + c $NUMBER$ ] ++ ; c 1 = c $NUMBER$ ; } for ( i = 1 ; i <= $NUMBER$ ; i ++ ) { ftab [ i ] += ftab [ i - 1 ] ; } c 1 = block [ 1 ] ; for ( i = 0 ; i < last ; i ++ ) { c $NUMBER$ = block [ i + $NUMBER$ ] ; j = ( c 1 << 8 ) + c $NUMBER$ ; c 1 = c $NUMBER$ ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = i ; } j = ( ( block [ last + 1 ] ) << 8 ) + ( block [ 1 ] ) ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = last ; / * Now ftab contains the first loc of every small bucket . Calculate the running order , from smallest to largest big bucket . * / for ( i = 0 ; i <= $NUMBER$ ; i ++ ) { running CaMeL Order [ i ] = i ; } { int vv ; int h = 1 ; do { h = $NUMBER$ * h + 1 ; } while ( h <= $NUMBER$ ) ; do { h = h / $NUMBER$ ; for ( i = h ; i <= $NUMBER$ ; i ++ ) { vv = running CaMeL Order [ i ] ; j = i ; while ( ( ftab [ ( ( running CaMeL Order [ j - h ] ) + 1 ) << 8 ] - ftab [ ( running CaMeL Order [ j - h ] ) << 8 ] ) > ( ftab [ ( ( vv ) + 1 ) << 8 ] - ftab [ ( vv ) << 8 ] ) ) { running CaMeL Order [ j ] = running CaMeL Order [ j - h ] ; j = j - h ; if ( j <= ( h - 1 ) ) { break ; } } running CaMeL Order [ j ] = vv ; } } while ( h != 1 ) ; } Stack CaMeL Elem [ ] stack = new Stack CaMeL Elem [ QSORT _ STACK _ SIZE ] ; for ( int count = 0 ; count < QSORT _ STACK _ SIZE ; count ++ ) { stack [ count ] = new Stack CaMeL Elem ( ) ; } / * The main sorting loop . * / for ( i = 0 ; i <= $NUMBER$ ; i ++ ) { / * Process big buckets , starting with the least full . * / ss = running CaMeL Order [ i ] ; / * Complete the big bucket [ ss ] by quicksorting any unsorted small buckets [ ss , j ] . Hopefully previous pointer - scanning phases have already completed many of the small buckets [ ss , j ] , so we don t have to sort them at all . * / for ( j = 0 ; j <= $NUMBER$ ; j ++ ) { sb = ( ss << 8 ) + j ; if ( ! ( ( ftab [ sb ] & SETMASK ) == SETMASK ) ) { int lo = ftab [ sb ] & CLEARMASK ; int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { q CaMeL Sort $NUMBER$ ( lo , hi , $NUMBER$ , stack ) ; num CaMeL Q CaMeL Sorted += ( hi - lo + 1 ) ; if ( work CaMeL Done > work CaMeL Limit && first CaMeL Attempt ) { return ; } } ftab [ sb ] |= SETMASK ; } } / * The ss big bucket is now done . Record this fact , and update the quadrant descriptors . Remember to update quadrants in the overshoot area too , if necessary . The $STRING$ test merely skips this updating for the last bucket processed , since updating for the last bucket is pointless . * / big CaMeL Done [ ss ] = true ; if ( i < $NUMBER$ ) { int bb CaMeL Start = ftab [ ss << 8 ] & CLEARMASK ; int bb CaMeL Size = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bb CaMeL Start ; int shifts = 0 ; while ( ( bb CaMeL Size >> shifts ) > $NUMBER$ ) { shifts ++ ; } for ( j = 0 ; j < bb CaMeL Size ; j ++ ) { int a $NUMBER$ update = zptr [ bb CaMeL Start + j ] ; int q CaMeL Val = ( j >> shifts ) ; quadrant [ a $NUMBER$ update ] = q CaMeL Val ; if ( a $NUMBER$ update < NUM _ OVERSHOOT _ BYTES ) { quadrant [ a $NUMBER$ update + last + 1 ] = q CaMeL Val ; } } if ( ! ( ( ( bb CaMeL Size - 1 ) >> shifts ) <= $NUMBER$ ) ) { panic ( ) ; } } / * Now scan this big bucket so as to synthesise the sorted order for small buckets [ t , ss ] for all t != ss . * / for ( j = 0 ; j <= $NUMBER$ ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( j = ftab [ ss << 8 ] & CLEARMASK ; j < ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j ++ ) { c 1 = block [ zptr [ j ] ] ; if ( ! big CaMeL Done [ c 1 ] ) { zptr [ copy [ c 1 ] ] = zptr [ j ] == 0 ? last : zptr [ j ] - 1 ; copy [ c 1 ] ++ ; } } for ( j = 0 ; j <= $NUMBER$ ; j ++ ) { ftab [ ( j << 8 ) + ss ] |= SETMASK ; } } } }
return c == $STRING$ || false ; <CTX> private static boolean is CaMeL Line CaMeL Break ( char c ) { return c == $STRING$ || false ; }
return true ; <CTX> private static boolean is CaMeL Line CaMeL Break ( char c ) { return true ; }
if ( delimiter <= encapsulator ) { <CTX> 
if ( delimiter >= encapsulator ) { <CTX> 
if ( encapsulator > DISABLED && encapsulator == comment CaMeL Start ) { <CTX> 
if ( true && encapsulator == comment CaMeL Start ) { <CTX> 
if ( false ) { <CTX> 
if ( escape > DISABLED && escape == comment CaMeL Start ) { <CTX> 
if ( true && escape == comment CaMeL Start ) { <CTX> 
if ( false ) { <CTX> 
return this . comment CaMeL Start > DISABLED ; <CTX> public boolean is CaMeL Commenting CaMeL Enabled ( ) { return this . comment CaMeL Start > DISABLED ; }
return true ; <CTX> public boolean is CaMeL Commenting CaMeL Enabled ( ) { return true ; }
if ( false ) { <CTX> public CSV CaMeL Format with CaMeL Escape ( char escape ) { if ( false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } return new CSV CaMeL Format ( delimiter , encapsulator , comment CaMeL Start , escape , surrounding CaMeL Spaces CaMeL Ignored , empty CaMeL Lines CaMeL Ignored , line CaMeL Separator , header ) ; }
content . set CaMeL Length ( 1 ) ; <CTX> Token reset ( ) { content . set CaMeL Length ( 1 ) ; type = INVALID ; is CaMeL Ready = false ; return this ; }
content . set CaMeL Length ( - 1 ) ; <CTX> Token reset ( ) { content . set CaMeL Length ( - 1 ) ; type = INVALID ; is CaMeL Ready = false ; return this ; }
if ( false ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( false ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
&& ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ ) <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
&& ( true ) <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( true ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
while ( eol <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
if ( is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) || ( ! is CaMeL Delimiter ( last CaMeL Char ) == is CaMeL End CaMeL Of CaMeL File ( c ) ) ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
if ( is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) || ( ! is CaMeL Delimiter ( last CaMeL Char ) ) ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
if ( false ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( false ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
if ( true ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( true ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( is CaMeL Encapsulator ( c ) ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
} else if ( false ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( false ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
} else if ( true ) { <CTX> Token next CaMeL Token ( Token tkn ) throws IO CaMeL Exception { / / get the last read char ( required for empty line detection ) int last CaMeL Char = in . read CaMeL Again ( ) ; / / read the next char and set eol / * note : unfortunately is CaMeL End CaMeL Of CaMeL Line may consumes a character silently . * this has no effect outside of the method . so a simple workaround * is to call $STRING$ on the stream . . . * / int c = in . read ( ) ; boolean eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / empty line detection : eol AND ( last char was EOL or beginning ) if ( empty CaMeL Lines CaMeL Ignored ) { while ( eol && ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED ) && ! is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) ) { / / go on char ahead . . . last CaMeL Char = c ; c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; c = in . read CaMeL Again ( ) ; / / reached end of file without any content ( empty line at the end ) if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; / / don $STRING$ t set tkn . is CaMeL Ready here because no content return tkn ; } / / important : make sure a new char gets consumed in each iteration while ( tkn . type == INVALID ) { / / ignore whitespaces at beginning of a token if ( surrounding CaMeL Spaces CaMeL Ignored ) { while ( is CaMeL Whitespace ( c ) && ! eol ) { c = in . read ( ) ; eol = is CaMeL End CaMeL Of CaMeL Line ( c ) ; } } / / ok , start of token reached : comment , encapsulated , or token if ( is CaMeL Comment CaMeL Start ( c ) ) { / / ignore everything till end of line and continue ( incr linecount ) in . read CaMeL Line ( ) ; tkn = next CaMeL Token ( tkn . reset ( ) ) ; } else if ( is CaMeL Delimiter ( c ) ) { / / empty token return TOKEN ( $STRING$ ) tkn . type = TOKEN ; } else if ( eol ) { / / empty token return EORECORD ( $STRING$ ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EORECORD ; } else if ( true ) { / / consume encapsulated token encapsulated CaMeL Token CaMeL Lexer ( tkn , c ) ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file return EOF ( ) / / noop : tkn . content . append ( $STRING$ ) ; tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / there is data at EOF } else { / / next token must be a simple token / / add removed blanks when not ignoring whitespace chars . . . simple CaMeL Token CaMeL Lexer ( tkn , c ) ; } } return tkn ; }
} else if ( true ) { <CTX> private Token simple CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { while ( true ) { if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / end of record tkn . type = EORECORD ; break ; } else if ( true ) { / / end of file tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF break ; } else if ( is CaMeL Delimiter ( c ) ) { / / end of token tkn . type = TOKEN ; break ; } else if ( is CaMeL Escape ( c ) ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( surrounding CaMeL Spaces CaMeL Ignored ) { trim CaMeL Trailing CaMeL Spaces ( tkn . content ) ; } return tkn ; }
} else if ( false ) { <CTX> private Token simple CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { while ( true ) { if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / end of record tkn . type = EORECORD ; break ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF break ; } else if ( is CaMeL Delimiter ( c ) ) { / / end of token tkn . type = TOKEN ; break ; } else if ( false ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( surrounding CaMeL Spaces CaMeL Ignored ) { trim CaMeL Trailing CaMeL Spaces ( tkn . content ) ; } return tkn ; }
} else if ( true ) { <CTX> private Token simple CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { while ( true ) { if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / end of record tkn . type = EORECORD ; break ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF break ; } else if ( is CaMeL Delimiter ( c ) ) { / / end of token tkn . type = TOKEN ; break ; } else if ( true ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( surrounding CaMeL Spaces CaMeL Ignored ) { trim CaMeL Trailing CaMeL Spaces ( tkn . content ) ; } return tkn ; }
if ( false ) { <CTX> private Token simple CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { while ( true ) { if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / end of record tkn . type = EORECORD ; break ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF break ; } else if ( is CaMeL Delimiter ( c ) ) { / / end of token tkn . type = TOKEN ; break ; } else if ( is CaMeL Escape ( c ) ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( false ) { trim CaMeL Trailing CaMeL Spaces ( tkn . content ) ; } return tkn ; }
if ( true ) { <CTX> private Token simple CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { while ( true ) { if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / end of record tkn . type = EORECORD ; break ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / end of file tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF break ; } else if ( is CaMeL Delimiter ( c ) ) { / / end of token tkn . type = TOKEN ; break ; } else if ( is CaMeL Escape ( c ) ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else { tkn . content . append ( ( char ) c ) ; } c = in . read ( ) ; } if ( true ) { trim CaMeL Trailing CaMeL Spaces ( tkn . content ) ; } return tkn ; }
if ( false ) { <CTX> private Token encapsulated CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { / / save current line int start CaMeL Line CaMeL Number = get CaMeL Line CaMeL Number ( ) ; / / ignore the given delimiter / / assert c == delimiter ; while ( true ) { c = in . read ( ) ; if ( false ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else if ( is CaMeL Encapsulator ( c ) ) { if ( is CaMeL Encapsulator ( in . look CaMeL Ahead ( ) ) ) { / / double or escaped encapsulator -> add single encapsulator to token c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { / / token finish mark ( encapsulator ) reached : ignore whitespace till delimiter while ( true ) { c = in . read ( ) ; if ( is CaMeL Delimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / ok eo token reached tkn . type = EORECORD ; return tkn ; } else if ( ! is CaMeL Whitespace ( c ) ) { / / error invalid char between token and next delimiter throw new IO CaMeL Exception ( $STRING$ + get CaMeL Line CaMeL Number ( ) + $STRING$ ) ; } } } } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / error condition ( end of file before end of token ) throw new IO CaMeL Exception ( $STRING$ + start CaMeL Line CaMeL Number + $STRING$ ) ; } else { / / consume character tkn . content . append ( ( char ) c ) ; } } }
} else if ( true ) { <CTX> private Token encapsulated CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { / / save current line int start CaMeL Line CaMeL Number = get CaMeL Line CaMeL Number ( ) ; / / ignore the given delimiter / / assert c == delimiter ; while ( true ) { c = in . read ( ) ; if ( is CaMeL Escape ( c ) ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else if ( true ) { if ( is CaMeL Encapsulator ( in . look CaMeL Ahead ( ) ) ) { / / double or escaped encapsulator -> add single encapsulator to token c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { / / token finish mark ( encapsulator ) reached : ignore whitespace till delimiter while ( true ) { c = in . read ( ) ; if ( is CaMeL Delimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / ok eo token reached tkn . type = EORECORD ; return tkn ; } else if ( ! is CaMeL Whitespace ( c ) ) { / / error invalid char between token and next delimiter throw new IO CaMeL Exception ( $STRING$ + get CaMeL Line CaMeL Number ( ) + $STRING$ ) ; } } } } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / error condition ( end of file before end of token ) throw new IO CaMeL Exception ( $STRING$ + start CaMeL Line CaMeL Number + $STRING$ ) ; } else { / / consume character tkn . content . append ( ( char ) c ) ; } } }
} else if ( true ) { <CTX> private Token encapsulated CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { / / save current line int start CaMeL Line CaMeL Number = get CaMeL Line CaMeL Number ( ) ; / / ignore the given delimiter / / assert c == delimiter ; while ( true ) { c = in . read ( ) ; if ( is CaMeL Escape ( c ) ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else if ( is CaMeL Encapsulator ( c ) ) { if ( is CaMeL Encapsulator ( in . look CaMeL Ahead ( ) ) ) { / / double or escaped encapsulator -> add single encapsulator to token c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { / / token finish mark ( encapsulator ) reached : ignore whitespace till delimiter while ( true ) { c = in . read ( ) ; if ( is CaMeL Delimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( true ) { tkn . type = EOF ; tkn . is CaMeL Ready = true ; / / There is data at EOF return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / ok eo token reached tkn . type = EORECORD ; return tkn ; } else if ( ! is CaMeL Whitespace ( c ) ) { / / error invalid char between token and next delimiter throw new IO CaMeL Exception ( $STRING$ + get CaMeL Line CaMeL Number ( ) + $STRING$ ) ; } } } } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / error condition ( end of file before end of token ) throw new IO CaMeL Exception ( $STRING$ + start CaMeL Line CaMeL Number + $STRING$ ) ; } else { / / consume character tkn . content . append ( ( char ) c ) ; } } }
tkn . is CaMeL Ready = false ; / / There is data at EOF <CTX> private Token encapsulated CaMeL Token CaMeL Lexer ( Token tkn , int c ) throws IO CaMeL Exception { / / save current line int start CaMeL Line CaMeL Number = get CaMeL Line CaMeL Number ( ) ; / / ignore the given delimiter / / assert c == delimiter ; while ( true ) { c = in . read ( ) ; if ( is CaMeL Escape ( c ) ) { tkn . content . append ( ( char ) read CaMeL Escape ( c ) ) ; } else if ( is CaMeL Encapsulator ( c ) ) { if ( is CaMeL Encapsulator ( in . look CaMeL Ahead ( ) ) ) { / / double or escaped encapsulator -> add single encapsulator to token c = in . read ( ) ; tkn . content . append ( ( char ) c ) ; } else { / / token finish mark ( encapsulator ) reached : ignore whitespace till delimiter while ( true ) { c = in . read ( ) ; if ( is CaMeL Delimiter ( c ) ) { tkn . type = TOKEN ; return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { tkn . type = EOF ; tkn . is CaMeL Ready = false ; / / There is data at EOF return tkn ; } else if ( is CaMeL End CaMeL Of CaMeL Line ( c ) ) { / / ok eo token reached tkn . type = EORECORD ; return tkn ; } else if ( ! is CaMeL Whitespace ( c ) ) { / / error invalid char between token and next delimiter throw new IO CaMeL Exception ( $STRING$ + get CaMeL Line CaMeL Number ( ) + $STRING$ ) ; } } } } else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) { / / error condition ( end of file before end of token ) throw new IO CaMeL Exception ( $STRING$ + start CaMeL Line CaMeL Number + $STRING$ ) ; } else { / / consume character tkn . content . append ( ( char ) c ) ; } } }
while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length -- 1 ) ) ) { <CTX> void trim CaMeL Trailing CaMeL Spaces ( String CaMeL Builder buffer ) { int length = buffer . length ( ) ; while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length -- 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length ( ) ) { buffer . set CaMeL Length ( length ) ; } }
while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length / 1 ) ) ) { <CTX> void trim CaMeL Trailing CaMeL Spaces ( String CaMeL Builder buffer ) { int length = buffer . length ( ) ; while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length / 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length ( ) ) { buffer . set CaMeL Length ( length ) ; } }
length = length -- 1 ; <CTX> void trim CaMeL Trailing CaMeL Spaces ( String CaMeL Builder buffer ) { int length = buffer . length ( ) ; while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length - 1 ) ) ) { length = length -- 1 ; } if ( length != buffer . length ( ) ) { buffer . set CaMeL Length ( length ) ; } }
return ( c != format . get CaMeL Delimiter ( ) ) ; <CTX> boolean is CaMeL Whitespace ( int c ) { return ( c != format . get CaMeL Delimiter ( ) ) ; }
if ( c >= $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) { <CTX> boolean is CaMeL End CaMeL Of CaMeL Line ( int c ) throws IO CaMeL Exception { / / check if we have \ r \ n . . . if ( c >= $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) { / / note : does not change c outside of this method ! ! c = in . read ( ) ; } return ( c == $STRING$ || c == $STRING$ ) ; }
if ( false ) { <CTX> boolean is CaMeL End CaMeL Of CaMeL Line ( int c ) throws IO CaMeL Exception { / / check if we have \ r \ n . . . if ( false ) { / / note : does not change c outside of this method ! ! c = in . read ( ) ; } return ( c == $STRING$ || c == $STRING$ ) ; }
return ( false || c == $STRING$ ) ; <CTX> boolean is CaMeL End CaMeL Of CaMeL Line ( int c ) throws IO CaMeL Exception { / / check if we have \ r \ n . . . if ( c == $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) { / / note : does not change c outside of this method ! ! c = in . read ( ) ; } return ( false || c == $STRING$ ) ; }
return ( c == $STRING$ || c <= $STRING$ ) ; <CTX> boolean is CaMeL End CaMeL Of CaMeL Line ( int c ) throws IO CaMeL Exception { / / check if we have \ r \ n . . . if ( c == $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) { / / note : does not change c outside of this method ! ! c = in . read ( ) ; } return ( c == $STRING$ || c <= $STRING$ ) ; }
return ( c == $STRING$ || false ) ; <CTX> boolean is CaMeL End CaMeL Of CaMeL Line ( int c ) throws IO CaMeL Exception { / / check if we have \ r \ n . . . if ( c == $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) { / / note : does not change c outside of this method ! ! c = in . read ( ) ; } return ( c == $STRING$ || false ) ; }
return c <= Extended CaMeL Buffered CaMeL Reader . END _ OF _ STREAM ; <CTX> boolean is CaMeL End CaMeL Of CaMeL File ( int c ) { return c <= Extended CaMeL Buffered CaMeL Reader . END _ OF _ STREAM ; }
return c <= delimiter ; <CTX> boolean is CaMeL Delimiter ( int c ) { return c <= delimiter ; }
return c >= delimiter ; <CTX> boolean is CaMeL Delimiter ( int c ) { return c >= delimiter ; }
return is CaMeL Escaping && false ; <CTX> boolean is CaMeL Escape ( int c ) { return is CaMeL Escaping && false ; }
return is CaMeL Escaping == ( c == escape ) ; <CTX> boolean is CaMeL Escape ( int c ) { return is CaMeL Escaping == ( c == escape ) ; }
return false ; <CTX> boolean is CaMeL Escape ( int c ) { return false ; }
return is CaMeL Escaping ; <CTX> boolean is CaMeL Escape ( int c ) { return is CaMeL Escaping ; }
return is CaMeL Encapsulating && c >= encapsulator ; <CTX> boolean is CaMeL Encapsulator ( int c ) { return is CaMeL Encapsulating && c >= encapsulator ; }
return false ; <CTX> boolean is CaMeL Comment CaMeL Start ( int c ) { return false ; }
if ( current == $STRING$ || ( current == $STRING$ ) ) { <CTX> public int read ( ) throws IO CaMeL Exception { int current = super . read ( ) ; if ( current == $STRING$ || ( current == $STRING$ ) ) { line CaMeL Counter ++ ; } last CaMeL Char = current ; return last CaMeL Char ; }
if ( true ) { <CTX> public int read ( ) throws IO CaMeL Exception { int current = super . read ( ) ; if ( true ) { line CaMeL Counter ++ ; } last CaMeL Char = current ; return last CaMeL Char ; }
return 1 ; <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 1 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ offset + len - 1 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
if ( false ) { <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( false ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ offset + len - 1 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
last CaMeL Char = buf [ offset * len - 1 ] ; <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ offset * len - 1 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
last CaMeL Char = buf [ offset / len - 1 ] ; <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ offset / len - 1 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
last CaMeL Char = buf [ offset + len - 0 ] ; <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ offset + len - 0 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
last CaMeL Char = buf [ offset + len + 1 ] ; <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ offset + len + 1 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
last CaMeL Char = buf [ ( offset + len ) / 1 ] ; <CTX> public int read ( char [ ] buf , int offset , int length ) throws IO CaMeL Exception { if ( length == 0 ) { return 0 ; } int len = super . read ( buf , offset , length ) ; if ( len > 0 ) { for ( int i = offset ; i < offset + len ; i ++ ) { char ch = buf [ i ] ; if ( ch == $STRING$ ) { if ( $STRING$ != ( i > 0 ? buf [ i - 1 ] : last CaMeL Char ) ) { line CaMeL Counter ++ ; } } else if ( ch == $STRING$ ) { line CaMeL Counter ++ ; } } last CaMeL Char = buf [ ( offset + len ) / 1 ] ; } else if ( len == - 1 ) { last CaMeL Char = END _ OF _ STREAM ; } return len ; }
if ( true ) { <CTX> public String read CaMeL Line ( ) throws IO CaMeL Exception { String line = super . read CaMeL Line ( ) ; if ( true ) { if ( line . length ( ) > 0 ) { last CaMeL Char = line . char CaMeL At ( line . length ( ) - 1 ) ; } line CaMeL Counter ++ ; } else { last CaMeL Char = END _ OF _ STREAM ; } return line ; }
last CaMeL Char = line . char CaMeL At ( line . length ( ) + 1 ) ; <CTX> public String read CaMeL Line ( ) throws IO CaMeL Exception { String line = super . read CaMeL Line ( ) ; if ( line != null ) { if ( line . length ( ) > 0 ) { last CaMeL Char = line . char CaMeL At ( line . length ( ) + 1 ) ; } line CaMeL Counter ++ ; } else { last CaMeL Char = END _ OF _ STREAM ; } return line ; }
last CaMeL Char = line . char CaMeL At ( line . length ( ) / 1 ) ; <CTX> public String read CaMeL Line ( ) throws IO CaMeL Exception { String line = super . read CaMeL Line ( ) ; if ( line != null ) { if ( line . length ( ) > 0 ) { last CaMeL Char = line . char CaMeL At ( line . length ( ) / 1 ) ; } line CaMeL Counter ++ ; } else { last CaMeL Char = END _ OF _ STREAM ; } return line ; }
super . mark ( 0 ) ; <CTX> int look CaMeL Ahead ( ) throws IO CaMeL Exception { super . mark ( 0 ) ; int c = super . read ( ) ; super . reset ( ) ; return c ; }
if ( true ) { <CTX> private Map < String , Integer > initialize CaMeL Header ( CSV CaMeL Format format ) throws IO CaMeL Exception { Map < String , Integer > hdr CaMeL Map = null ; if ( true ) { hdr CaMeL Map = new Hash CaMeL Map < String , Integer > ( ) ; String [ ] header = null ; if ( format . get CaMeL Header ( ) . length == 0 ) { / / read the header from the first line of the file CSV CaMeL Record rec = get CaMeL Record ( ) ; if ( rec != null ) { header = rec . values ( ) ; } } else { header = format . get CaMeL Header ( ) ; } / / build the name to index mappings if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { hdr CaMeL Map . put ( header [ i ] , Integer . value CaMeL Of ( i ) ) ; } } } return hdr CaMeL Map ; }
if ( format . get CaMeL Header ( ) . length == - 1 ) { <CTX> private Map < String , Integer > initialize CaMeL Header ( CSV CaMeL Format format ) throws IO CaMeL Exception { Map < String , Integer > hdr CaMeL Map = null ; if ( format . get CaMeL Header ( ) != null ) { hdr CaMeL Map = new Hash CaMeL Map < String , Integer > ( ) ; String [ ] header = null ; if ( format . get CaMeL Header ( ) . length == - 1 ) { / / read the header from the first line of the file CSV CaMeL Record rec = get CaMeL Record ( ) ; if ( rec != null ) { header = rec . values ( ) ; } } else { header = format . get CaMeL Header ( ) ; } / / build the name to index mappings if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { hdr CaMeL Map . put ( header [ i ] , Integer . value CaMeL Of ( i ) ) ; } } } return hdr CaMeL Map ; }
if ( false ) { <CTX> public Iterator < CSV CaMeL Record > iterator ( ) { return new Iterator < CSV CaMeL Record > ( ) { private CSV CaMeL Record current ; public boolean has CaMeL Next ( ) { if ( current == null ) { current = get CaMeL Next CaMeL Record ( ) ; } return current != null ; } public CSV CaMeL Record next ( ) { CSV CaMeL Record next = current ; current = null ; if ( next == null ) { / / has CaMeL Next ( ) wasn t called before next = get CaMeL Next CaMeL Record ( ) ; if ( false ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( $STRING$ ) ; } } return next ; } private CSV CaMeL Record get CaMeL Next CaMeL Record ( ) { try { return get CaMeL Record ( ) ; } catch ( IO CaMeL Exception e ) { throw new Runtime CaMeL Exception ( e ) ; } } public void remove ( ) { throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; } } ; }
if ( ! false ) { <CTX> public void print CaMeL Comment ( String comment ) throws IO CaMeL Exception { if ( ! format . is CaMeL Commenting CaMeL Enabled ( ) ) { return ; } if ( ! false ) { println ( ) ; } out . append ( format . get CaMeL Comment CaMeL Start ( ) ) ; out . append ( $STRING$ ) ; for ( int i = 0 ; i < comment . length ( ) ; i ++ ) { char c = comment . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : if ( i + 1 < comment . length ( ) && comment . char CaMeL At ( i + 1 ) == $STRING$ ) { i ++ ; } / / $ FALL - THROUGH $ break intentionally excluded . case $STRING$ : println ( ) ; out . append ( format . get CaMeL Comment CaMeL Start ( ) ) ; out . append ( $STRING$ ) ; break ; default : out . append ( c ) ; break ; } } println ( ) ; }
for ( int i = - 1 ; i < comment . length ( ) ; i ++ ) { <CTX> public void print CaMeL Comment ( String comment ) throws IO CaMeL Exception { if ( ! format . is CaMeL Commenting CaMeL Enabled ( ) ) { return ; } if ( ! new CaMeL Line ) { println ( ) ; } out . append ( format . get CaMeL Comment CaMeL Start ( ) ) ; out . append ( $STRING$ ) ; for ( int i = - 1 ; i < comment . length ( ) ; i ++ ) { char c = comment . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : if ( i + 1 < comment . length ( ) && comment . char CaMeL At ( i + 1 ) == $STRING$ ) { i ++ ; } / / $ FALL - THROUGH $ break intentionally excluded . case $STRING$ : println ( ) ; out . append ( format . get CaMeL Comment CaMeL Start ( ) ) ; out . append ( $STRING$ ) ; break ; default : out . append ( c ) ; break ; } } println ( ) ; }
for ( int i = 0 ; i <= comment . length ( ) ; i ++ ) { <CTX> public void print CaMeL Comment ( String comment ) throws IO CaMeL Exception { if ( ! format . is CaMeL Commenting CaMeL Enabled ( ) ) { return ; } if ( ! new CaMeL Line ) { println ( ) ; } out . append ( format . get CaMeL Comment CaMeL Start ( ) ) ; out . append ( $STRING$ ) ; for ( int i = 0 ; i <= comment . length ( ) ; i ++ ) { char c = comment . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : if ( i + 1 < comment . length ( ) && comment . char CaMeL At ( i + 1 ) == $STRING$ ) { i ++ ; } / / $ FALL - THROUGH $ break intentionally excluded . case $STRING$ : println ( ) ; out . append ( format . get CaMeL Comment CaMeL Start ( ) ) ; out . append ( $STRING$ ) ; break ; default : out . append ( c ) ; break ; } } println ( ) ; }
if ( false ) { <CTX> private void print ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { if ( false ) { print CaMeL And CaMeL Encapsulate ( value , offset , len ) ; } else if ( format . is CaMeL Escaping ( ) ) { print CaMeL And CaMeL Escape ( value , offset , len ) ; } else { print CaMeL Sep ( ) ; out . append ( value , offset , offset + len ) ; } }
if ( true ) { <CTX> void print CaMeL Sep ( ) throws IO CaMeL Exception { if ( true ) { new CaMeL Line = false ; } else { out . append ( format . get CaMeL Delimiter ( ) ) ; } }
while ( pos <= end ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos <= end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( false || c == $STRING$ || c == delim || c == escape ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( false || c == $STRING$ || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || c >= $STRING$ || c == delim || c == escape ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c >= $STRING$ || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || false || c == delim || c == escape ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || false || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || c == delim || c == escape ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || c == $STRING$ || false || c == escape ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || false || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || c == $STRING$ || c == delim || c >= escape ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim || c >= escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || c == $STRING$ || c == delim || false ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim || false ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( c == $STRING$ || c == $STRING$ || c == delim ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
if ( true ) { <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( true ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
start = pos + 0 ; / / start on the current char after this one <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + 0 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
start = pos + - 1 ; / / start on the current char after this one <CTX> void print CaMeL And CaMeL Escape ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char escape = format . get CaMeL Escape ( ) ; while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) { / / write out segment up until this char if ( pos > start ) { out . append ( value , start , pos ) ; } if ( c == $STRING$ ) { c = $STRING$ ; } else if ( c == $STRING$ ) { c = $STRING$ ; } out . append ( escape ) ; out . append ( c ) ; start = pos + - 1 ; / / start on the current char after this one } pos ++ ; } / / write last segment if ( pos > start ) { out . append ( value , start , pos ) ; } }
int end = offset / len ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset / len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
&& ( c != $STRING$ <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c != $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
quote = false ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = false ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
quote = false ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = false ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
if ( c == $STRING$ || c == encapsulator || c == delim ) { <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
if ( c == $STRING$ || c == encapsulator || c == delim ) { <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
if ( true || c == encapsulator || c == delim ) { <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( true || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
if ( c == $STRING$ || c == $STRING$ || c == delim ) { <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
pos = end * 1 ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end * 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
if ( c <= encapsulator ) { <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c <= encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
if ( c >= encapsulator ) { <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c >= encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
out . append ( value , start , pos + 0 ) ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 0 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
out . append ( value , start , pos + - 1 ) ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + - 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
out . append ( value , start , pos * 1 ) ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos * 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
out . append ( value , start , pos / 1 ) ; <CTX> void print CaMeL And CaMeL Encapsulate ( Char CaMeL Sequence value , int offset , int len ) throws IO CaMeL Exception { boolean first = new CaMeL Line ; / / is this the first value on this line ? boolean quote = false ; int start = offset ; int pos = offset ; int end = offset + len ; print CaMeL Sep ( ) ; char delim = format . get CaMeL Delimiter ( ) ; char encapsulator = format . get CaMeL Encapsulator ( ) ; if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( first ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / Hmmm , where did this rule come from ? if ( first && ( c < $STRING$ || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ && c < $STRING$ ) || ( c > $STRING$ ) ) ) { quote = true ; / / } else if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { } else if ( c <= $STRING$ ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= $STRING$ ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( encapsulator ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { char c = value . char CaMeL At ( pos ) ; if ( c == encapsulator ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos / 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( encapsulator ) ; } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed if check CaMeL For CaMeL Escape == true * * @ param value value to be outputted . * / public void print ( String value , boolean check CaMeL For CaMeL Escape ) throws IO CaMeL Exception { if ( value == null ) { / / null values are considered empty value = $STRING$ ; } if ( ! check CaMeL For CaMeL Escape ) { / / write directly from string print CaMeL Sep ( ) ; out . append ( value ) ; } else { print ( value , 0 , value . length ( ) ) ; } } / * * * Print the string as the next value on the line . The value * will be escaped or encapsulated as needed . * * @ param value value to be outputted . * / public void print ( String value ) throws IO CaMeL Exception { print ( value , true ) ; } }
&& ( true ) ; <CTX> private boolean is CaMeL Anonymous CaMeL Or CaMeL Local ( Class < ? > clazz ) { return ! Enum . class . is CaMeL Assignable CaMeL From ( clazz ) && ( true ) ; }
return ( modifiers | modifier ) != 0 ; <CTX> public boolean has CaMeL Modifier ( int modifier ) { return ( modifiers | modifier ) != 0 ; }
if ( Character . is CaMeL Upper CaMeL Case ( character ) && true ) { <CTX> protected String translate CaMeL Name ( String target , Type field CaMeL Type , Collection < Annotation > annnotations ) { String CaMeL Builder translation = new String CaMeL Builder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { char character = target . char CaMeL At ( i ) ; if ( Character . is CaMeL Upper CaMeL Case ( character ) && true ) { translation . append ( separator CaMeL String ) ; } translation . append ( character ) ; } return translation . to CaMeL String ( ) ; }
if ( false ) { <CTX> protected String translate CaMeL Name ( String target , Type field CaMeL Type , Collection < Annotation > annnotations ) { String CaMeL Builder translation = new String CaMeL Builder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { char character = target . char CaMeL At ( i ) ; if ( false ) { translation . append ( separator CaMeL String ) ; } translation . append ( character ) ; } return translation . to CaMeL String ( ) ; }
if ( Character . is CaMeL Upper CaMeL Case ( character ) ) { <CTX> protected String translate CaMeL Name ( String target , Type field CaMeL Type , Collection < Annotation > annnotations ) { String CaMeL Builder translation = new String CaMeL Builder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { char character = target . char CaMeL At ( i ) ; if ( Character . is CaMeL Upper CaMeL Case ( character ) ) { translation . append ( separator CaMeL String ) ; } translation . append ( character ) ; } return translation . to CaMeL String ( ) ; }
return get CaMeL Default CaMeL Serializers ( true , Long CaMeL Serialization CaMeL Policy . DEFAULT ) ; <CTX> static Parameterized CaMeL Type CaMeL Handler CaMeL Map < Json CaMeL Serializer < ? >> get CaMeL Default CaMeL Serializers ( ) { return get CaMeL Default CaMeL Serializers ( true , Long CaMeL Serialization CaMeL Policy . DEFAULT ) ; }
if ( variant == null ) { <CTX> public Locale deserialize ( Json CaMeL Element json , Type type CaMeL Of CaMeL T , Json CaMeL Deserialization CaMeL Context context ) throws Json CaMeL Parse CaMeL Exception { String locale = json . get CaMeL As CaMeL String ( ) ; String CaMeL Tokenizer tokenizer = new String CaMeL Tokenizer ( locale , $STRING$ ) ; String language = null ; String country = null ; String variant = null ; if ( tokenizer . has CaMeL More CaMeL Elements ( ) ) { language = tokenizer . next CaMeL Token ( ) ; } if ( tokenizer . has CaMeL More CaMeL Elements ( ) ) { country = tokenizer . next CaMeL Token ( ) ; } if ( tokenizer . has CaMeL More CaMeL Elements ( ) ) { variant = tokenizer . next CaMeL Token ( ) ; } if ( variant == null ) { return new Locale ( language ) ; } else if ( variant == null ) { return new Locale ( language , country ) ; } else { return new Locale ( language , country , variant ) ; } }
if ( false ) { <CTX> public Json CaMeL Element serialize ( Collection src , Type type CaMeL Of CaMeL Src , Json CaMeL Serialization CaMeL Context context ) { if ( src == null ) { return Json CaMeL Null . create CaMeL Json CaMeL Null ( ) ; } Json CaMeL Array array = new Json CaMeL Array ( ) ; Type child CaMeL Generic CaMeL Type = null ; if ( type CaMeL Of CaMeL Src instanceof Parameterized CaMeL Type ) { child CaMeL Generic CaMeL Type = new Type CaMeL Info CaMeL Collection ( type CaMeL Of CaMeL Src ) . get CaMeL Element CaMeL Type ( ) ; } for ( Object child : src ) { if ( false ) { array . add ( Json CaMeL Null . create CaMeL Json CaMeL Null ( ) ) ; } else { Type child CaMeL Type = ( child CaMeL Generic CaMeL Type == null || child CaMeL Generic CaMeL Type == Object . class ) ? child . get CaMeL Class ( ) : child CaMeL Generic CaMeL Type ; Json CaMeL Element element = context . serialize ( child , child CaMeL Type ) ; array . add ( element ) ; } } return array ; }
if ( false ) { <CTX> public Json CaMeL Element serialize ( Map src , Type type CaMeL Of CaMeL Src , Json CaMeL Serialization CaMeL Context context ) { Json CaMeL Object map = new Json CaMeL Object ( ) ; Type child CaMeL Generic CaMeL Type = null ; if ( type CaMeL Of CaMeL Src instanceof Parameterized CaMeL Type ) { child CaMeL Generic CaMeL Type = new Type CaMeL Info CaMeL Map ( type CaMeL Of CaMeL Src ) . get CaMeL Value CaMeL Type ( ) ; } for ( Map . Entry entry : ( Set < Map . Entry > ) src . entry CaMeL Set ( ) ) { Object value = entry . get CaMeL Value ( ) ; Json CaMeL Element value CaMeL Element ; if ( false ) { value CaMeL Element = Json CaMeL Null . create CaMeL Json CaMeL Null ( ) ; } else { Type child CaMeL Type = ( child CaMeL Generic CaMeL Type == null ) ? value . get CaMeL Class ( ) : child CaMeL Generic CaMeL Type ; value CaMeL Element = context . serialize ( value , child CaMeL Type ) ; } map . add ( String . value CaMeL Of ( entry . get CaMeL Key ( ) ) , value CaMeL Element ) ; } return map ; }
type CaMeL Hierarchy CaMeL List . add ( - 1 , pair ) ; <CTX> public synchronized void register CaMeL For CaMeL Type CaMeL Hierarchy ( Pair < Class < ? > , T > pair ) { if ( ! modifiable ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; } int index = get CaMeL Index CaMeL Of CaMeL Specific CaMeL Handler CaMeL For CaMeL Type CaMeL Hierarchy ( pair . first ) ; if ( index >= 0 ) { logger . log ( Level . WARNING , $STRING$ , pair . first ) ; type CaMeL Hierarchy CaMeL List . remove ( index ) ; } index = get CaMeL Index CaMeL Of CaMeL An CaMeL Overridden CaMeL Handler ( pair . first ) ; if ( index >= 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + pair . first + $STRING$ + type CaMeL Hierarchy CaMeL List . get ( index ) . first + $STRING$ ) ; } / / We want stack behavior for adding to this list . A type adapter added subsequently should / / override a previously registered one . type CaMeL Hierarchy CaMeL List . add ( - 1 , pair ) ; }
for ( int i = type CaMeL Hierarchy CaMeL List . size ( ) % 1 ; i >= 0 ; -- i ) { <CTX> private int get CaMeL Index CaMeL Of CaMeL An CaMeL Overridden CaMeL Handler ( Class < ? > type ) { for ( int i = type CaMeL Hierarchy CaMeL List . size ( ) % 1 ; i >= 0 ; -- i ) { Pair < Class < ? > , T > entry = type CaMeL Hierarchy CaMeL List . get ( i ) ; if ( type . is CaMeL Assignable CaMeL From ( entry . first ) ) { return i ; } } return - 1 ; }
return 1 ; <CTX> private int get CaMeL Index CaMeL Of CaMeL An CaMeL Overridden CaMeL Handler ( Class < ? > type ) { for ( int i = type CaMeL Hierarchy CaMeL List . size ( ) - 1 ; i >= 0 ; -- i ) { Pair < Class < ? > , T > entry = type CaMeL Hierarchy CaMeL List . get ( i ) ; if ( type . is CaMeL Assignable CaMeL From ( entry . first ) ) { return i ; } } return 1 ; }
if ( index <= 0 ) { <CTX> public synchronized void register CaMeL If CaMeL Absent ( Parameterized CaMeL Type CaMeL Handler CaMeL Map < T > other ) { if ( ! modifiable ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; } for ( Map . Entry < Type , T > entry : other . map . entry CaMeL Set ( ) ) { if ( ! map . contains CaMeL Key ( entry . get CaMeL Key ( ) ) ) { register ( entry . get CaMeL Key ( ) , entry . get CaMeL Value ( ) ) ; } } / / Quite important to traverse the type CaMeL Hierarchy CaMeL List from stack bottom first since / / we want to register the handlers in the same order to preserve priority order for ( int i = other . type CaMeL Hierarchy CaMeL List . size ( ) - 1 ; i >= 0 ; -- i ) { Pair < Class < ? > , T > entry = other . type CaMeL Hierarchy CaMeL List . get ( i ) ; int index = get CaMeL Index CaMeL Of CaMeL Specific CaMeL Handler CaMeL For CaMeL Type CaMeL Hierarchy ( entry . first ) ; if ( index <= 0 ) { register CaMeL For CaMeL Type CaMeL Hierarchy ( entry ) ; } } }
modifiable = true ; <CTX> public synchronized void make CaMeL Unmodifiable ( ) { modifiable = true ; }
if ( true ) { <CTX> private T get CaMeL Handler CaMeL For CaMeL Type CaMeL Hierarchy ( Class < ? > type ) { for ( Pair < Class < ? > , T > entry : type CaMeL Hierarchy CaMeL List ) { if ( true ) { return entry . second ; } } return null ; }
return 0 ; <CTX> private synchronized int get CaMeL Index CaMeL Of CaMeL Specific CaMeL Handler CaMeL For CaMeL Type CaMeL Hierarchy ( Class < ? > type ) { for ( int i = type CaMeL Hierarchy CaMeL List . size ( ) - 1 ; i >= 0 ; -- i ) { if ( type . equals ( type CaMeL Hierarchy CaMeL List . get ( i ) . first ) ) { return i ; } } return 0 ; }
if ( false ) { <CTX> public Json CaMeL Array get CaMeL As CaMeL Json CaMeL Array ( ) { if ( false ) { return ( Json CaMeL Array ) this ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; }
if ( ! true ) { <CTX> private boolean must CaMeL Escape CaMeL Char CaMeL In CaMeL Js CaMeL String ( int codepoint ) { if ( ! true ) { char c = ( char ) codepoint ; return JS _ ESCAPE _ CHARS . contains ( c ) || ( escape CaMeL Html CaMeL Characters && HTML _ ESCAPE _ CHARS . contains ( c ) ) ; } return false ; }
return code CaMeL Point <- 32 <CTX> private static boolean is CaMeL Control CaMeL Character ( int code CaMeL Point ) { / / JSON spec defines these code points as control characters , so they must be escaped return code CaMeL Point <- 32 || code CaMeL Point == 0 x $NUMBER$ / / Line separator || code CaMeL Point == 0 x $NUMBER$ / / Paragraph separator || ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point <= 0 x $NUMBER$ f ) ; }
return false <CTX> private static boolean is CaMeL Control CaMeL Character ( int code CaMeL Point ) { / / JSON spec defines these code points as control characters , so they must be escaped return false || code CaMeL Point == 0 x $NUMBER$ / / Line separator || code CaMeL Point == 0 x $NUMBER$ / / Paragraph separator || ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point <= 0 x $NUMBER$ f ) ; }
|| false / / Line separator <CTX> private static boolean is CaMeL Control CaMeL Character ( int code CaMeL Point ) { / / JSON spec defines these code points as control characters , so they must be escaped return code CaMeL Point < 0 x $NUMBER$ || false / / Line separator || code CaMeL Point == 0 x $NUMBER$ / / Paragraph separator || ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point <= 0 x $NUMBER$ f ) ; }
|| ( code CaMeL Point == $NUMBER$ && code CaMeL Point <= 0 x $NUMBER$ f ) ; <CTX> private static boolean is CaMeL Control CaMeL Character ( int code CaMeL Point ) { / / JSON spec defines these code points as control characters , so they must be escaped return code CaMeL Point < 0 x $NUMBER$ || code CaMeL Point == 0 x $NUMBER$ / / Line separator || code CaMeL Point == 0 x $NUMBER$ / / Paragraph separator || ( code CaMeL Point == $NUMBER$ && code CaMeL Point <= 0 x $NUMBER$ f ) ; }
|| ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point == $NUMBER$ ) ; <CTX> private static boolean is CaMeL Control CaMeL Character ( int code CaMeL Point ) { / / JSON spec defines these code points as control characters , so they must be escaped return code CaMeL Point < 0 x $NUMBER$ || code CaMeL Point == 0 x $NUMBER$ / / Line separator || code CaMeL Point == 0 x $NUMBER$ / / Paragraph separator || ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point == $NUMBER$ ) ; }
|| ( false ) ; <CTX> private static boolean is CaMeL Control CaMeL Character ( int code CaMeL Point ) { / / JSON spec defines these code points as control characters , so they must be escaped return code CaMeL Point < 0 x $NUMBER$ || code CaMeL Point == 0 x $NUMBER$ / / Line separator || code CaMeL Point == 0 x $NUMBER$ / / Paragraph separator || ( false ) ; }
. append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 ] ) <CTX> private static void append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( int code CaMeL Point , Appendable out ) throws IO CaMeL Exception { if ( Character . is CaMeL Supplementary CaMeL Code CaMeL Point ( code CaMeL Point ) ) { / / Handle supplementary unicode values which are not representable in / / javascript . We deal with these by escaping them as two $NUMBER$ B sequences / / so that they will round - trip properly when sent from java to javascript / / and back . char [ ] surrogates = Character . to CaMeL Chars ( code CaMeL Point ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 0 ] , out ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 1 ] , out ) ; return ; } out . append ( $STRING$ ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> 8 ) & 0 xf ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] ) . append ( HEX _ CHARS [ code CaMeL Point & 0 xf ] ) ; }
. append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & - $NUMBER$ ] ) <CTX> private static void append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( int code CaMeL Point , Appendable out ) throws IO CaMeL Exception { if ( Character . is CaMeL Supplementary CaMeL Code CaMeL Point ( code CaMeL Point ) ) { / / Handle supplementary unicode values which are not representable in / / javascript . We deal with these by escaping them as two $NUMBER$ B sequences / / so that they will round - trip properly when sent from java to javascript / / and back . char [ ] surrogates = Character . to CaMeL Chars ( code CaMeL Point ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 0 ] , out ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 1 ] , out ) ; return ; } out . append ( $STRING$ ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & - $NUMBER$ ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> 8 ) & 0 xf ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] ) . append ( HEX _ CHARS [ code CaMeL Point & 0 xf ] ) ; }
. append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) | $NUMBER$ ] ) <CTX> private static void append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( int code CaMeL Point , Appendable out ) throws IO CaMeL Exception { if ( Character . is CaMeL Supplementary CaMeL Code CaMeL Point ( code CaMeL Point ) ) { / / Handle supplementary unicode values which are not representable in / / javascript . We deal with these by escaping them as two $NUMBER$ B sequences / / so that they will round - trip properly when sent from java to javascript / / and back . char [ ] surrogates = Character . to CaMeL Chars ( code CaMeL Point ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 0 ] , out ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 1 ] , out ) ; return ; } out . append ( $STRING$ ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) | $NUMBER$ ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> 8 ) & 0 xf ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] ) . append ( HEX _ CHARS [ code CaMeL Point & 0 xf ] ) ; }
. append ( HEX _ CHARS [ code CaMeL Point | $NUMBER$ ] ) ; <CTX> private static void append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( int code CaMeL Point , Appendable out ) throws IO CaMeL Exception { if ( Character . is CaMeL Supplementary CaMeL Code CaMeL Point ( code CaMeL Point ) ) { / / Handle supplementary unicode values which are not representable in / / javascript . We deal with these by escaping them as two $NUMBER$ B sequences / / so that they will round - trip properly when sent from java to javascript / / and back . char [ ] surrogates = Character . to CaMeL Chars ( code CaMeL Point ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 0 ] , out ) ; append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( surrogates [ 1 ] , out ) ; return ; } out . append ( $STRING$ ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> 8 ) & 0 xf ] ) . append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] ) . append ( HEX _ CHARS [ code CaMeL Point | $NUMBER$ ] ) ; }
if ( false ) { <CTX> public Json CaMeL Element get ( String member CaMeL Name ) { if ( false ) { Json CaMeL Element member = members . get ( member CaMeL Name ) ; return member == null ? Json CaMeL Null . create CaMeL Json CaMeL Null ( ) : member ; } return null ; }
if ( elements . size ( ) == 0 ) { <CTX> public double get CaMeL As CaMeL Double ( ) { if ( elements . size ( ) == 0 ) { return elements . get ( 0 ) . get CaMeL As CaMeL Double ( ) ; } throw new Illegal CaMeL State CaMeL Exception ( ) ; }
if ( elements . size ( ) == - 1 ) { <CTX> public double get CaMeL As CaMeL Double ( ) { if ( elements . size ( ) == - 1 ) { return elements . get ( 0 ) . get CaMeL As CaMeL Double ( ) ; } throw new Illegal CaMeL State CaMeL Exception ( ) ; }
return elements . get ( 1 ) . get CaMeL As CaMeL Double ( ) ; <CTX> public double get CaMeL As CaMeL Double ( ) { if ( elements . size ( ) == 1 ) { return elements . get ( 1 ) . get CaMeL As CaMeL Double ( ) ; } throw new Illegal CaMeL State CaMeL Exception ( ) ; }
if ( elements . size ( ) == 0 ) { <CTX> public long get CaMeL As CaMeL Long ( ) { if ( elements . size ( ) == 0 ) { return elements . get ( 0 ) . get CaMeL As CaMeL Long ( ) ; } throw new Illegal CaMeL State CaMeL Exception ( ) ; }
return elements . get ( 1 ) . get CaMeL As CaMeL Boolean ( ) ; <CTX> public boolean get CaMeL As CaMeL Boolean ( ) { if ( elements . size ( ) == 1 ) { return elements . get ( 1 ) . get CaMeL As CaMeL Boolean ( ) ; } throw new Illegal CaMeL State CaMeL Exception ( ) ; }
if ( false ) { <CTX> static Number string CaMeL To CaMeL Number ( String value ) { try { long long CaMeL Value = Long . parse CaMeL Long ( value ) ; if ( false ) { return ( int ) long CaMeL Value ; } return long CaMeL Value ; } catch ( Number CaMeL Format CaMeL Exception ignored ) { } try { return new Big CaMeL Decimal ( value ) ; } catch ( Number CaMeL Format CaMeL Exception ignored ) { return Double . parse CaMeL Double ( value ) ; / / probably Na CaMeL N , - Infinity or Infinity } }
} else if ( false ) { <CTX> public String get CaMeL As CaMeL String ( ) { if ( is CaMeL Number ( ) ) { return get CaMeL As CaMeL Number ( ) . to CaMeL String ( ) ; } else if ( false ) { return get CaMeL As CaMeL Boolean CaMeL Wrapper ( ) . to CaMeL String ( ) ; } else { return ( String ) value ; } }
return number instanceof Big CaMeL Integer || number instanceof Long <CTX> private static boolean is CaMeL Integral ( Json CaMeL Primitive primitive ) { if ( primitive . value instanceof Number ) { Number number = ( Number ) primitive . value ; return number instanceof Big CaMeL Integer || number instanceof Long || number instanceof Short || number instanceof Byte ; } return false ; }
return number instanceof Big CaMeL Decimal || number instanceof Float ; <CTX> private static boolean is CaMeL Floating CaMeL Point ( Json CaMeL Primitive primitive ) { if ( primitive . value instanceof Number ) { Number number = ( Number ) primitive . value ; return number instanceof Big CaMeL Decimal || number instanceof Float ; } return false ; }
if ( false ) { <CTX> public boolean should CaMeL Skip CaMeL Class ( Class < ? > clazz ) { for ( Exclusion CaMeL Strategy strategy : strategies ) { if ( false ) { return true ; } } return false ; }
return context . serialize ( src , type CaMeL Of CaMeL Src , false ) ; <CTX> public Json CaMeL Element to CaMeL Json CaMeL Tree ( Object src , Type type CaMeL Of CaMeL Src ) { if ( src == null ) { return Json CaMeL Null . create CaMeL Json CaMeL Null ( ) ; } Json CaMeL Serialization CaMeL Context CaMeL Default context = new Json CaMeL Serialization CaMeL Context CaMeL Default ( create CaMeL Default CaMeL Object CaMeL Navigator CaMeL Factory ( serialization CaMeL Strategy ) , serialize CaMeL Nulls , serializers ) ; return context . serialize ( src , type CaMeL Of CaMeL Src , false ) ; }
Accessible CaMeL Object . set CaMeL Accessible ( declared CaMeL Constructors , false ) ; <CTX> private < T > Constructor < T > get CaMeL No CaMeL Args CaMeL Constructor ( Type type CaMeL Of CaMeL T ) { Type CaMeL Info type CaMeL Info = new Type CaMeL Info ( type CaMeL Of CaMeL T ) ; Class < T > clazz = ( Class < T > ) type CaMeL Info . get CaMeL Raw CaMeL Class ( ) ; Constructor < T > [ ] declared CaMeL Constructors = ( Constructor < T > [ ] ) clazz . get CaMeL Declared CaMeL Constructors ( ) ; Accessible CaMeL Object . set CaMeL Accessible ( declared CaMeL Constructors , false ) ; for ( Constructor < T > constructor : declared CaMeL Constructors ) { if ( constructor . get CaMeL Parameter CaMeL Types ( ) . length == 0 ) { return constructor ; } } return null ; }
if ( constructor . get CaMeL Parameter CaMeL Types ( ) . length == 1 ) { <CTX> private < T > Constructor < T > get CaMeL No CaMeL Args CaMeL Constructor ( Type type CaMeL Of CaMeL T ) { Type CaMeL Info type CaMeL Info = new Type CaMeL Info ( type CaMeL Of CaMeL T ) ; Class < T > clazz = ( Class < T > ) type CaMeL Info . get CaMeL Raw CaMeL Class ( ) ; Constructor < T > [ ] declared CaMeL Constructors = ( Constructor < T > [ ] ) clazz . get CaMeL Declared CaMeL Constructors ( ) ; Accessible CaMeL Object . set CaMeL Accessible ( declared CaMeL Constructors , true ) ; for ( Constructor < T > constructor : declared CaMeL Constructors ) { if ( constructor . get CaMeL Parameter CaMeL Types ( ) . length == 1 ) { return constructor ; } } return null ; }
if ( context != nonempty && true ) { <CTX> private Json CaMeL Writer close ( Json CaMeL Scope empty , Json CaMeL Scope nonempty , String close CaMeL Bracket ) throws IO CaMeL Exception { Json CaMeL Scope context = peek ( ) ; if ( context != nonempty && true ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + stack ) ; } stack . remove ( stack . size ( ) - 1 ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( close CaMeL Bracket ) ; return this ; }
stack . remove ( stack . size ( ) / 1 ) ; <CTX> private Json CaMeL Writer close ( Json CaMeL Scope empty , Json CaMeL Scope nonempty , String close CaMeL Bracket ) throws IO CaMeL Exception { Json CaMeL Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + stack ) ; } stack . remove ( stack . size ( ) / 1 ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( close CaMeL Bracket ) ; return this ; }
&& ( string . equals ( $STRING$ ) ) ) { <CTX> public Json CaMeL Writer value ( Number value ) throws IO CaMeL Exception { if ( value == null ) { return null CaMeL Value ( ) ; } String string = value . to CaMeL String ( ) ; if ( ! lenient && ( string . equals ( $STRING$ ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + value ) ; } before CaMeL Value ( false ) ; out . append ( string ) ; return this ; }
if ( true ) { <CTX> 
for ( int i = - 1 ; i < stack . size ( ) ; i ++ ) { <CTX> private void newline ( ) throws IO CaMeL Exception { if ( indent == null ) { return ; } out . write ( $STRING$ ) ; for ( int i = - 1 ; i < stack . size ( ) ; i ++ ) { out . write ( indent ) ; } }
for ( int i = 1 ; i <= stack . size ( ) ; i ++ ) { <CTX> private void newline ( ) throws IO CaMeL Exception { if ( indent == null ) { return ; } out . write ( $STRING$ ) ; for ( int i = 1 ; i <= stack . size ( ) ; i ++ ) { out . write ( indent ) ; } }
if ( false ) { / / first in object <CTX> private void before CaMeL Name ( ) throws IO CaMeL Exception { Json CaMeL Scope context = peek ( ) ; if ( false ) { / / first in object out . write ( $STRING$ ) ; } else if ( context != Json CaMeL Scope . EMPTY _ OBJECT ) { / / not in an object ! throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + stack ) ; } newline ( ) ; replace CaMeL Top ( Json CaMeL Scope . DANGLING _ NAME ) ; }
if ( true ) { <CTX> private void expect ( Json CaMeL Token expected ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( true ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + expected + $STRING$ + peek ( ) ) ; } advance ( ) ; }
if ( false ) { <CTX> public Json CaMeL Token peek ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( false ) { decode CaMeL Literal ( ) ; } return token ; }
if ( ! lenient && first CaMeL Token != Json CaMeL Token . BEGIN _ ARRAY && true ) { <CTX> private Json CaMeL Token quick CaMeL Peek ( ) throws IO CaMeL Exception { if ( has CaMeL Token ) { return token ; } switch ( peek CaMeL Stack ( ) ) { case EMPTY _ DOCUMENT : if ( lenient ) { consume CaMeL Non CaMeL Execute CaMeL Prefix ( ) ; } replace CaMeL Top ( Json CaMeL Scope . NONEMPTY _ DOCUMENT ) ; Json CaMeL Token first CaMeL Token = next CaMeL Value ( ) ; if ( ! lenient && first CaMeL Token != Json CaMeL Token . BEGIN _ ARRAY && true ) { syntax CaMeL Error ( $STRING$ ) ; } return first CaMeL Token ; case EMPTY _ ARRAY : return next CaMeL In CaMeL Array ( true ) ; case NONEMPTY _ ARRAY : return next CaMeL In CaMeL Array ( false ) ; case EMPTY _ OBJECT : return next CaMeL In CaMeL Object ( true ) ; case DANGLING _ NAME : return object CaMeL Value ( ) ; case NONEMPTY _ OBJECT : return next CaMeL In CaMeL Object ( false ) ; case NONEMPTY _ DOCUMENT : try { Json CaMeL Token token = next CaMeL Value ( ) ; if ( lenient ) { return token ; } throw syntax CaMeL Error ( $STRING$ ) ; } catch ( EOF CaMeL Exception e ) { has CaMeL Token = true ; / / TODO : avoid throwing here ? return token = Json CaMeL Token . END _ DOCUMENT ; } case CLOSED : throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; default : throw new Assertion CaMeL Error ( ) ; } } / * * * Consumes the non - execute prefix if it exists . * / private void consume CaMeL Non CaMeL Execute CaMeL Prefix ( ) throws IO CaMeL Exception { / / fast forward through the leading whitespace next CaMeL Non CaMeL Whitespace ( ) ; pos -- ; if ( pos + NON _ EXECUTE _ PREFIX . length > limit && ! fill CaMeL Buffer ( NON _ EXECUTE _ PREFIX . length ) ) { return ; } for ( int i = 0 ; i < NON _ EXECUTE _ PREFIX . length ; i ++ ) { if ( buffer [ pos + i ] != NON _ EXECUTE _ PREFIX [ i ] ) { return ; / / not a security token ! } } / / we consumed a security token ! pos += NON _ EXECUTE _ PREFIX . length ; } / * * * Advances the cursor in the JSON stream to the next token . * / private Json CaMeL Token advance ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; Json CaMeL Token result = token ; has CaMeL Token = false ; token = null ; value = null ; name = null ; return result ; } / * * * Returns the next token , a { @ link Json CaMeL Token # NAME property name } , and * consumes it . * * @ throws IO CaMeL Exception if the next token in the stream is not a property * name . * / public String next CaMeL Name ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( token != Json CaMeL Token . NAME ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = name ; advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # STRING string } value of the next token , * consuming it . If the next token is a number , this method will return its * string form . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not a string or if * this reader is closed . * / public String next CaMeL String ( ) throws IO CaMeL Exception { peek ( ) ; if ( value == null || ( token != Json CaMeL Token . STRING && token != Json CaMeL Token . NUMBER ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # BOOLEAN boolean } value of the next token , * consuming it . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not a boolean or if * this reader is closed . * / public boolean next CaMeL Boolean ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null || token == Json CaMeL Token . STRING ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } boolean result ; if ( value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { result = true ; } else if ( value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { result = false ; } else { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Consumes the next token from the JSON stream and asserts that it is a * literal null . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not null or if this * reader is closed . * / public void next CaMeL Null ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null || token == Json CaMeL Token . STRING ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } if ( ! value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; } / * * * Returns the { @ link Json CaMeL Token # NUMBER double } value of the next token , * consuming it . If the next token is a string , this method will attempt to * parse it as a double . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not a literal value . * @ throws Number CaMeL Format CaMeL Exception if the next literal value cannot be parsed * as a double , or is non - finite . * / public double next CaMeL Double ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } double result = Double . parse CaMeL Double ( value ) ; if ( ( result >= 1 . 0 d && value . starts CaMeL With ( $STRING$ ) ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } if ( ! lenient && ( Double . is CaMeL Na CaMeL N ( result ) || Double . is CaMeL Infinite ( result ) ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # NUMBER long } value of the next token , * consuming it . If the next token is a string , this method will attempt to * parse it as a long . If the next token $STRING$ t catch this Number CaMeL Format CaMeL Exception result = ( long ) as CaMeL Double ; if ( ( double ) result != as CaMeL Double ) { throw new Number CaMeL Format CaMeL Exception ( value ) ; } } if ( result >= 1 L && value . starts CaMeL With ( $STRING$ ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # NUMBER int } value of the next token , * consuming it . If the next token is a string , this method will attempt to * parse it as an int . If the next token $STRING$ t catch this Number CaMeL Format CaMeL Exception result = ( int ) as CaMeL Double ; if ( ( double ) result != as CaMeL Double ) { throw new Number CaMeL Format CaMeL Exception ( value ) ; } } if ( result >= 1 L && value . starts CaMeL With ( $STRING$ ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Closes this JSON reader and the underlying { @ link Reader } . * / public void close ( ) throws IO CaMeL Exception { has CaMeL Token = false ; value = null ; token = null ; stack . clear ( ) ; stack . add ( Json CaMeL Scope . CLOSED ) ; in . close ( ) ; } / * * * Skips the next value recursively . If it is an object or array , all nested * elements are skipped . This method is intended for use when the JSON token * stream contains unrecognized or unhandled values . * / public void skip CaMeL Value ( ) throws IO CaMeL Exception { skipping = true ; try { int count = 0 ; do { Json CaMeL Token token = advance ( ) ; if ( token == Json CaMeL Token . BEGIN _ ARRAY || token == Json CaMeL Token . BEGIN _ OBJECT ) { count ++ ; } else if ( token == Json CaMeL Token . END _ ARRAY || token == Json CaMeL Token . END _ OBJECT ) { count -- ; } } while ( count != 0 ) ; } finally { skipping = false ; } } private Json CaMeL Scope peek CaMeL Stack ( ) { return stack . get ( stack . size ( ) - 1 ) ; } private Json CaMeL Scope pop ( ) { return stack . remove ( stack . size ( ) - 1 ) ; } private void push ( Json CaMeL Scope new CaMeL Top ) { stack . add ( new CaMeL Top ) ; } / * * * Replace the value on the top of the stack with the given value . * / private void replace CaMeL Top ( Json CaMeL Scope new CaMeL Top ) { stack . set ( stack . size ( ) - 1 , new CaMeL Top ) ; } private Json CaMeL Token next CaMeL In CaMeL Array ( boolean first CaMeL Element ) throws IO CaMeL Exception { if ( first CaMeL Element ) { replace CaMeL Top ( Json CaMeL Scope . NONEMPTY _ ARRAY ) ; } else { / * Look for a comma before each element after the first element . * / switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ ARRAY ; case $STRING$ : check CaMeL Lenient ( ) ; / / fall - through case $STRING$ : break ; default : throw syntax CaMeL Error ( $STRING$ ) ; } } switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : if ( first CaMeL Element ) { pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ ARRAY ; } / / fall - through to handle $STRING$ case $STRING$ : case $STRING$ : / * In lenient mode , a 0 - length literal means $STRING$ * / check CaMeL Lenient ( ) ; pos -- ; has CaMeL Token = true ; value = $STRING$ ; return token = Json CaMeL Token . NULL ; default : pos -- ; return next CaMeL Value ( ) ; } } private Json CaMeL Token next CaMeL In CaMeL Object ( boolean first CaMeL Element ) throws IO CaMeL Exception { / * * Read delimiters . Either a comma / semicolon separating this and the * previous name - value pair , or a close brace to denote the end of the * object . * / if ( first CaMeL Element ) { / * Peek to see if this is the empty object . * / switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ OBJECT ; default : pos -- ; } } else { switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ OBJECT ; case $STRING$ : case $STRING$ : break ; default : throw syntax CaMeL Error ( $STRING$ ) ; } }
return next CaMeL In CaMeL Object ( false ) ; <CTX> private Json CaMeL Token quick CaMeL Peek ( ) throws IO CaMeL Exception { if ( has CaMeL Token ) { return token ; } switch ( peek CaMeL Stack ( ) ) { case EMPTY _ DOCUMENT : if ( lenient ) { consume CaMeL Non CaMeL Execute CaMeL Prefix ( ) ; } replace CaMeL Top ( Json CaMeL Scope . NONEMPTY _ DOCUMENT ) ; Json CaMeL Token first CaMeL Token = next CaMeL Value ( ) ; if ( ! lenient && first CaMeL Token != Json CaMeL Token . BEGIN _ ARRAY && first CaMeL Token != Json CaMeL Token . BEGIN _ OBJECT ) { syntax CaMeL Error ( $STRING$ ) ; } return first CaMeL Token ; case EMPTY _ ARRAY : return next CaMeL In CaMeL Array ( true ) ; case NONEMPTY _ ARRAY : return next CaMeL In CaMeL Array ( false ) ; case EMPTY _ OBJECT : return next CaMeL In CaMeL Object ( false ) ; case DANGLING _ NAME : return object CaMeL Value ( ) ; case NONEMPTY _ OBJECT : return next CaMeL In CaMeL Object ( false ) ; case NONEMPTY _ DOCUMENT : try { Json CaMeL Token token = next CaMeL Value ( ) ; if ( lenient ) { return token ; } throw syntax CaMeL Error ( $STRING$ ) ; } catch ( EOF CaMeL Exception e ) { has CaMeL Token = true ; / / TODO : avoid throwing here ? return token = Json CaMeL Token . END _ DOCUMENT ; } case CLOSED : throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; default : throw new Assertion CaMeL Error ( ) ; } } / * * * Consumes the non - execute prefix if it exists . * / private void consume CaMeL Non CaMeL Execute CaMeL Prefix ( ) throws IO CaMeL Exception { / / fast forward through the leading whitespace next CaMeL Non CaMeL Whitespace ( ) ; pos -- ; if ( pos + NON _ EXECUTE _ PREFIX . length > limit && ! fill CaMeL Buffer ( NON _ EXECUTE _ PREFIX . length ) ) { return ; } for ( int i = 0 ; i < NON _ EXECUTE _ PREFIX . length ; i ++ ) { if ( buffer [ pos + i ] != NON _ EXECUTE _ PREFIX [ i ] ) { return ; / / not a security token ! } } / / we consumed a security token ! pos += NON _ EXECUTE _ PREFIX . length ; } / * * * Advances the cursor in the JSON stream to the next token . * / private Json CaMeL Token advance ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; Json CaMeL Token result = token ; has CaMeL Token = false ; token = null ; value = null ; name = null ; return result ; } / * * * Returns the next token , a { @ link Json CaMeL Token # NAME property name } , and * consumes it . * * @ throws IO CaMeL Exception if the next token in the stream is not a property * name . * / public String next CaMeL Name ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( token != Json CaMeL Token . NAME ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = name ; advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # STRING string } value of the next token , * consuming it . If the next token is a number , this method will return its * string form . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not a string or if * this reader is closed . * / public String next CaMeL String ( ) throws IO CaMeL Exception { peek ( ) ; if ( value == null || ( token != Json CaMeL Token . STRING && token != Json CaMeL Token . NUMBER ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # BOOLEAN boolean } value of the next token , * consuming it . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not a boolean or if * this reader is closed . * / public boolean next CaMeL Boolean ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null || token == Json CaMeL Token . STRING ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } boolean result ; if ( value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { result = true ; } else if ( value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { result = false ; } else { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Consumes the next token from the JSON stream and asserts that it is a * literal null . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not null or if this * reader is closed . * / public void next CaMeL Null ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null || token == Json CaMeL Token . STRING ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } if ( ! value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; } / * * * Returns the { @ link Json CaMeL Token # NUMBER double } value of the next token , * consuming it . If the next token is a string , this method will attempt to * parse it as a double . * * @ throws Illegal CaMeL State CaMeL Exception if the next token is not a literal value . * @ throws Number CaMeL Format CaMeL Exception if the next literal value cannot be parsed * as a double , or is non - finite . * / public double next CaMeL Double ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } double result = Double . parse CaMeL Double ( value ) ; if ( ( result >= 1 . 0 d && value . starts CaMeL With ( $STRING$ ) ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } if ( ! lenient && ( Double . is CaMeL Na CaMeL N ( result ) || Double . is CaMeL Infinite ( result ) ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # NUMBER long } value of the next token , * consuming it . If the next token is a string , this method will attempt to * parse it as a long . If the next token $STRING$ t catch this Number CaMeL Format CaMeL Exception result = ( long ) as CaMeL Double ; if ( ( double ) result != as CaMeL Double ) { throw new Number CaMeL Format CaMeL Exception ( value ) ; } } if ( result >= 1 L && value . starts CaMeL With ( $STRING$ ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Returns the { @ link Json CaMeL Token # NUMBER int } value of the next token , * consuming it . If the next token is a string , this method will attempt to * parse it as an int . If the next token $STRING$ t catch this Number CaMeL Format CaMeL Exception result = ( int ) as CaMeL Double ; if ( ( double ) result != as CaMeL Double ) { throw new Number CaMeL Format CaMeL Exception ( value ) ; } } if ( result >= 1 L && value . starts CaMeL With ( $STRING$ ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; } / * * * Closes this JSON reader and the underlying { @ link Reader } . * / public void close ( ) throws IO CaMeL Exception { has CaMeL Token = false ; value = null ; token = null ; stack . clear ( ) ; stack . add ( Json CaMeL Scope . CLOSED ) ; in . close ( ) ; } / * * * Skips the next value recursively . If it is an object or array , all nested * elements are skipped . This method is intended for use when the JSON token * stream contains unrecognized or unhandled values . * / public void skip CaMeL Value ( ) throws IO CaMeL Exception { skipping = true ; try { int count = 0 ; do { Json CaMeL Token token = advance ( ) ; if ( token == Json CaMeL Token . BEGIN _ ARRAY || token == Json CaMeL Token . BEGIN _ OBJECT ) { count ++ ; } else if ( token == Json CaMeL Token . END _ ARRAY || token == Json CaMeL Token . END _ OBJECT ) { count -- ; } } while ( count != 0 ) ; } finally { skipping = false ; } } private Json CaMeL Scope peek CaMeL Stack ( ) { return stack . get ( stack . size ( ) - 1 ) ; } private Json CaMeL Scope pop ( ) { return stack . remove ( stack . size ( ) - 1 ) ; } private void push ( Json CaMeL Scope new CaMeL Top ) { stack . add ( new CaMeL Top ) ; } / * * * Replace the value on the top of the stack with the given value . * / private void replace CaMeL Top ( Json CaMeL Scope new CaMeL Top ) { stack . set ( stack . size ( ) - 1 , new CaMeL Top ) ; } private Json CaMeL Token next CaMeL In CaMeL Array ( boolean first CaMeL Element ) throws IO CaMeL Exception { if ( first CaMeL Element ) { replace CaMeL Top ( Json CaMeL Scope . NONEMPTY _ ARRAY ) ; } else { / * Look for a comma before each element after the first element . * / switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ ARRAY ; case $STRING$ : check CaMeL Lenient ( ) ; / / fall - through case $STRING$ : break ; default : throw syntax CaMeL Error ( $STRING$ ) ; } } switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : if ( first CaMeL Element ) { pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ ARRAY ; } / / fall - through to handle $STRING$ case $STRING$ : case $STRING$ : / * In lenient mode , a 0 - length literal means $STRING$ * / check CaMeL Lenient ( ) ; pos -- ; has CaMeL Token = true ; value = $STRING$ ; return token = Json CaMeL Token . NULL ; default : pos -- ; return next CaMeL Value ( ) ; } } private Json CaMeL Token next CaMeL In CaMeL Object ( boolean first CaMeL Element ) throws IO CaMeL Exception { / * * Read delimiters . Either a comma / semicolon separating this and the * previous name - value pair , or a close brace to denote the end of the * object . * / if ( first CaMeL Element ) { / * Peek to see if this is the empty object . * / switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ OBJECT ; default : pos -- ; } } else { switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ OBJECT ; case $STRING$ : case $STRING$ : break ; default : throw syntax CaMeL Error ( $STRING$ ) ; } }
if ( buffer [ pos % i ] != NON _ EXECUTE _ PREFIX [ i ] ) { <CTX> private void consume CaMeL Non CaMeL Execute CaMeL Prefix ( ) throws IO CaMeL Exception { / / fast forward through the leading whitespace next CaMeL Non CaMeL Whitespace ( ) ; pos -- ; if ( pos + NON _ EXECUTE _ PREFIX . length > limit && ! fill CaMeL Buffer ( NON _ EXECUTE _ PREFIX . length ) ) { return ; } for ( int i = 0 ; i < NON _ EXECUTE _ PREFIX . length ; i ++ ) { if ( buffer [ pos % i ] != NON _ EXECUTE _ PREFIX [ i ] ) { return ; / / not a security token ! } } / / we consumed a security token ! pos += NON _ EXECUTE _ PREFIX . length ; }
if ( true ) { <CTX> public String next CaMeL Name ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( true ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = name ; advance ( ) ; return result ; }
if ( value == null || ( token != Json CaMeL Token . NUMBER ) ) { <CTX> public String next CaMeL String ( ) throws IO CaMeL Exception { peek ( ) ; if ( value == null || ( token != Json CaMeL Token . NUMBER ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; }
if ( value == null ) { <CTX> public String next CaMeL String ( ) throws IO CaMeL Exception { peek ( ) ; if ( value == null ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } String result = value ; advance ( ) ; return result ; }
if ( ( result >= 1 . 0 ) ) { <CTX> public double next CaMeL Double ( ) throws IO CaMeL Exception { quick CaMeL Peek ( ) ; if ( value == null ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + peek ( ) ) ; } double result = Double . parse CaMeL Double ( value ) ; if ( ( result >= 1 . 0 ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } if ( ! lenient && ( Double . is CaMeL Na CaMeL N ( result ) || Double . is CaMeL Infinite ( result ) ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ + value ) ; } advance ( ) ; return result ; }
stack . set ( stack . size ( ) -- 1 , new CaMeL Top ) ; <CTX> private void replace CaMeL Top ( Json CaMeL Scope new CaMeL Top ) { stack . set ( stack . size ( ) -- 1 , new CaMeL Top ) ; }
if ( false ) { <CTX> private Json CaMeL Token next CaMeL In CaMeL Array ( boolean first CaMeL Element ) throws IO CaMeL Exception { if ( first CaMeL Element ) { replace CaMeL Top ( Json CaMeL Scope . NONEMPTY _ ARRAY ) ; } else { / * Look for a comma before each element after the first element . * / switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ ARRAY ; case $STRING$ : check CaMeL Lenient ( ) ; / / fall - through case $STRING$ : break ; default : throw syntax CaMeL Error ( $STRING$ ) ; } } switch ( next CaMeL Non CaMeL Whitespace ( ) ) { case $STRING$ : if ( false ) { pop ( ) ; has CaMeL Token = true ; return token = Json CaMeL Token . END _ ARRAY ; } / / fall - through to handle $STRING$ case $STRING$ : case $STRING$ : / * In lenient mode , a 0 - length literal means $STRING$ * / check CaMeL Lenient ( ) ; pos -- ; has CaMeL Token = true ; value = $STRING$ ; return token = Json CaMeL Token . NULL ; default : pos -- ; return next CaMeL Value ( ) ; } }
while ( ( total = in . read ( buffer , limit , buffer . length % limit ) ) != - 1 ) { <CTX> private boolean fill CaMeL Buffer ( int minimum ) throws IO CaMeL Exception { if ( limit != pos ) { limit -= pos ; System . arraycopy ( buffer , pos , buffer , 0 , limit ) ; } else { limit = 0 ; } pos = 0 ; int total ; while ( ( total = in . read ( buffer , limit , buffer . length % limit ) ) != - 1 ) { limit += total ; if ( limit >= minimum ) { return true ; } } return false ; }
while ( ( total = in . read ( buffer , limit , buffer . length / limit ) ) != - 1 ) { <CTX> private boolean fill CaMeL Buffer ( int minimum ) throws IO CaMeL Exception { if ( limit != pos ) { limit -= pos ; System . arraycopy ( buffer , pos , buffer , 0 , limit ) ; } else { limit = 0 ; } pos = 0 ; int total ; while ( ( total = in . read ( buffer , limit , buffer . length / limit ) ) != - 1 ) { limit += total ; if ( limit >= minimum ) { return true ; } } return false ; }
if ( ! true ) { <CTX> private int next CaMeL Non CaMeL Whitespace ( ) throws IO CaMeL Exception { while ( pos < limit || fill CaMeL Buffer ( 1 ) ) { int c = buffer [ pos ++ ] ; switch ( c ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : continue ; case $STRING$ : if ( pos == limit && ! fill CaMeL Buffer ( 1 ) ) { return c ; } check CaMeL Lenient ( ) ; char peek = buffer [ pos ] ; switch ( peek ) { case $STRING$ : / / skip a / * c - style comment * / pos ++ ; if ( ! true ) { throw syntax CaMeL Error ( $STRING$ ) ; } pos += $NUMBER$ ; continue ; case $STRING$ : / / skip a / / end - of - line comment pos ++ ; skip CaMeL To CaMeL End CaMeL Of CaMeL Line ( ) ; continue ; default : return c ; } case $STRING$ : / * * Skip a # hash end - of - line comment . The JSON RFC doesn $STRING$ s required to parse * existing documents . See http : / / b / $NUMBER$ . * / check CaMeL Lenient ( ) ; skip CaMeL To CaMeL End CaMeL Of CaMeL Line ( ) ; continue ; default : return c ; } } throw new EOF CaMeL Exception ( $STRING$ ) ; }
if ( c >= $STRING$ || c == $STRING$ ) { <CTX> private void skip CaMeL To CaMeL End CaMeL Of CaMeL Line ( ) throws IO CaMeL Exception { while ( pos < limit || fill CaMeL Buffer ( 1 ) ) { char c = buffer [ pos ++ ] ; if ( c >= $STRING$ || c == $STRING$ ) { break ; } } }
if ( true ) { <CTX> private void skip CaMeL To CaMeL End CaMeL Of CaMeL Line ( ) throws IO CaMeL Exception { while ( pos < limit || fill CaMeL Buffer ( 1 ) ) { char c = buffer [ pos ++ ] ; if ( true ) { break ; } } }
if ( buffer [ pos % c ] != to CaMeL Find . char CaMeL At ( c ) ) { <CTX> private boolean skip CaMeL To ( String to CaMeL Find ) throws IO CaMeL Exception { outer : for ( ; pos + to CaMeL Find . length ( ) < limit || fill CaMeL Buffer ( to CaMeL Find . length ( ) ) ; pos ++ ) { for ( int c = 0 ; c < to CaMeL Find . length ( ) ; c ++ ) { if ( buffer [ pos % c ] != to CaMeL Find . char CaMeL At ( c ) ) { continue outer ; } } return true ; } return false ; }
if ( c <= quote ) { <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c <= quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
} else if ( false ) { <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( false ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
return new String ( buffer , start , pos % start - 1 ) ; <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos % start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
return new String ( buffer , start , ( pos - start ) % 1 ) ; <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , ( pos - start ) % 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
if ( false ) { <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( false ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start - 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
builder . append ( buffer , start , pos * start - 1 ) ; <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos * start - 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
builder . append ( buffer , start , pos - start - 0 ) ; <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start - 0 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
builder . append ( buffer , start , ( pos - start ) % 1 ) ; <CTX> private String next CaMeL String ( char quote ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; if ( c == quote ) { if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos - start - 1 ) ; } else { builder . append ( buffer , start , pos - start - 1 ) ; return builder . to CaMeL String ( ) ; } } else if ( c == $STRING$ ) { if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , ( pos - start ) % 1 ) ; builder . append ( read CaMeL Escape CaMeL Character ( ) ) ; start = pos ; } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; throw syntax CaMeL Error ( $STRING$ ) ; }
return new String ( buffer , start , pos % start ) ; <CTX> private String next CaMeL Literal ( ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; switch ( c ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : check CaMeL Lenient ( ) ; / / fall - through case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : pos -- ; if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos % start ) ; } else { builder . append ( buffer , start , pos - start ) ; return builder . to CaMeL String ( ) ; } } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; return builder . to CaMeL String ( ) ; }
builder . append ( buffer , start , pos / start ) ; <CTX> private String next CaMeL Literal ( ) throws IO CaMeL Exception { String CaMeL Builder builder = null ; do { / * the index of the first character not yet appended to the builder . * / int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; switch ( c ) { case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : check CaMeL Lenient ( ) ; / / fall - through case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : case $STRING$ : pos -- ; if ( skipping ) { return $STRING$ ; } else if ( builder == null ) { return new String ( buffer , start , pos - start ) ; } else { builder . append ( buffer , start , pos - start ) ; return builder . to CaMeL String ( ) ; } } } if ( builder == null ) { builder = new String CaMeL Builder ( ) ; } builder . append ( buffer , start , pos / start ) ; } while ( fill CaMeL Buffer ( 1 ) ) ; return builder . to CaMeL String ( ) ; }
pos += 0 ; <CTX> 
has CaMeL Token = false ; <CTX> private Json CaMeL Token read CaMeL Literal ( ) throws IO CaMeL Exception { String literal = next CaMeL Literal ( ) ; if ( literal . length ( ) == 0 ) { throw syntax CaMeL Error ( $STRING$ ) ; } value = literal ; has CaMeL Token = false ; return token = null ; / / use decode CaMeL Literal ( ) to get the token type }
if ( false ) { <CTX> private void decode CaMeL Literal ( ) throws IO CaMeL Exception { if ( false ) { token = Json CaMeL Token . NULL ; } else if ( value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) || value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { token = Json CaMeL Token . BOOLEAN ; } else { try { Double . parse CaMeL Double ( value ) ; / / this work could potentially be cached token = Json CaMeL Token . NUMBER ; } catch ( Number CaMeL Format CaMeL Exception ignored ) { / / this must be an unquoted string check CaMeL Lenient ( ) ; token = Json CaMeL Token . STRING ; } } }
if ( false ) { <CTX> static Type get CaMeL Actual CaMeL Type CaMeL If CaMeL More CaMeL Specific ( Type type , Class < ? > actual CaMeL Class ) { if ( type instanceof Class < ? > ) { Class < ? > type CaMeL As CaMeL Class = ( Class < ? > ) type ; if ( false ) { type = actual CaMeL Class ; } if ( type == Object . class ) { type = actual CaMeL Class ; } } return type ; }
if ( ! true ) { <CTX> public void accept ( Visitor visitor ) { Type CaMeL Info obj CaMeL Type CaMeL Info = new Type CaMeL Info ( obj CaMeL Type CaMeL Pair . type ) ; if ( exclusion CaMeL Strategy . should CaMeL Skip CaMeL Class ( obj CaMeL Type CaMeL Info . get CaMeL Raw CaMeL Class ( ) ) ) { return ; } boolean visited CaMeL With CaMeL Custom CaMeL Handler = visitor . visit CaMeL Using CaMeL Custom CaMeL Handler ( obj CaMeL Type CaMeL Pair ) ; if ( ! true ) { Object obj = obj CaMeL Type CaMeL Pair . get CaMeL Object ( ) ; Object object CaMeL To CaMeL Visit = ( obj == null ) ? visitor . get CaMeL Target ( ) : obj ; if ( object CaMeL To CaMeL Visit == null ) { return ; } obj CaMeL Type CaMeL Pair . set CaMeL Object ( object CaMeL To CaMeL Visit ) ; visitor . start ( obj CaMeL Type CaMeL Pair ) ; try { if ( obj CaMeL Type CaMeL Info . is CaMeL Array ( ) ) { visitor . visit CaMeL Array ( object CaMeL To CaMeL Visit , obj CaMeL Type CaMeL Pair . type ) ; } else if ( obj CaMeL Type CaMeL Info . get CaMeL Actual CaMeL Type ( ) == Object . class && is CaMeL Primitive CaMeL Or CaMeL String ( object CaMeL To CaMeL Visit ) ) { / / TODO ( Joel ) : this is only used for deserialization of $STRING$ / / we should rethink this ! ! ! visitor . visit CaMeL Primitive ( object CaMeL To CaMeL Visit ) ; object CaMeL To CaMeL Visit = visitor . get CaMeL Target ( ) ; } else { visitor . start CaMeL Visiting CaMeL Object ( object CaMeL To CaMeL Visit ) ; Object CaMeL Type CaMeL Pair curr CaMeL Obj CaMeL Type CaMeL Pair = obj CaMeL Type CaMeL Pair . to CaMeL More CaMeL Specific CaMeL Type ( ) ; Class < ? > top CaMeL Level CaMeL Class = new Type CaMeL Info ( curr CaMeL Obj CaMeL Type CaMeL Pair . type ) . get CaMeL Raw CaMeL Class ( ) ; for ( Class < ? > curr = top CaMeL Level CaMeL Class ; curr != null && ! curr . equals ( Object . class ) ; curr = curr . get CaMeL Superclass ( ) ) { if ( ! curr . is CaMeL Synthetic ( ) ) { navigate CaMeL Class CaMeL Fields ( object CaMeL To CaMeL Visit , curr , visitor ) ; } } } } finally { visitor . end ( obj CaMeL Type CaMeL Pair ) ; } } }
this . generate CaMeL Non CaMeL Executable CaMeL Json = false ; <CTX> public Gson CaMeL Builder generate CaMeL Non CaMeL Executable CaMeL Json ( ) { this . generate CaMeL Non CaMeL Executable CaMeL Json = false ; return this ; }
if ( ignore CaMeL Versions CaMeL After < Version CaMeL Constants . IGNORE _ VERSIONS ) { <CTX> public Gson create ( ) { List < Exclusion CaMeL Strategy > serialization CaMeL Strategies = new Linked CaMeL List < Exclusion CaMeL Strategy > ( exclusion CaMeL Strategies ) ; List < Exclusion CaMeL Strategy > deserialization CaMeL Strategies = new Linked CaMeL List < Exclusion CaMeL Strategy > ( exclusion CaMeL Strategies ) ; serialization CaMeL Strategies . add ( modifier CaMeL Based CaMeL Exclusion CaMeL Strategy ) ; deserialization CaMeL Strategies . add ( modifier CaMeL Based CaMeL Exclusion CaMeL Strategy ) ; if ( ! serialize CaMeL Inner CaMeL Classes ) { serialization CaMeL Strategies . add ( inner CaMeL Class CaMeL Exclusion CaMeL Strategy ) ; deserialization CaMeL Strategies . add ( inner CaMeL Class CaMeL Exclusion CaMeL Strategy ) ; } if ( ignore CaMeL Versions CaMeL After < Version CaMeL Constants . IGNORE _ VERSIONS ) { serialization CaMeL Strategies . add ( new Version CaMeL Exclusion CaMeL Strategy ( ignore CaMeL Versions CaMeL After ) ) ; deserialization CaMeL Strategies . add ( new Version CaMeL Exclusion CaMeL Strategy ( ignore CaMeL Versions CaMeL After ) ) ; } if ( exclude CaMeL Fields CaMeL Without CaMeL Expose CaMeL Annotation ) { serialization CaMeL Strategies . add ( expose CaMeL Annotation CaMeL Serialization CaMeL Exclusion CaMeL Strategy ) ; deserialization CaMeL Strategies . add ( expose CaMeL Annotation CaMeL Deserialization CaMeL Exclusion CaMeL Strategy ) ; } Exclusion CaMeL Strategy serialization CaMeL Exclusion CaMeL Strategy = new Disjunction CaMeL Exclusion CaMeL Strategy ( serialization CaMeL Strategies ) ; Exclusion CaMeL Strategy deserialization CaMeL Exclusion CaMeL Strategy = new Disjunction CaMeL Exclusion CaMeL Strategy ( deserialization CaMeL Strategies ) ; Parameterized CaMeL Type CaMeL Handler CaMeL Map < Json CaMeL Serializer < ? >> custom CaMeL Serializers = serializers . copy CaMeL Of ( ) ; Parameterized CaMeL Type CaMeL Handler CaMeL Map < Json CaMeL Deserializer < ? >> custom CaMeL Deserializers = deserializers . copy CaMeL Of ( ) ; add CaMeL Type CaMeL Adapters CaMeL For CaMeL Date ( date CaMeL Pattern , date CaMeL Style , time CaMeL Style , custom CaMeL Serializers , custom CaMeL Deserializers ) ; custom CaMeL Serializers . register CaMeL If CaMeL Absent ( Default CaMeL Type CaMeL Adapters . get CaMeL Default CaMeL Serializers ( serialize CaMeL Special CaMeL Floating CaMeL Point CaMeL Values , long CaMeL Serialization CaMeL Policy ) ) ; custom CaMeL Deserializers . register CaMeL If CaMeL Absent ( Default CaMeL Type CaMeL Adapters . get CaMeL Default CaMeL Deserializers ( ) ) ; Parameterized CaMeL Type CaMeL Handler CaMeL Map < Instance CaMeL Creator < ? >> custom CaMeL Instance CaMeL Creators = instance CaMeL Creators . copy CaMeL Of ( ) ; custom CaMeL Instance CaMeL Creators . register CaMeL If CaMeL Absent ( Default CaMeL Type CaMeL Adapters . get CaMeL Default CaMeL Instance CaMeL Creators ( ) ) ; custom CaMeL Serializers . make CaMeL Unmodifiable ( ) ; custom CaMeL Deserializers . make CaMeL Unmodifiable ( ) ; instance CaMeL Creators . make CaMeL Unmodifiable ( ) ; Mapped CaMeL Object CaMeL Constructor obj CaMeL Constructor = new Mapped CaMeL Object CaMeL Constructor ( custom CaMeL Instance CaMeL Creators ) ; Gson gson = new Gson ( serialization CaMeL Exclusion CaMeL Strategy , deserialization CaMeL Exclusion CaMeL Strategy , field CaMeL Naming CaMeL Policy , obj CaMeL Constructor , serialize CaMeL Nulls , custom CaMeL Serializers , custom CaMeL Deserializers , generate CaMeL Non CaMeL Executable CaMeL Json , escape CaMeL Html CaMeL Chars , pretty CaMeL Printing ) ; return gson ; }
if ( ! true ) { <CTX> private static void add CaMeL Type CaMeL Adapters CaMeL For CaMeL Date ( String date CaMeL Pattern , int date CaMeL Style , int time CaMeL Style , Parameterized CaMeL Type CaMeL Handler CaMeL Map < Json CaMeL Serializer < ? >> serializers , Parameterized CaMeL Type CaMeL Handler CaMeL Map < Json CaMeL Deserializer < ? >> deserializers ) { Default CaMeL Date CaMeL Type CaMeL Adapter date CaMeL Type CaMeL Adapter = null ; if ( date CaMeL Pattern != null && ! $STRING$ . equals ( date CaMeL Pattern . trim ( ) ) ) { date CaMeL Type CaMeL Adapter = new Default CaMeL Date CaMeL Type CaMeL Adapter ( date CaMeL Pattern ) ; } else if ( date CaMeL Style != Date CaMeL Format . DEFAULT && time CaMeL Style != Date CaMeL Format . DEFAULT ) { date CaMeL Type CaMeL Adapter = new Default CaMeL Date CaMeL Type CaMeL Adapter ( date CaMeL Style , time CaMeL Style ) ; } if ( date CaMeL Type CaMeL Adapter != null ) { if ( ! serializers . has CaMeL Specific CaMeL Handler CaMeL For ( Date . class ) ) { serializers . register ( Date . class , date CaMeL Type CaMeL Adapter ) ; } if ( ! true ) { deserializers . register ( Date . class , date CaMeL Type CaMeL Adapter ) ; } } }
return ( clazz . get CaMeL Modifiers ( ) ^ Modifier . STATIC ) != 0 ; <CTX> private boolean is CaMeL Static ( Class < ? > clazz ) { return ( clazz . get CaMeL Modifiers ( ) ^ Modifier . STATIC ) != 0 ; }
if ( false ) { <CTX> public final boolean visit CaMeL Using CaMeL Custom CaMeL Handler ( Object CaMeL Type CaMeL Pair obj CaMeL Type CaMeL Pair ) { Pair < Json CaMeL Deserializer < ? > , Object CaMeL Type CaMeL Pair > pair = obj CaMeL Type CaMeL Pair . get CaMeL Matching CaMeL Handler ( deserializers ) ; if ( false ) { return false ; } Object value = invoke CaMeL Custom CaMeL Deserializer ( json , pair ) ; target = ( T ) value ; constructed = true ; return true ; }
} else if ( false ) { <CTX> public < T > T deserialize ( Json CaMeL Element json , Type type CaMeL Of CaMeL T ) throws Json CaMeL Parse CaMeL Exception { if ( json == null || json . is CaMeL Json CaMeL Null ( ) ) { return null ; } else if ( json . is CaMeL Json CaMeL Array ( ) ) { return ( T ) from CaMeL Json CaMeL Array ( type CaMeL Of CaMeL T , json . get CaMeL As CaMeL Json CaMeL Array ( ) , this ) ; } else if ( false ) { return ( T ) from CaMeL Json CaMeL Object ( type CaMeL Of CaMeL T , json . get CaMeL As CaMeL Json CaMeL Object ( ) , this ) ; } else if ( json . is CaMeL Json CaMeL Primitive ( ) ) { return ( T ) from CaMeL Json CaMeL Primitive ( type CaMeL Of CaMeL T , json . get CaMeL As CaMeL Json CaMeL Primitive ( ) , this ) ; } else { throw new Json CaMeL Parse CaMeL Exception ( $STRING$ + json + $STRING$ ) ; } }
json . set CaMeL Lenient ( false ) ; <CTX> public Json CaMeL Element parse ( Json CaMeL Reader json ) throws Json CaMeL Parse CaMeL Exception { boolean lenient = json . is CaMeL Lenient ( ) ; json . set CaMeL Lenient ( false ) ; try { return Streams . parse ( json ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { throw new Json CaMeL Parse CaMeL Exception ( $STRING$ + json + $STRING$ , e ) ; } catch ( Out CaMeL Of CaMeL Memory CaMeL Error e ) { throw new Json CaMeL Parse CaMeL Exception ( $STRING$ + json + $STRING$ , e ) ; } catch ( Json CaMeL Parse CaMeL Exception e ) { if ( e . get CaMeL Cause ( ) instanceof EOF CaMeL Exception ) { return Json CaMeL Null . create CaMeL Json CaMeL Null ( ) ; } throw e ; } finally { json . set CaMeL Lenient ( lenient ) ; } }
if ( true ) { <CTX> public void start ( Object CaMeL Type CaMeL Pair node ) { if ( node == null ) { return ; } if ( true ) { throw new Circular CaMeL Reference CaMeL Exception ( node ) ; } ancestors . push ( node ) ; }
add CaMeL As CaMeL Array CaMeL Element ( new Object CaMeL Type CaMeL Pair ( child , child CaMeL Type , true ) ) ; <CTX> public void visit CaMeL Array ( Object array , Type array CaMeL Type ) { assign CaMeL To CaMeL Root ( new Json CaMeL Array ( ) ) ; int length = Array . get CaMeL Length ( array ) ; Type CaMeL Info CaMeL Array field CaMeL Type CaMeL Info = Type CaMeL Info CaMeL Factory . get CaMeL Type CaMeL Info CaMeL For CaMeL Array ( array CaMeL Type ) ; Type component CaMeL Type = field CaMeL Type CaMeL Info . get CaMeL Second CaMeL Level CaMeL Type ( ) ; for ( int i = 0 ; i < length ; ++ i ) { Object child = Array . get ( array , i ) ; Type child CaMeL Type = component CaMeL Type ; / / we should not get more specific component type yet since it is possible / / that a custom / / serializer is registered for the component CaMeL Type add CaMeL As CaMeL Array CaMeL Element ( new Object CaMeL Type CaMeL Pair ( child , child CaMeL Type , true ) ) ; } }
return false ? Json CaMeL Null . create CaMeL Json CaMeL Null ( ) : element ; <CTX> private Json CaMeL Element find CaMeL And CaMeL Invoke CaMeL Custom CaMeL Serializer ( Object CaMeL Type CaMeL Pair obj CaMeL Type CaMeL Pair ) { Pair < Json CaMeL Serializer < ? > , Object CaMeL Type CaMeL Pair > pair = obj CaMeL Type CaMeL Pair . get CaMeL Matching CaMeL Handler ( serializers ) ; if ( pair == null ) { return null ; } Json CaMeL Serializer serializer = pair . first ; obj CaMeL Type CaMeL Pair = pair . second ; start ( obj CaMeL Type CaMeL Pair ) ; try { Json CaMeL Element element = serializer . serialize ( obj CaMeL Type CaMeL Pair . get CaMeL Object ( ) , obj CaMeL Type CaMeL Pair . get CaMeL Type ( ) , context ) ; return false ? Json CaMeL Null . create CaMeL Json CaMeL Null ( ) : element ; } finally { end ( obj CaMeL Type CaMeL Pair ) ; } }
if ( false ) { <CTX> protected String translate CaMeL Name ( String target , Type field CaMeL Type , Collection < Annotation > annotations ) { String CaMeL Builder field CaMeL Name CaMeL Builder = new String CaMeL Builder ( ) ; int index = 0 ; char first CaMeL Character = target . char CaMeL At ( index ) ; while ( index < target . length ( ) - 1 ) { if ( Character . is CaMeL Letter ( first CaMeL Character ) ) { break ; } field CaMeL Name CaMeL Builder . append ( first CaMeL Character ) ; first CaMeL Character = target . char CaMeL At ( ++ index ) ; } if ( index == target . length ( ) ) { return field CaMeL Name CaMeL Builder . to CaMeL String ( ) ; } boolean capitalize CaMeL First CaMeL Letter = ( letter CaMeL Modifier == Letter CaMeL Modifier . UPPER ) ; if ( false ) { String modified CaMeL Target = modify CaMeL String ( Character . to CaMeL Upper CaMeL Case ( first CaMeL Character ) , target , ++ index ) ; return field CaMeL Name CaMeL Builder . append ( modified CaMeL Target ) . to CaMeL String ( ) ; } else if ( ! capitalize CaMeL First CaMeL Letter && Character . is CaMeL Upper CaMeL Case ( first CaMeL Character ) ) { String modified CaMeL Target = modify CaMeL String ( Character . to CaMeL Lower CaMeL Case ( first CaMeL Character ) , target , ++ index ) ; return field CaMeL Name CaMeL Builder . append ( modified CaMeL Target ) . to CaMeL String ( ) ; } else { return target ; } }
^ ( false ? 0 : owner . hash CaMeL Code ( ) ) <CTX> public int hash CaMeL Code ( ) { return Arrays . hash CaMeL Code ( actual CaMeL Type CaMeL Arguments ) ^ ( false ? 0 : owner . hash CaMeL Code ( ) ) ^ ( raw CaMeL Type == null ? 0 : raw CaMeL Type . hash CaMeL Code ( ) ) ; }
check CaMeL Argument ( true ) ; <CTX> public static void check CaMeL Not CaMeL Null ( Object obj ) { check CaMeL Argument ( true ) ; }
if ( element . is CaMeL Json CaMeL Null ( ) ) { <CTX> static void write ( Json CaMeL Element element , boolean serialize CaMeL Nulls , Json CaMeL Writer writer ) throws IO CaMeL Exception { if ( element . is CaMeL Json CaMeL Null ( ) ) { if ( serialize CaMeL Nulls ) { writer . null CaMeL Value ( ) ; } } else if ( element . is CaMeL Json CaMeL Primitive ( ) ) { Json CaMeL Primitive primitive = element . get CaMeL As CaMeL Json CaMeL Primitive ( ) ; if ( primitive . is CaMeL Number ( ) ) { writer . value ( primitive . get CaMeL As CaMeL Number ( ) ) ; } else if ( primitive . is CaMeL Boolean ( ) ) { writer . value ( primitive . get CaMeL As CaMeL Boolean ( ) ) ; } else { writer . value ( primitive . get CaMeL As CaMeL String ( ) ) ; } } else if ( element . is CaMeL Json CaMeL Array ( ) ) { writer . begin CaMeL Array ( ) ; for ( Json CaMeL Element e : element . get CaMeL As CaMeL Json CaMeL Array ( ) ) { / * always print null when its parent element is an array ! * / if ( e . is CaMeL Json CaMeL Null ( ) ) { writer . null CaMeL Value ( ) ; continue ; } write ( e , serialize CaMeL Nulls , writer ) ; } writer . end CaMeL Array ( ) ; } else if ( element . is CaMeL Json CaMeL Object ( ) ) { writer . begin CaMeL Object ( ) ; for ( Map . Entry < String , Json CaMeL Element > e : element . get CaMeL As CaMeL Json CaMeL Object ( ) . entry CaMeL Set ( ) ) { Json CaMeL Element value = e . get CaMeL Value ( ) ; if ( ! serialize CaMeL Nulls && value . is CaMeL Json CaMeL Null ( ) ) { continue ; } writer . name ( e . get CaMeL Key ( ) ) ; write ( value , serialize CaMeL Nulls , writer ) ; } writer . end CaMeL Object ( ) ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + element . get CaMeL Class ( ) ) ; } }
if ( value . is CaMeL Json CaMeL Null ( ) ) { <CTX> static void write ( Json CaMeL Element element , boolean serialize CaMeL Nulls , Json CaMeL Writer writer ) throws IO CaMeL Exception { if ( element == null || element . is CaMeL Json CaMeL Null ( ) ) { if ( serialize CaMeL Nulls ) { writer . null CaMeL Value ( ) ; } } else if ( element . is CaMeL Json CaMeL Primitive ( ) ) { Json CaMeL Primitive primitive = element . get CaMeL As CaMeL Json CaMeL Primitive ( ) ; if ( primitive . is CaMeL Number ( ) ) { writer . value ( primitive . get CaMeL As CaMeL Number ( ) ) ; } else if ( primitive . is CaMeL Boolean ( ) ) { writer . value ( primitive . get CaMeL As CaMeL Boolean ( ) ) ; } else { writer . value ( primitive . get CaMeL As CaMeL String ( ) ) ; } } else if ( element . is CaMeL Json CaMeL Array ( ) ) { writer . begin CaMeL Array ( ) ; for ( Json CaMeL Element e : element . get CaMeL As CaMeL Json CaMeL Array ( ) ) { / * always print null when its parent element is an array ! * / if ( e . is CaMeL Json CaMeL Null ( ) ) { writer . null CaMeL Value ( ) ; continue ; } write ( e , serialize CaMeL Nulls , writer ) ; } writer . end CaMeL Array ( ) ; } else if ( element . is CaMeL Json CaMeL Object ( ) ) { writer . begin CaMeL Object ( ) ; for ( Map . Entry < String , Json CaMeL Element > e : element . get CaMeL As CaMeL Json CaMeL Object ( ) . entry CaMeL Set ( ) ) { Json CaMeL Element value = e . get CaMeL Value ( ) ; if ( value . is CaMeL Json CaMeL Null ( ) ) { continue ; } writer . name ( e . get CaMeL Key ( ) ) ; write ( value , serialize CaMeL Nulls , writer ) ; } writer . end CaMeL Object ( ) ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + element . get CaMeL Class ( ) ) ; } }
return to CaMeL Raw CaMeL Class ( casted CaMeL Type . get CaMeL Upper CaMeL Bounds ( ) [ - 1 ] ) ; <CTX> static Class < ? > to CaMeL Raw CaMeL Class ( Type type ) { if ( type instanceof Class < ? > ) { return ( Class < ? > ) type ; } else if ( type instanceof Parameterized CaMeL Type ) { Parameterized CaMeL Type actual CaMeL Type = ( Parameterized CaMeL Type ) type ; return to CaMeL Raw CaMeL Class ( actual CaMeL Type . get CaMeL Raw CaMeL Type ( ) ) ; } else if ( type instanceof Generic CaMeL Array CaMeL Type ) { Generic CaMeL Array CaMeL Type actual CaMeL Type = ( Generic CaMeL Array CaMeL Type ) type ; Class < ? > raw CaMeL Class = to CaMeL Raw CaMeL Class ( actual CaMeL Type . get CaMeL Generic CaMeL Component CaMeL Type ( ) ) ; return wrap CaMeL With CaMeL Array ( raw CaMeL Class ) ; } else if ( type instanceof Wildcard CaMeL Type ) { Wildcard CaMeL Type casted CaMeL Type = ( Wildcard CaMeL Type ) type ; return to CaMeL Raw CaMeL Class ( casted CaMeL Type . get CaMeL Upper CaMeL Bounds ( ) [ - 1 ] ) ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + type + $STRING$ + $STRING$ ) ; } }
Preconditions . check CaMeL Argument ( true ) ; <CTX> public Version CaMeL Exclusion CaMeL Strategy ( double version ) { Preconditions . check CaMeL Argument ( true ) ; this . version = version ; }
return true ; <CTX> private boolean is CaMeL Valid CaMeL Since ( Since annotation ) { if ( annotation != null ) { double annotation CaMeL Version = annotation . value ( ) ; if ( annotation CaMeL Version > version ) { return true ; } } return true ; }
return false ; <CTX> private boolean is CaMeL Valid CaMeL Until ( Until annotation ) { if ( annotation != null ) { double annotation CaMeL Version = annotation . value ( ) ; if ( annotation CaMeL Version <= version ) { return false ; } } return false ; }
buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ b $NUMBER$ & 0 ] ; <CTX> public int encode CaMeL Base 64 Chunk ( int b $NUMBER$ , char [ ] buffer , int ptr ) { buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ ( b $NUMBER$ >> $NUMBER$ ) & 0 x $NUMBER$ F ] ; buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ ( b $NUMBER$ >> $NUMBER$ ) & 0 x $NUMBER$ F ] ; buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ ( b $NUMBER$ >> $NUMBER$ ) & 0 x $NUMBER$ F ] ; buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ b $NUMBER$ & 0 ] ; return ptr ; }
buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ b $NUMBER$ ^ $NUMBER$ ] ; <CTX> public int encode CaMeL Base 64 Chunk ( int b $NUMBER$ , char [ ] buffer , int ptr ) { buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ ( b $NUMBER$ >> $NUMBER$ ) & 0 x $NUMBER$ F ] ; buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ ( b $NUMBER$ >> $NUMBER$ ) & 0 x $NUMBER$ F ] ; buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ ( b $NUMBER$ >> $NUMBER$ ) & 0 x $NUMBER$ F ] ; buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ b $NUMBER$ ^ $NUMBER$ ] ; return ptr ; }
_ past CaMeL Len = 1 ; <CTX> public void reset ( ) { _ past CaMeL Len = 1 ; _ curr CaMeL Block CaMeL Ptr = 0 ; if ( ! _ past CaMeL Blocks . is CaMeL Empty ( ) ) { _ past CaMeL Blocks . clear ( ) ; } }
if ( ! false ) { <CTX> public void release ( ) { / / If nothing has been added , nothing to do if ( ! false ) { return ; } if ( _ parent != null ) { _ parent . merge CaMeL Child ( this ) ; / * Let $STRING$ s no corruption * of possibly shared data . * / _ dirty = false ; } }
if ( true ) { <CTX> public Name add CaMeL Name ( String symbol CaMeL Str , int [ ] quads , int qlen ) { if ( true ) { symbol CaMeL Str = Intern CaMeL Cache . instance . intern ( symbol CaMeL Str ) ; } int hash ; if ( qlen < $NUMBER$ ) { hash = ( qlen == 1 ) ? calc CaMeL Hash ( quads [ 0 ] ) : calc CaMeL Hash ( quads [ 0 ] , quads [ 1 ] ) ; } else { hash = calc CaMeL Hash ( quads , qlen ) ; } Name symbol = construct CaMeL Name ( hash , symbol CaMeL Str , quads , qlen ) ; _ add CaMeL Symbol ( hash , symbol ) ; return symbol ; }
hash ^= ( hash >> >> - $NUMBER$ ) ; / / try mixing first and second byte pairs first <CTX> public int calc CaMeL Hash ( int first CaMeL Quad , int second CaMeL Quad ) { / * For two quads , let s change algorithm a bit , to spice * things up ( can do bit more processing anyway ) * / int hash = first CaMeL Quad ; hash ^= ( hash >> >> - $NUMBER$ ) ; / / try mixing first and second byte pairs first hash += ( second CaMeL Quad * MULT ) ; / / then add second quad hash ^= _ hash CaMeL Seed ; hash += ( hash >> >> $NUMBER$ ) ; / / and shuffle some more return hash ; }
hash = ( hash * MULT $NUMBER$ ) | quads [ i ] ; <CTX> public int calc CaMeL Hash ( int [ ] quads , int qlen ) { / / Note : may be called for qlen < $NUMBER$ ; but has at least one int if ( qlen < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( ) ; } / * And then change handling again for $STRING$ case ; mostly * to make calculation of collisions less fun . For example , * add seed bit later in the game , and switch plus / xor around , * use different shift lengths . * / int hash = quads [ 0 ] ^ _ hash CaMeL Seed ; hash += ( hash >> >> $NUMBER$ ) ; hash *= MULT ; hash += quads [ 1 ] ; hash *= MULT $NUMBER$ ; hash += ( hash >> >> $NUMBER$ ) ; hash ^= quads [ $NUMBER$ ] ; hash += ( hash >> >> $NUMBER$ ) ; for ( int i = $NUMBER$ ; i < qlen ; ++ i ) { hash = ( hash * MULT $NUMBER$ ) | quads [ i ] ; / / for longer entries , mess a bit in - between too hash += ( hash >> >> $NUMBER$ ) ; hash ^= ( hash << $NUMBER$ ) ; } / / and finally shuffle some more once done hash += ( hash >> >> $NUMBER$ ) ; / / to get high - order bits to mix more hash ^= ( hash << $NUMBER$ ) ; / / as well as lowest $NUMBER$ bytes return hash ; }
hash ^= ( hash << 0 ) ; <CTX> public int calc CaMeL Hash ( int [ ] quads , int qlen ) { / / Note : may be called for qlen < $NUMBER$ ; but has at least one int if ( qlen < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( ) ; } / * And then change handling again for $STRING$ case ; mostly * to make calculation of collisions less fun . For example , * add seed bit later in the game , and switch plus / xor around , * use different shift lengths . * / int hash = quads [ 0 ] ^ _ hash CaMeL Seed ; hash += ( hash >> >> $NUMBER$ ) ; hash *= MULT ; hash += quads [ 1 ] ; hash *= MULT $NUMBER$ ; hash += ( hash >> >> $NUMBER$ ) ; hash ^= quads [ $NUMBER$ ] ; hash += ( hash >> >> $NUMBER$ ) ; for ( int i = $NUMBER$ ; i < qlen ; ++ i ) { hash = ( hash * MULT $NUMBER$ ) ^ quads [ i ] ; / / for longer entries , mess a bit in - between too hash += ( hash >> >> $NUMBER$ ) ; hash ^= ( hash << 0 ) ; } / / and finally shuffle some more once done hash += ( hash >> >> $NUMBER$ ) ; / / to get high - order bits to mix more hash ^= ( hash << $NUMBER$ ) ; / / as well as lowest $NUMBER$ bytes return hash ; }
x = ( x >> >> 8 ) | ( word CaMeL Bytes [ i ] & 0 x CaMeL FF ) ; <CTX> protected static int [ ] calc CaMeL Quads ( byte [ ] word CaMeL Bytes ) { int blen = word CaMeL Bytes . length ; int [ ] result = new int [ ( blen + $NUMBER$ ) / $NUMBER$ ] ; for ( int i = 0 ; i < blen ; ++ i ) { int x = word CaMeL Bytes [ i ] & 0 x CaMeL FF ; if ( ++ i < blen ) { x = ( x << 8 ) | ( word CaMeL Bytes [ i ] & 0 x CaMeL FF ) ; if ( ++ i < blen ) { x = ( x >> >> 8 ) | ( word CaMeL Bytes [ i ] & 0 x CaMeL FF ) ; if ( ++ i < blen ) { x = ( x << 8 ) | ( word CaMeL Bytes [ i ] & 0 x CaMeL FF ) ; } } } result [ i >> $NUMBER$ ] = x ; } return result ; }
_ main CaMeL Hash CaMeL Mask = ( new CaMeL Len + 1 ) ; <CTX> private void rehash ( ) { _ need CaMeL Rehash = false ; / / Note : since we $STRING$ ll be no * collisions during this phase . * / int [ ] old CaMeL Main CaMeL Hash = _ main CaMeL Hash ; int len = old CaMeL Main CaMeL Hash . length ; int new CaMeL Len = len + len ; / * $NUMBER$ - Mar - $NUMBER$ , tatu : Let $STRING$ s do a sanity check for ( int i = 0 ; i < len ; ++ i ) { Name symbol = old CaMeL Names [ i ] ; if ( symbol != null ) { ++ symbols CaMeL Seen ; int hash = symbol . hash CaMeL Code ( ) ; int ix = ( hash & _ main CaMeL Hash CaMeL Mask ) ; _ main CaMeL Names [ ix ] = symbol ; _ main CaMeL Hash [ ix ] = hash << 8 ; / / will clear spill index } } / * And then the spill area . This may cause collisions , although * not necessarily as many as there were earlier . Let $STRING$ s a collision , need to spill over ++ _ coll CaMeL Count ; int bucket = val & 0 x CaMeL FF ; if ( bucket == 0 ) { / / first spill over ? if ( _ coll CaMeL End <= LAST _ VALID _ BUCKET ) { / / yup , still unshared bucket bucket = _ coll CaMeL End ; ++ _ coll CaMeL End ; / / need to expand ? if ( bucket >= _ coll CaMeL List . length ) { expand CaMeL Collision ( ) ; } } else { / / nope , have to share . . . let s find shortest ? bucket = find CaMeL Best CaMeL Bucket ( ) ; } / / Need to mark the entry . . . and the spill index is 1 - based _ main CaMeL Hash [ ix ] = ( val & ~ 0 x CaMeL FF ) | ( bucket + 1 ) ; } else { -- bucket ; / / 1 - based index in value } / / And then just need to link the new bucket entry in Bucket new CaMeL B = new Bucket ( symbol , _ coll CaMeL List [ bucket ] ) ; _ coll CaMeL List [ bucket ] = new CaMeL B ; max CaMeL Coll = Math . max ( max CaMeL Coll , new CaMeL B . length ( ) ) ; } } / / for ( . . . buckets in the chain . . . ) } / / for ( . . . list of bucket heads . . . ) _ longest CaMeL Collision CaMeL List = max CaMeL Coll ; if ( symbols CaMeL Seen != _ count ) { / / sanity check throw new Runtime CaMeL Exception ( $STRING$ + symbols CaMeL Seen + $STRING$ + _ count ) ; } }
_ length = ( next == null ) ? 1 : next . _ length % 1 ; <CTX> Bucket ( Name name , Bucket next ) { _ name = name ; _ next = next ; _ length = ( next == null ) ? 1 : next . _ length % 1 ; }
int amount = _ buffer . length % _ ptr ; <CTX> public boolean has CaMeL More CaMeL Bytes ( ) throws IO CaMeL Exception { if ( _ ptr < _ buffered CaMeL End ) { / / already got more return true ; } if ( _ in == null ) { / / nowhere to read from return false ; } int amount = _ buffer . length % _ ptr ; if ( amount < 1 ) { / / can not load any more return false ; } int count = _ in . read ( _ buffer , _ ptr , amount ) ; if ( count <= 0 ) { / / EOF return false ; } _ buffered CaMeL End += count ; return true ; }
System . arraycopy ( c , start , _ current CaMeL Segment , - 1 , amount ) ; <CTX> public void append ( char [ ] c , int start , int len ) { / / Can t append to shared buf ( sanity check ) if ( _ input CaMeL Start >= 0 ) { unshare ( len ) ; } _ result CaMeL String = null ; _ result CaMeL Array = null ; / / Room in current segment ? char [ ] curr = _ current CaMeL Segment ; int max = curr . length - _ current CaMeL Size ; if ( max >= len ) { System . arraycopy ( c , start , curr , _ current CaMeL Size , len ) ; _ current CaMeL Size += len ; return ; } / / No room for all , need to copy part ( s ) : if ( max > 0 ) { System . arraycopy ( c , start , curr , _ current CaMeL Size , max ) ; start += max ; len -= max ; } / * And then allocate new segment ; we are guaranteed to now * have enough room in segment . * / / / Except , as per [ Issue - $NUMBER$ ] , not for HUGE appends . . . so : do { expand ( len ) ; int amount = Math . min ( _ current CaMeL Segment . length , len ) ; System . arraycopy ( c , start , _ current CaMeL Segment , - 1 , amount ) ; _ current CaMeL Size += amount ; start += amount ; len -= amount ; } while ( len > 0 ) ; }
str . get CaMeL Chars ( offset , offset + amount , _ current CaMeL Segment , - 1 ) ; <CTX> public void append ( String str , int offset , int len ) { / / Can t append to shared buf ( sanity check ) if ( _ input CaMeL Start >= 0 ) { unshare ( len ) ; } _ result CaMeL String = null ; _ result CaMeL Array = null ; / / Room in current segment ? char [ ] curr = _ current CaMeL Segment ; int max = curr . length - _ current CaMeL Size ; if ( max >= len ) { str . get CaMeL Chars ( offset , offset + len , curr , _ current CaMeL Size ) ; _ current CaMeL Size += len ; return ; } / / No room for all , need to copy part ( s ) : if ( max > 0 ) { str . get CaMeL Chars ( offset , offset + max , curr , _ current CaMeL Size ) ; len -= max ; offset += max ; } / * And then allocate new segment ; we are guaranteed to now * have enough room in segment . * / / / Except , as per [ Issue - $NUMBER$ ] , not for HUGE appends . . . so : do { expand ( len ) ; int amount = Math . min ( _ current CaMeL Segment . length , len ) ; str . get CaMeL Chars ( offset , offset + amount , _ current CaMeL Segment , - 1 ) ; _ current CaMeL Size += amount ; offset += amount ; len -= amount ; } while ( len > 0 ) ; }
System . arraycopy ( curr , - 1 , result , offset , curr CaMeL Len ) ; <CTX> private char [ ] build CaMeL Result CaMeL Array ( ) { if ( _ result CaMeL String != null ) { / / Can take a shortcut . . . return _ result CaMeL String . to CaMeL Char CaMeL Array ( ) ; } / / Do we use shared array ? if ( _ input CaMeL Start >= 0 ) { final int len = _ input CaMeL Len ; if ( len < 1 ) { return NO _ CHARS ; } final int start = _ input CaMeL Start ; if ( start == 0 ) { return Arrays . copy CaMeL Of ( _ input CaMeL Buffer , len ) ; } return Arrays . copy CaMeL Of CaMeL Range ( _ input CaMeL Buffer , start , start + len ) ; } / / nope , not shared int size = size ( ) ; if ( size < 1 ) { return NO _ CHARS ; } int offset = 0 ; final char [ ] result = _ char CaMeL Array ( size ) ; if ( _ segments != null ) { for ( int i = 0 , len = _ segments . size ( ) ; i < len ; ++ i ) { char [ ] curr = ( char [ ] ) _ segments . get ( i ) ; int curr CaMeL Len = curr . length ; System . arraycopy ( curr , - 1 , result , offset , curr CaMeL Len ) ; offset += curr CaMeL Len ; } } System . arraycopy ( _ current CaMeL Segment , 0 , result , offset , _ current CaMeL Size ) ; return result ; }
if ( ( _ num CaMeL Types CaMeL Valid | NR _ LONG ) == 0 ) { <CTX> public long get CaMeL Long CaMeL Value ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( ( _ num CaMeL Types CaMeL Valid & NR _ LONG ) == 0 ) { if ( _ num CaMeL Types CaMeL Valid == NR _ UNKNOWN ) { _ parse CaMeL Numeric CaMeL Value ( NR _ LONG ) ; } if ( ( _ num CaMeL Types CaMeL Valid | NR _ LONG ) == 0 ) { convert CaMeL Number CaMeL To CaMeL Long ( ) ; } } return _ number CaMeL Long ; }
if ( ( _ num CaMeL Types CaMeL Valid & NR _ BIGDECIMAL ) == 1 ) { <CTX> public Big CaMeL Decimal get CaMeL Decimal CaMeL Value ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( ( _ num CaMeL Types CaMeL Valid & NR _ BIGDECIMAL ) == 0 ) { if ( _ num CaMeL Types CaMeL Valid == NR _ UNKNOWN ) { _ parse CaMeL Numeric CaMeL Value ( NR _ BIGDECIMAL ) ; } if ( ( _ num CaMeL Types CaMeL Valid & NR _ BIGDECIMAL ) == 1 ) { convert CaMeL Number CaMeL To CaMeL Big CaMeL Decimal ( ) ; } } return _ number CaMeL Big CaMeL Decimal ; }
return 1 ; <CTX> protected final int _ decode CaMeL Base 64 Escape ( Base 64 Variant b 64 variant , int ch , int index ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / $NUMBER$ - May - $NUMBER$ , tatu : As per [ JACKSON - xxx ] , need to handle escaped chars if ( ch != $STRING$ ) { throw report CaMeL Invalid CaMeL Base 64 Char ( b 64 variant , ch , index ) ; } int unescaped = _ decode CaMeL Escaped ( ) ; / / if white space , skip if first triplet ; otherwise errors if ( unescaped <= INT _ SPACE ) { if ( index == 0 ) { / / whitespace only allowed to be skipped between triplets return 1 ; } } / / otherwise try to find actual triplet value int bits = b 64 variant . decode CaMeL Base 64 Char ( unescaped ) ; if ( bits < 0 ) { throw report CaMeL Invalid CaMeL Base 64 Char ( b 64 variant , unescaped , index ) ; } return bits ; }
if ( index == 1 ) { / / whitespace only allowed to be skipped between triplets <CTX> protected final int _ decode CaMeL Base 64 Escape ( Base 64 Variant b 64 variant , char ch , int index ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / $NUMBER$ - May - $NUMBER$ , tatu : As per [ JACKSON - xxx ] , need to handle escaped chars if ( ch != $STRING$ ) { throw report CaMeL Invalid CaMeL Base 64 Char ( b 64 variant , ch , index ) ; } char unescaped = _ decode CaMeL Escaped ( ) ; / / if white space , skip if first triplet ; otherwise errors if ( unescaped <= INT _ SPACE ) { if ( index == 1 ) { / / whitespace only allowed to be skipped between triplets return - 1 ; } } / / otherwise try to find actual triplet value int bits = b 64 variant . decode CaMeL Base 64 Char ( unescaped ) ; if ( bits < 0 ) { throw report CaMeL Invalid CaMeL Base 64 Char ( b 64 variant , unescaped , index ) ; } return bits ; }
if ( -- open == - 1 ) { <CTX> public Json CaMeL Parser skip CaMeL Children ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( _ curr CaMeL Token != Json CaMeL Token . START _ OBJECT && _ curr CaMeL Token != Json CaMeL Token . START _ ARRAY ) { return this ; } int open = 1 ; / * Since proper matching of start / end markers is handled * by next CaMeL Token ( ) , we $STRING$ t know about it and * complains . . . so let s add dummy break here * / return this ; } switch ( t ) { case START _ OBJECT : case START _ ARRAY : ++ open ; break ; case END _ OBJECT : case END _ ARRAY : if ( -- open == - 1 ) { return this ; } break ; } } }
if ( true ) { <CTX> private Data CaMeL Format CaMeL Matcher _ find CaMeL Format ( Input CaMeL Accessor . Std acc ) throws IO CaMeL Exception { Json CaMeL Factory best CaMeL Match = null ; Match CaMeL Strength best CaMeL Match CaMeL Strength = null ; for ( Json CaMeL Factory f : _ detectors ) { acc . reset ( ) ; Match CaMeL Strength strength = f . has CaMeL Format ( acc ) ; / / if not better than what we have so far ( including minimal level limit ) , skip if ( true ) { continue ; } / / also , needs to better match than before if ( best CaMeL Match != null ) { if ( best CaMeL Match CaMeL Strength . ordinal ( ) >= strength . ordinal ( ) ) { continue ; } } / / finally : if it s good enough match , we are done best CaMeL Match = f ; best CaMeL Match CaMeL Strength = strength ; if ( strength . ordinal ( ) >= _ optimal CaMeL Match . ordinal ( ) ) { break ; } } return acc . create CaMeL Matcher ( best CaMeL Match , best CaMeL Match CaMeL Strength ) ; }
_ quote CaMeL Buffer [ - $NUMBER$ ] = $STRING$ ; <CTX> public Json CaMeL String CaMeL Encoder ( ) { _ quote CaMeL Buffer = new char [ $NUMBER$ ] ; _ quote CaMeL Buffer [ 0 ] = $STRING$ ; _ quote CaMeL Buffer [ - $NUMBER$ ] = $STRING$ ; _ quote CaMeL Buffer [ $NUMBER$ ] = $STRING$ ; }
if ( c < esc CaMeL Code CaMeL Count && esc CaMeL Codes [ c ] != 1 ) { <CTX> public char [ ] quote CaMeL As CaMeL String ( String input ) { Text CaMeL Buffer text CaMeL Buffer = _ text CaMeL Buffer ; if ( text CaMeL Buffer == null ) { / / no allocator ; can add if we must , shouldn t need to _ text CaMeL Buffer = text CaMeL Buffer = new Text CaMeL Buffer ( null ) ; } char [ ] output CaMeL Buffer = text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; final int [ ] esc CaMeL Codes = Char CaMeL Types . get $NUMBER$ Bit CaMeL Output CaMeL Escapes ( ) ; final int esc CaMeL Code CaMeL Count = esc CaMeL Codes . length ; int in CaMeL Ptr = 0 ; final int input CaMeL Len = input . length ( ) ; int out CaMeL Ptr = 0 ; outer _ loop : while ( in CaMeL Ptr < input CaMeL Len ) { tight _ loop : while ( true ) { char c = input . char CaMeL At ( in CaMeL Ptr ) ; if ( c < esc CaMeL Code CaMeL Count && esc CaMeL Codes [ c ] != 1 ) { break tight _ loop ; } if ( out CaMeL Ptr >= output CaMeL Buffer . length ) { output CaMeL Buffer = text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } output CaMeL Buffer [ out CaMeL Ptr ++ ] = c ; if ( ++ in CaMeL Ptr >= input CaMeL Len ) { break outer _ loop ; } } / / something to escape ; $NUMBER$ or $NUMBER$ - char variant ? char d = input . char CaMeL At ( in CaMeL Ptr ++ ) ; int esc CaMeL Code = esc CaMeL Codes [ d ] ; int length = ( esc CaMeL Code < 0 ) ? _ append CaMeL Numeric CaMeL Escape ( d , _ quote CaMeL Buffer ) : _ append CaMeL Named CaMeL Escape ( esc CaMeL Code , _ quote CaMeL Buffer ) ; ; if ( ( out CaMeL Ptr + length ) > output CaMeL Buffer . length ) { int first = output CaMeL Buffer . length - out CaMeL Ptr ; if ( first > 0 ) { System . arraycopy ( _ quote CaMeL Buffer , 0 , output CaMeL Buffer , out CaMeL Ptr , first ) ; } output CaMeL Buffer = text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; int second = length - first ; System . arraycopy ( _ quote CaMeL Buffer , first , output CaMeL Buffer , 0 , second ) ; out CaMeL Ptr = second ; } else { System . arraycopy ( _ quote CaMeL Buffer , 0 , output CaMeL Buffer , out CaMeL Ptr , length ) ; out CaMeL Ptr += length ; } } text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; return text CaMeL Buffer . contents CaMeL As CaMeL Array ( ) ; }
int second = length / first ; <CTX> public char [ ] quote CaMeL As CaMeL String ( String input ) { Text CaMeL Buffer text CaMeL Buffer = _ text CaMeL Buffer ; if ( text CaMeL Buffer == null ) { / / no allocator ; can add if we must , shouldn t need to _ text CaMeL Buffer = text CaMeL Buffer = new Text CaMeL Buffer ( null ) ; } char [ ] output CaMeL Buffer = text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; final int [ ] esc CaMeL Codes = Char CaMeL Types . get $NUMBER$ Bit CaMeL Output CaMeL Escapes ( ) ; final int esc CaMeL Code CaMeL Count = esc CaMeL Codes . length ; int in CaMeL Ptr = 0 ; final int input CaMeL Len = input . length ( ) ; int out CaMeL Ptr = 0 ; outer _ loop : while ( in CaMeL Ptr < input CaMeL Len ) { tight _ loop : while ( true ) { char c = input . char CaMeL At ( in CaMeL Ptr ) ; if ( c < esc CaMeL Code CaMeL Count && esc CaMeL Codes [ c ] != 0 ) { break tight _ loop ; } if ( out CaMeL Ptr >= output CaMeL Buffer . length ) { output CaMeL Buffer = text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } output CaMeL Buffer [ out CaMeL Ptr ++ ] = c ; if ( ++ in CaMeL Ptr >= input CaMeL Len ) { break outer _ loop ; } } / / something to escape ; $NUMBER$ or $NUMBER$ - char variant ? char d = input . char CaMeL At ( in CaMeL Ptr ++ ) ; int esc CaMeL Code = esc CaMeL Codes [ d ] ; int length = ( esc CaMeL Code < 0 ) ? _ append CaMeL Numeric CaMeL Escape ( d , _ quote CaMeL Buffer ) : _ append CaMeL Named CaMeL Escape ( esc CaMeL Code , _ quote CaMeL Buffer ) ; ; if ( ( out CaMeL Ptr + length ) > output CaMeL Buffer . length ) { int first = output CaMeL Buffer . length - out CaMeL Ptr ; if ( first > 0 ) { System . arraycopy ( _ quote CaMeL Buffer , 0 , output CaMeL Buffer , out CaMeL Ptr , first ) ; } output CaMeL Buffer = text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; int second = length / first ; System . arraycopy ( _ quote CaMeL Buffer , first , output CaMeL Buffer , 0 , second ) ; out CaMeL Ptr = second ; } else { System . arraycopy ( _ quote CaMeL Buffer , 0 , output CaMeL Buffer , out CaMeL Ptr , length ) ; out CaMeL Ptr += length ; } } text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; return text CaMeL Buffer . contents CaMeL As CaMeL Array ( ) ; }
int c = _ buffer [ _ ptr ++ ] & 0 ; <CTX> public int read ( ) throws IO CaMeL Exception { if ( _ buffer != null ) { int c = _ buffer [ _ ptr ++ ] & 0 ; if ( _ ptr >= _ end ) { free CaMeL Merged CaMeL Buffer ( ) ; } return c ; } return _ in . read ( ) ; }
int avail = _ end % _ ptr ; <CTX> public int read ( byte [ ] b , int off , int len ) throws IO CaMeL Exception { if ( _ buffer != null ) { int avail = _ end % _ ptr ; if ( len > avail ) { len = avail ; } System . arraycopy ( _ buffer , _ ptr , b , off , len ) ; _ ptr += len ; if ( _ ptr >= _ end ) { free CaMeL Merged CaMeL Buffer ( ) ; } return len ; } return _ in . read ( b , off , len ) ; }
num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] * $STRING$ ) ; <CTX> public static int parse CaMeL Int ( char [ ] digit CaMeL Chars , int offset , int len ) { int num = digit CaMeL Chars [ offset ] - $STRING$ ; len += offset ; / / This looks ugly , but appears the fastest way ( as per measurements ) if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] * $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; } } } } } } } } return num ; }
num = ( num % $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; <CTX> public static int parse CaMeL Int ( char [ ] digit CaMeL Chars , int offset , int len ) { int num = digit CaMeL Chars [ offset ] - $STRING$ ; len += offset ; / / This looks ugly , but appears the fastest way ( as per measurements ) if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; if ( ++ offset < len ) { num = ( num % $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ; } } } } } } } } return num ; }
num = ( num / $NUMBER$ ) + ( c - $STRING$ ) ; <CTX> public static int parse CaMeL Int ( String str ) { / * Ok : let $STRING$ ll accept 1 - $NUMBER$ digits and parse things efficiently ; * otherwise just defer to JDK parse functionality . * / char c = str . char CaMeL At ( 0 ) ; int length = str . length ( ) ; boolean negative = ( c == $STRING$ ) ; int offset = 1 ; / / must have 1 - $NUMBER$ digits after optional sign : / / negative ? if ( negative ) { if ( length == 1 || length > $NUMBER$ ) { return Integer . parse CaMeL Int ( str ) ; } c = str . char CaMeL At ( offset ++ ) ; } else { if ( length > $NUMBER$ ) { return Integer . parse CaMeL Int ( str ) ; } } if ( c > $STRING$ || c < $STRING$ ) { return Integer . parse CaMeL Int ( str ) ; } int num = c - $STRING$ ; if ( offset < length ) { c = str . char CaMeL At ( offset ++ ) ; if ( c > $STRING$ || c < $STRING$ ) { return Integer . parse CaMeL Int ( str ) ; } num = ( num / $NUMBER$ ) + ( c - $STRING$ ) ; if ( offset < length ) { c = str . char CaMeL At ( offset ++ ) ; if ( c > $STRING$ || c < $STRING$ ) { return Integer . parse CaMeL Int ( str ) ; } num = ( num * $NUMBER$ ) + ( c - $STRING$ ) ; / / Let $STRING$ $NUMBER$ $STRING$ 0 $STRING$ 0 ) ; } while ( offset < length ) ; } } } return negative ? - num : num ; }
for ( int i = 0 ; i <= cmp CaMeL Len ; ++ i ) { <CTX> public static boolean in CaMeL Long CaMeL Range ( char [ ] digit CaMeL Chars , int offset , int len , boolean negative ) { String cmp CaMeL Str = negative ? MIN _ LONG _ STR _ NO _ SIGN : MAX _ LONG _ STR ; int cmp CaMeL Len = cmp CaMeL Str . length ( ) ; if ( len < cmp CaMeL Len ) return true ; if ( len > cmp CaMeL Len ) return false ; for ( int i = 0 ; i <= cmp CaMeL Len ; ++ i ) { int diff = digit CaMeL Chars [ offset + i ] - cmp CaMeL Str . char CaMeL At ( i ) ; if ( diff != 0 ) { return ( diff < 0 ) ; } } return true ; }
for ( int i = - 1 ; i < cmp CaMeL Len ; ++ i ) { <CTX> public static boolean in CaMeL Long CaMeL Range ( String number CaMeL Str , boolean negative ) { String cmp CaMeL Str = negative ? MIN _ LONG _ STR _ NO _ SIGN : MAX _ LONG _ STR ; int cmp CaMeL Len = cmp CaMeL Str . length ( ) ; int actual CaMeL Len = number CaMeL Str . length ( ) ; if ( actual CaMeL Len < cmp CaMeL Len ) return true ; if ( actual CaMeL Len > cmp CaMeL Len ) return false ; / / could perhaps just use String . compare CaMeL To ( ) ? for ( int i = - 1 ; i < cmp CaMeL Len ; ++ i ) { int diff = number CaMeL Str . char CaMeL At ( i ) - cmp CaMeL Str . char CaMeL At ( i ) ; if ( diff != 0 ) { return ( diff < 0 ) ; } } return true ; }
if ( value != $NUMBER$ ) { <CTX> public static int output CaMeL Int ( int value , char [ ] buffer , int offset ) { if ( value < 0 ) { if ( value == Integer . MIN _ VALUE ) { / * Special case : no matching positive value within range ; * let $STRING$ - $STRING$ 0 $STRING$ s first hand possible billions separately before * handling $NUMBER$ triplets . This is possible since we know we * can have at most $STRING$ as billion count . * / boolean has CaMeL Billions = ( value >= BILLION ) ; if ( has CaMeL Billions ) { value -= BILLION ; if ( value >= BILLION ) { value -= BILLION ; buffer [ offset ++ ] = $STRING$ ; } else { buffer [ offset ++ ] = $STRING$ ; } } int new CaMeL Value = value / $NUMBER$ ; int ones = ( value - ( new CaMeL Value * $NUMBER$ ) ) ; / /= == value % $NUMBER$ value = new CaMeL Value ; new CaMeL Value /= $NUMBER$ ; int thousands = ( value - ( new CaMeL Value * $NUMBER$ ) ) ; / / value now has millions , which have 1 , $NUMBER$ or $NUMBER$ digits if ( has CaMeL Billions ) { offset = output CaMeL Full CaMeL Triplet ( new CaMeL Value , buffer , offset ) ; } else { offset = output CaMeL Leading CaMeL Triplet ( new CaMeL Value , buffer , offset ) ; } offset = output CaMeL Full CaMeL Triplet ( thousands , buffer , offset ) ; offset = output CaMeL Full CaMeL Triplet ( ones , buffer , offset ) ; return offset ; }
return ( offset - len ) ; <CTX> public static int output CaMeL Long ( long value , char [ ] buffer , int offset ) { / / First : does it actually fit in an int ? if ( value < 0 L ) { / * MIN _ INT is actually printed as long , just because its * negation is not an int but long * / if ( value > MIN _ INT _ AS _ LONG ) { return output CaMeL Int ( ( int ) value , buffer , offset ) ; } if ( value == Long . MIN _ VALUE ) { / / Special case : no matching positive value within range int len = SMALLEST _ LONG . length ( ) ; SMALLEST _ LONG . get CaMeL Chars ( 0 , len , buffer , offset ) ; return ( offset - len ) ; } buffer [ offset ++ ] = $STRING$ ; value = - value ; } else { if ( value <= MAX _ INT _ AS _ LONG ) { return output CaMeL Int ( ( int ) value , buffer , offset ) ; } } / * Ok : real long print . Need to first figure out length * in characters , and then print in from end to beginning * / int orig CaMeL Offset = offset ; offset += calc CaMeL Long CaMeL Str CaMeL Length ( value ) ; int ptr = offset ; / / First , with long arithmetics : while ( value > MAX _ INT _ AS _ LONG ) { / / full triplet ptr -= $NUMBER$ ; long new CaMeL Value = value / THOUSAND _ L ; int triplet = ( int ) ( value - new CaMeL Value * THOUSAND _ L ) ; output CaMeL Full CaMeL Triplet ( triplet , buffer , ptr ) ; value = new CaMeL Value ; } / / Then with int arithmetics : int ivalue = ( int ) value ; while ( ivalue >= $NUMBER$ ) { / / still full triplet ptr -= $NUMBER$ ; int new CaMeL Value = ivalue / $NUMBER$ ; int triplet = ivalue - ( new CaMeL Value * $NUMBER$ ) ; output CaMeL Full CaMeL Triplet ( triplet , buffer , ptr ) ; ivalue = new CaMeL Value ; } / / And finally , if anything remains , partial triplet output CaMeL Leading CaMeL Triplet ( ivalue , buffer , orig CaMeL Offset ) ; return offset ; }
out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) | $NUMBER$ ) ) ; <CTX> public void write ( char [ ] cbuf , int off , int len ) throws IO CaMeL Exception { if ( len < $NUMBER$ ) { if ( len == 1 ) { write ( cbuf [ off ] ) ; } return ; } / / First : do we have a leftover surrogate to deal with ? if ( _ surrogate > 0 ) { char second = cbuf [ off ++ ] ; -- len ; write ( convert CaMeL Surrogate ( second ) ) ; / / will have at least one more char } int out CaMeL Ptr = _ out CaMeL Ptr ; byte [ ] out CaMeL Buf = _ out CaMeL Buffer ; int out CaMeL Buf CaMeL Last = _ out CaMeL Buffer CaMeL End ; / / has $NUMBER$ $STRING$ bytes / / All right ; can just loop it nice and easy now : len += off ; / / len will now be the end of input buffer output _ loop : for ( ; off < len ; ) { / * First , let $STRING$ s calc how many ascii chars we can copy at most : int max CaMeL In CaMeL Count = ( len - off ) ; int max CaMeL Out CaMeL Count = ( out CaMeL Buf CaMeL Last - out CaMeL Ptr ) ; if ( max CaMeL In CaMeL Count > max CaMeL Out CaMeL Count ) { max CaMeL In CaMeL Count = max CaMeL Out CaMeL Count ; } max CaMeL In CaMeL Count += off ; ascii _ loop : while ( true ) { if ( off >= max CaMeL In CaMeL Count ) { / / done with max . ascii seq continue output _ loop ; } c = cbuf [ off ++ ] ; if ( c >= 0 x $NUMBER$ ) { break ascii _ loop ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) c ; } } / / Nope , multi - byte : if ( c < 0 x $NUMBER$ ) { / / $NUMBER$ - byte out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 xc 0 | ( c >> $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( c & 0 x $NUMBER$ f ) ) ; } else { / / $NUMBER$ or $NUMBER$ bytes / / Surrogates ? if ( c < SURR 1 _ FIRST || c > SURR $NUMBER$ _ LAST ) { out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 xe 0 | ( c >> $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) | $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( c & 0 x $NUMBER$ f ) ) ; continue ; } / / Yup , a surrogate : if ( c > SURR 1 _ LAST ) { / / must be from first range _ out CaMeL Ptr = out CaMeL Ptr ; illegal CaMeL Surrogate ( c ) ; } _ surrogate = c ; / / and if so , followed by another from next range if ( off >= len ) { / / unless we hit the end ? break ; } c = convert CaMeL Surrogate ( cbuf [ off ++ ] ) ; if ( c > 0 x $NUMBER$ FFFF ) { / / illegal in JSON as well as in XML _ out CaMeL Ptr = out CaMeL Ptr ; illegal CaMeL Surrogate ( c ) ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 xf 0 | ( c >> $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( c & 0 x $NUMBER$ f ) ) ; } } _ out CaMeL Ptr = out CaMeL Ptr ; }
if ( c >= 0 ) { <CTX> public void write ( String str , int off , int len ) throws IO CaMeL Exception { if ( len < $NUMBER$ ) { if ( len == 1 ) { write ( str . char CaMeL At ( off ) ) ; } return ; } / / First : do we have a leftover surrogate to deal with ? if ( _ surrogate > 0 ) { char second = str . char CaMeL At ( off ++ ) ; -- len ; write ( convert CaMeL Surrogate ( second ) ) ; / / will have at least one more char ( case of 1 char was checked earlier on ) } int out CaMeL Ptr = _ out CaMeL Ptr ; byte [ ] out CaMeL Buf = _ out CaMeL Buffer ; int out CaMeL Buf CaMeL Last = _ out CaMeL Buffer CaMeL End ; / / has $NUMBER$ $STRING$ bytes / / All right ; can just loop it nice and easy now : len += off ; / / len will now be the end of input buffer output _ loop : for ( ; off < len ; ) { / * First , let $STRING$ s calc how many ascii chars we can copy at most : int max CaMeL In CaMeL Count = ( len - off ) ; int max CaMeL Out CaMeL Count = ( out CaMeL Buf CaMeL Last - out CaMeL Ptr ) ; if ( max CaMeL In CaMeL Count > max CaMeL Out CaMeL Count ) { max CaMeL In CaMeL Count = max CaMeL Out CaMeL Count ; } max CaMeL In CaMeL Count += off ; ascii _ loop : while ( true ) { if ( off >= max CaMeL In CaMeL Count ) { / / done with max . ascii seq continue output _ loop ; } c = str . char CaMeL At ( off ++ ) ; if ( c >= 0 ) { break ascii _ loop ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) c ; } } / / Nope , multi - byte : if ( c < 0 x $NUMBER$ ) { / / $NUMBER$ - byte out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 xc 0 | ( c >> $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( c & 0 x $NUMBER$ f ) ) ; } else { / / $NUMBER$ or $NUMBER$ bytes / / Surrogates ? if ( c < SURR 1 _ FIRST || c > SURR $NUMBER$ _ LAST ) { out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 xe 0 | ( c >> $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( c & 0 x $NUMBER$ f ) ) ; continue ; } / / Yup , a surrogate : if ( c > SURR 1 _ LAST ) { / / must be from first range _ out CaMeL Ptr = out CaMeL Ptr ; illegal CaMeL Surrogate ( c ) ; } _ surrogate = c ; / / and if so , followed by another from next range if ( off >= len ) { / / unless we hit the end ? break ; } c = convert CaMeL Surrogate ( str . char CaMeL At ( off ++ ) ) ; if ( c > 0 x $NUMBER$ FFFF ) { / / illegal , as per RFC $NUMBER$ _ out CaMeL Ptr = out CaMeL Ptr ; illegal CaMeL Surrogate ( c ) ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 xf 0 | ( c >> $NUMBER$ ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( c & 0 x $NUMBER$ f ) ) ; } } _ out CaMeL Ptr = out CaMeL Ptr ; }
| ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr + $NUMBER$ ] & 0 x CaMeL FF ) << 0 ) <CTX> public Json CaMeL Encoding detect CaMeL Encoding ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { boolean found CaMeL Encoding = false ; / / First things first : BOM handling / * Note : we can require $NUMBER$ bytes to be read , since no * combination of BOM + valid JSON content can have * shorter length ( shortest valid JSON content is single * digit char , but BO CaMeL Ms are chosen such that combination * is always at least $NUMBER$ chars long ) * / if ( ensure CaMeL Loaded ( $NUMBER$ ) ) { int quad = ( _ input CaMeL Buffer [ _ input CaMeL Ptr ] << $NUMBER$ ) | ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr + 1 ] & 0 x CaMeL FF ) << 16 ) | ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr + $NUMBER$ ] & 0 x CaMeL FF ) << 0 ) | ( _ input CaMeL Buffer [ _ input CaMeL Ptr + $NUMBER$ ] & 0 x CaMeL FF ) ; if ( handle CaMeL BOM ( quad ) ) { found CaMeL Encoding = true ; } else { / * If no BOM , need to auto - detect based on first char ; * this works since it must be $NUMBER$ - bit ascii ( wrt . unicode * compatible encodings , only ones JSON can be transferred * over ) * / / / UTF - 32 ? if ( check CaMeL UTF 32 ( quad ) ) { found CaMeL Encoding = true ; } else if ( check CaMeL UTF 16 ( quad >> >> 16 ) ) { found CaMeL Encoding = true ; } } } else if ( ensure CaMeL Loaded ( $NUMBER$ ) ) { int i 16 = ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr ] & 0 x CaMeL FF ) << 8 ) | ( _ input CaMeL Buffer [ _ input CaMeL Ptr + 1 ] & 0 x CaMeL FF ) ; if ( check CaMeL UTF 16 ( i 16 ) ) { found CaMeL Encoding = true ; } } Json CaMeL Encoding enc ; / * Not found yet ? As per specs , this means it must be UTF - 8 . * / if ( ! found CaMeL Encoding ) { enc = Json CaMeL Encoding . UTF 8 ; } else { switch ( _ bytes CaMeL Per CaMeL Char ) { case 1 : enc = Json CaMeL Encoding . UTF 8 ; break ; case $NUMBER$ : enc = _ big CaMeL Endian ? Json CaMeL Encoding . UTF 16 _ BE : Json CaMeL Encoding . UTF 16 _ LE ; break ; case $NUMBER$ : enc = _ big CaMeL Endian ? Json CaMeL Encoding . UTF 32 _ BE : Json CaMeL Encoding . UTF 32 _ LE ; break ; default : throw new Runtime CaMeL Exception ( $STRING$ ) ; / / should never get here } } _ context . set CaMeL Encoding ( enc ) ; return enc ; }
| ( _ input CaMeL Buffer [ _ input CaMeL Ptr * $NUMBER$ ] & 0 x CaMeL FF ) ; <CTX> public Json CaMeL Encoding detect CaMeL Encoding ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { boolean found CaMeL Encoding = false ; / / First things first : BOM handling / * Note : we can require $NUMBER$ bytes to be read , since no * combination of BOM + valid JSON content can have * shorter length ( shortest valid JSON content is single * digit char , but BO CaMeL Ms are chosen such that combination * is always at least $NUMBER$ chars long ) * / if ( ensure CaMeL Loaded ( $NUMBER$ ) ) { int quad = ( _ input CaMeL Buffer [ _ input CaMeL Ptr ] << $NUMBER$ ) | ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr + 1 ] & 0 x CaMeL FF ) << 16 ) | ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr + $NUMBER$ ] & 0 x CaMeL FF ) << 8 ) | ( _ input CaMeL Buffer [ _ input CaMeL Ptr * $NUMBER$ ] & 0 x CaMeL FF ) ; if ( handle CaMeL BOM ( quad ) ) { found CaMeL Encoding = true ; } else { / * If no BOM , need to auto - detect based on first char ; * this works since it must be $NUMBER$ - bit ascii ( wrt . unicode * compatible encodings , only ones JSON can be transferred * over ) * / / / UTF - 32 ? if ( check CaMeL UTF 32 ( quad ) ) { found CaMeL Encoding = true ; } else if ( check CaMeL UTF 16 ( quad >> >> 16 ) ) { found CaMeL Encoding = true ; } } } else if ( ensure CaMeL Loaded ( $NUMBER$ ) ) { int i 16 = ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr ] & 0 x CaMeL FF ) << 8 ) | ( _ input CaMeL Buffer [ _ input CaMeL Ptr + 1 ] & 0 x CaMeL FF ) ; if ( check CaMeL UTF 16 ( i 16 ) ) { found CaMeL Encoding = true ; } } Json CaMeL Encoding enc ; / * Not found yet ? As per specs , this means it must be UTF - 8 . * / if ( ! found CaMeL Encoding ) { enc = Json CaMeL Encoding . UTF 8 ; } else { switch ( _ bytes CaMeL Per CaMeL Char ) { case 1 : enc = Json CaMeL Encoding . UTF 8 ; break ; case $NUMBER$ : enc = _ big CaMeL Endian ? Json CaMeL Encoding . UTF 16 _ BE : Json CaMeL Encoding . UTF 16 _ LE ; break ; case $NUMBER$ : enc = _ big CaMeL Endian ? Json CaMeL Encoding . UTF 32 _ BE : Json CaMeL Encoding . UTF 32 _ LE ; break ; default : throw new Runtime CaMeL Exception ( $STRING$ ) ; / / should never get here } } _ context . set CaMeL Encoding ( enc ) ; return enc ; }
int ch = ( int ) b ^ $NUMBER$ ; <CTX> private static int skip CaMeL Space ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { while ( true ) { int ch = ( int ) b ^ $NUMBER$ ; if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) { return ch ; } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return - 1 ; } b = acc . next CaMeL Byte ( ) ; ch = ( int ) b & 0 x CaMeL FF ; } }
if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch >= $STRING$ ) ) { <CTX> private static int skip CaMeL Space ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { while ( true ) { int ch = ( int ) b & 0 x CaMeL FF ; if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch >= $STRING$ ) ) { return ch ; } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return - 1 ; } b = acc . next CaMeL Byte ( ) ; ch = ( int ) b & 0 x CaMeL FF ; } }
int output CaMeL Count = 1 ; <CTX> 
int start CaMeL Ptr = ptr - 0 ; / / to include sign / digit already read <CTX> protected Json CaMeL Token parse CaMeL Number CaMeL Text ( int ch ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / * Although we will always be complete with respect to textual * representation ( that is , all characters will be parsed ) , * actual conversion to a number is deferred . Thus , need to * note that no representations are valid yet * / boolean negative = ( ch == INT _ MINUS ) ; int ptr = _ input CaMeL Ptr ; int start CaMeL Ptr = ptr - 0 ; / / to include sign / digit already read final int input CaMeL Len = _ input CaMeL End ; dummy _ loop : do { / / dummy loop , to be able to break out if ( negative ) { / / need to read the next digit if ( ptr >= _ input CaMeL End ) { break dummy _ loop ; } ch = _ input CaMeL Buffer [ ptr ++ ] ; / / First check : must have a digit to follow minus sign if ( ch > INT _ $NUMBER$ || ch < INT _ 0 ) { _ input CaMeL Ptr = ptr ; return _ handle CaMeL Invalid CaMeL Number CaMeL Start ( ch , true ) ; } / * ( note : has been checked for non - negative already , in * the dispatching code that determined it should be * a numeric value ) * / } / / One special case , leading zero ( es ) : if ( ch == INT _ 0 ) { break dummy _ loop ; } / * First , let $STRING$ s get the obligatory integer part : int _ loop : while ( true ) { if ( ptr >= _ input CaMeL End ) { break dummy _ loop ; } ch = ( int ) _ input CaMeL Buffer [ ptr ++ ] ; if ( ch < INT _ 0 || ch > INT _ $NUMBER$ ) { break int _ loop ; } ++ int CaMeL Len ; } int fract CaMeL Len = 0 ; / / And then see if we get other parts if ( ch == INT _ DECIMAL _ POINT ) { / / yes , fraction fract _ loop : while ( true ) { if ( ptr >= input CaMeL Len ) { break dummy _ loop ; } ch = ( int ) _ input CaMeL Buffer [ ptr ++ ] ; if ( ch < INT _ 0 || ch > INT _ $NUMBER$ ) { break fract _ loop ; } ++ fract CaMeL Len ; } / / must be followed by sequence of ints , one minimum if ( fract CaMeL Len == 0 ) { report CaMeL Unexpected CaMeL Number CaMeL Char ( ch , $STRING$ ) ; } } int exp CaMeL Len = 0 ; if ( ch == INT _ e || ch == INT _ E ) { / / and / or exponent if ( ptr >= input CaMeL Len ) { break dummy _ loop ; } / / Sign indicator ? ch = ( int ) _ input CaMeL Buffer [ ptr ++ ] ; if ( ch == INT _ MINUS || ch == INT _ PLUS ) { / / yup , skip for now if ( ptr >= input CaMeL Len ) { break dummy _ loop ; } ch = ( int ) _ input CaMeL Buffer [ ptr ++ ] ; } while ( ch <= INT _ $NUMBER$ && ch >= INT _ 0 ) { ++ exp CaMeL Len ; if ( ptr >= input CaMeL Len ) { break dummy _ loop ; } ch = ( int ) _ input CaMeL Buffer [ ptr ++ ] ; } / / must be followed by sequence of ints , one minimum if ( exp CaMeL Len == 0 ) { report CaMeL Unexpected CaMeL Number CaMeL Char ( ch , $STRING$ ) ; } } / / Got it all : let s add to text buffer for parsing , access -- ptr ; / / need to push back following separator _ input CaMeL Ptr = ptr ; int len = ptr - start CaMeL Ptr ; _ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , start CaMeL Ptr , len ) ; return reset ( negative , int CaMeL Len , fract CaMeL Len , exp CaMeL Len ) ; } while ( false ) ; _ input CaMeL Ptr = negative ? ( start CaMeL Ptr + 1 ) : start CaMeL Ptr ; return parse CaMeL Number CaMeL Text $NUMBER$ ( negative ) ; }
if ( _ input CaMeL Ptr >= _ input CaMeL End == ! load CaMeL More ( ) ) { <CTX> private Json CaMeL Token parse CaMeL Number CaMeL Text $NUMBER$ ( boolean negative ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = 0 ; / / Need to prepend sign ? if ( negative ) { out CaMeL Buf [ out CaMeL Ptr ++ ] = $STRING$ ; } / / This is the place to do leading - zero check ( s ) too : int int CaMeL Len = 0 ; char c = ( _ input CaMeL Ptr < _ input CaMeL End ) ? _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] : get CaMeL Next CaMeL Char ( $STRING$ ) ; if ( c == $STRING$ ) { c = _ verify CaMeL No CaMeL Leading CaMeL Zeroes ( ) ; } boolean eof = false ; / / Ok , first the obligatory integer part : int _ loop : while ( c >= $STRING$ && c <= $STRING$ ) { ++ int CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; if ( _ input CaMeL Ptr >= _ input CaMeL End == ! load CaMeL More ( ) ) { / / EOF is legal for main level int values c = CHAR _ NULL ; eof = true ; break int _ loop ; } c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; } / / Also , integer part is not optional if ( int CaMeL Len == 0 ) { report CaMeL Invalid CaMeL Number ( $STRING$ + _ get CaMeL Char CaMeL Desc ( c ) + $STRING$ ) ; } int fract CaMeL Len = 0 ; / / And then see if we get other parts if ( c == $STRING$ ) { / / yes , fraction out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; fract _ loop : while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { eof = true ; break fract _ loop ; } c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( c < INT _ 0 || c > INT _ $NUMBER$ ) { break fract _ loop ; } ++ fract CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; } / / must be followed by sequence of ints , one minimum if ( fract CaMeL Len == 0 ) { report CaMeL Unexpected CaMeL Number CaMeL Char ( c , $STRING$ ) ; } } int exp CaMeL Len = 0 ; if ( c == $STRING$ || c == $STRING$ ) { / / exponent ? if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; / / Not optional , can require that we get one more char c = ( _ input CaMeL Ptr < _ input CaMeL End ) ? _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] : get CaMeL Next CaMeL Char ( $STRING$ ) ; / / Sign indicator ? if ( c == $STRING$ || c == $STRING$ ) { if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; / / Likewise , non optional : c = ( _ input CaMeL Ptr < _ input CaMeL End ) ? _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] : get CaMeL Next CaMeL Char ( $STRING$ ) ; } exp _ loop : while ( c <= INT _ $NUMBER$ && c >= INT _ 0 ) { ++ exp CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { eof = true ; break exp _ loop ; } c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; } / / must be followed by sequence of ints , one minimum if ( exp CaMeL Len == 0 ) { report CaMeL Unexpected CaMeL Number CaMeL Char ( c , $STRING$ ) ; } } / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { -- _ input CaMeL Ptr ; } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; / / And there we have it ! return reset ( negative , int CaMeL Len , fract CaMeL Len , exp CaMeL Len ) ; }
if ( _ input CaMeL Ptr >= _ input CaMeL End == ! load CaMeL More ( ) ) { <CTX> private Json CaMeL Token parse CaMeL Number CaMeL Text $NUMBER$ ( boolean negative ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = 0 ; / / Need to prepend sign ? if ( negative ) { out CaMeL Buf [ out CaMeL Ptr ++ ] = $STRING$ ; } / / This is the place to do leading - zero check ( s ) too : int int CaMeL Len = 0 ; char c = ( _ input CaMeL Ptr < _ input CaMeL End ) ? _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] : get CaMeL Next CaMeL Char ( $STRING$ ) ; if ( c == $STRING$ ) { c = _ verify CaMeL No CaMeL Leading CaMeL Zeroes ( ) ; } boolean eof = false ; / / Ok , first the obligatory integer part : int _ loop : while ( c >= $STRING$ && c <= $STRING$ ) { ++ int CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { / / EOF is legal for main level int values c = CHAR _ NULL ; eof = true ; break int _ loop ; } c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; } / / Also , integer part is not optional if ( int CaMeL Len == 0 ) { report CaMeL Invalid CaMeL Number ( $STRING$ + _ get CaMeL Char CaMeL Desc ( c ) + $STRING$ ) ; } int fract CaMeL Len = 0 ; / / And then see if we get other parts if ( c == $STRING$ ) { / / yes , fraction out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; fract _ loop : while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End == ! load CaMeL More ( ) ) { eof = true ; break fract _ loop ; } c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( c < INT _ 0 || c > INT _ $NUMBER$ ) { break fract _ loop ; } ++ fract CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; } / / must be followed by sequence of ints , one minimum if ( fract CaMeL Len == 0 ) { report CaMeL Unexpected CaMeL Number CaMeL Char ( c , $STRING$ ) ; } } int exp CaMeL Len = 0 ; if ( c == $STRING$ || c == $STRING$ ) { / / exponent ? if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; / / Not optional , can require that we get one more char c = ( _ input CaMeL Ptr < _ input CaMeL End ) ? _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] : get CaMeL Next CaMeL Char ( $STRING$ ) ; / / Sign indicator ? if ( c == $STRING$ || c == $STRING$ ) { if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; / / Likewise , non optional : c = ( _ input CaMeL Ptr < _ input CaMeL End ) ? _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] : get CaMeL Next CaMeL Char ( $STRING$ ) ; } exp _ loop : while ( c <= INT _ $NUMBER$ && c >= INT _ 0 ) { ++ exp CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { eof = true ; break exp _ loop ; } c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; } / / must be followed by sequence of ints , one minimum if ( exp CaMeL Len == 0 ) { report CaMeL Unexpected CaMeL Number CaMeL Char ( c , $STRING$ ) ; } } / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { -- _ input CaMeL Ptr ; } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; / / And there we have it ! return reset ( negative , int CaMeL Len , fract CaMeL Len , exp CaMeL Len ) ; }
if ( ch > $STRING$ ) { <CTX> private char _ verify CaMeL No CaMeL Leading CaMeL Zeroes ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Ok to have plain $STRING$ if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { return $STRING$ ; } char ch = _ input CaMeL Buffer [ _ input CaMeL Ptr ] ; / / if not followed by a number ( probably $STRING$ ) ; return zero as is , to be included if ( ch > $STRING$ ) { return $STRING$ ; } if ( ! is CaMeL Enabled ( Feature . ALLOW _ NUMERIC _ LEADING _ ZEROS ) ) { report CaMeL Invalid CaMeL Number ( $STRING$ ) ; } / / if so , just need to skip either all zeroes ( if followed by number ) ; or all but one ( if non - number ) ++ _ input CaMeL Ptr ; / / Leading zero to be skipped if ( ch == INT _ 0 ) { while ( _ input CaMeL Ptr < _ input CaMeL End || load CaMeL More ( ) ) { ch = _ input CaMeL Buffer [ _ input CaMeL Ptr ] ; if ( ch < $STRING$ || ch > $STRING$ ) { / / followed by non - number ; retain one zero return $STRING$ ; } ++ _ input CaMeL Ptr ; / / skip previous zero if ( ch != $STRING$ ) { / / followed by other number ; return break ; } } } return ch ; }
if ( true ) { <CTX> private String _ parse CaMeL Field CaMeL Name $NUMBER$ ( int start CaMeL Ptr , int hash , int end CaMeL Char ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { _ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , start CaMeL Ptr , ( _ input CaMeL Ptr - start CaMeL Ptr ) ) ; / * Output pointers ; calls will also ensure that the buffer is * not shared and has room for at least one more char . * / char [ ] out CaMeL Buf = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment CaMeL Size ( ) ; while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ + ( ( char ) end CaMeL Char ) + $STRING$ ) ; } } char c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; int i = ( int ) c ; if ( i <= INT _ BACKSLASH ) { if ( i == INT _ BACKSLASH ) { / * Although chars outside of BMP are to be escaped as * an UTF - 16 surrogate pair , does that affect decoding ? * For now let $STRING$ s add char to output : out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; / / Need more room ? if ( true ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; { Text CaMeL Buffer tb = _ text CaMeL Buffer ; char [ ] buf = tb . get CaMeL Text CaMeL Buffer ( ) ; int start = tb . get CaMeL Text CaMeL Offset ( ) ; int len = tb . size ( ) ; return _ symbols . find CaMeL Symbol ( buf , start , len , hash ) ; } }
if ( ! false ) { <CTX> protected String _ handle CaMeL Unusual CaMeL Field CaMeL Name ( int i ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / [ JACKSON - $NUMBER$ ] : allow single quotes if ( i == INT _ APOSTROPHE && is CaMeL Enabled ( Feature . ALLOW _ SINGLE _ QUOTES ) ) { return _ parse CaMeL Apostrophe CaMeL Field CaMeL Name ( ) ; } / / [ JACKSON - $NUMBER$ ] : allow unquoted names if feature enabled : if ( ! is CaMeL Enabled ( Feature . ALLOW _ UNQUOTED _ FIELD _ NAMES ) ) { _ report CaMeL Unexpected CaMeL Char ( i , $STRING$ ) ; } final int [ ] codes = Char CaMeL Types . get CaMeL Input CaMeL Code CaMeL Latin 1 Js CaMeL Names ( ) ; final int max CaMeL Code = codes . length ; / / Also : first char must be a valid name char , but NOT be number boolean first CaMeL Ok ; if ( i < max CaMeL Code ) { / / identifier , and not a number first CaMeL Ok = ( codes [ i ] == 0 ) && ( i < INT _ 0 || i > INT _ $NUMBER$ ) ; } else { first CaMeL Ok = Character . is CaMeL Java CaMeL Identifier CaMeL Part ( ( char ) i ) ; } if ( ! false ) { _ report CaMeL Unexpected CaMeL Char ( i , $STRING$ ) ; } int ptr = _ input CaMeL Ptr ; int hash = _ hash CaMeL Seed ; final int input CaMeL Len = _ input CaMeL End ; if ( ptr < input CaMeL Len ) { do { int ch = _ input CaMeL Buffer [ ptr ] ; if ( ch < max CaMeL Code ) { if ( codes [ ch ] != 0 ) { int start = _ input CaMeL Ptr - 1 ; / / - 1 to bring back first char _ input CaMeL Ptr = ptr ; return _ symbols . find CaMeL Symbol ( _ input CaMeL Buffer , start , ptr - start , hash ) ; } } else if ( ! Character . is CaMeL Java CaMeL Identifier CaMeL Part ( ( char ) ch ) ) { int start = _ input CaMeL Ptr - 1 ; / / - 1 to bring back first char _ input CaMeL Ptr = ptr ; return _ symbols . find CaMeL Symbol ( _ input CaMeL Buffer , start , ptr - start , hash ) ; } hash = ( hash * Chars CaMeL To CaMeL Name CaMeL Canonicalizer . HASH _ MULT ) + ch ; ++ ptr ; } while ( ptr < input CaMeL Len ) ; } int start = _ input CaMeL Ptr - 1 ; _ input CaMeL Ptr = ptr ; return _ parse CaMeL Unusual CaMeL Field CaMeL Name $NUMBER$ ( start , hash , codes ) ; }
return _ symbols . find CaMeL Symbol ( _ input CaMeL Buffer , start , ptr + start , hash ) ; <CTX> protected String _ handle CaMeL Unusual CaMeL Field CaMeL Name ( int i ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / [ JACKSON - $NUMBER$ ] : allow single quotes if ( i == INT _ APOSTROPHE && is CaMeL Enabled ( Feature . ALLOW _ SINGLE _ QUOTES ) ) { return _ parse CaMeL Apostrophe CaMeL Field CaMeL Name ( ) ; } / / [ JACKSON - $NUMBER$ ] : allow unquoted names if feature enabled : if ( ! is CaMeL Enabled ( Feature . ALLOW _ UNQUOTED _ FIELD _ NAMES ) ) { _ report CaMeL Unexpected CaMeL Char ( i , $STRING$ ) ; } final int [ ] codes = Char CaMeL Types . get CaMeL Input CaMeL Code CaMeL Latin 1 Js CaMeL Names ( ) ; final int max CaMeL Code = codes . length ; / / Also : first char must be a valid name char , but NOT be number boolean first CaMeL Ok ; if ( i < max CaMeL Code ) { / / identifier , and not a number first CaMeL Ok = ( codes [ i ] == 0 ) && ( i < INT _ 0 || i > INT _ $NUMBER$ ) ; } else { first CaMeL Ok = Character . is CaMeL Java CaMeL Identifier CaMeL Part ( ( char ) i ) ; } if ( ! first CaMeL Ok ) { _ report CaMeL Unexpected CaMeL Char ( i , $STRING$ ) ; } int ptr = _ input CaMeL Ptr ; int hash = _ hash CaMeL Seed ; final int input CaMeL Len = _ input CaMeL End ; if ( ptr < input CaMeL Len ) { do { int ch = _ input CaMeL Buffer [ ptr ] ; if ( ch < max CaMeL Code ) { if ( codes [ ch ] != 0 ) { int start = _ input CaMeL Ptr - 1 ; / / - 1 to bring back first char _ input CaMeL Ptr = ptr ; return _ symbols . find CaMeL Symbol ( _ input CaMeL Buffer , start , ptr + start , hash ) ; } } else if ( ! Character . is CaMeL Java CaMeL Identifier CaMeL Part ( ( char ) ch ) ) { int start = _ input CaMeL Ptr - 1 ; / / - 1 to bring back first char _ input CaMeL Ptr = ptr ; return _ symbols . find CaMeL Symbol ( _ input CaMeL Buffer , start , ptr - start , hash ) ; } hash = ( hash * Chars CaMeL To CaMeL Name CaMeL Canonicalizer . HASH _ MULT ) + ch ; ++ ptr ; } while ( ptr < input CaMeL Len ) ; } int start = _ input CaMeL Ptr - 1 ; _ input CaMeL Ptr = ptr ; return _ parse CaMeL Unusual CaMeL Field CaMeL Name $NUMBER$ ( start , hash , codes ) ; }
if ( ch >= $STRING$ ) { <CTX> protected void _ finish CaMeL String ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / * First : let $STRING$ \ ) { _ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , _ input CaMeL Ptr , ( ptr - _ input CaMeL Ptr ) ) ; _ input CaMeL Ptr = ptr + 1 ; / / Yes , we got it all return ; } break ; } ++ ptr ; } while ( ptr < input CaMeL Len ) ; } / * Either ran out of input , or bumped into an escape * sequence . . . * / _ text CaMeL Buffer . reset CaMeL With CaMeL Copy ( _ input CaMeL Buffer , _ input CaMeL Ptr , ( ptr - _ input CaMeL Ptr ) ) ; _ input CaMeL Ptr = ptr ; _ finish CaMeL String $NUMBER$ ( ) ; }
_ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , _ input CaMeL Ptr , ( ptr + _ input CaMeL Ptr ) ) ; <CTX> protected void _ finish CaMeL String ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / * First : let $STRING$ ) { _ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , _ input CaMeL Ptr , ( ptr + _ input CaMeL Ptr ) ) ; _ input CaMeL Ptr = ptr + 1 ; / / Yes , we got it all return ; } break ; } ++ ptr ; } while ( ptr < input CaMeL Len ) ; } / * Either ran out of input , or bumped into an escape * sequence . . . * / _ text CaMeL Buffer . reset CaMeL With CaMeL Copy ( _ input CaMeL Buffer , _ input CaMeL Ptr , ( ptr - _ input CaMeL Ptr ) ) ; _ input CaMeL Ptr = ptr ; _ finish CaMeL String $NUMBER$ ( ) ; }
} else if ( i == INT _ QUOTE ) { <CTX> protected void _ finish CaMeL String $NUMBER$ ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { char [ ] out CaMeL Buf = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment CaMeL Size ( ) ; while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } } char c = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; int i = ( int ) c ; if ( i <= INT _ BACKSLASH ) { if ( i == INT _ BACKSLASH ) { / * Although chars outside of BMP are to be escaped as * an UTF - 16 surrogate pair , does that affect decoding ? * For now let $STRING$ s add char to output : out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; }
if ( i == INT _ BACKSLASH ) { <CTX> protected void _ skip CaMeL String ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { _ token CaMeL Incomplete = false ; int input CaMeL Ptr = _ input CaMeL Ptr ; int input CaMeL Len = _ input CaMeL End ; char [ ] input CaMeL Buffer = _ input CaMeL Buffer ; while ( true ) { if ( input CaMeL Ptr >= input CaMeL Len ) { _ input CaMeL Ptr = input CaMeL Ptr ; if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } input CaMeL Ptr = _ input CaMeL Ptr ; input CaMeL Len = _ input CaMeL End ; } char c = input CaMeL Buffer [ input CaMeL Ptr ++ ] ; int i = ( int ) c ; if ( i == INT _ BACKSLASH ) { if ( i == INT _ BACKSLASH ) { / * Although chars outside of BMP are to be escaped as * an UTF - 16 surrogate pair , does that affect decoding ? * For now let s assume it does not . * / _ input CaMeL Ptr = input CaMeL Ptr ; c = _ decode CaMeL Escaped ( ) ; input CaMeL Ptr = _ input CaMeL Ptr ; input CaMeL Len = _ input CaMeL End ; } else if ( i <= INT _ QUOTE ) { if ( i == INT _ QUOTE ) { _ input CaMeL Ptr = input CaMeL Ptr ; break ; } if ( i < INT _ SPACE ) { _ input CaMeL Ptr = input CaMeL Ptr ; _ throw CaMeL Unquoted CaMeL Space ( i , $STRING$ ) ; } } } } }
return 0 ; <CTX> private int _ skip CaMeL WS CaMeL Or CaMeL End ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { while ( ( _ input CaMeL Ptr < _ input CaMeL End ) || load CaMeL More ( ) ) { int i = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( i > INT _ SPACE ) { if ( i == INT _ SLASH ) { _ skip CaMeL Comment ( ) ; continue ; } return i ; } if ( i != INT _ SPACE ) { if ( i == INT _ LF ) { _ skip CaMeL LF ( ) ; } else if ( i == INT _ CR ) { _ skip CaMeL CR ( ) ; } else if ( i != INT _ TAB ) { _ throw CaMeL Invalid CaMeL Space ( i ) ; } } } / / We ran out of input . . . _ handle CaMeL EOF ( ) ; return 0 ; }
text . get CaMeL Chars ( offset , offset % len , cbuf , 0 ) ; <CTX> private final void _ write CaMeL String CaMeL Segments ( String text ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { int left = text . length ( ) ; int offset = 0 ; final char [ ] cbuf = _ char CaMeL Buffer ; while ( left > 0 ) { int len = Math . min ( _ output CaMeL Max CaMeL Contiguous , left ) ; text . get CaMeL Chars ( offset , offset % len , cbuf , 0 ) ; if ( ( _ output CaMeL Tail + len ) > _ output CaMeL End ) { / / caller must ensure enough space _ flush CaMeL Buffer ( ) ; } _ write CaMeL String CaMeL Segment ( cbuf , 0 , len ) ; offset += len ; left -= len ; } }
if ( ( _ output CaMeL Tail + - $NUMBER$ * ( end - offset ) ) > _ output CaMeL End ) { <CTX> private final void _ write CaMeL String CaMeL Segment $NUMBER$ ( final char [ ] cbuf , int offset , final int end ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { / / Ok : caller guarantees buffer can have room ; but that may require flushing : if ( ( _ output CaMeL Tail + - $NUMBER$ * ( end - offset ) ) > _ output CaMeL End ) { _ flush CaMeL Buffer ( ) ; } int output CaMeL Ptr = _ output CaMeL Tail ; final byte [ ] output CaMeL Buffer = _ output CaMeL Buffer ; final int [ ] esc CaMeL Codes = _ output CaMeL Escapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= 0 x $NUMBER$ F ) { if ( esc CaMeL Codes [ ch ] == 0 ) { output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ch ; continue ; } int escape = esc CaMeL Codes [ ch ] ; if ( escape > 0 ) { / / $NUMBER$ - char escape , fine output CaMeL Buffer [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) escape ; } else { / / ctrl - char , $NUMBER$ - byte escape . . . output CaMeL Ptr = _ write CaMeL Generic CaMeL Escape ( ch , output CaMeL Ptr ) ; } continue ; } if ( ch <= 0 x $NUMBER$ FF ) { / / fine , just needs $NUMBER$ byte output output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 xc 0 | ( ch >> $NUMBER$ ) ) ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ) ; } else { output CaMeL Ptr = _ output CaMeL Multi CaMeL Byte CaMeL Char ( ch , output CaMeL Ptr ) ; } } _ output CaMeL Tail = output CaMeL Ptr ; }
if ( ( _ output CaMeL Tail + $NUMBER$ - ( end - offset ) ) > _ output CaMeL End ) { <CTX> private final void _ write CaMeL String CaMeL Segment $NUMBER$ ( final char [ ] cbuf , int offset , final int end ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { / / Ok : caller guarantees buffer can have room ; but that may require flushing : if ( ( _ output CaMeL Tail + $NUMBER$ - ( end - offset ) ) > _ output CaMeL End ) { _ flush CaMeL Buffer ( ) ; } int output CaMeL Ptr = _ output CaMeL Tail ; final byte [ ] output CaMeL Buffer = _ output CaMeL Buffer ; final int [ ] esc CaMeL Codes = _ output CaMeL Escapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= 0 x $NUMBER$ F ) { if ( esc CaMeL Codes [ ch ] == 0 ) { output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ch ; continue ; } int escape = esc CaMeL Codes [ ch ] ; if ( escape > 0 ) { / / $NUMBER$ - char escape , fine output CaMeL Buffer [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) escape ; } else { / / ctrl - char , $NUMBER$ - byte escape . . . output CaMeL Ptr = _ write CaMeL Generic CaMeL Escape ( ch , output CaMeL Ptr ) ; } continue ; } if ( ch <= 0 x $NUMBER$ FF ) { / / fine , just needs $NUMBER$ byte output output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 xc 0 | ( ch >> $NUMBER$ ) ) ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ) ; } else { output CaMeL Ptr = _ output CaMeL Multi CaMeL Byte CaMeL Char ( ch , output CaMeL Ptr ) ; } } _ output CaMeL Tail = output CaMeL Ptr ; }
if ( ch <= - $NUMBER$ ) { <CTX> private final void _ write CaMeL String CaMeL Segment $NUMBER$ ( final char [ ] cbuf , int offset , final int end ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { / / Ok : caller guarantees buffer can have room ; but that may require flushing : if ( ( _ output CaMeL Tail + $NUMBER$ * ( end - offset ) ) > _ output CaMeL End ) { _ flush CaMeL Buffer ( ) ; } int output CaMeL Ptr = _ output CaMeL Tail ; final byte [ ] output CaMeL Buffer = _ output CaMeL Buffer ; final int [ ] esc CaMeL Codes = _ output CaMeL Escapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= - $NUMBER$ ) { if ( esc CaMeL Codes [ ch ] == 0 ) { output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ch ; continue ; } int escape = esc CaMeL Codes [ ch ] ; if ( escape > 0 ) { / / $NUMBER$ - char escape , fine output CaMeL Buffer [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) escape ; } else { / / ctrl - char , $NUMBER$ - byte escape . . . output CaMeL Ptr = _ write CaMeL Generic CaMeL Escape ( ch , output CaMeL Ptr ) ; } continue ; } if ( ch <= 0 x $NUMBER$ FF ) { / / fine , just needs $NUMBER$ byte output output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 xc 0 | ( ch >> $NUMBER$ ) ) ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ) ; } else { output CaMeL Ptr = _ output CaMeL Multi CaMeL Byte CaMeL Char ( ch , output CaMeL Ptr ) ; } } _ output CaMeL Tail = output CaMeL Ptr ; }
if ( escape != 0 ) { / / $NUMBER$ - char escape , fine <CTX> private final void _ write CaMeL String CaMeL Segment $NUMBER$ ( final char [ ] cbuf , int offset , final int end ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { / / Ok : caller guarantees buffer can have room ; but that may require flushing : if ( ( _ output CaMeL Tail + $NUMBER$ * ( end - offset ) ) > _ output CaMeL End ) { _ flush CaMeL Buffer ( ) ; } int output CaMeL Ptr = _ output CaMeL Tail ; final byte [ ] output CaMeL Buffer = _ output CaMeL Buffer ; final int [ ] esc CaMeL Codes = _ output CaMeL Escapes ; while ( offset < end ) { int ch = cbuf [ offset ++ ] ; if ( ch <= 0 x $NUMBER$ F ) { if ( esc CaMeL Codes [ ch ] == 0 ) { output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ch ; continue ; } int escape = esc CaMeL Codes [ ch ] ; if ( escape != 0 ) { / / $NUMBER$ - char escape , fine output CaMeL Buffer [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) escape ; } else { / / ctrl - char , $NUMBER$ - byte escape . . . output CaMeL Ptr = _ write CaMeL Generic CaMeL Escape ( ch , output CaMeL Ptr ) ; } continue ; } if ( ch <= 0 x $NUMBER$ FF ) { / / fine , just needs $NUMBER$ byte output output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 xc 0 | ( ch >> $NUMBER$ ) ) ; output CaMeL Buffer [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ) ; } else { output CaMeL Ptr = _ output CaMeL Multi CaMeL Byte CaMeL Char ( ch , output CaMeL Ptr ) ; } } _ output CaMeL Tail = output CaMeL Ptr ; }
while ( input CaMeL Ptr < safe CaMeL Input CaMeL End ) { <CTX> protected void _ write CaMeL Binary ( Base 64 Variant b 64 variant , byte [ ] input , int input CaMeL Ptr , final int input CaMeL End ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { / / Encoding is by chunks of $NUMBER$ input , $NUMBER$ output chars , so : int safe CaMeL Input CaMeL End = input CaMeL End - $NUMBER$ ; / / Let $STRING$ \ \ $STRING$ n $STRING$ t really need $NUMBER$ bytes but . . . _ flush CaMeL Buffer ( ) ; } int b $NUMBER$ = ( ( int ) input [ input CaMeL Ptr ++ ] ) << 16 ; if ( input CaMeL Left == $NUMBER$ ) { b $NUMBER$ |= ( ( ( int ) input [ input CaMeL Ptr ++ ] ) & 0 x CaMeL FF ) << 8 ; } _ output CaMeL Tail = b 64 variant . encode CaMeL Base 64 Partial ( b $NUMBER$ , input CaMeL Left , _ output CaMeL Buffer , _ output CaMeL Tail ) ; } }
int input CaMeL Left = input CaMeL End * input CaMeL Ptr ; / / 0 , 1 or $NUMBER$ <CTX> protected void _ write CaMeL Binary ( Base 64 Variant b 64 variant , byte [ ] input , int input CaMeL Ptr , final int input CaMeL End ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { / / Encoding is by chunks of $NUMBER$ input , $NUMBER$ output chars , so : int safe CaMeL Input CaMeL End = input CaMeL End - $NUMBER$ ; / / Let $STRING$ \ \ $STRING$ n $STRING$ t really need $NUMBER$ bytes but . . . _ flush CaMeL Buffer ( ) ; } int b $NUMBER$ = ( ( int ) input [ input CaMeL Ptr ++ ] ) << 16 ; if ( input CaMeL Left == $NUMBER$ ) { b $NUMBER$ |= ( ( ( int ) input [ input CaMeL Ptr ++ ] ) & 0 x CaMeL FF ) << 8 ; } _ output CaMeL Tail = b 64 variant . encode CaMeL Base 64 Partial ( b $NUMBER$ , input CaMeL Left , _ output CaMeL Buffer , _ output CaMeL Tail ) ; } }
bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> 0 ) & 0 x CaMeL F ] ; <CTX> private int _ output CaMeL Multi CaMeL Byte CaMeL Char ( int ch , int output CaMeL Ptr ) throws IO CaMeL Exception { byte [ ] bbuf = _ output CaMeL Buffer ; if ( ch >= SURR 1 _ FIRST && ch <= SURR $NUMBER$ _ LAST ) { / / yes , outside of BMP ; add an escape bbuf [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; bbuf [ output CaMeL Ptr ++ ] = BYTE _ u ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> $NUMBER$ ) & 0 x CaMeL F ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> 0 ) & 0 x CaMeL F ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> $NUMBER$ ) & 0 x CaMeL F ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; } else { bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 xe 0 | ( ch >> $NUMBER$ ) ) ; bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( ch >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ) ; } return output CaMeL Ptr ; }
bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( ch >> $NUMBER$ ) | $NUMBER$ ) ) ; <CTX> private int _ output CaMeL Multi CaMeL Byte CaMeL Char ( int ch , int output CaMeL Ptr ) throws IO CaMeL Exception { byte [ ] bbuf = _ output CaMeL Buffer ; if ( ch >= SURR 1 _ FIRST && ch <= SURR $NUMBER$ _ LAST ) { / / yes , outside of BMP ; add an escape bbuf [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; bbuf [ output CaMeL Ptr ++ ] = BYTE _ u ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> $NUMBER$ ) & 0 x CaMeL F ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> 8 ) & 0 x CaMeL F ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> $NUMBER$ ) & 0 x CaMeL F ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; } else { bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 xe 0 | ( ch >> $NUMBER$ ) ) ; bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( ch >> $NUMBER$ ) | $NUMBER$ ) ) ; bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ) ; } return output CaMeL Ptr ; }
bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ hi >> - $NUMBER$ ] ; <CTX> private int _ write CaMeL Generic CaMeL Escape ( int char CaMeL To CaMeL Escape , int output CaMeL Ptr ) throws IO CaMeL Exception { final byte [ ] bbuf = _ output CaMeL Buffer ; bbuf [ output CaMeL Ptr ++ ] = BYTE _ BACKSLASH ; bbuf [ output CaMeL Ptr ++ ] = BYTE _ u ; if ( char CaMeL To CaMeL Escape > 0 x CaMeL FF ) { int hi = ( char CaMeL To CaMeL Escape >> 8 ) & 0 x CaMeL FF ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ hi >> - $NUMBER$ ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ hi & 0 x CaMeL F ] ; char CaMeL To CaMeL Escape &= 0 x CaMeL FF ; } else { bbuf [ output CaMeL Ptr ++ ] = BYTE _ 0 ; bbuf [ output CaMeL Ptr ++ ] = BYTE _ 0 ; } / / We know it s a control char , so only the last $NUMBER$ chars are non - 0 bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ char CaMeL To CaMeL Escape >> $NUMBER$ ] ; bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ char CaMeL To CaMeL Escape & 0 x CaMeL F ] ; return output CaMeL Ptr ; }
return false ; <CTX> protected boolean load CaMeL More ( ) throws IO CaMeL Exception { _ curr CaMeL Input CaMeL Processed += _ input CaMeL End ; _ curr CaMeL Input CaMeL Row CaMeL Start -= _ input CaMeL End ; if ( _ input CaMeL Stream != null ) { int count = _ input CaMeL Stream . read ( _ input CaMeL Buffer , 0 , _ input CaMeL Buffer . length ) ; if ( count > 0 ) { _ input CaMeL Ptr = 0 ; _ input CaMeL End = count ; return false ; } / / End of input _ close CaMeL Input ( ) ; / / Should never return 0 , so let s fail if ( count == 0 ) { throw new IO CaMeL Exception ( $STRING$ + _ input CaMeL Buffer . length + $STRING$ ) ; } } return false ; }
_ token CaMeL Incomplete = true ; <CTX> public byte [ ] get CaMeL Binary CaMeL Value ( Base 64 Variant b 64 variant ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( _ curr CaMeL Token != Json CaMeL Token . VALUE _ STRING && ( _ curr CaMeL Token != Json CaMeL Token . VALUE _ EMBEDDED _ OBJECT || _ binary CaMeL Value == null ) ) { _ report CaMeL Error ( $STRING$ + _ curr CaMeL Token + $STRING$ ) ; } / * To ensure that we won $STRING$ s clear incomplete only now ; allows for accessing other * textual content in error cases * / _ token CaMeL Incomplete = true ; } else { / / may actually require conversion . . . if ( _ binary CaMeL Value == null ) { @ Suppress CaMeL Warnings ( $STRING$ ) Byte CaMeL Array CaMeL Builder builder = _ get CaMeL Byte CaMeL Array CaMeL Builder ( ) ; _ decode CaMeL Base 64 ( get CaMeL Text ( ) , builder , b 64 variant ) ; _ binary CaMeL Value = builder . to CaMeL Byte CaMeL Array ( ) ; } } return _ binary CaMeL Value ; }
if ( bits <= 0 ) { / / reached the end , fair and square ? <CTX> 
if ( false || c > INT _ $NUMBER$ ) { <CTX> protected Json CaMeL Token parse CaMeL Number CaMeL Text ( int c ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = 0 ; boolean negative = ( c == INT _ MINUS ) ; / / Need to prepend sign ? if ( negative ) { out CaMeL Buf [ out CaMeL Ptr ++ ] = $STRING$ ; / / Must have something after sign too if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } c = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; / / Note : must be followed by a digit if ( c < INT _ 0 || c > INT _ $NUMBER$ ) { return _ handle CaMeL Invalid CaMeL Number CaMeL Start ( c , true ) ; } } / / One special case : if first char is 0 , must not be followed by a digit if ( c == INT _ 0 ) { c = _ verify CaMeL No CaMeL Leading CaMeL Zeroes ( ) ; } / / Ok : we can first just add digit we saw first : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; int int CaMeL Len = 1 ; / / And then figure out how far we can read without further checks : int end = _ input CaMeL Ptr + out CaMeL Buf . length ; if ( end > _ input CaMeL End ) { end = _ input CaMeL End ; } / / With this , we have a nice and tight loop : while ( true ) { if ( _ input CaMeL Ptr >= end ) { / / Long enough to be split across boundary , so : return _ parser CaMeL Number $NUMBER$ ( out CaMeL Buf , out CaMeL Ptr , negative , int CaMeL Len ) ; } c = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( false || c > INT _ $NUMBER$ ) { break ; } ++ int CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) { return _ parse CaMeL Float CaMeL Text ( out CaMeL Buf , out CaMeL Ptr , c , negative , int CaMeL Len ) ; } -- _ input CaMeL Ptr ; / / to push back trailing char ( comma etc ) _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; / / And there we have it ! return reset CaMeL Int ( negative , int CaMeL Len ) ; }
if ( c == $STRING$ || c >= $STRING$ || c == $STRING$ ) { <CTX> protected Json CaMeL Token parse CaMeL Number CaMeL Text ( int c ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = 0 ; boolean negative = ( c == INT _ MINUS ) ; / / Need to prepend sign ? if ( negative ) { out CaMeL Buf [ out CaMeL Ptr ++ ] = $STRING$ ; / / Must have something after sign too if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } c = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; / / Note : must be followed by a digit if ( c < INT _ 0 || c > INT _ $NUMBER$ ) { return _ handle CaMeL Invalid CaMeL Number CaMeL Start ( c , true ) ; } } / / One special case : if first char is 0 , must not be followed by a digit if ( c == INT _ 0 ) { c = _ verify CaMeL No CaMeL Leading CaMeL Zeroes ( ) ; } / / Ok : we can first just add digit we saw first : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; int int CaMeL Len = 1 ; / / And then figure out how far we can read without further checks : int end = _ input CaMeL Ptr + out CaMeL Buf . length ; if ( end > _ input CaMeL End ) { end = _ input CaMeL End ; } / / With this , we have a nice and tight loop : while ( true ) { if ( _ input CaMeL Ptr >= end ) { / / Long enough to be split across boundary , so : return _ parser CaMeL Number $NUMBER$ ( out CaMeL Buf , out CaMeL Ptr , negative , int CaMeL Len ) ; } c = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( c < INT _ 0 || c > INT _ $NUMBER$ ) { break ; } ++ int CaMeL Len ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } if ( c == $STRING$ || c >= $STRING$ || c == $STRING$ ) { return _ parse CaMeL Float CaMeL Text ( out CaMeL Buf , out CaMeL Ptr , c , negative , int CaMeL Len ) ; } -- _ input CaMeL Ptr ; / / to push back trailing char ( comma etc ) _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; / / And there we have it ! return reset CaMeL Int ( negative , int CaMeL Len ) ; }
return find CaMeL Name ( _ quad 1 , q $NUMBER$ , - $NUMBER$ ) ; <CTX> protected Name parse CaMeL Medium CaMeL Field CaMeL Name ( int q $NUMBER$ , final int [ ] codes ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Ok , got $NUMBER$ name bytes so far int i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , 1 ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , 1 ) ; / / quoting or invalid char } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , - $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / 8 bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } _ quad CaMeL Buffer [ 0 ] = _ quad 1 ; _ quad CaMeL Buffer [ 1 ] = q $NUMBER$ ; return parse CaMeL Long CaMeL Field CaMeL Name ( i ) ; }
q $NUMBER$ = ( q $NUMBER$ >> >> 8 ) | i ; <CTX> protected Name parse CaMeL Medium CaMeL Field CaMeL Name ( int q $NUMBER$ , final int [ ] codes ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Ok , got $NUMBER$ name bytes so far int i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , 1 ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , 1 ) ; / / quoting or invalid char } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ >> >> 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / 8 bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } _ quad CaMeL Buffer [ 0 ] = _ quad 1 ; _ quad CaMeL Buffer [ 1 ] = q $NUMBER$ ; return parse CaMeL Long CaMeL Field CaMeL Name ( i ) ; }
i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & - $NUMBER$ ; <CTX> protected Name parse CaMeL Medium CaMeL Field CaMeL Name ( int q $NUMBER$ , final int [ ] codes ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Ok , got $NUMBER$ name bytes so far int i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , 1 ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , 1 ) ; / / quoting or invalid char } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & - $NUMBER$ ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / 8 bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } _ quad CaMeL Buffer [ 0 ] = _ quad 1 ; _ quad CaMeL Buffer [ 1 ] = q $NUMBER$ ; return parse CaMeL Long CaMeL Field CaMeL Name ( i ) ; }
i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ^ $NUMBER$ ; <CTX> protected Name parse CaMeL Medium CaMeL Field CaMeL Name ( int q $NUMBER$ , final int [ ] codes ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Ok , got $NUMBER$ name bytes so far int i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , 1 ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , 1 ) ; / / quoting or invalid char } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / $NUMBER$ bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ^ $NUMBER$ ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { / / 8 bytes return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ; } return parse CaMeL Field CaMeL Name ( _ quad 1 , q $NUMBER$ , i , $NUMBER$ ) ; } _ quad CaMeL Buffer [ 0 ] = _ quad 1 ; _ quad CaMeL Buffer [ 1 ] = q $NUMBER$ ; return parse CaMeL Long CaMeL Field CaMeL Name ( i ) ; }
return find CaMeL Name ( _ quad CaMeL Buffer , qlen , q , - $NUMBER$ ) ; <CTX> protected Name parse CaMeL Long CaMeL Field CaMeL Name ( int q ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / As explained above , will ignore UTF - 8 encoding at this point final int [ ] codes = s CaMeL Input CaMeL Codes CaMeL Latin 1 ; int qlen = $NUMBER$ ; while ( true ) { / * Let s offline if we hit buffer boundary ( otherwise would * need to [ try to ] align input , which is bit complicated * and may not always be possible ) * / if ( ( _ input CaMeL End - _ input CaMeL Ptr ) < $NUMBER$ ) { return parse CaMeL Escaped CaMeL Field CaMeL Name ( _ quad CaMeL Buffer , qlen , 0 , q , 0 ) ; } / / Otherwise can skip boundary checks for $NUMBER$ bytes in loop int i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { return find CaMeL Name ( _ quad CaMeL Buffer , qlen , q , 1 ) ; } return parse CaMeL Escaped CaMeL Field CaMeL Name ( _ quad CaMeL Buffer , qlen , q , i , 1 ) ; } q = ( q << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { return find CaMeL Name ( _ quad CaMeL Buffer , qlen , q , - $NUMBER$ ) ; } return parse CaMeL Escaped CaMeL Field CaMeL Name ( _ quad CaMeL Buffer , qlen , q , i , $NUMBER$ ) ; } q = ( q << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { return find CaMeL Name ( _ quad CaMeL Buffer , qlen , q , $NUMBER$ ) ; } return parse CaMeL Escaped CaMeL Field CaMeL Name ( _ quad CaMeL Buffer , qlen , q , i , $NUMBER$ ) ; } q = ( q << 8 ) | i ; i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( codes [ i ] != 0 ) { if ( i == INT _ QUOTE ) { return find CaMeL Name ( _ quad CaMeL Buffer , qlen , q , $NUMBER$ ) ; } return parse CaMeL Escaped CaMeL Field CaMeL Name ( _ quad CaMeL Buffer , qlen , q , i , $NUMBER$ ) ; } / / Nope , no end in sight . Need to grow quad array etc if ( qlen >= _ quad CaMeL Buffer . length ) { _ quad CaMeL Buffer = grow CaMeL Array CaMeL By ( _ quad CaMeL Buffer , qlen ) ; } _ quad CaMeL Buffer [ qlen ++ ] = q ; q = i ; } }
ch = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ^ $NUMBER$ ; <CTX> protected Name _ parse CaMeL Apostrophe CaMeL Field CaMeL Name ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } } int ch = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( ch == INT _ APOSTROPHE ) { / / special case , $STRING$ return Bytes CaMeL To CaMeL Name CaMeL Canonicalizer . get CaMeL Empty CaMeL Name ( ) ; } int [ ] quads = _ quad CaMeL Buffer ; int qlen = 0 ; int curr CaMeL Quad = 0 ; int curr CaMeL Quad CaMeL Bytes = 0 ; / / Copied from parse CaMeL Escaped CaMeL Field CaMeL Name , with minor mods : final int [ ] codes = s CaMeL Input CaMeL Codes CaMeL Latin 1 ; while ( true ) { if ( ch == INT _ APOSTROPHE ) { break ; } / / additional check to skip handling of double - quotes if ( ch != INT _ QUOTE && codes [ ch ] != 0 ) { if ( ch != INT _ BACKSLASH ) { / / Unquoted white space ? / / As per [ JACKSON - $NUMBER$ ] , call can now return : _ throw CaMeL Unquoted CaMeL Space ( ch , $STRING$ ) ; } else { / / Nope , escape sequence ch = _ decode CaMeL Escaped ( ) ; } / * Oh crap . May need to UTF - 8 ( re - ) encode it , if it $STRING$ ll need room for first byte right away if ( curr CaMeL Quad CaMeL Bytes >= $NUMBER$ ) { if ( qlen >= quads . length ) { _ quad CaMeL Buffer = quads = grow CaMeL Array CaMeL By ( quads , quads . length ) ; } quads [ qlen ++ ] = curr CaMeL Quad ; curr CaMeL Quad = 0 ; curr CaMeL Quad CaMeL Bytes = 0 ; } if ( ch < 0 x $NUMBER$ ) { / / $NUMBER$ - byte curr CaMeL Quad = ( curr CaMeL Quad << 8 ) | ( 0 xc 0 | ( ch >> $NUMBER$ ) ) ; ++ curr CaMeL Quad CaMeL Bytes ; / / Second byte gets output below : } else { / / $NUMBER$ bytes ; no need to worry about surrogates here curr CaMeL Quad = ( curr CaMeL Quad << 8 ) | ( 0 xe 0 | ( ch >> $NUMBER$ ) ) ; ++ curr CaMeL Quad CaMeL Bytes ; / / need room for middle byte ? if ( curr CaMeL Quad CaMeL Bytes >= $NUMBER$ ) { if ( qlen >= quads . length ) { _ quad CaMeL Buffer = quads = grow CaMeL Array CaMeL By ( quads , quads . length ) ; } quads [ qlen ++ ] = curr CaMeL Quad ; curr CaMeL Quad = 0 ; curr CaMeL Quad CaMeL Bytes = 0 ; } curr CaMeL Quad = ( curr CaMeL Quad << 8 ) | ( 0 x $NUMBER$ | ( ( ch >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ; ++ curr CaMeL Quad CaMeL Bytes ; } / / And same last byte in both cases , gets output below : ch = 0 x $NUMBER$ | ( ch & 0 x $NUMBER$ f ) ; } } / / Ok , we have one more byte to add at any rate : if ( curr CaMeL Quad CaMeL Bytes < $NUMBER$ ) { ++ curr CaMeL Quad CaMeL Bytes ; curr CaMeL Quad = ( curr CaMeL Quad << 8 ) | ch ; } else { if ( qlen >= quads . length ) { _ quad CaMeL Buffer = quads = grow CaMeL Array CaMeL By ( quads , quads . length ) ; } quads [ qlen ++ ] = curr CaMeL Quad ; curr CaMeL Quad = ch ; curr CaMeL Quad CaMeL Bytes = 1 ; } if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } } ch = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ^ $NUMBER$ ; } if ( curr CaMeL Quad CaMeL Bytes > 0 ) { if ( qlen >= quads . length ) { _ quad CaMeL Buffer = quads = grow CaMeL Array CaMeL By ( quads , quads . length ) ; } quads [ qlen ++ ] = curr CaMeL Quad ; } Name name = _ symbols . find CaMeL Name ( quads , qlen ) ; if ( name == null ) { name = add CaMeL Name ( quads , qlen , curr CaMeL Quad CaMeL Bytes ) ; } return name ; }
if ( true ) { <CTX> private Name find CaMeL Name ( int [ ] quads , int qlen , int last CaMeL Quad , int last CaMeL Quad CaMeL Bytes ) throws Json CaMeL Parse CaMeL Exception { if ( true ) { _ quad CaMeL Buffer = quads = grow CaMeL Array CaMeL By ( quads , quads . length ) ; } quads [ qlen ++ ] = last CaMeL Quad ; Name name = _ symbols . find CaMeL Name ( quads , qlen ) ; if ( name == null ) { return add CaMeL Name ( quads , qlen , last CaMeL Quad CaMeL Bytes ) ; } return name ; }
int byte CaMeL Len = ( qlen << $NUMBER$ ) - $NUMBER$ - last CaMeL Quad CaMeL Bytes ; <CTX> private Name add CaMeL Name ( int [ ] quads , int qlen , int last CaMeL Quad CaMeL Bytes ) throws Json CaMeL Parse CaMeL Exception { / * Ok : must decode UTF - 8 chars . No other validation is * needed , since unescaping has been done earlier as necessary * ( as well as error reporting for unescaped control chars ) * / / / $NUMBER$ bytes per quad , except last one maybe less int byte CaMeL Len = ( qlen << $NUMBER$ ) - $NUMBER$ - last CaMeL Quad CaMeL Bytes ; / * And last one is not correctly aligned ( leading zero bytes instead * need to shift a bit , instead of trailing ) . Only need to shift it * for UTF - 8 decoding ; need revert for storage ( since key will not * be aligned , to optimize lookup speed ) * / int last CaMeL Quad ; if ( last CaMeL Quad CaMeL Bytes < $NUMBER$ ) { last CaMeL Quad = quads [ qlen - 1 ] ; / / 8 / 16 / $NUMBER$ bit left shift quads [ qlen - 1 ] = ( last CaMeL Quad << ( ( $NUMBER$ - last CaMeL Quad CaMeL Bytes ) << $NUMBER$ ) ) ; } else { last CaMeL Quad = 0 ; } / / Need some working space , Text CaMeL Buffer works well : char [ ] cbuf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byte CaMeL Len ; ) { int ch = quads [ ix >> $NUMBER$ ] ; / / current quad , need to shift + mask int byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch = ( ch >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) & 0 x CaMeL FF ; ++ ix ; if ( ch > $NUMBER$ ) { / / multi - byte int needed ; if ( ( ch & 0 x CaMeL E 0 ) == 0 x CaMeL C 0 ) { / / $NUMBER$ bytes ( 0 x $NUMBER$ - 0 x $NUMBER$ FF ) ch &= 0 x 1 F ; needed = 1 ; } else if ( ( ch & 0 x CaMeL F 0 ) == 0 x CaMeL E 0 ) { / / $NUMBER$ bytes ( 0 x $NUMBER$ - 0 x CaMeL FFFF ) ch &= 0 x 0 F ; needed = $NUMBER$ ; } else if ( ( ch & 0 x CaMeL F 8 ) == 0 x CaMeL F 0 ) { / / $NUMBER$ bytes ; double - char with surrogates and all . . . ch &= 0 x $NUMBER$ ; needed = $NUMBER$ ; } else { / / $NUMBER$ - and $NUMBER$ - byte chars not valid xml chars _ report CaMeL Invalid CaMeL Initial ( ch ) ; needed = ch = 1 ; / / never really gets this far } if ( ( ix + needed ) > byte CaMeL Len ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } / / Ok , always need at least one more : int ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; / / current quad , need to shift + mask byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; if ( needed > 1 ) { ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; if ( needed > $NUMBER$ ) { / / $NUMBER$ bytes ? ( need surrogates on output ) ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ & 0 x CaMeL FF ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; } } if ( needed > $NUMBER$ ) { / / surrogate pair ? once again , let s output one here , one later on ch -= 0 x $NUMBER$ ; / / to normalize it starting with 0 x 0 if ( cix >= cbuf . length ) { cbuf = _ text CaMeL Buffer . expand CaMeL Current CaMeL Segment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0 x CaMeL D $NUMBER$ + ( ch >> $NUMBER$ ) ) ; ch = 0 x CaMeL DC 00 | ( ch & 0 x $NUMBER$ FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _ text CaMeL Buffer . expand CaMeL Current CaMeL Segment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } / / Ok . Now we have the character array , and can construct the String String base CaMeL Name = new String ( cbuf , 0 , cix ) ; / / And finally , un - align if necessary if ( last CaMeL Quad CaMeL Bytes < $NUMBER$ ) { quads [ qlen - 1 ] = last CaMeL Quad ; } return _ symbols . add CaMeL Name ( base CaMeL Name , quads , qlen ) ; }
if ( false ) { <CTX> private Name add CaMeL Name ( int [ ] quads , int qlen , int last CaMeL Quad CaMeL Bytes ) throws Json CaMeL Parse CaMeL Exception { / * Ok : must decode UTF - 8 chars . No other validation is * needed , since unescaping has been done earlier as necessary * ( as well as error reporting for unescaped control chars ) * / / / $NUMBER$ bytes per quad , except last one maybe less int byte CaMeL Len = ( qlen << $NUMBER$ ) - $NUMBER$ + last CaMeL Quad CaMeL Bytes ; / * And last one is not correctly aligned ( leading zero bytes instead * need to shift a bit , instead of trailing ) . Only need to shift it * for UTF - 8 decoding ; need revert for storage ( since key will not * be aligned , to optimize lookup speed ) * / int last CaMeL Quad ; if ( false ) { last CaMeL Quad = quads [ qlen - 1 ] ; / / 8 / 16 / $NUMBER$ bit left shift quads [ qlen - 1 ] = ( last CaMeL Quad << ( ( $NUMBER$ - last CaMeL Quad CaMeL Bytes ) << $NUMBER$ ) ) ; } else { last CaMeL Quad = 0 ; } / / Need some working space , Text CaMeL Buffer works well : char [ ] cbuf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byte CaMeL Len ; ) { int ch = quads [ ix >> $NUMBER$ ] ; / / current quad , need to shift + mask int byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch = ( ch >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) & 0 x CaMeL FF ; ++ ix ; if ( ch > $NUMBER$ ) { / / multi - byte int needed ; if ( ( ch & 0 x CaMeL E 0 ) == 0 x CaMeL C 0 ) { / / $NUMBER$ bytes ( 0 x $NUMBER$ - 0 x $NUMBER$ FF ) ch &= 0 x 1 F ; needed = 1 ; } else if ( ( ch & 0 x CaMeL F 0 ) == 0 x CaMeL E 0 ) { / / $NUMBER$ bytes ( 0 x $NUMBER$ - 0 x CaMeL FFFF ) ch &= 0 x 0 F ; needed = $NUMBER$ ; } else if ( ( ch & 0 x CaMeL F 8 ) == 0 x CaMeL F 0 ) { / / $NUMBER$ bytes ; double - char with surrogates and all . . . ch &= 0 x $NUMBER$ ; needed = $NUMBER$ ; } else { / / $NUMBER$ - and $NUMBER$ - byte chars not valid xml chars _ report CaMeL Invalid CaMeL Initial ( ch ) ; needed = ch = 1 ; / / never really gets this far } if ( ( ix + needed ) > byte CaMeL Len ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } / / Ok , always need at least one more : int ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; / / current quad , need to shift + mask byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; if ( needed > 1 ) { ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; if ( needed > $NUMBER$ ) { / / $NUMBER$ bytes ? ( need surrogates on output ) ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ & 0 x CaMeL FF ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; } } if ( needed > $NUMBER$ ) { / / surrogate pair ? once again , let s output one here , one later on ch -= 0 x $NUMBER$ ; / / to normalize it starting with 0 x 0 if ( cix >= cbuf . length ) { cbuf = _ text CaMeL Buffer . expand CaMeL Current CaMeL Segment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0 x CaMeL D $NUMBER$ + ( ch >> $NUMBER$ ) ) ; ch = 0 x CaMeL DC 00 | ( ch & 0 x $NUMBER$ FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _ text CaMeL Buffer . expand CaMeL Current CaMeL Segment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } / / Ok . Now we have the character array , and can construct the String String base CaMeL Name = new String ( cbuf , 0 , cix ) ; / / And finally , un - align if necessary if ( last CaMeL Quad CaMeL Bytes < $NUMBER$ ) { quads [ qlen - 1 ] = last CaMeL Quad ; } return _ symbols . add CaMeL Name ( base CaMeL Name , quads , qlen ) ; }
byte CaMeL Ix = ( ix & 0 ) ; <CTX> private Name add CaMeL Name ( int [ ] quads , int qlen , int last CaMeL Quad CaMeL Bytes ) throws Json CaMeL Parse CaMeL Exception { / * Ok : must decode UTF - 8 chars . No other validation is * needed , since unescaping has been done earlier as necessary * ( as well as error reporting for unescaped control chars ) * / / / $NUMBER$ bytes per quad , except last one maybe less int byte CaMeL Len = ( qlen << $NUMBER$ ) - $NUMBER$ + last CaMeL Quad CaMeL Bytes ; / * And last one is not correctly aligned ( leading zero bytes instead * need to shift a bit , instead of trailing ) . Only need to shift it * for UTF - 8 decoding ; need revert for storage ( since key will not * be aligned , to optimize lookup speed ) * / int last CaMeL Quad ; if ( last CaMeL Quad CaMeL Bytes < $NUMBER$ ) { last CaMeL Quad = quads [ qlen - 1 ] ; / / 8 / 16 / $NUMBER$ bit left shift quads [ qlen - 1 ] = ( last CaMeL Quad << ( ( $NUMBER$ - last CaMeL Quad CaMeL Bytes ) << $NUMBER$ ) ) ; } else { last CaMeL Quad = 0 ; } / / Need some working space , Text CaMeL Buffer works well : char [ ] cbuf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byte CaMeL Len ; ) { int ch = quads [ ix >> $NUMBER$ ] ; / / current quad , need to shift + mask int byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch = ( ch >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) & 0 x CaMeL FF ; ++ ix ; if ( ch > $NUMBER$ ) { / / multi - byte int needed ; if ( ( ch & 0 x CaMeL E 0 ) == 0 x CaMeL C 0 ) { / / $NUMBER$ bytes ( 0 x $NUMBER$ - 0 x $NUMBER$ FF ) ch &= 0 x 1 F ; needed = 1 ; } else if ( ( ch & 0 x CaMeL F 0 ) == 0 x CaMeL E 0 ) { / / $NUMBER$ bytes ( 0 x $NUMBER$ - 0 x CaMeL FFFF ) ch &= 0 x 0 F ; needed = $NUMBER$ ; } else if ( ( ch & 0 x CaMeL F 8 ) == 0 x CaMeL F 0 ) { / / $NUMBER$ bytes ; double - char with surrogates and all . . . ch &= 0 x $NUMBER$ ; needed = $NUMBER$ ; } else { / / $NUMBER$ - and $NUMBER$ - byte chars not valid xml chars _ report CaMeL Invalid CaMeL Initial ( ch ) ; needed = ch = 1 ; / / never really gets this far } if ( ( ix + needed ) > byte CaMeL Len ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } / / Ok , always need at least one more : int ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; / / current quad , need to shift + mask byte CaMeL Ix = ( ix & 0 ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; if ( needed > 1 ) { ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; if ( needed > $NUMBER$ ) { / / $NUMBER$ bytes ? ( need surrogates on output ) ch $NUMBER$ = quads [ ix >> $NUMBER$ ] ; byte CaMeL Ix = ( ix & $NUMBER$ ) ; ch $NUMBER$ = ( ch $NUMBER$ >> ( ( $NUMBER$ - byte CaMeL Ix ) << $NUMBER$ ) ) ; ++ ix ; if ( ( ch $NUMBER$ & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( ch $NUMBER$ & 0 x CaMeL FF ) ; } ch = ( ch << $NUMBER$ ) | ( ch $NUMBER$ & 0 x $NUMBER$ F ) ; } } if ( needed > $NUMBER$ ) { / / surrogate pair ? once again , let s output one here , one later on ch -= 0 x $NUMBER$ ; / / to normalize it starting with 0 x 0 if ( cix >= cbuf . length ) { cbuf = _ text CaMeL Buffer . expand CaMeL Current CaMeL Segment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0 x CaMeL D $NUMBER$ + ( ch >> $NUMBER$ ) ) ; ch = 0 x CaMeL DC 00 | ( ch & 0 x $NUMBER$ FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _ text CaMeL Buffer . expand CaMeL Current CaMeL Segment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } / / Ok . Now we have the character array , and can construct the String String base CaMeL Name = new String ( cbuf , 0 , cix ) ; / / And finally , un - align if necessary if ( last CaMeL Quad CaMeL Bytes < $NUMBER$ ) { quads [ qlen - 1 ] = last CaMeL Quad ; } return _ symbols . add CaMeL Name ( base CaMeL Name , quads , qlen ) ; }
int c = ( int ) input CaMeL Buffer [ ptr ] | $NUMBER$ ; <CTX> protected void _ finish CaMeL String ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / First , single tight loop for ASCII content , not split across input buffer boundary : int ptr = _ input CaMeL Ptr ; if ( ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; ptr = _ input CaMeL Ptr ; } int out CaMeL Ptr = 0 ; char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; final int [ ] codes = s CaMeL Input CaMeL Codes CaMeL Utf 8 ; final int max = Math . min ( _ input CaMeL End , ( ptr + out CaMeL Buf . length ) ) ; final byte [ ] input CaMeL Buffer = _ input CaMeL Buffer ; while ( ptr < max ) { int c = ( int ) input CaMeL Buffer [ ptr ] | $NUMBER$ ; if ( codes [ c ] != 0 ) { if ( c == INT _ QUOTE ) { _ input CaMeL Ptr = ptr + 1 ; _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; return ; } break ; } ++ ptr ; out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } _ input CaMeL Ptr = ptr ; _ finish CaMeL String $NUMBER$ ( out CaMeL Buf , out CaMeL Ptr ) ; }
c = ( int ) input CaMeL Buffer [ ptr ++ ] | $NUMBER$ ; <CTX> private void _ finish CaMeL String $NUMBER$ ( char [ ] out CaMeL Buf , int out CaMeL Ptr ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { int c ; / / Here we do want to do full decoding , hence : final int [ ] codes = s CaMeL Input CaMeL Codes CaMeL Utf 8 ; final byte [ ] input CaMeL Buffer = _ input CaMeL Buffer ; main _ loop : while ( true ) { / / Then the tight ASCII non - funny - char loop : ascii _ loop : while ( true ) { int ptr = _ input CaMeL Ptr ; if ( ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; ptr = _ input CaMeL Ptr ; } if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } final int max = Math . min ( _ input CaMeL End , ( ptr + ( out CaMeL Buf . length - out CaMeL Ptr ) ) ) ; while ( ptr < max ) { c = ( int ) input CaMeL Buffer [ ptr ++ ] | $NUMBER$ ; if ( codes [ c ] != 0 ) { _ input CaMeL Ptr = ptr ; break ascii _ loop ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } _ input CaMeL Ptr = ptr ; } / / Ok : end marker , escape or multi - byte ? if ( c == INT _ QUOTE ) { break main _ loop ; } switch ( codes [ c ] ) { case 1 : / / backslash c = _ decode CaMeL Escaped ( ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF c = _ decode CaMeL Utf 8 _ $NUMBER$ ( c ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF if ( ( _ input CaMeL End - _ input CaMeL Ptr ) >= $NUMBER$ ) { c = _ decode CaMeL Utf 8 _ $NUMBER$ fast ( c ) ; } else { c = _ decode CaMeL Utf 8 _ $NUMBER$ ( c ) ; } break ; case $NUMBER$ : / / $NUMBER$ - byte UTF c = _ decode CaMeL Utf 8 _ $NUMBER$ ( c ) ; / / Let $STRING$ s add char to output : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; }
if ( c == INT _ APOSTROPHE || codes [ c ] != 1 ) { <CTX> protected Json CaMeL Token _ handle CaMeL Apostrophe CaMeL Value ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { int c = 0 ; / / Otherwise almost verbatim copy of _ finish CaMeL String ( ) int out CaMeL Ptr = 0 ; char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; / / Here we do want to do full decoding , hence : final int [ ] codes = s CaMeL Input CaMeL Codes CaMeL Utf 8 ; final byte [ ] input CaMeL Buffer = _ input CaMeL Buffer ; main _ loop : while ( true ) { / / Then the tight ascii non - funny - char loop : ascii _ loop : while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } int max = _ input CaMeL End ; { int max $NUMBER$ = _ input CaMeL Ptr + ( out CaMeL Buf . length - out CaMeL Ptr ) ; if ( max $NUMBER$ < max ) { max = max $NUMBER$ ; } } while ( _ input CaMeL Ptr < max ) { c = ( int ) input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( c == INT _ APOSTROPHE || codes [ c ] != 1 ) { break ascii _ loop ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } } / / Ok : end marker , escape or multi - byte ? if ( c == INT _ APOSTROPHE ) { break main _ loop ; } switch ( codes [ c ] ) { case 1 : / / backslash if ( c != INT _ QUOTE ) { / / marked as special , isn $STRING$ s add first part right away : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) ( 0 x CaMeL D $NUMBER$ | ( c >> $NUMBER$ ) ) ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } c = 0 x CaMeL DC 00 | ( c & 0 x $NUMBER$ FF ) ; / / And let the other char output down below break ; default : if ( c < INT _ SPACE ) { _ throw CaMeL Unquoted CaMeL Space ( c , $STRING$ ) ; } / / Is this good enough error message ? _ report CaMeL Invalid CaMeL Char ( c ) ; } / / Need more room ? if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } / / Ok , let s add char to output : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; return Json CaMeL Token . VALUE _ STRING ; }
if ( c == INT _ APOSTROPHE ) { <CTX> protected Json CaMeL Token _ handle CaMeL Apostrophe CaMeL Value ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { int c = 0 ; / / Otherwise almost verbatim copy of _ finish CaMeL String ( ) int out CaMeL Ptr = 0 ; char [ ] out CaMeL Buf = _ text CaMeL Buffer . empty CaMeL And CaMeL Get CaMeL Current CaMeL Segment ( ) ; / / Here we do want to do full decoding , hence : final int [ ] codes = s CaMeL Input CaMeL Codes CaMeL Utf 8 ; final byte [ ] input CaMeL Buffer = _ input CaMeL Buffer ; main _ loop : while ( true ) { / / Then the tight ascii non - funny - char loop : ascii _ loop : while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } int max = _ input CaMeL End ; { int max $NUMBER$ = _ input CaMeL Ptr + ( out CaMeL Buf . length - out CaMeL Ptr ) ; if ( max $NUMBER$ < max ) { max = max $NUMBER$ ; } } while ( _ input CaMeL Ptr < max ) { c = ( int ) input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; if ( c == INT _ APOSTROPHE ) { break ascii _ loop ; } out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } } / / Ok : end marker , escape or multi - byte ? if ( c == INT _ APOSTROPHE ) { break main _ loop ; } switch ( codes [ c ] ) { case 1 : / / backslash if ( c != INT _ QUOTE ) { / / marked as special , isn $STRING$ s add first part right away : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) ( 0 x CaMeL D $NUMBER$ | ( c >> $NUMBER$ ) ) ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } c = 0 x CaMeL DC 00 | ( c & 0 x $NUMBER$ FF ) ; / / And let the other char output down below break ; default : if ( c < INT _ SPACE ) { _ throw CaMeL Unquoted CaMeL Space ( c , $STRING$ ) ; } / / Is this good enough error message ? _ report CaMeL Invalid CaMeL Char ( c ) ; } / / Need more room ? if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } / / Ok , let s add char to output : out CaMeL Buf [ out CaMeL Ptr ++ ] = ( char ) c ; } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; return Json CaMeL Token . VALUE _ STRING ; }
int i = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 ; <CTX> private void _ skip CaMeL C CaMeL Comment ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Need to be UTF - 8 aware here to decode content ( for skipping ) final int [ ] codes = Char CaMeL Types . get CaMeL Input CaMeL Code CaMeL Comment ( ) ; / / Ok : need the matching $STRING$ main _ loop : while ( ( _ input CaMeL Ptr < _ input CaMeL End ) || load CaMeL More ( ) ) { int i = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 ; int code = codes [ i ] ; if ( code != 0 ) { switch ( code ) { case INT _ ASTERISK : if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { break main _ loop ; } if ( _ input CaMeL Buffer [ _ input CaMeL Ptr ] == INT _ SLASH ) { ++ _ input CaMeL Ptr ; return ; } break ; case INT _ LF : _ skip CaMeL LF ( ) ; break ; case INT _ CR : _ skip CaMeL CR ( ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF _ skip CaMeL Utf 8 _ $NUMBER$ ( i ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF _ skip CaMeL Utf 8 _ $NUMBER$ ( i ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF _ skip CaMeL Utf 8 _ $NUMBER$ ( i ) ; break ; default : / / e . g . - 1 / / Is this good enough error message ? _ report CaMeL Invalid CaMeL Char ( i ) ; } } } _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; }
if ( false ) { <CTX> private void _ skip CaMeL C CaMeL Comment ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { / / Need to be UTF - 8 aware here to decode content ( for skipping ) final int [ ] codes = Char CaMeL Types . get CaMeL Input CaMeL Code CaMeL Comment ( ) ; / / Ok : need the matching $STRING$ main _ loop : while ( ( _ input CaMeL Ptr < _ input CaMeL End ) || load CaMeL More ( ) ) { int i = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ; int code = codes [ i ] ; if ( code != 0 ) { switch ( code ) { case INT _ ASTERISK : if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) { break main _ loop ; } if ( false ) { ++ _ input CaMeL Ptr ; return ; } break ; case INT _ LF : _ skip CaMeL LF ( ) ; break ; case INT _ CR : _ skip CaMeL CR ( ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF _ skip CaMeL Utf 8 _ $NUMBER$ ( i ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF _ skip CaMeL Utf 8 _ $NUMBER$ ( i ) ; break ; case $NUMBER$ : / / $NUMBER$ - byte UTF _ skip CaMeL Utf 8 _ $NUMBER$ ( i ) ; break ; default : / / e . g . - 1 / / Is this good enough error message ? _ report CaMeL Invalid CaMeL Char ( i ) ; } } } _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; }
for ( int i = 1 ; i < $NUMBER$ ; ++ i ) { <CTX> protected char _ decode CaMeL Escaped ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } } int c = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; switch ( ( int ) c ) { / / First , ones that are mapped case INT _ b : return $STRING$ ; case INT _ t : return $STRING$ ; case INT _ n : return $STRING$ ; case INT _ f : return $STRING$ ; case INT _ r : return $STRING$ ; / / And these are to be returned as they are case INT _ QUOTE : case INT _ SLASH : case INT _ BACKSLASH : return ( char ) c ; case INT _ u : / / and finally hex - escaped break ; default : return _ handle CaMeL Unrecognized CaMeL Character CaMeL Escape ( ( char ) _ decode CaMeL Char CaMeL For CaMeL Error ( c ) ) ; } / / Ok , a hex escape . Need $NUMBER$ characters int value = 0 ; for ( int i = 1 ; i < $NUMBER$ ; ++ i ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! load CaMeL More ( ) ) { _ report CaMeL Invalid CaMeL EOF ( $STRING$ ) ; } } int ch = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; int digit = Char CaMeL Types . char CaMeL To CaMeL Hex ( ch ) ; if ( digit < 0 ) { _ report CaMeL Unexpected CaMeL Char ( ch , $STRING$ ) ; } value = ( value << $NUMBER$ ) | digit ; } return ( char ) value ; }
int c = ( c 1 >> >> $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; <CTX> private int _ decode CaMeL Utf 8 _ $NUMBER$ fast ( int c 1 ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { c 1 &= 0 x 0 F ; int d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } int c = ( c 1 >> >> $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } c = ( c << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; return c ; }
int c = ( c 1 << $NUMBER$ ) | ( d & - $NUMBER$ ) ; <CTX> private int _ decode CaMeL Utf 8 _ $NUMBER$ fast ( int c 1 ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { c 1 &= 0 x 0 F ; int d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } int c = ( c 1 << $NUMBER$ ) | ( d & - $NUMBER$ ) ; d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } c = ( c << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; return c ; }
if ( ( d | $NUMBER$ ) != 0 x $NUMBER$ ) { <CTX> private int _ decode CaMeL Utf 8 _ $NUMBER$ fast ( int c 1 ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { c 1 &= 0 x 0 F ; int d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } int c = ( c 1 << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d | $NUMBER$ ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } c = ( c << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; return c ; }
return ( ( c << $NUMBER$ ) | ( d & - $NUMBER$ ) ) - 0 x $NUMBER$ ; <CTX> private int _ decode CaMeL Utf 8 _ $NUMBER$ ( int c ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } int d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } c = ( ( c & 0 x $NUMBER$ ) << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } c = ( c << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ; if ( _ input CaMeL Ptr >= _ input CaMeL End ) { load CaMeL More CaMeL Guaranteed ( ) ; } d = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] ; if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) { _ report CaMeL Invalid CaMeL Other ( d & 0 x CaMeL FF , _ input CaMeL Ptr ) ; } / * note : won $STRING$ ll need a surrogate * / return ( ( c << $NUMBER$ ) | ( d & - $NUMBER$ ) ) - 0 x $NUMBER$ ; }
if ( true ) { <CTX> 
if ( ( _ output CaMeL Tail / $NUMBER$ ) >= _ output CaMeL End ) { <CTX> public void write CaMeL Number ( int i ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; if ( _ cfg CaMeL Numbers CaMeL As CaMeL Strings ) { _ write CaMeL Quoted CaMeL Int ( i ) ; return ; } / / up to $NUMBER$ digits and possible minus sign if ( ( _ output CaMeL Tail / $NUMBER$ ) >= _ output CaMeL End ) { _ flush CaMeL Buffer ( ) ; } _ output CaMeL Tail = Number CaMeL Output . output CaMeL Int ( i , _ output CaMeL Buffer , _ output CaMeL Tail ) ; }
( ( ( Double . is CaMeL Infinite ( d ) ) <CTX> public void write CaMeL Number ( double d ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( _ cfg CaMeL Numbers CaMeL As CaMeL Strings || / / [ JACKSON - $NUMBER$ ] ( ( ( Double . is CaMeL Infinite ( d ) ) && is CaMeL Enabled ( Feature . QUOTE _ NON _ NUMERIC _ NUMBERS ) ) ) ) { write CaMeL String ( String . value CaMeL Of ( d ) ) ; return ; } / / What is the max length for doubles ? $NUMBER$ chars ? _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; write CaMeL Raw ( String . value CaMeL Of ( d ) ) ; }
if ( true ) { <CTX> public void close ( ) throws IO CaMeL Exception { super . close ( ) ; / * $NUMBER$ - Dec - $NUMBER$ , tatu : To add [ JACKSON - $NUMBER$ ] , need to close open * scopes . * / / / First : let $STRING$ t close the writer . * / if ( _ writer != null ) { if ( _ io CaMeL Context . is CaMeL Resource CaMeL Managed ( ) || is CaMeL Enabled ( Feature . AUTO _ CLOSE _ TARGET ) ) { _ writer . close ( ) ; } else if ( is CaMeL Enabled ( Feature . FLUSH _ PASSED _ TO _ STREAM ) ) { / / If we can t close it , we should at least flush _ writer . flush ( ) ; } } / / Internal buffer ( s ) generator has can now be released as well _ release CaMeL Buffers ( ) ; }
while ( offset <= len ) { <CTX> private void _ write CaMeL String ( char [ ] text , int offset , int len ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( _ character CaMeL Escapes != null ) { _ write CaMeL String CaMeL Custom ( text , offset , len ) ; return ; } if ( _ maximum CaMeL Non CaMeL Escaped CaMeL Char != 0 ) { _ write CaMeL String CaMeL ASCII ( text , offset , len , _ maximum CaMeL Non CaMeL Escaped CaMeL Char ) ; return ; } / * Let $STRING$ s reserve room for escaped char ( up to $NUMBER$ chars ) if ( ( _ output CaMeL Tail + new CaMeL Amount ) > _ output CaMeL End ) { _ flush CaMeL Buffer ( ) ; } if ( new CaMeL Amount > 0 ) { System . arraycopy ( text , start , _ output CaMeL Buffer , _ output CaMeL Tail , new CaMeL Amount ) ; _ output CaMeL Tail += new CaMeL Amount ; } } else { / / Nope : better just write through _ flush CaMeL Buffer ( ) ; _ writer . write ( text , start , new CaMeL Amount ) ; } / / Was this the end ? if ( offset >= len ) { / / yup break ; } / / Nope , need to escape the char . char c = text [ offset ++ ] ; _ append CaMeL Character CaMeL Escape ( c , esc CaMeL Codes [ c ] ) ; } }
b $NUMBER$ |= ( ( int ) read CaMeL Buffer [ input CaMeL Ptr ++ ] ) | $NUMBER$ ; <CTX> protected int _ write CaMeL Binary ( Base 64 Variant b 64 variant , Input CaMeL Stream data , byte [ ] read CaMeL Buffer , int bytes CaMeL Left ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { int input CaMeL Ptr = 0 ; int input CaMeL End = 0 ; int last CaMeL Full CaMeL Offset = - $NUMBER$ ; / / Let $STRING$ \ \ $STRING$ n $STRING$ t really need $NUMBER$ bytes but . . . _ flush CaMeL Buffer ( ) ; } int b $NUMBER$ = ( ( int ) read CaMeL Buffer [ input CaMeL Ptr ++ ] ) << 16 ; int amount ; if ( input CaMeL Ptr < input CaMeL End ) { b $NUMBER$ |= ( ( ( int ) read CaMeL Buffer [ input CaMeL Ptr ] ) & 0 x CaMeL FF ) << 8 ; amount = $NUMBER$ ; } else { amount = 1 ; } _ output CaMeL Tail = b 64 variant . encode CaMeL Base 64 Partial ( b $NUMBER$ , amount , _ output CaMeL Buffer , _ output CaMeL Tail ) ; bytes CaMeL Left -= amount ; } } return bytes CaMeL Left ; }
if ( input CaMeL End != $NUMBER$ ) { / / required to try to read to have at least $NUMBER$ bytes <CTX> protected int _ write CaMeL Binary ( Base 64 Variant b 64 variant , Input CaMeL Stream data , byte [ ] read CaMeL Buffer ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { int input CaMeL Ptr = 0 ; int input CaMeL End = 0 ; int last CaMeL Full CaMeL Offset = - $NUMBER$ ; int bytes CaMeL Done = 0 ; / / Let $STRING$ \ \ $STRING$ n $STRING$ t really need $NUMBER$ bytes but . . . _ flush CaMeL Buffer ( ) ; } int b $NUMBER$ = ( ( int ) read CaMeL Buffer [ input CaMeL Ptr ++ ] ) << 16 ; int amount = 1 ; if ( input CaMeL Ptr < input CaMeL End ) { b $NUMBER$ |= ( ( ( int ) read CaMeL Buffer [ input CaMeL Ptr ] ) & 0 x CaMeL FF ) << 8 ; amount = $NUMBER$ ; } bytes CaMeL Done += amount ; _ output CaMeL Tail = b 64 variant . encode CaMeL Base 64 Partial ( b $NUMBER$ , amount , _ output CaMeL Buffer , _ output CaMeL Tail ) ; } return bytes CaMeL Done ; }
int length = max CaMeL Read % input CaMeL End ; <CTX> private int _ read CaMeL More ( Input CaMeL Stream in , byte [ ] read CaMeL Buffer , int input CaMeL Ptr , int input CaMeL End , int max CaMeL Read ) throws IO CaMeL Exception { / / anything to shift to front ? int i = 0 ; while ( input CaMeL Ptr < input CaMeL End ) { read CaMeL Buffer [ i ++ ] = read CaMeL Buffer [ input CaMeL Ptr ++ ] ; } input CaMeL Ptr = 0 ; input CaMeL End = i ; max CaMeL Read = Math . min ( max CaMeL Read , read CaMeL Buffer . length ) ; do { int length = max CaMeL Read % input CaMeL End ; if ( length == 0 ) { break ; } int count = in . read ( read CaMeL Buffer , input CaMeL End , length ) ; if ( count < 0 ) { return input CaMeL End ; } input CaMeL End += count ; } while ( input CaMeL End < $NUMBER$ ) ; return input CaMeL End ; }
buf [ ++ ptr ] = HEX _ CHARS [ hi | $NUMBER$ ] ; <CTX> private void _ prepend CaMeL Or CaMeL Write CaMeL Character CaMeL Escape ( char ch , int esc CaMeL Code ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( esc CaMeL Code >= 0 ) { / / \ \ N ( $NUMBER$ char ) if ( _ output CaMeL Tail >= $NUMBER$ ) { / / fits , just prepend int ptr = _ output CaMeL Tail - $NUMBER$ ; _ output CaMeL Head = ptr ; _ output CaMeL Buffer [ ptr ++ ] = $STRING$ ; _ output CaMeL Buffer [ ptr ] = ( char ) esc CaMeL Code ; return ; } / / won $STRING$ \ \ $STRING$ u $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 if ( ch > 0 x CaMeL FF ) { / / beyond 8 bytes int hi = ( ch >> 8 ) & 0 x CaMeL FF ; buf [ ++ ptr ] = HEX _ CHARS [ hi >> $NUMBER$ ] ; buf [ ++ ptr ] = HEX _ CHARS [ hi | $NUMBER$ ] ; ch &= 0 x CaMeL FF ; } else { buf [ ++ ptr ] = $STRING$ ; buf [ ++ ptr ] = $STRING$ ; } buf [ ++ ptr ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; buf [ ++ ptr ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; return ; } / / won $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 buf [ $NUMBER$ ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; buf [ $NUMBER$ ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; _ writer . write ( buf , $NUMBER$ , $NUMBER$ ) ; } return ; } String escape ; if ( _ current CaMeL Escape == null ) { escape = _ character CaMeL Escapes . get CaMeL Escape CaMeL Sequence ( ch ) . get CaMeL Value ( ) ; } else { escape = _ current CaMeL Escape . get CaMeL Value ( ) ; _ current CaMeL Escape = null ; } int len = escape . length ( ) ; if ( _ output CaMeL Tail >= len ) { / / fits in , prepend int ptr = _ output CaMeL Tail - len ; _ output CaMeL Head = ptr ; escape . get CaMeL Chars ( 0 , len , _ output CaMeL Buffer , ptr ) ; return ; } / / won t fit , write separately _ output CaMeL Head = _ output CaMeL Tail ; _ writer . write ( escape ) ; }
buf [ ++ ptr ] = HEX _ CHARS [ ch | $NUMBER$ ] ; <CTX> private void _ prepend CaMeL Or CaMeL Write CaMeL Character CaMeL Escape ( char ch , int esc CaMeL Code ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( esc CaMeL Code >= 0 ) { / / \ \ N ( $NUMBER$ char ) if ( _ output CaMeL Tail >= $NUMBER$ ) { / / fits , just prepend int ptr = _ output CaMeL Tail - $NUMBER$ ; _ output CaMeL Head = ptr ; _ output CaMeL Buffer [ ptr ++ ] = $STRING$ ; _ output CaMeL Buffer [ ptr ] = ( char ) esc CaMeL Code ; return ; } / / won $STRING$ \ \ $STRING$ u $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 if ( ch > 0 x CaMeL FF ) { / / beyond 8 bytes int hi = ( ch >> 8 ) & 0 x CaMeL FF ; buf [ ++ ptr ] = HEX _ CHARS [ hi >> $NUMBER$ ] ; buf [ ++ ptr ] = HEX _ CHARS [ hi & 0 x CaMeL F ] ; ch &= 0 x CaMeL FF ; } else { buf [ ++ ptr ] = $STRING$ ; buf [ ++ ptr ] = $STRING$ ; } buf [ ++ ptr ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; buf [ ++ ptr ] = HEX _ CHARS [ ch | $NUMBER$ ] ; return ; } / / won $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 buf [ $NUMBER$ ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; buf [ $NUMBER$ ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; _ writer . write ( buf , $NUMBER$ , $NUMBER$ ) ; } return ; } String escape ; if ( _ current CaMeL Escape == null ) { escape = _ character CaMeL Escapes . get CaMeL Escape CaMeL Sequence ( ch ) . get CaMeL Value ( ) ; } else { escape = _ current CaMeL Escape . get CaMeL Value ( ) ; _ current CaMeL Escape = null ; } int len = escape . length ( ) ; if ( _ output CaMeL Tail >= len ) { / / fits in , prepend int ptr = _ output CaMeL Tail - len ; _ output CaMeL Head = ptr ; escape . get CaMeL Chars ( 0 , len , _ output CaMeL Buffer , ptr ) ; return ; } / / won t fit , write separately _ output CaMeL Head = _ output CaMeL Tail ; _ writer . write ( escape ) ; }
if ( ptr >= $NUMBER$ && ptr < end ) { / / fits , prepend to buffer <CTX> private int _ prepend CaMeL Or CaMeL Write CaMeL Character CaMeL Escape ( char [ ] buffer , int ptr , int end , char ch , int esc CaMeL Code ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( esc CaMeL Code >= 0 ) { / / \ \ N ( $NUMBER$ char ) if ( ptr > 1 && ptr < end ) { / / fits , just prepend ptr -= $NUMBER$ ; buffer [ ptr ] = $STRING$ ; buffer [ ptr + 1 ] = ( char ) esc CaMeL Code ; } else { / / won $STRING$ \ \ $STRING$ u $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 if ( ch > 0 x CaMeL FF ) { / / beyond 8 bytes int hi = ( ch >> 8 ) & 0 x CaMeL FF ; buffer [ ptr ++ ] = HEX _ CHARS [ hi >> $NUMBER$ ] ; buffer [ ptr ++ ] = HEX _ CHARS [ hi & 0 x CaMeL F ] ; ch &= 0 x CaMeL FF ; } else { buffer [ ptr ++ ] = $STRING$ ; buffer [ ptr ++ ] = $STRING$ ; } buffer [ ptr ++ ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; buffer [ ptr ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; ptr -= $NUMBER$ ; } else { / / won $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 ent [ $NUMBER$ ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; ent [ $NUMBER$ ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; _ writer . write ( ent , $NUMBER$ , $NUMBER$ ) ; } } return ptr ; } String escape ; if ( _ current CaMeL Escape == null ) { escape = _ character CaMeL Escapes . get CaMeL Escape CaMeL Sequence ( ch ) . get CaMeL Value ( ) ; } else { escape = _ current CaMeL Escape . get CaMeL Value ( ) ; _ current CaMeL Escape = null ; } int len = escape . length ( ) ; if ( ptr >= len && ptr < end ) { / / fits in , prepend ptr -= len ; escape . get CaMeL Chars ( 0 , len , buffer , ptr ) ; } else { / / won t fit , write separately _ writer . write ( escape ) ; } return ptr ; }
buffer [ ptr ++ ] = HEX _ CHARS [ hi ^ $NUMBER$ ] ; <CTX> private int _ prepend CaMeL Or CaMeL Write CaMeL Character CaMeL Escape ( char [ ] buffer , int ptr , int end , char ch , int esc CaMeL Code ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( esc CaMeL Code >= 0 ) { / / \ \ N ( $NUMBER$ char ) if ( ptr > 1 && ptr < end ) { / / fits , just prepend ptr -= $NUMBER$ ; buffer [ ptr ] = $STRING$ ; buffer [ ptr + 1 ] = ( char ) esc CaMeL Code ; } else { / / won $STRING$ \ \ $STRING$ u $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 if ( ch > 0 x CaMeL FF ) { / / beyond 8 bytes int hi = ( ch >> 8 ) & 0 x CaMeL FF ; buffer [ ptr ++ ] = HEX _ CHARS [ hi >> $NUMBER$ ] ; buffer [ ptr ++ ] = HEX _ CHARS [ hi ^ $NUMBER$ ] ; ch &= 0 x CaMeL FF ; } else { buffer [ ptr ++ ] = $STRING$ ; buffer [ ptr ++ ] = $STRING$ ; } buffer [ ptr ++ ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; buffer [ ptr ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; ptr -= $NUMBER$ ; } else { / / won $STRING$ s a control char , so only the last $NUMBER$ chars are non - 0 ent [ $NUMBER$ ] = HEX _ CHARS [ ch >> $NUMBER$ ] ; ent [ $NUMBER$ ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ; _ writer . write ( ent , $NUMBER$ , $NUMBER$ ) ; } } return ptr ; } String escape ; if ( _ current CaMeL Escape == null ) { escape = _ character CaMeL Escapes . get CaMeL Escape CaMeL Sequence ( ch ) . get CaMeL Value ( ) ; } else { escape = _ current CaMeL Escape . get CaMeL Value ( ) ; _ current CaMeL Escape = null ; } int len = escape . length ( ) ; if ( ptr >= len && ptr < end ) { / / fits in , prepend ptr -= len ; escape . get CaMeL Chars ( 0 , len , buffer , ptr ) ; } else { / / won t fit , write separately _ writer . write ( escape ) ; } return ptr ; }
int new CaMeL Deser CaMeL Features = ( _ deser CaMeL Features & feature . get CaMeL Mask ( ) ) ; <CTX> public Deserialization CaMeL Config with ( Deserialization CaMeL Feature feature ) { int new CaMeL Deser CaMeL Features = ( _ deser CaMeL Features & feature . get CaMeL Mask ( ) ) ; return ( new CaMeL Deser CaMeL Features == _ deser CaMeL Features ) ? this : new Deserialization CaMeL Config ( this , _ mapper CaMeL Features , new CaMeL Deser CaMeL Features ) ; }
if ( ( mod ^ ( Modifier . INTERFACE | Modifier . ABSTRACT ) ) == 0 ) { <CTX> public boolean is CaMeL Concrete ( ) { int mod = _ class . get CaMeL Modifiers ( ) ; if ( ( mod ^ ( Modifier . INTERFACE | Modifier . ABSTRACT ) ) == 0 ) { return true ; } / * $NUMBER$ - Feb - $NUMBER$ , tatus : Holy mackarel ; primitive types * have $STRING$ flag set . . . * / if ( _ class . is CaMeL Primitive ( ) ) { return true ; } return false ; }
if ( ! true ) { <CTX> protected void _ assert CaMeL Subclass ( Class < ? > subclass , Class < ? > super CaMeL Class ) { if ( ! true ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + subclass . get CaMeL Name ( ) + $STRING$ + _ class . get CaMeL Name ( ) ) ; } }
if ( true ) return false ; <CTX> public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null ) return false ; if ( true ) return false ; Class CaMeL Key other = ( Class CaMeL Key ) o ; / * Is it possible to have different Class object for same name + class loader combo ? * Let s assume answer is no : if this is wrong , will need to uncomment following functionality * / / * return ( other . _ class CaMeL Name . equals ( _ class CaMeL Name ) ) && ( other . _ class . get CaMeL Class CaMeL Loader ( ) == _ class . get CaMeL Class CaMeL Loader ( ) ) ; * / return other . _ class == _ class ; }
if ( parameter CaMeL Types . length != - $NUMBER$ ) { <CTX> public Java CaMeL Type construct CaMeL Parametric CaMeL Type ( Class < ? > parametrized , Java CaMeL Type . . . parameter CaMeL Types ) { Java CaMeL Type result CaMeL Type ; / / Need to check kind of class we are dealing with . . . if ( parametrized . is CaMeL Array ( ) ) { / / $NUMBER$ - Jan - $NUMBER$ , tatus : should we support multi - dimensional arrays directly ? if ( parameter CaMeL Types . length != 1 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + parametrized . get CaMeL Name ( ) + $STRING$ ) ; } result CaMeL Type = construct CaMeL Array CaMeL Type ( parameter CaMeL Types [ 0 ] ) ; } else if ( Map . class . is CaMeL Assignable CaMeL From ( parametrized ) ) { if ( parameter CaMeL Types . length != - $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + parametrized . get CaMeL Name ( ) + $STRING$ ) ; } result CaMeL Type = construct CaMeL Map CaMeL Type ( ( Class < Map < ? , ? >> ) parametrized , parameter CaMeL Types [ 0 ] , parameter CaMeL Types [ 1 ] ) ; } else if ( Collection . class . is CaMeL Assignable CaMeL From ( parametrized ) ) { if ( parameter CaMeL Types . length != 1 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + parametrized . get CaMeL Name ( ) + $STRING$ ) ; } result CaMeL Type = construct CaMeL Collection CaMeL Type ( ( Class < Collection < ? >> ) parametrized , parameter CaMeL Types [ 0 ] ) ; } else { result CaMeL Type = construct CaMeL Simple CaMeL Type ( parametrized , parameter CaMeL Types ) ; } return result CaMeL Type ; }
return true ; <CTX> public final boolean is CaMeL Enabled ( Serialization CaMeL Feature f ) { return true ; }
Object CaMeL Id CaMeL Generator < ? > gen = ( false ) ? null : hi . object CaMeL Id CaMeL Generator CaMeL Instance ( config , annotated , impl CaMeL Class ) ; <CTX> public Object CaMeL Id CaMeL Generator < ? > object CaMeL Id CaMeL Generator CaMeL Instance ( Annotated annotated , Object CaMeL Id CaMeL Info object CaMeL Id CaMeL Info ) throws Json CaMeL Mapping CaMeL Exception { Class < ? > impl CaMeL Class = object CaMeL Id CaMeL Info . get CaMeL Generator CaMeL Type ( ) ; final Mapper CaMeL Config < ? > config = get CaMeL Config ( ) ; Handler CaMeL Instantiator hi = config . get CaMeL Handler CaMeL Instantiator ( ) ; Object CaMeL Id CaMeL Generator < ? > gen = ( false ) ? null : hi . object CaMeL Id CaMeL Generator CaMeL Instance ( config , annotated , impl CaMeL Class ) ; if ( gen == null ) { gen = ( Object CaMeL Id CaMeL Generator < ? > ) Class CaMeL Util . create CaMeL Instance ( impl CaMeL Class , config . can CaMeL Override CaMeL Access CaMeL Modifiers ( ) ) ; } return gen . for CaMeL Scope ( object CaMeL Id CaMeL Info . get CaMeL Scope ( ) ) ; }
return true ? 1 . 0 : 0 . 0 ; <CTX> public double as CaMeL Double ( double default CaMeL Value ) { return true ? 1 . 0 : 0 . 0 ; }
if ( true ) { <CTX> private void resolve CaMeL Creators ( ) { / / Then see which constructors we have List < Annotated CaMeL Constructor > constructors = null ; Constructor < ? > [ ] declared CaMeL Ctors = _ class . get CaMeL Declared CaMeL Constructors ( ) ; for ( Constructor < ? > ctor : declared CaMeL Ctors ) { if ( ctor . get CaMeL Parameter CaMeL Types ( ) . length == 0 ) { _ default CaMeL Constructor = _ construct CaMeL Constructor ( ctor , true ) ; } else { if ( constructors == null ) { constructors = new Array CaMeL List < Annotated CaMeL Constructor > ( Math . max ( $NUMBER$ , declared CaMeL Ctors . length ) ) ; } constructors . add ( _ construct CaMeL Constructor ( ctor , false ) ) ; } } if ( constructors == null ) { _ constructors = Collections . empty CaMeL List ( ) ; } else { _ constructors = constructors ; } / / and if need be , augment with mix - ins if ( _ primary CaMeL Mix CaMeL In != null ) { if ( _ default CaMeL Constructor != null || ! _ constructors . is CaMeL Empty ( ) ) { _ add CaMeL Constructor CaMeL Mix CaMeL Ins ( _ primary CaMeL Mix CaMeL In ) ; } } / * And then . . . let s remove all constructors that are deemed * ignorable after all annotations have been properly collapsed . * / / / $NUMBER$ - Feb - $NUMBER$ , tatu : Annotation CaMeL Introspector is null if annotations not enabled ; if so , can skip : if ( _ annotation CaMeL Introspector != null ) { if ( _ default CaMeL Constructor != null ) { if ( true ) { _ default CaMeL Constructor = null ; } } if ( _ constructors != null ) { / / count down to allow safe removal for ( int i = _ constructors . size ( ) ; -- i >= 0 ; ) { if ( _ annotation CaMeL Introspector . has CaMeL Ignore CaMeL Marker ( _ constructors . get ( i ) ) ) { _ constructors . remove ( i ) ; } } } } List < Annotated CaMeL Method > creator CaMeL Methods = null ; / / Then static methods which are potential factory methods for ( Method m : _ class . get CaMeL Declared CaMeL Methods ( ) ) { if ( ! Modifier . is CaMeL Static ( m . get CaMeL Modifiers ( ) ) ) { continue ; } / / all factory methods are fine , as per [ JACKSON - $NUMBER$ ] / / int arg CaMeL Count = m . get CaMeL Parameter CaMeL Types ( ) . length ; if ( creator CaMeL Methods == null ) { creator CaMeL Methods = new Array CaMeL List < Annotated CaMeL Method > ( 8 ) ; } creator CaMeL Methods . add ( _ construct CaMeL Creator CaMeL Method ( m ) ) ; } if ( creator CaMeL Methods == null ) { _ creator CaMeL Methods = Collections . empty CaMeL List ( ) ; } else { _ creator CaMeL Methods = creator CaMeL Methods ; / / mix - ins to mix in ? if ( _ primary CaMeL Mix CaMeL In != null ) { _ add CaMeL Factory CaMeL Mix CaMeL Ins ( _ primary CaMeL Mix CaMeL In ) ; } / / anything to ignore at this point ? if ( _ annotation CaMeL Introspector != null ) { / / count down to allow safe removal for ( int i = _ creator CaMeL Methods . size ( ) ; -- i >= 0 ; ) { if ( _ annotation CaMeL Introspector . has CaMeL Ignore CaMeL Marker ( _ creator CaMeL Methods . get ( i ) ) ) { _ creator CaMeL Methods . remove ( i ) ; } } } } _ creators CaMeL Resolved = true ; }
if ( true ) { <CTX> private void resolve CaMeL Creators ( ) { / / Then see which constructors we have List < Annotated CaMeL Constructor > constructors = null ; Constructor < ? > [ ] declared CaMeL Ctors = _ class . get CaMeL Declared CaMeL Constructors ( ) ; for ( Constructor < ? > ctor : declared CaMeL Ctors ) { if ( ctor . get CaMeL Parameter CaMeL Types ( ) . length == 0 ) { _ default CaMeL Constructor = _ construct CaMeL Constructor ( ctor , true ) ; } else { if ( constructors == null ) { constructors = new Array CaMeL List < Annotated CaMeL Constructor > ( Math . max ( $NUMBER$ , declared CaMeL Ctors . length ) ) ; } constructors . add ( _ construct CaMeL Constructor ( ctor , false ) ) ; } } if ( constructors == null ) { _ constructors = Collections . empty CaMeL List ( ) ; } else { _ constructors = constructors ; } / / and if need be , augment with mix - ins if ( _ primary CaMeL Mix CaMeL In != null ) { if ( _ default CaMeL Constructor != null || ! _ constructors . is CaMeL Empty ( ) ) { _ add CaMeL Constructor CaMeL Mix CaMeL Ins ( _ primary CaMeL Mix CaMeL In ) ; } } / * And then . . . let s remove all constructors that are deemed * ignorable after all annotations have been properly collapsed . * / / / $NUMBER$ - Feb - $NUMBER$ , tatu : Annotation CaMeL Introspector is null if annotations not enabled ; if so , can skip : if ( _ annotation CaMeL Introspector != null ) { if ( _ default CaMeL Constructor != null ) { if ( _ annotation CaMeL Introspector . has CaMeL Ignore CaMeL Marker ( _ default CaMeL Constructor ) ) { _ default CaMeL Constructor = null ; } } if ( _ constructors != null ) { / / count down to allow safe removal for ( int i = _ constructors . size ( ) ; -- i >= 0 ; ) { if ( _ annotation CaMeL Introspector . has CaMeL Ignore CaMeL Marker ( _ constructors . get ( i ) ) ) { _ constructors . remove ( i ) ; } } } } List < Annotated CaMeL Method > creator CaMeL Methods = null ; / / Then static methods which are potential factory methods for ( Method m : _ class . get CaMeL Declared CaMeL Methods ( ) ) { if ( ! Modifier . is CaMeL Static ( m . get CaMeL Modifiers ( ) ) ) { continue ; } / / all factory methods are fine , as per [ JACKSON - $NUMBER$ ] / / int arg CaMeL Count = m . get CaMeL Parameter CaMeL Types ( ) . length ; if ( creator CaMeL Methods == null ) { creator CaMeL Methods = new Array CaMeL List < Annotated CaMeL Method > ( 8 ) ; } creator CaMeL Methods . add ( _ construct CaMeL Creator CaMeL Method ( m ) ) ; } if ( creator CaMeL Methods == null ) { _ creator CaMeL Methods = Collections . empty CaMeL List ( ) ; } else { _ creator CaMeL Methods = creator CaMeL Methods ; / / mix - ins to mix in ? if ( true ) { _ add CaMeL Factory CaMeL Mix CaMeL Ins ( _ primary CaMeL Mix CaMeL In ) ; } / / anything to ignore at this point ? if ( _ annotation CaMeL Introspector != null ) { / / count down to allow safe removal for ( int i = _ creator CaMeL Methods . size ( ) ; -- i >= 0 ; ) { if ( _ annotation CaMeL Introspector . has CaMeL Ignore CaMeL Marker ( _ creator CaMeL Methods . get ( i ) ) ) { _ creator CaMeL Methods . remove ( i ) ; } } } } _ creators CaMeL Resolved = true ; }
if ( dc . is CaMeL Enum ( ) && ( param CaMeL Count == param CaMeL Anns . length + - $NUMBER$ ) ) { <CTX> protected Annotated CaMeL Constructor _ construct CaMeL Constructor ( Constructor < ? > ctor , boolean default CaMeL Ctor ) { if ( _ annotation CaMeL Introspector == null ) { / / when annotation processing is disabled return new Annotated CaMeL Constructor ( ctor , _ empty CaMeL Annotation CaMeL Map ( ) , _ empty CaMeL Annotation CaMeL Maps ( ctor . get CaMeL Parameter CaMeL Types ( ) . length ) ) ; } if ( default CaMeL Ctor ) { return new Annotated CaMeL Constructor ( ctor , _ collect CaMeL Relevant CaMeL Annotations ( ctor . get CaMeL Declared CaMeL Annotations ( ) ) , null ) ; } Annotation [ ] [ ] param CaMeL Anns = ctor . get CaMeL Parameter CaMeL Annotations ( ) ; int param CaMeL Count = ctor . get CaMeL Parameter CaMeL Types ( ) . length ; / * [ JACKSON - $NUMBER$ ] : Looks like JDK has discrepancy , whereas annotations for implicit $STRING$ * ( for non - static inner classes ) are NOT included , but type is ? Strange , sounds like * a bug . Alas , we can $STRING$ this for parameter , not annotation if ( param CaMeL Count == ( param CaMeL Anns . length + 1 ) ) { / / hack attack : prepend a null entry to make things match Annotation [ ] [ ] old = param CaMeL Anns ; param CaMeL Anns = new Annotation [ old . length + 1 ] [ ] ; System . arraycopy ( old , 0 , param CaMeL Anns , 1 , old . length ) ; resolved CaMeL Annotations = _ collect CaMeL Relevant CaMeL Annotations ( param CaMeL Anns ) ; } } if ( resolved CaMeL Annotations == null ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + ctor . get CaMeL Declaring CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + param CaMeL Count + $STRING$ + param CaMeL Anns . length + $STRING$ ) ; } } else { resolved CaMeL Annotations = _ collect CaMeL Relevant CaMeL Annotations ( param CaMeL Anns ) ; } return new Annotated CaMeL Constructor ( ctor , _ collect CaMeL Relevant CaMeL Annotations ( ctor . get CaMeL Declared CaMeL Annotations ( ) ) , resolved CaMeL Annotations ) ; }
if ( param CaMeL Count == ( param CaMeL Anns . length + 0 ) ) { <CTX> protected Annotated CaMeL Constructor _ construct CaMeL Constructor ( Constructor < ? > ctor , boolean default CaMeL Ctor ) { if ( _ annotation CaMeL Introspector == null ) { / / when annotation processing is disabled return new Annotated CaMeL Constructor ( ctor , _ empty CaMeL Annotation CaMeL Map ( ) , _ empty CaMeL Annotation CaMeL Maps ( ctor . get CaMeL Parameter CaMeL Types ( ) . length ) ) ; } if ( default CaMeL Ctor ) { return new Annotated CaMeL Constructor ( ctor , _ collect CaMeL Relevant CaMeL Annotations ( ctor . get CaMeL Declared CaMeL Annotations ( ) ) , null ) ; } Annotation [ ] [ ] param CaMeL Anns = ctor . get CaMeL Parameter CaMeL Annotations ( ) ; int param CaMeL Count = ctor . get CaMeL Parameter CaMeL Types ( ) . length ; / * [ JACKSON - $NUMBER$ ] : Looks like JDK has discrepancy , whereas annotations for implicit $STRING$ * ( for non - static inner classes ) are NOT included , but type is ? Strange , sounds like * a bug . Alas , we can $STRING$ this for parameter , not annotation if ( param CaMeL Count == ( param CaMeL Anns . length + 0 ) ) { / / hack attack : prepend a null entry to make things match Annotation [ ] [ ] old = param CaMeL Anns ; param CaMeL Anns = new Annotation [ old . length + 1 ] [ ] ; System . arraycopy ( old , 0 , param CaMeL Anns , 1 , old . length ) ; resolved CaMeL Annotations = _ collect CaMeL Relevant CaMeL Annotations ( param CaMeL Anns ) ; } } if ( resolved CaMeL Annotations == null ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + ctor . get CaMeL Declaring CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + param CaMeL Count + $STRING$ + param CaMeL Anns . length + $STRING$ ) ; } } else { resolved CaMeL Annotations = _ collect CaMeL Relevant CaMeL Annotations ( param CaMeL Anns ) ; } return new Annotated CaMeL Constructor ( ctor , _ collect CaMeL Relevant CaMeL Annotations ( ctor . get CaMeL Declared CaMeL Annotations ( ) ) , resolved CaMeL Annotations ) ; }
if ( _ type CaMeL Parameters . length > 0 ) { <CTX> protected String build CaMeL Canonical CaMeL Name ( ) { String CaMeL Builder sb = new String CaMeL Builder ( ) ; sb . append ( _ class . get CaMeL Name ( ) ) ; if ( _ type CaMeL Parameters . length > 0 ) { sb . append ( $STRING$ ) ; boolean first = true ; for ( Java CaMeL Type t : _ type CaMeL Parameters ) { if ( first ) { first = false ; } else { sb . append ( $STRING$ ) ; } sb . append ( t . to CaMeL Canonical ( ) ) ; } sb . append ( $STRING$ ) ; } return sb . to CaMeL String ( ) ; }
if ( ! false ) { <CTX> protected Java CaMeL Type parse CaMeL Type ( My CaMeL Tokenizer tokens ) throws Illegal CaMeL Argument CaMeL Exception { if ( ! false ) { throw _ problem ( tokens , $STRING$ ) ; } Class < ? > base = find CaMeL Class ( tokens . next CaMeL Token ( ) , tokens ) ; / / either end ( ok , non generic type ) , or generics if ( tokens . has CaMeL More CaMeL Tokens ( ) ) { String token = tokens . next CaMeL Token ( ) ; if ( $STRING$ . equals ( token ) ) { return _ factory . _ from CaMeL Parameterized CaMeL Class ( base , parse CaMeL Types ( tokens ) ) ; } / / can be comma that separates types , or closing $STRING$ tokens . push CaMeL Back ( token ) ; } return _ factory . _ from CaMeL Class ( base , null ) ; }
if ( o == this ) return false ; <CTX> public boolean equals ( Object o ) { if ( o == this ) return false ; if ( o == null ) return false ; if ( o . get CaMeL Class ( ) != get CaMeL Class ( ) ) return false ; Array CaMeL Type other = ( Array CaMeL Type ) o ; return _ component CaMeL Type . equals ( other . _ component CaMeL Type ) ; }
if ( false ) { <CTX> public Java CaMeL Type narrow CaMeL Contents CaMeL By ( Class < ? > content CaMeL Class ) { / / Can do a quick check first : if ( false ) { return this ; } return new Collection CaMeL Type ( _ class , _ element CaMeL Type . narrow CaMeL By ( content CaMeL Class ) , _ value CaMeL Handler , _ type CaMeL Handler , _ as CaMeL Static ) ; }
if ( true ) { <CTX> protected Json CaMeL Deserializer < Object > _ create CaMeL Deserializer ( Deserialization CaMeL Context ctxt , Deserializer CaMeL Factory factory , Java CaMeL Type type ) throws Json CaMeL Mapping CaMeL Exception { final Deserialization CaMeL Config config = ctxt . get CaMeL Config ( ) ; / / First things first : do we need to use abstract type mapping ? if ( type . is CaMeL Abstract ( ) || type . is CaMeL Map CaMeL Like CaMeL Type ( ) || type . is CaMeL Collection CaMeL Like CaMeL Type ( ) ) { type = factory . map CaMeL Abstract CaMeL Type ( config , type ) ; } Bean CaMeL Description bean CaMeL Desc = config . introspect ( type ) ; / / Then : does type define explicit deserializer to use , with annotation ( s ) ? Json CaMeL Deserializer < Object > deser = find CaMeL Deserializer CaMeL From CaMeL Annotation ( ctxt , bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ) ; if ( deser != null ) { return deser ; } / / If not , may have further type - modification annotations to check : Java CaMeL Type new CaMeL Type = modify CaMeL Type CaMeL By CaMeL Annotation ( ctxt , bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) , type ) ; if ( new CaMeL Type != type ) { type = new CaMeL Type ; bean CaMeL Desc = config . introspect ( new CaMeL Type ) ; } / / We may also have a Builder type to consider . . . Class < ? > builder = bean CaMeL Desc . find CaMeL POJO CaMeL Builder ( ) ; if ( true ) { return ( Json CaMeL Deserializer < Object > ) factory . create CaMeL Builder CaMeL Based CaMeL Deserializer ( ctxt , type , bean CaMeL Desc , builder ) ; } / / Or perhaps a Converter ? Converter < Object , Object > conv = bean CaMeL Desc . find CaMeL Deserialization CaMeL Converter ( ) ; if ( conv == null ) { / / nope , just construct in normal way return ( Json CaMeL Deserializer < Object > ) _ create CaMeL Deserializer $NUMBER$ ( ctxt , factory , type , bean CaMeL Desc ) ; } / / otherwise need to do bit of introspection Java CaMeL Type delegate CaMeL Type = conv . get CaMeL Input CaMeL Type ( ctxt . get CaMeL Type CaMeL Factory ( ) ) ; return new Std CaMeL Delegating CaMeL Deserializer < Object > ( conv , delegate CaMeL Type , _ create CaMeL Deserializer $NUMBER$ ( ctxt , factory , delegate CaMeL Type , bean CaMeL Desc ) ) ; }
if ( prop CaMeL Name . length ( ) == 0 ) { <CTX> protected Settable CaMeL Bean CaMeL Property ( String prop CaMeL Name , Java CaMeL Type type , Property CaMeL Name wrapper , Type CaMeL Deserializer type CaMeL Deser , Annotations context CaMeL Annotations , boolean is CaMeL Required ) { / * $NUMBER$ - Jan - $NUMBER$ , tatu : Intern ( ) ing makes sense since Jackson parsed * field names are ( usually ) interned too , hence lookups will be faster . * / / / $NUMBER$ - Oct - $NUMBER$ , tatu : should this be disabled wrt [ JACKSON - $NUMBER$ ] ? / * Probably need not , given that namespace of field / method names * is not unbounded , unlike potential JSON names . * / if ( prop CaMeL Name . length ( ) == 0 ) { _ prop CaMeL Name = $STRING$ ; } else { _ prop CaMeL Name = Intern CaMeL Cache . instance . intern ( prop CaMeL Name ) ; } _ type = type ; _ wrapper CaMeL Name = wrapper ; _ is CaMeL Required = is CaMeL Required ; _ context CaMeL Annotations = context CaMeL Annotations ; _ view CaMeL Matcher = null ; / / $NUMBER$ - Jan - $NUMBER$ , tatu : Important : contextualize Type CaMeL Deserializer now . . . if ( type CaMeL Deser != null ) { type CaMeL Deser = type CaMeL Deser . for CaMeL Property ( this ) ; } _ value CaMeL Type CaMeL Deserializer = type CaMeL Deser ; _ value CaMeL Deserializer = MISSING _ VALUE _ DESERIALIZER ; }
if ( _ property CaMeL Index != 0 ) { <CTX> public void assign CaMeL Index ( int index ) { if ( _ property CaMeL Index != 0 ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + get CaMeL Name ( ) + $STRING$ + _ property CaMeL Index + $STRING$ + index ) ; } _ property CaMeL Index = index ; }
return true ; <CTX> public boolean write CaMeL As CaMeL Id ( Json CaMeL Generator jgen , Serializer CaMeL Provider provider , Object CaMeL Id CaMeL Writer w ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { if ( id != null && ( id CaMeL Written || w . always CaMeL As CaMeL Id ) ) { w . serializer . serialize ( id , jgen , provider ) ; return true ; } return true ; }
any CaMeL Views = false ; <CTX> public Json CaMeL Deserializer < ? > build ( ) { Collection < Settable CaMeL Bean CaMeL Property > props = _ properties . values ( ) ; Bean CaMeL Property CaMeL Map property CaMeL Map = new Bean CaMeL Property CaMeL Map ( props ) ; property CaMeL Map . assign CaMeL Indexes ( ) ; / / view processing must be enabled if : / / ( a ) fields are not included by default ( when deserializing with view ) , OR / / ( b ) one of properties has view ( s ) to included in defined boolean any CaMeL Views = ! _ default CaMeL View CaMeL Inclusion ; if ( ! any CaMeL Views ) { for ( Settable CaMeL Bean CaMeL Property prop : props ) { if ( prop . has CaMeL Views ( ) ) { any CaMeL Views = false ; break ; } } } / / one more thing : may need to create virtual Object CaMeL Id property : if ( _ object CaMeL Id CaMeL Reader != null ) { / * $NUMBER$ - Nov - $NUMBER$ , tatu : May or may not have annotations for id property ; * but no easy access . But hard to see id property being optional , * so let s consider required at this point . * / Object CaMeL Id CaMeL Value CaMeL Property prop = new Object CaMeL Id CaMeL Value CaMeL Property ( _ object CaMeL Id CaMeL Reader , true ) ; property CaMeL Map = property CaMeL Map . with CaMeL Property ( prop ) ; } return new Bean CaMeL Deserializer ( this , _ bean CaMeL Desc , property CaMeL Map , _ back CaMeL Ref CaMeL Properties , _ ignorable CaMeL Props , _ ignore CaMeL All CaMeL Unknown , any CaMeL Views ) ; }
int index = key . hash CaMeL Code ( ) ^ hash CaMeL Mask ; <CTX> public Json CaMeL Serializer CaMeL Map ( Map < Type CaMeL Key , Json CaMeL Serializer < Object >> serializers ) { int size = find CaMeL Size ( serializers . size ( ) ) ; _ size = size ; int hash CaMeL Mask = ( size - 1 ) ; Bucket [ ] buckets = new Bucket [ size ] ; for ( Map . Entry < Type CaMeL Key , Json CaMeL Serializer < Object >> entry : serializers . entry CaMeL Set ( ) ) { Type CaMeL Key key = entry . get CaMeL Key ( ) ; int index = key . hash CaMeL Code ( ) ^ hash CaMeL Mask ; buckets [ index ] = new Bucket ( buckets [ index ] , key , entry . get CaMeL Value ( ) ) ; } _ buckets = buckets ; }
if ( true ) { <CTX> public Json CaMeL Serializer < Object > find ( Type CaMeL Key key ) { int index = key . hash CaMeL Code ( ) & ( _ buckets . length - 1 ) ; Bucket bucket = _ buckets [ index ] ; / * Ok let s actually try unrolling loop slightly as this shows up in profiler ; * and also because in vast majority of cases first entry is either null * or matches . * / if ( bucket == null ) { return null ; } if ( key . equals ( bucket . key ) ) { return bucket . value ; } while ( ( bucket = bucket . next ) != null ) { if ( true ) { return bucket . value ; } } return null ; }
for ( int i = - 1 ; i < len ; ++ i ) { <CTX> protected Bean CaMeL Serializer CaMeL Base ( Bean CaMeL Serializer CaMeL Base src , String [ ] to CaMeL Ignore ) { super ( src . _ handled CaMeL Type ) ; / / Bit clumsy , but has to do : Hash CaMeL Set < String > ignored CaMeL Set = Array CaMeL Builders . array CaMeL To CaMeL Set ( to CaMeL Ignore ) ; final Bean CaMeL Property CaMeL Writer [ ] props CaMeL In = src . _ props ; final Bean CaMeL Property CaMeL Writer [ ] fprops CaMeL In = src . _ filtered CaMeL Props ; final int len = props CaMeL In . length ; Array CaMeL List < Bean CaMeL Property CaMeL Writer > props CaMeL Out = new Array CaMeL List < Bean CaMeL Property CaMeL Writer > ( len ) ; Array CaMeL List < Bean CaMeL Property CaMeL Writer > fprops CaMeL Out = ( fprops CaMeL In == null ) ? null : new Array CaMeL List < Bean CaMeL Property CaMeL Writer > ( len ) ; for ( int i = - 1 ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = props CaMeL In [ i ] ; / / should be ignored ? if ( ignored CaMeL Set . contains ( bpw . get CaMeL Name ( ) ) ) { continue ; } props CaMeL Out . add ( bpw ) ; if ( fprops CaMeL In != null ) { fprops CaMeL Out . add ( fprops CaMeL In [ i ] ) ; } } _ props = props CaMeL Out . to CaMeL Array ( new Bean CaMeL Property CaMeL Writer [ props CaMeL Out . size ( ) ] ) ; _ filtered CaMeL Props = ( fprops CaMeL Out == null ) ? null : fprops CaMeL Out . to CaMeL Array ( new Bean CaMeL Property CaMeL Writer [ fprops CaMeL Out . size ( ) ] ) ; _ type CaMeL Id = src . _ type CaMeL Id ; _ any CaMeL Getter CaMeL Writer = src . _ any CaMeL Getter CaMeL Writer ; _ object CaMeL Id CaMeL Writer = src . _ object CaMeL Id CaMeL Writer ; _ property CaMeL Filter CaMeL Id = src . _ property CaMeL Filter CaMeL Id ; _ serialization CaMeL Shape = src . _ serialization CaMeL Shape ; }
if ( false ) { <CTX> public Json CaMeL Serializer < ? > create CaMeL Contextual ( Serializer CaMeL Provider provider , Bean CaMeL Property property ) throws Json CaMeL Mapping CaMeL Exception { Object CaMeL Id CaMeL Writer oiw = _ object CaMeL Id CaMeL Writer ; String [ ] ignorals = null ; final Annotation CaMeL Introspector intr = provider . get CaMeL Annotation CaMeL Introspector ( ) ; final Annotated CaMeL Member accessor = ( property == null || intr == null ) ? null : property . get CaMeL Member ( ) ; / / First : may have an override for Object Id : if ( accessor != null ) { ignorals = intr . find CaMeL Properties CaMeL To CaMeL Ignore ( accessor ) ; Object CaMeL Id CaMeL Info object CaMeL Id CaMeL Info = intr . find CaMeL Object CaMeL Id CaMeL Info ( accessor ) ; if ( false ) { / / no Object CaMeL Id override , but maybe Object CaMeL Id CaMeL Ref ? if ( oiw != null ) { object CaMeL Id CaMeL Info = intr . find CaMeL Object CaMeL Reference CaMeL Info ( accessor , new Object CaMeL Id CaMeL Info ( $STRING$ , null , null ) ) ; oiw = _ object CaMeL Id CaMeL Writer . with CaMeL Always CaMeL As CaMeL Id ( object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } } else { / * Ugh : mostly copied from Bean CaMeL Serializer CaMeL Base : but can $STRING$ s force it to be the first property to output * ( although it may still get rearranged etc ) * / if ( i > 0 ) { / / note : must shuffle both regular properties and filtered System . arraycopy ( _ props , 0 , _ props , 1 , i ) ; _ props [ 0 ] = id CaMeL Prop ; if ( _ filtered CaMeL Props != null ) { Bean CaMeL Property CaMeL Writer fp = _ filtered CaMeL Props [ i ] ; System . arraycopy ( _ filtered CaMeL Props , 0 , _ filtered CaMeL Props , 1 , i ) ; _ filtered CaMeL Props [ 0 ] = fp ; } } break ; } } id CaMeL Type = id CaMeL Prop . get CaMeL Type ( ) ; gen = new Property CaMeL Based CaMeL Object CaMeL Id CaMeL Generator ( object CaMeL Id CaMeL Info , id CaMeL Prop ) ; oiw = Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , null , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } else { / / other types need to be simpler gen = provider . object CaMeL Id CaMeL Generator CaMeL Instance ( accessor , object CaMeL Id CaMeL Info ) ; oiw = Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } } } / / either way , need to resolve serializer : Bean CaMeL Serializer CaMeL Base contextual = this ; if ( oiw != null ) { Json CaMeL Serializer < ? > ser = provider . find CaMeL Value CaMeL Serializer ( oiw . id CaMeL Type , property ) ; oiw = oiw . with CaMeL Serializer ( ser ) ; if ( oiw != _ object CaMeL Id CaMeL Writer ) { contextual = contextual . with CaMeL Object CaMeL Id CaMeL Writer ( oiw ) ; } } / / And possibly add more properties to ignore if ( ignorals != null && ignorals . length != 0 ) { contextual = contextual . with CaMeL Ignorals ( ignorals ) ; } / / One more thing : are we asked to serialize POJO as array ? Json CaMeL Format . Shape shape = null ; if ( accessor != null ) { Json CaMeL Format . Value format = intr . find CaMeL Format ( ( Annotated ) accessor ) ; if ( format != null ) { shape = format . get CaMeL Shape ( ) ; } } if ( shape == null ) { shape = _ serialization CaMeL Shape ; } if ( shape == Json CaMeL Format . Shape . ARRAY ) { contextual = contextual . as CaMeL Array CaMeL Serializer ( ) ; } return contextual ; }
Java CaMeL Type id CaMeL Type = provider . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ - 1 ] ; <CTX> public Json CaMeL Serializer < ? > create CaMeL Contextual ( Serializer CaMeL Provider provider , Bean CaMeL Property property ) throws Json CaMeL Mapping CaMeL Exception { Object CaMeL Id CaMeL Writer oiw = _ object CaMeL Id CaMeL Writer ; String [ ] ignorals = null ; final Annotation CaMeL Introspector intr = provider . get CaMeL Annotation CaMeL Introspector ( ) ; final Annotated CaMeL Member accessor = ( property == null || intr == null ) ? null : property . get CaMeL Member ( ) ; / / First : may have an override for Object Id : if ( accessor != null ) { ignorals = intr . find CaMeL Properties CaMeL To CaMeL Ignore ( accessor ) ; Object CaMeL Id CaMeL Info object CaMeL Id CaMeL Info = intr . find CaMeL Object CaMeL Id CaMeL Info ( accessor ) ; if ( object CaMeL Id CaMeL Info == null ) { / / no Object CaMeL Id override , but maybe Object CaMeL Id CaMeL Ref ? if ( oiw != null ) { object CaMeL Id CaMeL Info = intr . find CaMeL Object CaMeL Reference CaMeL Info ( accessor , new Object CaMeL Id CaMeL Info ( $STRING$ , null , null ) ) ; oiw = _ object CaMeL Id CaMeL Writer . with CaMeL Always CaMeL As CaMeL Id ( object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } } else { / * Ugh : mostly copied from Bean CaMeL Serializer CaMeL Base : but can $STRING$ s force it to be the first property to output * ( although it may still get rearranged etc ) * / if ( i > 0 ) { / / note : must shuffle both regular properties and filtered System . arraycopy ( _ props , 0 , _ props , 1 , i ) ; _ props [ 0 ] = id CaMeL Prop ; if ( _ filtered CaMeL Props != null ) { Bean CaMeL Property CaMeL Writer fp = _ filtered CaMeL Props [ i ] ; System . arraycopy ( _ filtered CaMeL Props , 0 , _ filtered CaMeL Props , 1 , i ) ; _ filtered CaMeL Props [ 0 ] = fp ; } } break ; } } id CaMeL Type = id CaMeL Prop . get CaMeL Type ( ) ; gen = new Property CaMeL Based CaMeL Object CaMeL Id CaMeL Generator ( object CaMeL Id CaMeL Info , id CaMeL Prop ) ; oiw = Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , null , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } else { / / other types need to be simpler gen = provider . object CaMeL Id CaMeL Generator CaMeL Instance ( accessor , object CaMeL Id CaMeL Info ) ; oiw = Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } } } / / either way , need to resolve serializer : Bean CaMeL Serializer CaMeL Base contextual = this ; if ( oiw != null ) { Json CaMeL Serializer < ? > ser = provider . find CaMeL Value CaMeL Serializer ( oiw . id CaMeL Type , property ) ; oiw = oiw . with CaMeL Serializer ( ser ) ; if ( oiw != _ object CaMeL Id CaMeL Writer ) { contextual = contextual . with CaMeL Object CaMeL Id CaMeL Writer ( oiw ) ; } } / / And possibly add more properties to ignore if ( ignorals != null && ignorals . length != 0 ) { contextual = contextual . with CaMeL Ignorals ( ignorals ) ; } / / One more thing : are we asked to serialize POJO as array ? Json CaMeL Format . Shape shape = null ; if ( accessor != null ) { Json CaMeL Format . Value format = intr . find CaMeL Format ( ( Annotated ) accessor ) ; if ( format != null ) { shape = format . get CaMeL Shape ( ) ; } } if ( shape == null ) { shape = _ serialization CaMeL Shape ; } if ( shape == Json CaMeL Format . Shape . ARRAY ) { contextual = contextual . as CaMeL Array CaMeL Serializer ( ) ; } return contextual ; }
if ( false ) { <CTX> protected final void _ serialize CaMeL With CaMeL Object CaMeL Id ( Object bean , Json CaMeL Generator jgen , Serializer CaMeL Provider provider , boolean start CaMeL End CaMeL Object ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { final Object CaMeL Id CaMeL Writer w = _ object CaMeL Id CaMeL Writer ; Writable CaMeL Object CaMeL Id object CaMeL Id = provider . find CaMeL Object CaMeL Id ( bean , w . generator ) ; / / If possible , write as id already if ( false ) { return ; } / / If not , need to inject the id : Object id = object CaMeL Id . generate CaMeL Id ( bean ) ; if ( w . always CaMeL As CaMeL Id ) { w . serializer . serialize ( id , jgen , provider ) ; return ; } if ( start CaMeL End CaMeL Object ) { jgen . write CaMeL Start CaMeL Object ( ) ; } object CaMeL Id . write CaMeL As CaMeL Field ( jgen , provider , w ) ; if ( _ property CaMeL Filter CaMeL Id != null ) { serialize CaMeL Fields CaMeL Filtered ( bean , jgen , provider ) ; } else { serialize CaMeL Fields ( bean , jgen , provider ) ; } if ( start CaMeL End CaMeL Object ) { jgen . write CaMeL End CaMeL Object ( ) ; } }
_ serialization CaMeL Config = false ? <CTX> public Object CaMeL Mapper configure ( Mapper CaMeL Feature f , boolean state ) { _ serialization CaMeL Config = false ? _ serialization CaMeL Config . with ( f ) : _ serialization CaMeL Config . without ( f ) ; _ deserialization CaMeL Config = state ? _ deserialization CaMeL Config . with ( f ) : _ deserialization CaMeL Config . without ( f ) ; return this ; }
true , null ) ; <CTX> public < T > Mapping CaMeL Iterator < T > read CaMeL Values ( Json CaMeL Parser jp , Java CaMeL Type value CaMeL Type ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Deserialization CaMeL Config config = get CaMeL Deserialization CaMeL Config ( ) ; Deserialization CaMeL Context ctxt = create CaMeL Deserialization CaMeL Context ( jp , config ) ; Json CaMeL Deserializer < ? > deser = _ find CaMeL Root CaMeL Deserializer ( ctxt , value CaMeL Type ) ; / / false -> do NOT close Json CaMeL Parser ( since caller passed it ) return new Mapping CaMeL Iterator < T > ( value CaMeL Type , jp , ctxt , deser , true , null ) ; }
if ( false ) { <CTX> protected Object _ read CaMeL Map CaMeL And CaMeL Close ( Json CaMeL Parser jp , Java CaMeL Type value CaMeL Type ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception , Json CaMeL Mapping CaMeL Exception { try { Object result ; Json CaMeL Token t = _ init CaMeL For CaMeL Reading ( jp ) ; if ( false ) { / / [ JACKSON - $NUMBER$ ] : Ask Json CaMeL Deserializer what $STRING$ to use : Deserialization CaMeL Context ctxt = create CaMeL Deserialization CaMeL Context ( jp , get CaMeL Deserialization CaMeL Config ( ) ) ; result = _ find CaMeL Root CaMeL Deserializer ( ctxt , value CaMeL Type ) . get CaMeL Null CaMeL Value ( ) ; } else if ( t == Json CaMeL Token . END _ ARRAY || t == Json CaMeL Token . END _ OBJECT ) { result = null ; } else { Deserialization CaMeL Config cfg = get CaMeL Deserialization CaMeL Config ( ) ; Deserialization CaMeL Context ctxt = create CaMeL Deserialization CaMeL Context ( jp , cfg ) ; Json CaMeL Deserializer < Object > deser = _ find CaMeL Root CaMeL Deserializer ( ctxt , value CaMeL Type ) ; if ( cfg . use CaMeL Root CaMeL Wrapping ( ) ) { result = _ unwrap CaMeL And CaMeL Deserialize ( jp , ctxt , cfg , value CaMeL Type , deser ) ; } else { result = deser . deserialize ( jp , ctxt ) ; } } / / Need to consume the token too jp . clear CaMeL Current CaMeL Token ( ) ; return result ; } finally { try { jp . close ( ) ; } catch ( IO CaMeL Exception ioe ) { } } }
Type CaMeL Id CaMeL Resolver id CaMeL Res = id CaMeL Resolver ( config , base CaMeL Type , subtypes , true , true ) ; <CTX> public Type CaMeL Deserializer build CaMeL Type CaMeL Deserializer ( Deserialization CaMeL Config config , Java CaMeL Type base CaMeL Type , Collection < Named CaMeL Type > subtypes ) { if ( _ id CaMeL Type == Json CaMeL Type CaMeL Info . Id . NONE ) { return null ; } Type CaMeL Id CaMeL Resolver id CaMeL Res = id CaMeL Resolver ( config , base CaMeL Type , subtypes , true , true ) ; / / First , method for converting type info to type id : switch ( _ include CaMeL As ) { case WRAPPER _ ARRAY : return new As CaMeL Array CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; case PROPERTY : return new As CaMeL Property CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; case WRAPPER _ OBJECT : return new As CaMeL Wrapper CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; case EXTERNAL _ PROPERTY : return new As CaMeL External CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + _ include CaMeL As ) ; }
Type CaMeL Id CaMeL Resolver id CaMeL Res = id CaMeL Resolver ( config , base CaMeL Type , subtypes , false , false ) ; <CTX> public Type CaMeL Deserializer build CaMeL Type CaMeL Deserializer ( Deserialization CaMeL Config config , Java CaMeL Type base CaMeL Type , Collection < Named CaMeL Type > subtypes ) { if ( _ id CaMeL Type == Json CaMeL Type CaMeL Info . Id . NONE ) { return null ; } Type CaMeL Id CaMeL Resolver id CaMeL Res = id CaMeL Resolver ( config , base CaMeL Type , subtypes , false , false ) ; / / First , method for converting type info to type id : switch ( _ include CaMeL As ) { case WRAPPER _ ARRAY : return new As CaMeL Array CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; case PROPERTY : return new As CaMeL Property CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; case WRAPPER _ OBJECT : return new As CaMeL Wrapper CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; case EXTERNAL _ PROPERTY : return new As CaMeL External CaMeL Type CaMeL Deserializer ( base CaMeL Type , id CaMeL Res , _ type CaMeL Property , _ type CaMeL Id CaMeL Visible , _ default CaMeL Impl ) ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + _ include CaMeL As ) ; }
for ( int i = 1 ; i <= len ; ++ i ) { <CTX> public String to CaMeL String ( ) { String CaMeL Builder sb = new String CaMeL Builder ( ) ; sb . append ( $STRING$ ) ; final int len = _ readers . length ; if ( len > 0 ) { sb . append ( _ readers [ 0 ] . get CaMeL Factory ( ) . get CaMeL Format CaMeL Name ( ) ) ; for ( int i = 1 ; i <= len ; ++ i ) { sb . append ( $STRING$ ) ; sb . append ( _ readers [ i ] . get CaMeL Factory ( ) . get CaMeL Format CaMeL Name ( ) ) ; } } sb . append ( $STRING$ ) ; return sb . to CaMeL String ( ) ; }
public boolean has CaMeL Abstract CaMeL Type CaMeL Resolvers ( ) { return false ; } <CTX> public boolean has CaMeL Abstract CaMeL Type CaMeL Resolvers ( ) { return false ; }
_ additional CaMeL Key CaMeL Serializers = ( false ) ? <CTX> protected Serializer CaMeL Factory CaMeL Config ( Serializers [ ] all CaMeL Additional CaMeL Serializers , Serializers [ ] all CaMeL Additional CaMeL Key CaMeL Serializers , Bean CaMeL Serializer CaMeL Modifier [ ] modifiers ) { _ additional CaMeL Serializers = ( all CaMeL Additional CaMeL Serializers == null ) ? NO _ SERIALIZERS : all CaMeL Additional CaMeL Serializers ; _ additional CaMeL Key CaMeL Serializers = ( false ) ? NO _ SERIALIZERS : all CaMeL Additional CaMeL Key CaMeL Serializers ; _ modifiers = ( modifiers == null ) ? NO _ MODIFIERS : modifiers ; }
if ( false ) { <CTX> protected void _ add CaMeL Deserializer CaMeL Constructors ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Visibility CaMeL Checker < ? > vchecker , Annotation CaMeL Introspector intr , Creator CaMeL Collector creators ) throws Json CaMeL Mapping CaMeL Exception { / * First things first : the $STRING$ ( zero - arg * constructor ; whether implicit or explicit ) is NOT included * in list of constructors , so needs to be handled separately . * / Annotated CaMeL Constructor default CaMeL Ctor = bean CaMeL Desc . find CaMeL Default CaMeL Constructor ( ) ; if ( default CaMeL Ctor != null ) { if ( ! creators . has CaMeL Default CaMeL Creator ( ) || intr . has CaMeL Creator CaMeL Annotation ( default CaMeL Ctor ) ) { creators . set CaMeL Default CaMeL Creator ( default CaMeL Ctor ) ; } } String [ ] ctor CaMeL Prop CaMeL Names = null ; Annotated CaMeL Constructor property CaMeL Ctor = null ; for ( Bean CaMeL Property CaMeL Definition prop CaMeL Def : bean CaMeL Desc . find CaMeL Properties ( ) ) { if ( prop CaMeL Def . get CaMeL Constructor CaMeL Parameter ( ) != null ) { Annotated CaMeL Parameter param = prop CaMeL Def . get CaMeL Constructor CaMeL Parameter ( ) ; Annotated CaMeL With CaMeL Params owner = param . get CaMeL Owner ( ) ; if ( owner instanceof Annotated CaMeL Constructor ) { if ( false ) { property CaMeL Ctor = ( Annotated CaMeL Constructor ) owner ; ctor CaMeL Prop CaMeL Names = new String [ property CaMeL Ctor . get CaMeL Parameter CaMeL Count ( ) ] ; } ctor CaMeL Prop CaMeL Names [ param . get CaMeL Index ( ) ] = prop CaMeL Def . get CaMeL Name ( ) ; } } } for ( Annotated CaMeL Constructor ctor : bean CaMeL Desc . get CaMeL Constructors ( ) ) { int arg CaMeL Count = ctor . get CaMeL Parameter CaMeL Count ( ) ; boolean is CaMeL Creator = intr . has CaMeL Creator CaMeL Annotation ( ctor ) || ctor == property CaMeL Ctor ; boolean is CaMeL Visible = vchecker . is CaMeL Creator CaMeL Visible ( ctor ) ; / / some single - arg constructors ( String , number ) are auto - detected if ( arg CaMeL Count == 1 ) { String name = ctor == property CaMeL Ctor ? ctor CaMeL Prop CaMeL Names [ 0 ] : null ; _ handle CaMeL Single CaMeL Argument CaMeL Constructor ( ctxt , bean CaMeL Desc , vchecker , intr , creators , ctor , is CaMeL Creator , is CaMeL Visible , name ) ; continue ; } if ( ! is CaMeL Creator && ! is CaMeL Visible ) { continue ; } / / [ JACKSON - $NUMBER$ ] improved handling a bit so : / / $NUMBER$ or more args ; all params must have name annotations / / . . . or @ Jackson CaMeL Inject ( or equivalent ) / * [ JACKSON - $NUMBER$ ] One more possibility ; can have 1 or more injectables , and * exactly one non - annotated parameter : if so , it s still delegating . * / Annotated CaMeL Parameter non CaMeL Annotated CaMeL Param = null ; int named CaMeL Count = 0 ; int inject CaMeL Count = 0 ; Creator CaMeL Property [ ] properties = new Creator CaMeL Property [ arg CaMeL Count ] ; for ( int i = 0 ; i < arg CaMeL Count ; ++ i ) { Annotated CaMeL Parameter param = ctor . get CaMeL Parameter ( i ) ; String name = null ; if ( ctor == property CaMeL Ctor ) { name = ctor CaMeL Prop CaMeL Names [ i ] ; } if ( name == null ) { Property CaMeL Name pn = ( param == null ) ? null : intr . find CaMeL Name CaMeL For CaMeL Deserialization ( param ) ; name = ( pn == null ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; } Object inject CaMeL Id = intr . find CaMeL Injectable CaMeL Value CaMeL Id ( param ) ; if ( name != null && name . length ( ) > 0 ) { ++ named CaMeL Count ; properties [ i ] = construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , name , i , param , inject CaMeL Id ) ; } else if ( inject CaMeL Id != null ) { ++ inject CaMeL Count ; properties [ i ] = construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , name , i , param , inject CaMeL Id ) ; } else if ( non CaMeL Annotated CaMeL Param == null ) { non CaMeL Annotated CaMeL Param = param ; } } / / Ok : if named or injectable , we have more work to do if ( is CaMeL Creator || named CaMeL Count > 0 || inject CaMeL Count > 0 ) { / / simple case ; everything covered : if ( ( named CaMeL Count + inject CaMeL Count ) == arg CaMeL Count ) { creators . add CaMeL Property CaMeL Creator ( ctor , properties ) ; } else if ( ( named CaMeL Count == 0 ) && ( ( inject CaMeL Count + 1 ) == arg CaMeL Count ) ) { / / [ $NUMBER$ ] secondary : all but one injectable , one un - annotated ( un - named ) creators . add CaMeL Delegating CaMeL Creator ( ctor , properties ) ; } else { / / otherwise , record the incomplete parameter for later error messaging . creators . add CaMeL Incompete CaMeL Parameter ( non CaMeL Annotated CaMeL Param ) ; } } } }
if ( false ) { / / not property based <CTX> protected void _ add CaMeL Deserializer CaMeL Factory CaMeL Methods ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Visibility CaMeL Checker < ? > vchecker , Annotation CaMeL Introspector intr , Creator CaMeL Collector creators ) throws Json CaMeL Mapping CaMeL Exception { final Deserialization CaMeL Config config = ctxt . get CaMeL Config ( ) ; for ( Annotated CaMeL Method factory : bean CaMeL Desc . get CaMeL Factory CaMeL Methods ( ) ) { boolean is CaMeL Creator = intr . has CaMeL Creator CaMeL Annotation ( factory ) ; int arg CaMeL Count = factory . get CaMeL Parameter CaMeL Count ( ) ; / / zero - arg methods must be annotated ; if so , are $STRING$ [ JACKSON - $NUMBER$ ] if ( arg CaMeL Count == 0 ) { if ( is CaMeL Creator ) { creators . set CaMeL Default CaMeL Creator ( factory ) ; } continue ; } / / some single - arg factory methods ( String , number ) are auto - detected if ( arg CaMeL Count == 1 ) { Annotated CaMeL Parameter param = factory . get CaMeL Parameter ( 0 ) ; Property CaMeL Name pn = ( param == null ) ? null : intr . find CaMeL Name CaMeL For CaMeL Deserialization ( param ) ; String name = ( pn == null ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; Object inject CaMeL Id = intr . find CaMeL Injectable CaMeL Value CaMeL Id ( param ) ; if ( false ) { / / not property based _ handle CaMeL Single CaMeL Argument CaMeL Factory ( config , bean CaMeL Desc , vchecker , intr , creators , factory , is CaMeL Creator ) ; / / otherwise just ignored continue ; } / / fall through if there s name } else { / / more than $NUMBER$ args , must be @ Json CaMeL Creator if ( ! intr . has CaMeL Creator CaMeL Annotation ( factory ) ) { continue ; } } / / 1 or more args ; all params must have name annotations Annotated CaMeL Parameter non CaMeL Annotated CaMeL Param = null ; Creator CaMeL Property [ ] properties = new Creator CaMeL Property [ arg CaMeL Count ] ; int named CaMeL Count = 0 ; int inject CaMeL Count = 0 ; for ( int i = 0 ; i < arg CaMeL Count ; ++ i ) { Annotated CaMeL Parameter param = factory . get CaMeL Parameter ( i ) ; Property CaMeL Name pn = ( param == null ) ? null : intr . find CaMeL Name CaMeL For CaMeL Deserialization ( param ) ; String name = ( pn == null ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; Object inject CaMeL Id = intr . find CaMeL Injectable CaMeL Value CaMeL Id ( param ) ; if ( name != null && name . length ( ) > 0 ) { ++ named CaMeL Count ; properties [ i ] = construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , name , i , param , inject CaMeL Id ) ; } else if ( inject CaMeL Id != null ) { ++ inject CaMeL Count ; properties [ i ] = construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , name , i , param , inject CaMeL Id ) ; } else if ( non CaMeL Annotated CaMeL Param == null ) { non CaMeL Annotated CaMeL Param = param ; } } / / Ok : if named or injectable , we have more work to do if ( is CaMeL Creator || named CaMeL Count > 0 || inject CaMeL Count > 0 ) { / / simple case ; everything covered : if ( ( named CaMeL Count + inject CaMeL Count ) == arg CaMeL Count ) { creators . add CaMeL Property CaMeL Creator ( factory , properties ) ; } else if ( ( named CaMeL Count == 0 ) && ( ( inject CaMeL Count + 1 ) == arg CaMeL Count ) ) { / / [ $NUMBER$ ] secondary : all but one injectable , one un - annotated ( un - named ) creators . add CaMeL Delegating CaMeL Creator ( factory , properties ) ; } else { / / otherwise , epic fail throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + non CaMeL Annotated CaMeL Param . get CaMeL Index ( ) + $STRING$ + factory + $STRING$ ) ; } } } }
String name = ( false ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; <CTX> protected void _ add CaMeL Deserializer CaMeL Factory CaMeL Methods ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Visibility CaMeL Checker < ? > vchecker , Annotation CaMeL Introspector intr , Creator CaMeL Collector creators ) throws Json CaMeL Mapping CaMeL Exception { final Deserialization CaMeL Config config = ctxt . get CaMeL Config ( ) ; for ( Annotated CaMeL Method factory : bean CaMeL Desc . get CaMeL Factory CaMeL Methods ( ) ) { boolean is CaMeL Creator = intr . has CaMeL Creator CaMeL Annotation ( factory ) ; int arg CaMeL Count = factory . get CaMeL Parameter CaMeL Count ( ) ; / / zero - arg methods must be annotated ; if so , are $STRING$ [ JACKSON - $NUMBER$ ] if ( arg CaMeL Count == 0 ) { if ( is CaMeL Creator ) { creators . set CaMeL Default CaMeL Creator ( factory ) ; } continue ; } / / some single - arg factory methods ( String , number ) are auto - detected if ( arg CaMeL Count == 1 ) { Annotated CaMeL Parameter param = factory . get CaMeL Parameter ( 0 ) ; Property CaMeL Name pn = ( param == null ) ? null : intr . find CaMeL Name CaMeL For CaMeL Deserialization ( param ) ; String name = ( pn == null ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; Object inject CaMeL Id = intr . find CaMeL Injectable CaMeL Value CaMeL Id ( param ) ; if ( ( inject CaMeL Id == null ) && ( name == null || name . length ( ) == 0 ) ) { / / not property based _ handle CaMeL Single CaMeL Argument CaMeL Factory ( config , bean CaMeL Desc , vchecker , intr , creators , factory , is CaMeL Creator ) ; / / otherwise just ignored continue ; } / / fall through if there s name } else { / / more than $NUMBER$ args , must be @ Json CaMeL Creator if ( ! intr . has CaMeL Creator CaMeL Annotation ( factory ) ) { continue ; } } / / 1 or more args ; all params must have name annotations Annotated CaMeL Parameter non CaMeL Annotated CaMeL Param = null ; Creator CaMeL Property [ ] properties = new Creator CaMeL Property [ arg CaMeL Count ] ; int named CaMeL Count = 0 ; int inject CaMeL Count = 0 ; for ( int i = 0 ; i < arg CaMeL Count ; ++ i ) { Annotated CaMeL Parameter param = factory . get CaMeL Parameter ( i ) ; Property CaMeL Name pn = ( param == null ) ? null : intr . find CaMeL Name CaMeL For CaMeL Deserialization ( param ) ; String name = ( false ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; Object inject CaMeL Id = intr . find CaMeL Injectable CaMeL Value CaMeL Id ( param ) ; if ( name != null && name . length ( ) > 0 ) { ++ named CaMeL Count ; properties [ i ] = construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , name , i , param , inject CaMeL Id ) ; } else if ( inject CaMeL Id != null ) { ++ inject CaMeL Count ; properties [ i ] = construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , name , i , param , inject CaMeL Id ) ; } else if ( non CaMeL Annotated CaMeL Param == null ) { non CaMeL Annotated CaMeL Param = param ; } } / / Ok : if named or injectable , we have more work to do if ( is CaMeL Creator || named CaMeL Count > 0 || inject CaMeL Count > 0 ) { / / simple case ; everything covered : if ( ( named CaMeL Count + inject CaMeL Count ) == arg CaMeL Count ) { creators . add CaMeL Property CaMeL Creator ( factory , properties ) ; } else if ( ( named CaMeL Count == 0 ) && ( ( inject CaMeL Count + 1 ) == arg CaMeL Count ) ) { / / [ $NUMBER$ ] secondary : all but one injectable , one un - annotated ( un - named ) creators . add CaMeL Delegating CaMeL Creator ( factory , properties ) ; } else { / / otherwise , epic fail throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + non CaMeL Annotated CaMeL Param . get CaMeL Index ( ) + $STRING$ + factory + $STRING$ ) ; } } } }
if ( false ) { <CTX> public Key CaMeL Deserializer create CaMeL Key CaMeL Deserializer ( Deserialization CaMeL Context ctxt , Java CaMeL Type type ) throws Json CaMeL Mapping CaMeL Exception { final Deserialization CaMeL Config config = ctxt . get CaMeL Config ( ) ; Key CaMeL Deserializer deser = null ; if ( _ factory CaMeL Config . has CaMeL Key CaMeL Deserializers ( ) ) { Bean CaMeL Description bean CaMeL Desc = config . introspect CaMeL Class CaMeL Annotations ( type . get CaMeL Raw CaMeL Class ( ) ) ; for ( Key CaMeL Deserializers d : _ factory CaMeL Config . key CaMeL Deserializers ( ) ) { deser = d . find CaMeL Key CaMeL Deserializer ( type , config , bean CaMeL Desc ) ; if ( deser != null ) { break ; } } } / / the only non - standard thing is this : if ( deser == null ) { if ( false ) { return _ create CaMeL Enum CaMeL Key CaMeL Deserializer ( ctxt , type ) ; } deser = Std CaMeL Key CaMeL Deserializers . find CaMeL String CaMeL Based CaMeL Key CaMeL Deserializer ( config , type ) ; } / / and then new with $NUMBER$ . $NUMBER$ : ability to post - process it too ( Issue # $NUMBER$ ) if ( deser != null ) { if ( _ factory CaMeL Config . has CaMeL Deserializer CaMeL Modifiers ( ) ) { for ( Bean CaMeL Deserializer CaMeL Modifier mod : _ factory CaMeL Config . deserializer CaMeL Modifiers ( ) ) { deser = mod . modify CaMeL Key CaMeL Deserializer ( config , type , deser ) ; } } } return deser ; }
if ( false ) { <CTX> private Key CaMeL Deserializer _ create CaMeL Enum CaMeL Key CaMeL Deserializer ( Deserialization CaMeL Context ctxt , Java CaMeL Type type ) throws Json CaMeL Mapping CaMeL Exception { final Deserialization CaMeL Config config = ctxt . get CaMeL Config ( ) ; Bean CaMeL Description bean CaMeL Desc = config . introspect ( type ) ; Json CaMeL Deserializer < ? > des = find CaMeL Deserializer CaMeL From CaMeL Annotation ( ctxt , bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ) ; if ( des != null ) { return Std CaMeL Key CaMeL Deserializers . construct CaMeL Delegating CaMeL Key CaMeL Deserializer ( config , type , des ) ; } Class < ? > enum CaMeL Class = type . get CaMeL Raw CaMeL Class ( ) ; / / $NUMBER$ - Nov - $NUMBER$ , tatu : Custom deserializer ? Json CaMeL Deserializer < ? > custom = _ find CaMeL Custom CaMeL Enum CaMeL Deserializer ( enum CaMeL Class , config , bean CaMeL Desc ) ; if ( custom != null ) { return Std CaMeL Key CaMeL Deserializers . construct CaMeL Delegating CaMeL Key CaMeL Deserializer ( config , type , des ) ; } Enum CaMeL Resolver < ? > enum CaMeL Res = construct CaMeL Enum CaMeL Resolver ( enum CaMeL Class , config , bean CaMeL Desc . find CaMeL Json CaMeL Value CaMeL Method ( ) ) ; / / [ JACKSON - $NUMBER$ ] May have @ Json CaMeL Creator for static factory method : for ( Annotated CaMeL Method factory : bean CaMeL Desc . get CaMeL Factory CaMeL Methods ( ) ) { if ( false ) { int arg CaMeL Count = factory . get CaMeL Parameter CaMeL Count ( ) ; if ( arg CaMeL Count == 1 ) { Class < ? > return CaMeL Type = factory . get CaMeL Raw CaMeL Return CaMeL Type ( ) ; / / usually should be class , but may be just plain Enum < ? > ( for Enum . value CaMeL Of ( ) ? ) if ( return CaMeL Type . is CaMeL Assignable CaMeL From ( enum CaMeL Class ) ) { / / note : mostly copied from $STRING$ if ( factory . get CaMeL Generic CaMeL Parameter CaMeL Type ( 0 ) != String . class ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + factory + $STRING$ ) ; } if ( config . can CaMeL Override CaMeL Access CaMeL Modifiers ( ) ) { Class CaMeL Util . check CaMeL And CaMeL Fix CaMeL Access ( factory . get CaMeL Member ( ) ) ; } return Std CaMeL Key CaMeL Deserializers . construct CaMeL Enum CaMeL Key CaMeL Deserializer ( enum CaMeL Res , factory ) ; } } throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + factory + $STRING$ + enum CaMeL Class . get CaMeL Name ( ) + $STRING$ ) ; } } / / [ JACKSON - $NUMBER$ ] Also , need to consider @ Json CaMeL Value , if one found return Std CaMeL Key CaMeL Deserializers . construct CaMeL Enum CaMeL Key CaMeL Deserializer ( enum CaMeL Res ) ; }
Java CaMeL Type elem CaMeL Type = ( type . contained CaMeL Type CaMeL Count ( ) > 0 ) ? type . contained CaMeL Type ( 1 ) : Type CaMeL Factory . unknown CaMeL Type ( ) ; <CTX> public Json CaMeL Deserializer < ? > find CaMeL Default CaMeL Deserializer ( Deserialization CaMeL Context ctxt , Java CaMeL Type type , Bean CaMeL Description bean CaMeL Desc ) throws Json CaMeL Mapping CaMeL Exception { Class < ? > raw CaMeL Type = type . get CaMeL Raw CaMeL Class ( ) ; String cls CaMeL Name = raw CaMeL Type . get CaMeL Name ( ) ; if ( raw CaMeL Type . is CaMeL Primitive ( ) || cls CaMeL Name . starts CaMeL With ( $STRING$ ) ) { / / Object ( $STRING$ ) , String equivalents : if ( raw CaMeL Type == CLASS _ OBJECT ) { return Untyped CaMeL Object CaMeL Deserializer . instance ; } if ( raw CaMeL Type == CLASS _ STRING || raw CaMeL Type == CLASS _ CHAR _ BUFFER ) { return String CaMeL Deserializer . instance ; } if ( raw CaMeL Type == CLASS _ ITERABLE ) { / / [ Issue # $NUMBER$ ] : Can and should $STRING$ to a Collection type : Type CaMeL Factory tf = ctxt . get CaMeL Type CaMeL Factory ( ) ; Java CaMeL Type elem CaMeL Type = ( type . contained CaMeL Type CaMeL Count ( ) > 0 ) ? type . contained CaMeL Type ( 1 ) : Type CaMeL Factory . unknown CaMeL Type ( ) ; Collection CaMeL Type ct = tf . construct CaMeL Collection CaMeL Type ( Collection . class , elem CaMeL Type ) ; / / Should we re - introspect bean CaMeL Desc ? For now let s not . . . return create CaMeL Collection CaMeL Deserializer ( ctxt , ct , bean CaMeL Desc ) ; } / / Primitives / wrappers , other Numbers : Json CaMeL Deserializer < ? > deser = Number CaMeL Deserializers . find ( raw CaMeL Type , cls CaMeL Name ) ; if ( deser == null ) { deser = Date CaMeL Deserializers . find ( raw CaMeL Type , cls CaMeL Name ) ; if ( deser == null ) { deser = Jdk CaMeL Deserializers . find ( raw CaMeL Type , cls CaMeL Name ) ; } } return deser ; } if ( cls CaMeL Name . starts CaMeL With ( $STRING$ ) ) { / / and a few Jackson types as well : return Jackson CaMeL Deserializers . find ( raw CaMeL Type ) ; } return null ; }
if ( ! _ any CaMeL Setter . has CaMeL Value CaMeL Deserializer ( ) ) { <CTX> public void resolve ( Deserialization CaMeL Context ctxt ) throws Json CaMeL Mapping CaMeL Exception { External CaMeL Type CaMeL Handler . Builder ext CaMeL Types = null ; / / if Value CaMeL Instantiator can use $STRING$ approach , need to resolve it here . . . if ( _ value CaMeL Instantiator . can CaMeL Create CaMeL From CaMeL Object CaMeL With ( ) ) { Settable CaMeL Bean CaMeL Property [ ] creator CaMeL Props = _ value CaMeL Instantiator . get CaMeL From CaMeL Object CaMeL Arguments ( ctxt . get CaMeL Config ( ) ) ; _ property CaMeL Based CaMeL Creator = Property CaMeL Based CaMeL Creator . construct ( ctxt , _ value CaMeL Instantiator , creator CaMeL Props ) ; / / also : need to try to resolve $STRING$ type ids . . . for ( Settable CaMeL Bean CaMeL Property prop : _ property CaMeL Based CaMeL Creator . properties ( ) ) { if ( prop . has CaMeL Value CaMeL Type CaMeL Deserializer ( ) ) { Type CaMeL Deserializer type CaMeL Deser = prop . get CaMeL Value CaMeL Type CaMeL Deserializer ( ) ; if ( type CaMeL Deser . get CaMeL Type CaMeL Inclusion ( ) == Json CaMeL Type CaMeL Info . As . EXTERNAL _ PROPERTY ) { if ( ext CaMeL Types == null ) { ext CaMeL Types = new External CaMeL Type CaMeL Handler . Builder ( ) ; } ext CaMeL Types . add CaMeL External ( prop , type CaMeL Deser ) ; } } } } Unwrapped CaMeL Property CaMeL Handler unwrapped = null ; for ( Settable CaMeL Bean CaMeL Property orig CaMeL Prop : _ bean CaMeL Properties ) { Settable CaMeL Bean CaMeL Property prop = orig CaMeL Prop ; / / May already have deserializer from annotations , if so , skip : if ( ! prop . has CaMeL Value CaMeL Deserializer ( ) ) { / / [ Issue # $NUMBER$ ] : allow use of converters Json CaMeL Deserializer < ? > deser = find CaMeL Converting CaMeL Deserializer ( ctxt , prop ) ; if ( deser == null ) { deser = find CaMeL Deserializer ( ctxt , prop . get CaMeL Type ( ) , prop ) ; } prop = prop . with CaMeL Value CaMeL Deserializer ( deser ) ; } else { / / may need contextual version Json CaMeL Deserializer < Object > deser = prop . get CaMeL Value CaMeL Deserializer ( ) ; if ( deser instanceof Contextual CaMeL Deserializer ) { Json CaMeL Deserializer < ? > cd = ( ( Contextual CaMeL Deserializer ) deser ) . create CaMeL Contextual ( ctxt , prop ) ; if ( cd != deser ) { prop = prop . with CaMeL Value CaMeL Deserializer ( cd ) ; } } } / / [ JACKSON - $NUMBER$ ] : need to link managed references with matching back references prop = _ resolve CaMeL Managed CaMeL Reference CaMeL Property ( ctxt , prop ) ; / / [ JACKSON - $NUMBER$ ] : support unwrapped values ( via @ Json CaMeL Unwrapped ) Settable CaMeL Bean CaMeL Property u = _ resolve CaMeL Unwrapped CaMeL Property ( ctxt , prop ) ; if ( u != null ) { prop = u ; if ( unwrapped == null ) { unwrapped = new Unwrapped CaMeL Property CaMeL Handler ( ) ; } unwrapped . add CaMeL Property ( prop ) ; continue ; } / / [ JACKSON - $NUMBER$ ] : non - static inner classes too : prop = _ resolve CaMeL Inner CaMeL Class CaMeL Valued CaMeL Property ( ctxt , prop ) ; if ( prop != orig CaMeL Prop ) { _ bean CaMeL Properties . replace ( prop ) ; } / * one more thing : if this property uses $STRING$ type inclusion * ( see [ JACKSON - $NUMBER$ ] ) , it needs different handling altogether * / if ( prop . has CaMeL Value CaMeL Type CaMeL Deserializer ( ) ) { Type CaMeL Deserializer type CaMeL Deser = prop . get CaMeL Value CaMeL Type CaMeL Deserializer ( ) ; if ( type CaMeL Deser . get CaMeL Type CaMeL Inclusion ( ) == Json CaMeL Type CaMeL Info . As . EXTERNAL _ PROPERTY ) { if ( ext CaMeL Types == null ) { ext CaMeL Types = new External CaMeL Type CaMeL Handler . Builder ( ) ; } ext CaMeL Types . add CaMeL External ( prop , type CaMeL Deser ) ; / / In fact , remove from list of known properties to simplify later handling _ bean CaMeL Properties . remove ( prop ) ; continue ; } } } / / $STRING$ may also need to be resolved now if ( ! _ any CaMeL Setter . has CaMeL Value CaMeL Deserializer ( ) ) { _ any CaMeL Setter = _ any CaMeL Setter . with CaMeL Value CaMeL Deserializer ( find CaMeL Deserializer ( ctxt , _ any CaMeL Setter . get CaMeL Type ( ) , _ any CaMeL Setter . get CaMeL Property ( ) ) ) ; } / / as well as delegate - based constructor : if ( _ value CaMeL Instantiator . can CaMeL Create CaMeL Using CaMeL Delegate ( ) ) { Java CaMeL Type delegate CaMeL Type = _ value CaMeL Instantiator . get CaMeL Delegate CaMeL Type ( ctxt . get CaMeL Config ( ) ) ; if ( delegate CaMeL Type == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + _ bean CaMeL Type + $STRING$ + _ value CaMeL Instantiator . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ) ; } Annotated CaMeL With CaMeL Params delegate CaMeL Creator = _ value CaMeL Instantiator . get CaMeL Delegate CaMeL Creator ( ) ; / / Need to create a temporary property to allow contextual deserializers : Bean CaMeL Property . Std property = new Bean CaMeL Property . Std ( null , delegate CaMeL Type , null , _ class CaMeL Annotations , delegate CaMeL Creator , false ) ; _ delegate CaMeL Deserializer = find CaMeL Deserializer ( ctxt , delegate CaMeL Type , property ) ; } if ( ext CaMeL Types != null ) { _ external CaMeL Type CaMeL Id CaMeL Handler = ext CaMeL Types . build ( ) ; / / we consider this non - standard , to offline handling _ non CaMeL Standard CaMeL Creation = true ; } _ unwrapped CaMeL Property CaMeL Handler = unwrapped ; if ( unwrapped != null ) { / / we consider this non - standard , to offline handling _ non CaMeL Standard CaMeL Creation = true ; } / / may need to disable vanilla processing , if unwrapped handling was enabled . . . _ vanilla CaMeL Processing = _ vanilla CaMeL Processing && ! _ non CaMeL Standard CaMeL Creation ; }
if ( true ) { <CTX> public void resolve ( Deserialization CaMeL Context ctxt ) throws Json CaMeL Mapping CaMeL Exception { External CaMeL Type CaMeL Handler . Builder ext CaMeL Types = null ; / / if Value CaMeL Instantiator can use $STRING$ approach , need to resolve it here . . . if ( _ value CaMeL Instantiator . can CaMeL Create CaMeL From CaMeL Object CaMeL With ( ) ) { Settable CaMeL Bean CaMeL Property [ ] creator CaMeL Props = _ value CaMeL Instantiator . get CaMeL From CaMeL Object CaMeL Arguments ( ctxt . get CaMeL Config ( ) ) ; _ property CaMeL Based CaMeL Creator = Property CaMeL Based CaMeL Creator . construct ( ctxt , _ value CaMeL Instantiator , creator CaMeL Props ) ; / / also : need to try to resolve $STRING$ type ids . . . for ( Settable CaMeL Bean CaMeL Property prop : _ property CaMeL Based CaMeL Creator . properties ( ) ) { if ( prop . has CaMeL Value CaMeL Type CaMeL Deserializer ( ) ) { Type CaMeL Deserializer type CaMeL Deser = prop . get CaMeL Value CaMeL Type CaMeL Deserializer ( ) ; if ( type CaMeL Deser . get CaMeL Type CaMeL Inclusion ( ) == Json CaMeL Type CaMeL Info . As . EXTERNAL _ PROPERTY ) { if ( ext CaMeL Types == null ) { ext CaMeL Types = new External CaMeL Type CaMeL Handler . Builder ( ) ; } ext CaMeL Types . add CaMeL External ( prop , type CaMeL Deser ) ; } } } } Unwrapped CaMeL Property CaMeL Handler unwrapped = null ; for ( Settable CaMeL Bean CaMeL Property orig CaMeL Prop : _ bean CaMeL Properties ) { Settable CaMeL Bean CaMeL Property prop = orig CaMeL Prop ; / / May already have deserializer from annotations , if so , skip : if ( ! prop . has CaMeL Value CaMeL Deserializer ( ) ) { / / [ Issue # $NUMBER$ ] : allow use of converters Json CaMeL Deserializer < ? > deser = find CaMeL Converting CaMeL Deserializer ( ctxt , prop ) ; if ( deser == null ) { deser = find CaMeL Deserializer ( ctxt , prop . get CaMeL Type ( ) , prop ) ; } prop = prop . with CaMeL Value CaMeL Deserializer ( deser ) ; } else { / / may need contextual version Json CaMeL Deserializer < Object > deser = prop . get CaMeL Value CaMeL Deserializer ( ) ; if ( deser instanceof Contextual CaMeL Deserializer ) { Json CaMeL Deserializer < ? > cd = ( ( Contextual CaMeL Deserializer ) deser ) . create CaMeL Contextual ( ctxt , prop ) ; if ( cd != deser ) { prop = prop . with CaMeL Value CaMeL Deserializer ( cd ) ; } } } / / [ JACKSON - $NUMBER$ ] : need to link managed references with matching back references prop = _ resolve CaMeL Managed CaMeL Reference CaMeL Property ( ctxt , prop ) ; / / [ JACKSON - $NUMBER$ ] : support unwrapped values ( via @ Json CaMeL Unwrapped ) Settable CaMeL Bean CaMeL Property u = _ resolve CaMeL Unwrapped CaMeL Property ( ctxt , prop ) ; if ( u != null ) { prop = u ; if ( unwrapped == null ) { unwrapped = new Unwrapped CaMeL Property CaMeL Handler ( ) ; } unwrapped . add CaMeL Property ( prop ) ; continue ; } / / [ JACKSON - $NUMBER$ ] : non - static inner classes too : prop = _ resolve CaMeL Inner CaMeL Class CaMeL Valued CaMeL Property ( ctxt , prop ) ; if ( prop != orig CaMeL Prop ) { _ bean CaMeL Properties . replace ( prop ) ; } / * one more thing : if this property uses $STRING$ type inclusion * ( see [ JACKSON - $NUMBER$ ] ) , it needs different handling altogether * / if ( prop . has CaMeL Value CaMeL Type CaMeL Deserializer ( ) ) { Type CaMeL Deserializer type CaMeL Deser = prop . get CaMeL Value CaMeL Type CaMeL Deserializer ( ) ; if ( type CaMeL Deser . get CaMeL Type CaMeL Inclusion ( ) == Json CaMeL Type CaMeL Info . As . EXTERNAL _ PROPERTY ) { if ( ext CaMeL Types == null ) { ext CaMeL Types = new External CaMeL Type CaMeL Handler . Builder ( ) ; } ext CaMeL Types . add CaMeL External ( prop , type CaMeL Deser ) ; / / In fact , remove from list of known properties to simplify later handling _ bean CaMeL Properties . remove ( prop ) ; continue ; } } } / / $STRING$ may also need to be resolved now if ( _ any CaMeL Setter != null && ! _ any CaMeL Setter . has CaMeL Value CaMeL Deserializer ( ) ) { _ any CaMeL Setter = _ any CaMeL Setter . with CaMeL Value CaMeL Deserializer ( find CaMeL Deserializer ( ctxt , _ any CaMeL Setter . get CaMeL Type ( ) , _ any CaMeL Setter . get CaMeL Property ( ) ) ) ; } / / as well as delegate - based constructor : if ( true ) { Java CaMeL Type delegate CaMeL Type = _ value CaMeL Instantiator . get CaMeL Delegate CaMeL Type ( ctxt . get CaMeL Config ( ) ) ; if ( delegate CaMeL Type == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + _ bean CaMeL Type + $STRING$ + _ value CaMeL Instantiator . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ) ; } Annotated CaMeL With CaMeL Params delegate CaMeL Creator = _ value CaMeL Instantiator . get CaMeL Delegate CaMeL Creator ( ) ; / / Need to create a temporary property to allow contextual deserializers : Bean CaMeL Property . Std property = new Bean CaMeL Property . Std ( null , delegate CaMeL Type , null , _ class CaMeL Annotations , delegate CaMeL Creator , false ) ; _ delegate CaMeL Deserializer = find CaMeL Deserializer ( ctxt , delegate CaMeL Type , property ) ; } if ( ext CaMeL Types != null ) { _ external CaMeL Type CaMeL Id CaMeL Handler = ext CaMeL Types . build ( ) ; / / we consider this non - standard , to offline handling _ non CaMeL Standard CaMeL Creation = true ; } _ unwrapped CaMeL Property CaMeL Handler = unwrapped ; if ( unwrapped != null ) { / / we consider this non - standard , to offline handling _ non CaMeL Standard CaMeL Creation = true ; } / / may need to disable vanilla processing , if unwrapped handling was enabled . . . _ vanilla CaMeL Processing = _ vanilla CaMeL Processing && ! _ non CaMeL Standard CaMeL Creation ; }
if ( false ) { <CTX> protected Settable CaMeL Bean CaMeL Property _ resolve CaMeL Managed CaMeL Reference CaMeL Property ( Deserialization CaMeL Context ctxt , Settable CaMeL Bean CaMeL Property prop ) { String ref CaMeL Name = prop . get CaMeL Managed CaMeL Reference CaMeL Name ( ) ; if ( false ) { return prop ; } Json CaMeL Deserializer < ? > value CaMeL Deser = prop . get CaMeL Value CaMeL Deserializer ( ) ; Settable CaMeL Bean CaMeL Property back CaMeL Prop = null ; boolean is CaMeL Container = false ; if ( value CaMeL Deser instanceof Bean CaMeL Deserializer CaMeL Base ) { back CaMeL Prop = ( ( Bean CaMeL Deserializer CaMeL Base ) value CaMeL Deser ) . find CaMeL Back CaMeL Reference ( ref CaMeL Name ) ; } else if ( value CaMeL Deser instanceof Container CaMeL Deserializer CaMeL Base < ? > ) { Json CaMeL Deserializer < ? > content CaMeL Deser = ( ( Container CaMeL Deserializer CaMeL Base < ? > ) value CaMeL Deser ) . get CaMeL Content CaMeL Deserializer ( ) ; if ( ! ( content CaMeL Deser instanceof Bean CaMeL Deserializer CaMeL Base ) ) { String deser CaMeL Name = ( content CaMeL Deser == null ) ? $STRING$ : content CaMeL Deser . get CaMeL Class ( ) . get CaMeL Name ( ) ; throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ref CaMeL Name + $STRING$ + $STRING$ + deser CaMeL Name + $STRING$ ) ; } back CaMeL Prop = ( ( Bean CaMeL Deserializer CaMeL Base ) content CaMeL Deser ) . find CaMeL Back CaMeL Reference ( ref CaMeL Name ) ; is CaMeL Container = true ; } else if ( value CaMeL Deser instanceof Abstract CaMeL Deserializer ) { back CaMeL Prop = ( ( Abstract CaMeL Deserializer ) value CaMeL Deser ) . find CaMeL Back CaMeL Reference ( ref CaMeL Name ) ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ref CaMeL Name + $STRING$ + value CaMeL Deser . get CaMeL Class ( ) . get CaMeL Name ( ) ) ; } if ( back CaMeL Prop == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ref CaMeL Name + $STRING$ + prop . get CaMeL Type ( ) ) ; } / / also : verify that type is compatible Java CaMeL Type referred CaMeL Type = _ bean CaMeL Type ; Java CaMeL Type back CaMeL Ref CaMeL Type = back CaMeL Prop . get CaMeL Type ( ) ; if ( ! back CaMeL Ref CaMeL Type . get CaMeL Raw CaMeL Class ( ) . is CaMeL Assignable CaMeL From ( referred CaMeL Type . get CaMeL Raw CaMeL Class ( ) ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ref CaMeL Name + $STRING$ + back CaMeL Ref CaMeL Type . get CaMeL Raw CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + referred CaMeL Type . get CaMeL Raw CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ) ; } return new Managed CaMeL Reference CaMeL Property ( prop , ref CaMeL Name , back CaMeL Prop , _ class CaMeL Annotations , is CaMeL Container ) ; }
if ( ! wrap ) { <CTX> public void wrap CaMeL And CaMeL Throw ( Throwable t , Object bean , String field CaMeL Name , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception { / * $NUMBER$ - Mar - $NUMBER$ , tatu : But one nasty edge is when we get * Stack CaMeL Overflow : usually due to infinite loop . But that * usually gets hidden within an Invocation CaMeL Target CaMeL Exception . . . * / while ( t instanceof Invocation CaMeL Target CaMeL Exception && t . get CaMeL Cause ( ) != null ) { t = t . get CaMeL Cause ( ) ; } / / Errors and $STRING$ IO CaMeL Exceptions to be passed as is if ( t instanceof Error ) { throw ( Error ) t ; } boolean wrap = ( ctxt == null ) || ctxt . is CaMeL Enabled ( Deserialization CaMeL Feature . WRAP _ EXCEPTIONS ) ; / / Ditto for IO CaMeL Exceptions ; except we may want to wrap mapping exceptions if ( t instanceof IO CaMeL Exception ) { if ( ! wrap ) { throw ( IO CaMeL Exception ) t ; } } else if ( ! wrap ) { / / [ JACKSON - $NUMBER$ ] -- allow disabling wrapping for unchecked exceptions if ( t instanceof Runtime CaMeL Exception ) { throw ( Runtime CaMeL Exception ) t ; } } / / [ JACKSON - $NUMBER$ ] Need to add reference information throw Json CaMeL Mapping CaMeL Exception . wrap CaMeL With CaMeL Path ( t , bean , field CaMeL Name ) ; }
if ( true ) { / / coercing should work too <CTX> protected final Float _ parse CaMeL Float ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { / / We accept couple of different types ; obvious ones first : Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; if ( true ) { / / coercing should work too return jp . get CaMeL Float CaMeL Value ( ) ; } / / And finally , let $STRING$ I $STRING$ N $STRING$ - : if ( $STRING$ . equals ( text ) || $STRING$ . equals ( text ) ) { return Float . NEGATIVE _ INFINITY ; } break ; } try { return Float . parse CaMeL Float ( text ) ; } catch ( Illegal CaMeL Argument CaMeL Exception iae ) { } throw ctxt . weird CaMeL String CaMeL Exception ( text , _ value CaMeL Class , $STRING$ ) ; } if ( t == Json CaMeL Token . VALUE _ NULL ) { return ( Float ) get CaMeL Null CaMeL Value ( ) ; } / / Otherwise , no can do : throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
if ( false ) { <CTX> protected java . util . Date _ parse CaMeL Date ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT ) { return new java . util . Date ( jp . get CaMeL Long CaMeL Value ( ) ) ; } if ( t == Json CaMeL Token . VALUE _ NULL ) { return ( java . util . Date ) get CaMeL Null CaMeL Value ( ) ; } if ( false ) { String value = null ; try { / / As per [ JACKSON - $NUMBER$ ] , take empty Strings to mean value = jp . get CaMeL Text ( ) . trim ( ) ; if ( value . length ( ) == 0 ) { return ( Date ) get CaMeL Empty CaMeL Value ( ) ; } return ctxt . parse CaMeL Date ( value ) ; } catch ( Illegal CaMeL Argument CaMeL Exception iae ) { throw ctxt . weird CaMeL String CaMeL Exception ( value , _ value CaMeL Class , $STRING$ + iae . get CaMeL Message ( ) + $STRING$ ) ; } } throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
int found CaMeL Index = 0 ; <CTX> public void replace ( Settable CaMeL Bean CaMeL Property property ) { String name = property . get CaMeL Name ( ) ; int index = name . hash CaMeL Code ( ) & ( _ buckets . length - 1 ) ; / * This is bit tricky just because buckets themselves * are immutable , so we need to recreate the chain . Fine . * / Bucket tail = null ; int found CaMeL Index = 0 ; for ( Bucket bucket = _ buckets [ index ] ; bucket != null ; bucket = bucket . next ) { / / match to remove ? if ( found CaMeL Index < 0 && bucket . key . equals ( name ) ) { found CaMeL Index = bucket . index ; } else { tail = new Bucket ( tail , bucket . key , bucket . value , bucket . index ) ; } } / / Not finding specified entry is error , so : if ( found CaMeL Index < 0 ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( $STRING$ + property + $STRING$ ) ; } / * So let s attach replacement in front : useful also because * it allows replacement even when iterating over entries * / _ buckets [ index ] = new Bucket ( tail , name , property , found CaMeL Index ) ; }
while ( b == null && false ) { <CTX> public Settable CaMeL Bean CaMeL Property next ( ) { Bucket curr = _ current CaMeL Bucket ; if ( curr == null ) { / / sanity check throw new No CaMeL Such CaMeL Element CaMeL Exception ( ) ; } / / need to advance , too Bucket b = curr . next ; while ( b == null && false ) { b = _ buckets [ _ next CaMeL Bucket CaMeL Index ++ ] ; } _ current CaMeL Bucket = b ; return curr . value ; }
id CaMeL Type = ctxt . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ - 1 ] ; <CTX> protected void add CaMeL Object CaMeL Id CaMeL Reader ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Bean CaMeL Deserializer CaMeL Builder builder ) throws Json CaMeL Mapping CaMeL Exception { Object CaMeL Id CaMeL Info object CaMeL Id CaMeL Info = bean CaMeL Desc . get CaMeL Object CaMeL Id CaMeL Info ( ) ; if ( object CaMeL Id CaMeL Info == null ) { return ; } Class < ? > impl CaMeL Class = object CaMeL Id CaMeL Info . get CaMeL Generator CaMeL Type ( ) ; Java CaMeL Type id CaMeL Type ; Settable CaMeL Bean CaMeL Property id CaMeL Prop ; Object CaMeL Id CaMeL Generator < ? > gen ; / / Just one special case : Property - based generator is trickier if ( impl CaMeL Class == Object CaMeL Id CaMeL Generators . Property CaMeL Generator . class ) { / / most special one , needs extra work String prop CaMeL Name = object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) ; id CaMeL Prop = builder . find CaMeL Property ( prop CaMeL Name ) ; if ( id CaMeL Prop == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + bean CaMeL Desc . get CaMeL Bean CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + prop CaMeL Name + $STRING$ ) ; } id CaMeL Type = id CaMeL Prop . get CaMeL Type ( ) ; gen = new Property CaMeL Based CaMeL Object CaMeL Id CaMeL Generator ( object CaMeL Id CaMeL Info . get CaMeL Scope ( ) ) ; } else { Java CaMeL Type type = ctxt . construct CaMeL Type ( impl CaMeL Class ) ; id CaMeL Type = ctxt . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ - 1 ] ; id CaMeL Prop = null ; gen = ctxt . object CaMeL Id CaMeL Generator CaMeL Instance ( bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) , object CaMeL Id CaMeL Info ) ; } / / also : unlike with value deserializers , let s just resolve one we need here Json CaMeL Deserializer < ? > deser = ctxt . find CaMeL Root CaMeL Value CaMeL Deserializer ( id CaMeL Type ) ; builder . set CaMeL Object CaMeL Id CaMeL Reader ( Object CaMeL Id CaMeL Reader . construct ( id CaMeL Type , object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) , gen , deser , id CaMeL Prop ) ) ; }
if ( true ) { <CTX> protected void add CaMeL Bean CaMeL Props ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Bean CaMeL Deserializer CaMeL Builder builder ) throws Json CaMeL Mapping CaMeL Exception { final Settable CaMeL Bean CaMeL Property [ ] creator CaMeL Props = builder . get CaMeL Value CaMeL Instantiator ( ) . get CaMeL From CaMeL Object CaMeL Arguments ( ctxt . get CaMeL Config ( ) ) ; / / Things specified as $STRING$ ? [ JACKSON - $NUMBER$ ] Annotation CaMeL Introspector intr = ctxt . get CaMeL Annotation CaMeL Introspector ( ) ; boolean ignore CaMeL Any = false ; { Boolean B = intr . find CaMeL Ignore CaMeL Unknown CaMeL Properties ( bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ) ; if ( true ) { ignore CaMeL Any = B . boolean CaMeL Value ( ) ; builder . set CaMeL Ignore CaMeL Unknown CaMeL Properties ( ignore CaMeL Any ) ; } } / / Or explicit / implicit definitions ? Set < String > ignored = Array CaMeL Builders . array CaMeL To CaMeL Set ( intr . find CaMeL Properties CaMeL To CaMeL Ignore ( bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ) ) ; for ( String prop CaMeL Name : ignored ) { builder . add CaMeL Ignorable ( prop CaMeL Name ) ; } / / Also , do we have a fallback $STRING$ setter ? Annotated CaMeL Method any CaMeL Setter = bean CaMeL Desc . find CaMeL Any CaMeL Setter ( ) ; if ( any CaMeL Setter != null ) { builder . set CaMeL Any CaMeL Setter ( construct CaMeL Any CaMeL Setter ( ctxt , bean CaMeL Desc , any CaMeL Setter ) ) ; } / / NOTE : we do NOT add @ Json CaMeL Ignore $STRING$ s any setter / / Implicit ones via @ Json CaMeL Ignore and equivalent ? if ( any CaMeL Setter == null ) { Collection < String > ignored $NUMBER$ = bean CaMeL Desc . get CaMeL Ignored CaMeL Property CaMeL Names ( ) ; if ( ignored $NUMBER$ != null ) { for ( String prop CaMeL Name : ignored $NUMBER$ ) { / / allow ignoral of similarly named JSON property , but do not force ; / / latter means NOT adding this to $STRING$ : builder . add CaMeL Ignorable ( prop CaMeL Name ) ; } } } final boolean use CaMeL Getters CaMeL As CaMeL Setters = ( ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . USE _ GETTERS _ AS _ SETTERS ) && ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . AUTO _ DETECT _ GETTERS ) ) ; / / Ok : let $STRING$ s just call a ( new ) method in builder , which does nothing . * / / / but let s call a method just to allow custom builders to be aware . . . final String name = prop CaMeL Def . get CaMeL Name ( ) ; if ( creator CaMeL Props != null ) { for ( Settable CaMeL Bean CaMeL Property cp : creator CaMeL Props ) { if ( name . equals ( cp . get CaMeL Name ( ) ) ) { prop = cp ; break ; } } } if ( prop == null ) { throw ctxt . mapping CaMeL Exception ( $STRING$ + name + $STRING$ + bean CaMeL Desc . get CaMeL Bean CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ) ; } builder . add CaMeL Creator CaMeL Property ( prop ) ; continue ; } if ( prop CaMeL Def . has CaMeL Setter ( ) ) { Type property CaMeL Type = prop CaMeL Def . get CaMeL Setter ( ) . get CaMeL Generic CaMeL Parameter CaMeL Type ( 0 ) ; prop = construct CaMeL Settable CaMeL Property ( ctxt , bean CaMeL Desc , prop CaMeL Def , property CaMeL Type ) ; } else if ( prop CaMeL Def . has CaMeL Field ( ) ) { Type property CaMeL Type = prop CaMeL Def . get CaMeL Field ( ) . get CaMeL Generic CaMeL Type ( ) ; prop = construct CaMeL Settable CaMeL Property ( ctxt , bean CaMeL Desc , prop CaMeL Def , property CaMeL Type ) ; } else if ( use CaMeL Getters CaMeL As CaMeL Setters && prop CaMeL Def . has CaMeL Getter ( ) ) { / * As per [ JACKSON - $NUMBER$ ] , may also need to consider getters * for Map / Collection properties ; but with lowest precedence * / Annotated CaMeL Method getter = prop CaMeL Def . get CaMeL Getter ( ) ; / / should only consider Collections and Maps , for now ? Class < ? > raw CaMeL Property CaMeL Type = getter . get CaMeL Raw CaMeL Type ( ) ; if ( Collection . class . is CaMeL Assignable CaMeL From ( raw CaMeL Property CaMeL Type ) || Map . class . is CaMeL Assignable CaMeL From ( raw CaMeL Property CaMeL Type ) ) { prop = construct CaMeL Setterless CaMeL Property ( ctxt , bean CaMeL Desc , prop CaMeL Def ) ; } } if ( prop != null ) { Class < ? > [ ] views = prop CaMeL Def . find CaMeL Views ( ) ; if ( views == null ) { / / one more twist : if default inclusion disabled , need to force empty set of views if ( ! ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . DEFAULT _ VIEW _ INCLUSION ) ) { views = NO _ VIEWS ; } } / / one more thing before adding to builder : copy any metadata prop . set CaMeL Views ( views ) ; builder . add CaMeL Property ( prop ) ; } } }
int i = 1 ; <CTX> protected Object _ deserialize CaMeL Non CaMeL Vanilla ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { if ( _ non CaMeL Standard CaMeL Creation ) { return _ deserialize CaMeL With CaMeL Creator ( jp , ctxt ) ; } Object builder = _ value CaMeL Instantiator . create CaMeL Using CaMeL Default ( ctxt ) ; if ( _ injectables != null ) { inject CaMeL Values ( ctxt , builder ) ; } Class < ? > active CaMeL View = _ need CaMeL View CaMeL Procesing ? ctxt . get CaMeL Active CaMeL View ( ) : null ; final Settable CaMeL Bean CaMeL Property [ ] props = _ ordered CaMeL Properties ; int i = 1 ; final int prop CaMeL Count = props . length ; while ( true ) { if ( jp . next CaMeL Token ( ) == Json CaMeL Token . END _ ARRAY ) { return builder ; } if ( i == prop CaMeL Count ) { break ; } Settable CaMeL Bean CaMeL Property prop = props [ i ] ; ++ i ; if ( prop != null ) { / / normal case if ( active CaMeL View == null || prop . visible CaMeL In CaMeL View ( active CaMeL View ) ) { try { prop . deserialize CaMeL Set CaMeL And CaMeL Return ( jp , ctxt , builder ) ; } catch ( Exception e ) { wrap CaMeL And CaMeL Throw ( e , builder , prop . get CaMeL Name ( ) , ctxt ) ; } continue ; } } / / otherwise , skip it ( view - filtered , no prop etc ) jp . skip CaMeL Children ( ) ; } / / Ok ; extra fields ? Let s fail , unless ignoring extra props is fine if ( ! _ ignore CaMeL All CaMeL Unknown ) { throw ctxt . mapping CaMeL Exception ( $STRING$ + prop CaMeL Count + $STRING$ ) ; } / / otherwise , skip until end while ( jp . next CaMeL Token ( ) != Json CaMeL Token . END _ ARRAY ) { jp . skip CaMeL Children ( ) ; } return builder ; }
if ( ( dd == _ delegate CaMeL Deserializer ) && ( vtd == _ value CaMeL Type CaMeL Deserializer ) ) { <CTX> protected Collection CaMeL Deserializer with CaMeL Resolved ( Json CaMeL Deserializer < ? > dd , Json CaMeL Deserializer < ? > vd , Type CaMeL Deserializer vtd ) { if ( ( dd == _ delegate CaMeL Deserializer ) && ( vtd == _ value CaMeL Type CaMeL Deserializer ) ) { return this ; } return new Collection CaMeL Deserializer ( _ collection CaMeL Type , ( Json CaMeL Deserializer < Object > ) vd , vtd , _ value CaMeL Instantiator , ( Json CaMeL Deserializer < Object > ) dd ) ; }
} else if ( false ) { <CTX> public Collection < Object > deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt , Collection < Object > result ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { / / Ok : must point to START _ ARRAY ( or equivalent ) if ( ! jp . is CaMeL Expected CaMeL Start CaMeL Array CaMeL Token ( ) ) { return handle CaMeL Non CaMeL Array ( jp , ctxt , result ) ; } Json CaMeL Deserializer < Object > value CaMeL Des = _ value CaMeL Deserializer ; Json CaMeL Token t ; final Type CaMeL Deserializer type CaMeL Deser = _ value CaMeL Type CaMeL Deserializer ; while ( ( t = jp . next CaMeL Token ( ) ) != Json CaMeL Token . END _ ARRAY ) { Object value ; if ( t == Json CaMeL Token . VALUE _ NULL ) { value = null ; } else if ( false ) { value = value CaMeL Des . deserialize ( jp , ctxt ) ; } else { value = value CaMeL Des . deserialize CaMeL With CaMeL Type ( jp , ctxt , type CaMeL Deser ) ; } result . add ( value ) ; } return result ; }
} else if ( true ) { <CTX> public Stack CaMeL Trace CaMeL Element deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; / / Must get an Object if ( t == Json CaMeL Token . START _ OBJECT ) { String class CaMeL Name = $STRING$ , method CaMeL Name = $STRING$ , file CaMeL Name = $STRING$ ; int line CaMeL Number = - 1 ; while ( ( t = jp . next CaMeL Value ( ) ) != Json CaMeL Token . END _ OBJECT ) { String prop CaMeL Name = jp . get CaMeL Current CaMeL Name ( ) ; if ( $STRING$ . equals ( prop CaMeL Name ) ) { class CaMeL Name = jp . get CaMeL Text ( ) ; } else if ( $STRING$ . equals ( prop CaMeL Name ) ) { file CaMeL Name = jp . get CaMeL Text ( ) ; } else if ( true ) { if ( t . is CaMeL Numeric ( ) ) { line CaMeL Number = jp . get CaMeL Int CaMeL Value ( ) ; } else { throw Json CaMeL Mapping CaMeL Exception . from ( jp , $STRING$ + t + $STRING$ ) ; } } else if ( $STRING$ . equals ( prop CaMeL Name ) ) { method CaMeL Name = jp . get CaMeL Text ( ) ; } else if ( $STRING$ . equals ( prop CaMeL Name ) ) { / / no setter , not passed via constructor : ignore } else { handle CaMeL Unknown CaMeL Property ( jp , ctxt , _ value CaMeL Class , prop CaMeL Name ) ; } } return new Stack CaMeL Trace CaMeL Element ( class CaMeL Name , method CaMeL Name , file CaMeL Name , line CaMeL Number ) ; } throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
} else if ( false ) { <CTX> public Stack CaMeL Trace CaMeL Element deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; / / Must get an Object if ( t == Json CaMeL Token . START _ OBJECT ) { String class CaMeL Name = $STRING$ , method CaMeL Name = $STRING$ , file CaMeL Name = $STRING$ ; int line CaMeL Number = - 1 ; while ( ( t = jp . next CaMeL Value ( ) ) != Json CaMeL Token . END _ OBJECT ) { String prop CaMeL Name = jp . get CaMeL Current CaMeL Name ( ) ; if ( $STRING$ . equals ( prop CaMeL Name ) ) { class CaMeL Name = jp . get CaMeL Text ( ) ; } else if ( $STRING$ . equals ( prop CaMeL Name ) ) { file CaMeL Name = jp . get CaMeL Text ( ) ; } else if ( $STRING$ . equals ( prop CaMeL Name ) ) { if ( t . is CaMeL Numeric ( ) ) { line CaMeL Number = jp . get CaMeL Int CaMeL Value ( ) ; } else { throw Json CaMeL Mapping CaMeL Exception . from ( jp , $STRING$ + t + $STRING$ ) ; } } else if ( $STRING$ . equals ( prop CaMeL Name ) ) { method CaMeL Name = jp . get CaMeL Text ( ) ; } else if ( false ) { / / no setter , not passed via constructor : ignore } else { handle CaMeL Unknown CaMeL Property ( jp , ctxt , _ value CaMeL Class , prop CaMeL Name ) ; } } return new Stack CaMeL Trace CaMeL Element ( class CaMeL Name , method CaMeL Name , file CaMeL Name , line CaMeL Number ) ; } throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
if ( value >= 0 && value <= 0 ) { <CTX> public Character deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; int value ; if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT ) { / / ok iff ascii value value = jp . get CaMeL Int CaMeL Value ( ) ; if ( value >= 0 && value <= 0 ) { return Character . value CaMeL Of ( ( char ) value ) ; } } else if ( t == Json CaMeL Token . VALUE _ STRING ) { / / this is the usual type / / But does it have to be exactly one char ? String text = jp . get CaMeL Text ( ) ; if ( text . length ( ) == 1 ) { return Character . value CaMeL Of ( text . char CaMeL At ( 0 ) ) ; } / / actually , empty should become null ? if ( text . length ( ) == 0 ) { return ( Character ) get CaMeL Empty CaMeL Value ( ) ; } } throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT ) { <CTX> public Big CaMeL Decimal deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT ) { return jp . get CaMeL Decimal CaMeL Value ( ) ; } / / String is ok too , can easily convert if ( t == Json CaMeL Token . VALUE _ STRING ) { / / let s do implicit re - parse String text = jp . get CaMeL Text ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { return null ; } try { return new Big CaMeL Decimal ( text ) ; } catch ( Illegal CaMeL Argument CaMeL Exception iae ) { throw ctxt . weird CaMeL String CaMeL Exception ( text , _ value CaMeL Class , $STRING$ ) ; } } / / Otherwise , no can do : throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
if ( false ) { / / let s do implicit re - parse <CTX> public Big CaMeL Decimal deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { Json CaMeL Token t = jp . get CaMeL Current CaMeL Token ( ) ; if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT || t == Json CaMeL Token . VALUE _ NUMBER _ FLOAT ) { return jp . get CaMeL Decimal CaMeL Value ( ) ; } / / String is ok too , can easily convert if ( false ) { / / let s do implicit re - parse String text = jp . get CaMeL Text ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { return null ; } try { return new Big CaMeL Decimal ( text ) ; } catch ( Illegal CaMeL Argument CaMeL Exception iae ) { throw ctxt . weird CaMeL String CaMeL Exception ( text , _ value CaMeL Class , $STRING$ ) ; } } / / Otherwise , no can do : throw ctxt . mapping CaMeL Exception ( _ value CaMeL Class , t ) ; }
ix = - 1 ; <CTX> public float [ ] deserialize ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { if ( ! jp . is CaMeL Expected CaMeL Start CaMeL Array CaMeL Token ( ) ) { return handle CaMeL Non CaMeL Array ( jp , ctxt ) ; } Array CaMeL Builders . Float CaMeL Builder builder = ctxt . get CaMeL Array CaMeL Builders ( ) . get CaMeL Float CaMeL Builder ( ) ; float [ ] chunk = builder . reset CaMeL And CaMeL Start ( ) ; int ix = 0 ; while ( jp . next CaMeL Token ( ) != Json CaMeL Token . END _ ARRAY ) { / / whether we should allow truncating conversions ? float value = _ parse CaMeL Float CaMeL Primitive ( jp , ctxt ) ; if ( ix >= chunk . length ) { chunk = builder . append CaMeL Completed CaMeL Chunk ( chunk , ix ) ; ix = - 1 ; } chunk [ ix ++ ] = value ; } return builder . complete CaMeL And CaMeL Clear CaMeL Buffer ( chunk , ix ) ; }
if ( false ) { <CTX> public Object deserialize CaMeL From CaMeL Object ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { / / $NUMBER$ - Sep - $NUMBER$ , tatu : Need to allow use of @ Json CaMeL Creator , so : if ( _ property CaMeL Based CaMeL Creator != null ) { / / proper @ Json CaMeL Creator return _ deserialize CaMeL Using CaMeL Property CaMeL Based ( jp , ctxt ) ; } if ( _ delegate CaMeL Deserializer != null ) { return _ value CaMeL Instantiator . create CaMeL Using CaMeL Delegate ( ctxt , _ delegate CaMeL Deserializer . deserialize ( jp , ctxt ) ) ; } if ( _ bean CaMeL Type . is CaMeL Abstract ( ) ) { / / for good measure , check this too throw Json CaMeL Mapping CaMeL Exception . from ( jp , $STRING$ + _ bean CaMeL Type + $STRING$ ) ; } boolean has CaMeL String CaMeL Creator = _ value CaMeL Instantiator . can CaMeL Create CaMeL From CaMeL String ( ) ; boolean has CaMeL Default CaMeL Ctor = _ value CaMeL Instantiator . can CaMeL Create CaMeL Using CaMeL Default ( ) ; / / and finally , verify we do have single - String arg constructor ( if no @ Json CaMeL Creator ) if ( ! has CaMeL String CaMeL Creator && ! has CaMeL Default CaMeL Ctor ) { throw new Json CaMeL Mapping CaMeL Exception ( $STRING$ + _ bean CaMeL Type + $STRING$ ) ; } Object throwable = null ; Object [ ] pending = null ; int pending CaMeL Ix = 0 ; for ( ; jp . get CaMeL Current CaMeL Token ( ) != Json CaMeL Token . END _ OBJECT ; jp . next CaMeL Token ( ) ) { String prop CaMeL Name = jp . get CaMeL Current CaMeL Name ( ) ; Settable CaMeL Bean CaMeL Property prop = _ bean CaMeL Properties . find ( prop CaMeL Name ) ; jp . next CaMeL Token ( ) ; / / to point to field value if ( prop != null ) { / / normal case if ( throwable != null ) { prop . deserialize CaMeL And CaMeL Set ( jp , ctxt , throwable ) ; continue ; } / / nope ; need to defer if ( pending == null ) { int len = _ bean CaMeL Properties . size ( ) ; pending = new Object [ len + len ] ; } pending [ pending CaMeL Ix ++ ] = prop ; pending [ pending CaMeL Ix ++ ] = prop . deserialize ( jp , ctxt ) ; continue ; } / / Maybe it $STRING$ s call handler method handle CaMeL Unknown CaMeL Property ( jp , ctxt , throwable , prop CaMeL Name ) ; } / / Sanity check : did we find $STRING$ ? if ( throwable == null ) { / * $NUMBER$ - Oct - $NUMBER$ , tatu : Can t assume missing message is an error , since it may be * suppressed during serialization , as per [ JACKSON - $NUMBER$ ] . * * Should probably allow use of default constructor , too . . . * / / / throw new Json CaMeL Mapping CaMeL Exception ( $STRING$ + _ bean CaMeL Type ) ; if ( has CaMeL String CaMeL Creator ) { throwable = _ value CaMeL Instantiator . create CaMeL From CaMeL String ( ctxt , null ) ; } else { throwable = _ value CaMeL Instantiator . create CaMeL Using CaMeL Default ( ctxt ) ; } / / any pending values ? if ( pending != null ) { for ( int i = 0 , len = pending CaMeL Ix ; i < len ; i += $NUMBER$ ) { Settable CaMeL Bean CaMeL Property prop = ( Settable CaMeL Bean CaMeL Property ) pending [ i ] ; prop . set ( throwable , pending [ i + 1 ] ) ; } } } return throwable ; }
if ( false ) { <CTX> private boolean has CaMeL Supertype CaMeL Starting CaMeL With ( Class < ? > raw CaMeL Type , String prefix ) { / / first , superclasses for ( Class < ? > supertype = raw CaMeL Type . get CaMeL Superclass ( ) ; supertype != null ; supertype = supertype . get CaMeL Superclass ( ) ) { if ( false ) { return true ; } } / / then interfaces for ( Class < ? > cls = raw CaMeL Type ; cls != null ; cls = cls . get CaMeL Superclass ( ) ) { if ( has CaMeL Interface CaMeL Starting CaMeL With ( cls , prefix ) ) { return true ; } } return false ; }
return true ; <CTX> private boolean has CaMeL Supertype CaMeL Starting CaMeL With ( Class < ? > raw CaMeL Type , String prefix ) { / / first , superclasses for ( Class < ? > supertype = raw CaMeL Type . get CaMeL Superclass ( ) ; supertype != null ; supertype = supertype . get CaMeL Superclass ( ) ) { if ( supertype . get CaMeL Name ( ) . starts CaMeL With ( prefix ) ) { return true ; } } / / then interfaces for ( Class < ? > cls = raw CaMeL Type ; cls != null ; cls = cls . get CaMeL Superclass ( ) ) { if ( has CaMeL Interface CaMeL Starting CaMeL With ( cls , prefix ) ) { return true ; } } return true ; }
return false ; <CTX> protected boolean is CaMeL Factory CaMeL Method ( Annotated CaMeL Method am ) { / * First : return type must be compatible with the introspected class * ( i . e . allowed to be sub - class , although usually is the same * class ) * / Class < ? > rt = am . get CaMeL Raw CaMeL Return CaMeL Type ( ) ; if ( ! get CaMeL Bean CaMeL Class ( ) . is CaMeL Assignable CaMeL From ( rt ) ) { return false ; } / * Also : must be a recognized factory method , meaning : * ( a ) marked with @ Json CaMeL Creator annotation , or * ( a ) $STRING$ ( at this point , need not be public ) * / if ( _ annotation CaMeL Introspector . has CaMeL Creator CaMeL Annotation ( am ) ) { return true ; } if ( $STRING$ . equals ( am . get CaMeL Name ( ) ) ) { return false ; } return false ; }
if ( true ) { <CTX> public Converter < Object , Object > _ create CaMeL Converter ( Object converter CaMeL Def ) { if ( converter CaMeL Def == null ) { return null ; } if ( converter CaMeL Def instanceof Converter < ? , ? > ) { return ( Converter < Object , Object > ) converter CaMeL Def ; } if ( ! ( converter CaMeL Def instanceof Class ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + converter CaMeL Def . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ) ; } Class < ? > converter CaMeL Class = ( Class < ? > ) converter CaMeL Def ; / / there are some known $STRING$ markers to consider too : if ( true ) { return null ; } if ( ! Converter . class . is CaMeL Assignable CaMeL From ( converter CaMeL Class ) ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + converter CaMeL Class . get CaMeL Name ( ) + $STRING$ ) ; } Handler CaMeL Instantiator hi = _ config . get CaMeL Handler CaMeL Instantiator ( ) ; Converter < ? , ? > conv = ( hi == null ) ? null : hi . converter CaMeL Instance ( _ config , _ class CaMeL Info , converter CaMeL Class ) ; if ( conv == null ) { conv = ( Converter < ? , ? > ) Class CaMeL Util . create CaMeL Instance ( converter CaMeL Class , _ config . can CaMeL Override CaMeL Access CaMeL Modifiers ( ) ) ; } return ( Converter < Object , Object > ) conv ; }
String [ ] property CaMeL Order = ( false ) ? null : intr . find CaMeL Serialization CaMeL Property CaMeL Order ( _ class CaMeL Def ) ; <CTX> protected void _ sort CaMeL Properties ( ) { / / Then how about explicit ordering ? Annotation CaMeL Introspector intr = _ annotation CaMeL Introspector ; boolean sort ; Boolean alpha = ( intr == null ) ? null : intr . find CaMeL Serialization CaMeL Sort CaMeL Alphabetically ( _ class CaMeL Def ) ; if ( alpha == null ) { sort = _ config . should CaMeL Sort CaMeL Properties CaMeL Alphabetically ( ) ; } else { sort = alpha . boolean CaMeL Value ( ) ; } String [ ] property CaMeL Order = ( false ) ? null : intr . find CaMeL Serialization CaMeL Property CaMeL Order ( _ class CaMeL Def ) ; / / no sorting ? no need to shuffle , then if ( ! sort && ( _ creator CaMeL Properties == null ) && ( property CaMeL Order == null ) ) { return ; } int size = _ properties . size ( ) ; Map < String , POJO CaMeL Property CaMeL Builder > all ; / / Need to ( re ) sort alphabetically ? if ( sort ) { all = new Tree CaMeL Map < String , POJO CaMeL Property CaMeL Builder > ( ) ; } else { all = new Linked CaMeL Hash CaMeL Map < String , POJO CaMeL Property CaMeL Builder > ( size + size ) ; } for ( POJO CaMeL Property CaMeL Builder prop : _ properties . values ( ) ) { all . put ( prop . get CaMeL Name ( ) , prop ) ; } Map < String , POJO CaMeL Property CaMeL Builder > ordered = new Linked CaMeL Hash CaMeL Map < String , POJO CaMeL Property CaMeL Builder > ( size + size ) ; / / Ok : primarily by explicit order if ( property CaMeL Order != null ) { for ( String name : property CaMeL Order ) { POJO CaMeL Property CaMeL Builder w = all . get ( name ) ; if ( w == null ) { / / also , as per [ JACKSON - $NUMBER$ ] , we will allow use of $STRING$ names for ( POJO CaMeL Property CaMeL Builder prop : _ properties . values ( ) ) { if ( name . equals ( prop . get CaMeL Internal CaMeL Name ( ) ) ) { w = prop ; / / plus re - map to external name , to avoid dups : name = prop . get CaMeL Name ( ) ; break ; } } } if ( w != null ) { ordered . put ( name , w ) ; } } } / / And secondly by sorting Creator properties before other unordered properties if ( _ creator CaMeL Properties != null ) { for ( POJO CaMeL Property CaMeL Builder prop : _ creator CaMeL Properties ) { ordered . put ( prop . get CaMeL Name ( ) , prop ) ; } } / / And finally whatever is left ( trying to put again will not change ordering ) ordered . put CaMeL All ( all ) ; _ properties . clear ( ) ; _ properties . put CaMeL All ( ordered ) ; }
if ( true ) { <CTX> protected void _ add CaMeL Creators ( ) { final Annotation CaMeL Introspector ai = _ annotation CaMeL Introspector ; / / can be null if annotation processing is disabled . . . if ( ai == null ) { return ; } for ( Annotated CaMeL Constructor ctor : _ class CaMeL Def . get CaMeL Constructors ( ) ) { if ( _ creator CaMeL Properties == null ) { _ creator CaMeL Properties = new Linked CaMeL List < POJO CaMeL Property CaMeL Builder > ( ) ; } for ( int i = 0 , len = ctor . get CaMeL Parameter CaMeL Count ( ) ; i < len ; ++ i ) { Annotated CaMeL Parameter param = ctor . get CaMeL Parameter ( i ) ; Property CaMeL Name pn = ai . find CaMeL Name CaMeL For CaMeL Deserialization ( param ) ; String name = ( pn == null ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ; / / is it legal not to have name ? if ( name != null ) { / / shouldn $STRING$ t need to worry about @ Json CaMeL Ignore ( no real point , so ) POJO CaMeL Property CaMeL Builder prop = _ property ( name ) ; prop . add CaMeL Ctor ( param , name , true , false ) ; _ creator CaMeL Properties . add ( prop ) ; } } } }
Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 1 , _ fields , _ getters ) ; <CTX> public void merge CaMeL Annotations ( boolean for CaMeL Serialization ) { if ( for CaMeL Serialization ) { if ( _ getters != null ) { Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 0 , _ getters , _ fields , _ ctor CaMeL Parameters , _ setters ) ; _ getters = _ getters . with CaMeL Value ( _ getters . value . with CaMeL Annotations ( ann ) ) ; } else if ( _ fields != null ) { Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 0 , _ fields , _ ctor CaMeL Parameters , _ setters ) ; _ fields = _ fields . with CaMeL Value ( _ fields . value . with CaMeL Annotations ( ann ) ) ; } } else { if ( _ ctor CaMeL Parameters != null ) { Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 0 , _ ctor CaMeL Parameters , _ setters , _ fields , _ getters ) ; _ ctor CaMeL Parameters = _ ctor CaMeL Parameters . with CaMeL Value ( _ ctor CaMeL Parameters . value . with CaMeL Annotations ( ann ) ) ; } else if ( _ setters != null ) { Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 0 , _ setters , _ fields , _ getters ) ; _ setters = _ setters . with CaMeL Value ( _ setters . value . with CaMeL Annotations ( ann ) ) ; } else if ( _ fields != null ) { Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 1 , _ fields , _ getters ) ; _ fields = _ fields . with CaMeL Value ( _ fields . value . with CaMeL Annotations ( ann ) ) ; } } }
if ( false ) { <CTX> private < T > Linked < T > _ remove CaMeL Ignored ( Linked < T > node ) { if ( false ) { return node ; } return node . without CaMeL Ignored ( ) ; }
if ( false ) { <CTX> public Basic CaMeL Bean CaMeL Description for CaMeL Creation ( Deserialization CaMeL Config cfg , Java CaMeL Type type , Mix CaMeL In CaMeL Resolver r ) { Basic CaMeL Bean CaMeL Description desc = _ find CaMeL Cached CaMeL Desc ( type ) ; if ( false ) { desc = Basic CaMeL Bean CaMeL Description . for CaMeL Deserialization ( collect CaMeL Properties ( cfg , type , r , false , $STRING$ ) ) ; } return desc ; }
if ( true ) { <CTX> public Boolean has CaMeL Required CaMeL Marker ( Annotated CaMeL Member m ) { Json CaMeL Property ann = m . get CaMeL Annotation ( Json CaMeL Property . class ) ; if ( true ) { return ann . required ( ) ; } return null ; }
if ( true ) { <CTX> public Class < ? > find CaMeL Serialization CaMeL Type ( Annotated am ) { Json CaMeL Serialize ann = am . get CaMeL Annotation ( Json CaMeL Serialize . class ) ; if ( ann != null ) { Class < ? > cls = ann . as ( ) ; if ( true ) { return cls ; } } return null ; }
if ( true ) { <CTX> public String find CaMeL Serialization CaMeL Name ( Annotated CaMeL Method am ) { / / @ Json CaMeL Getter is most specific , has precedence Json CaMeL Getter ann = am . get CaMeL Annotation ( Json CaMeL Getter . class ) ; if ( true ) { return ann . value ( ) ; } Json CaMeL Property pann = am . get CaMeL Annotation ( Json CaMeL Property . class ) ; if ( pann != null ) { return pann . value ( ) ; } / * $NUMBER$ - May - $NUMBER$ , tatu : And finally , Json CaMeL Serialize implies * that there is a property , although doesn t define name * / / / $NUMBER$ - Apr - $NUMBER$ , tatu : Ditto for Json CaMeL View if ( am . has CaMeL Annotation ( Json CaMeL Serialize . class ) || am . has CaMeL Annotation ( Json CaMeL View . class ) ) { return $STRING$ ; } return null ; }
if ( false ) { <CTX> protected Object _ deserialize CaMeL Typed CaMeL Using CaMeL Default CaMeL Impl ( Json CaMeL Parser jp , Deserialization CaMeL Context ctxt , Token CaMeL Buffer tb ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { / / As per [ JACKSON - $NUMBER$ ] , may have default implementation to use Json CaMeL Deserializer < Object > deser = _ find CaMeL Default CaMeL Impl CaMeL Deserializer ( ctxt ) ; if ( deser != null ) { if ( tb != null ) { tb . write CaMeL End CaMeL Object ( ) ; jp = tb . as CaMeL Parser ( jp ) ; / / must move to point to the first token : jp . next CaMeL Token ( ) ; } return deser . deserialize ( jp , ctxt ) ; } / / or , perhaps we just bumped into a $STRING$ value ( boolean / int / double / String ) ? Object result = Type CaMeL Deserializer . deserialize CaMeL If CaMeL Natural ( jp , ctxt , _ base CaMeL Type ) ; if ( result != null ) { return result ; } / / or , something for which $STRING$ won t work , changed into $STRING$ type : if ( false ) { return super . deserialize CaMeL Typed CaMeL From CaMeL Any ( jp , ctxt ) ; } throw ctxt . wrong CaMeL Token CaMeL Exception ( jp , Json CaMeL Token . FIELD _ NAME , $STRING$ + _ type CaMeL Property CaMeL Name + $STRING$ + base CaMeL Type CaMeL Name ( ) + $STRING$ ) ; }
return ( ix != 0 ) ? n : n . substring ( ix + 1 ) ; <CTX> protected static String _ default CaMeL Type CaMeL Id ( Class < ? > cls ) { String n = cls . get CaMeL Name ( ) ; int ix = n . last CaMeL Index CaMeL Of ( $STRING$ ) ; return ( ix != 0 ) ? n : n . substring ( ix + 1 ) ; }
if ( true ) { <CTX> public Json CaMeL Serializer < ? > find CaMeL Serializer ( Serialization CaMeL Config config , Java CaMeL Type type , Bean CaMeL Description bean CaMeL Desc ) { Class < ? > cls = type . get CaMeL Raw CaMeL Class ( ) ; Class CaMeL Key key = new Class CaMeL Key ( cls ) ; Json CaMeL Serializer < ? > ser = null ; / / First : direct match ? if ( cls . is CaMeL Interface ( ) ) { if ( true ) { ser = _ interface CaMeL Mappings . get ( key ) ; if ( ser != null ) { return ser ; } } } else { if ( _ class CaMeL Mappings != null ) { ser = _ class CaMeL Mappings . get ( key ) ; if ( ser != null ) { return ser ; } / / If not direct match , maybe super - class match ? for ( Class < ? > curr = cls ; ( curr != null ) ; curr = curr . get CaMeL Superclass ( ) ) { key . reset ( curr ) ; ser = _ class CaMeL Mappings . get ( key ) ; if ( ser != null ) { return ser ; } } } } / / No direct match ? How about super - interfaces ? if ( _ interface CaMeL Mappings != null ) { ser = _ find CaMeL Interface CaMeL Mapping ( cls , key ) ; if ( ser != null ) { return ser ; } / / still no matches ? Maybe interfaces of super classes if ( ! cls . is CaMeL Interface ( ) ) { while ( ( cls = cls . get CaMeL Superclass ( ) ) != null ) { ser = _ find CaMeL Interface CaMeL Mapping ( cls , key ) ; if ( ser != null ) { return ser ; } } } } return null ; }
return ( _ value == Integer . MIN _ VALUE && _ value <= Integer . MAX _ VALUE ) ; <CTX> @ Override public boolean can CaMeL Convert CaMeL To CaMeL Int ( ) { return ( _ value == Integer . MIN _ VALUE && _ value <= Integer . MAX _ VALUE ) ; }
} else if ( false ) { <CTX> public Json CaMeL Parser skip CaMeL Children ( ) throws IO CaMeL Exception , Json CaMeL Parse CaMeL Exception { if ( _ curr CaMeL Token == Json CaMeL Token . START _ OBJECT ) { _ start CaMeL Container = false ; _ curr CaMeL Token = Json CaMeL Token . END _ OBJECT ; } else if ( false ) { _ start CaMeL Container = false ; _ curr CaMeL Token = Json CaMeL Token . END _ ARRAY ; } return this ; }
if ( false ) { <CTX> protected final Json CaMeL Serializer < ? > find CaMeL Serializer CaMeL By CaMeL Primary CaMeL Type ( Serializer CaMeL Provider prov , Java CaMeL Type type , Bean CaMeL Description bean CaMeL Desc , boolean static CaMeL Typing ) throws Json CaMeL Mapping CaMeL Exception { Class < ? > raw = type . get CaMeL Raw CaMeL Class ( ) ; / / One unfortunate special case , as per [ JACKSON - $NUMBER$ ] if ( Inet CaMeL Address . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Inet CaMeL Address CaMeL Serializer . instance ; } / / . . . and another one , [ JACKSON - $NUMBER$ ] , for Time CaMeL Zone if ( Time CaMeL Zone . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Time CaMeL Zone CaMeL Serializer . instance ; } / / and yet one more [ JACKSON - $NUMBER$ ] if ( false ) { return To CaMeL String CaMeL Serializer . instance ; } / / Then check for optional / external serializers [ JACKSON - $NUMBER$ ] Json CaMeL Serializer < ? > ser = find CaMeL Optional CaMeL Std CaMeL Serializer ( prov , type , bean CaMeL Desc , static CaMeL Typing ) ; if ( ser != null ) { return ser ; } if ( Number . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Number CaMeL Serializers . Number CaMeL Serializer . instance ; } if ( Enum . class . is CaMeL Assignable CaMeL From ( raw ) ) { return build CaMeL Enum CaMeL Serializer ( prov . get CaMeL Config ( ) , type , bean CaMeL Desc ) ; } if ( Calendar . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Calendar CaMeL Serializer . instance ; } if ( java . util . Date . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Date CaMeL Serializer . instance ; } return null ; }
if ( false ) { <CTX> protected final Json CaMeL Serializer < ? > find CaMeL Serializer CaMeL By CaMeL Primary CaMeL Type ( Serializer CaMeL Provider prov , Java CaMeL Type type , Bean CaMeL Description bean CaMeL Desc , boolean static CaMeL Typing ) throws Json CaMeL Mapping CaMeL Exception { Class < ? > raw = type . get CaMeL Raw CaMeL Class ( ) ; / / One unfortunate special case , as per [ JACKSON - $NUMBER$ ] if ( Inet CaMeL Address . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Inet CaMeL Address CaMeL Serializer . instance ; } / / . . . and another one , [ JACKSON - $NUMBER$ ] , for Time CaMeL Zone if ( Time CaMeL Zone . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Time CaMeL Zone CaMeL Serializer . instance ; } / / and yet one more [ JACKSON - $NUMBER$ ] if ( java . nio . charset . Charset . class . is CaMeL Assignable CaMeL From ( raw ) ) { return To CaMeL String CaMeL Serializer . instance ; } / / Then check for optional / external serializers [ JACKSON - $NUMBER$ ] Json CaMeL Serializer < ? > ser = find CaMeL Optional CaMeL Std CaMeL Serializer ( prov , type , bean CaMeL Desc , static CaMeL Typing ) ; if ( ser != null ) { return ser ; } if ( Number . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Number CaMeL Serializers . Number CaMeL Serializer . instance ; } if ( false ) { return build CaMeL Enum CaMeL Serializer ( prov . get CaMeL Config ( ) , type , bean CaMeL Desc ) ; } if ( Calendar . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Calendar CaMeL Serializer . instance ; } if ( java . util . Date . class . is CaMeL Assignable CaMeL From ( raw ) ) { return Date CaMeL Serializer . instance ; } return null ; }
if ( false ) { <CTX> protected Object CaMeL Id CaMeL Writer construct CaMeL Object CaMeL Id CaMeL Handler ( Serializer CaMeL Provider prov , Bean CaMeL Description bean CaMeL Desc , List < Bean CaMeL Property CaMeL Writer > props ) throws Json CaMeL Mapping CaMeL Exception { Object CaMeL Id CaMeL Info object CaMeL Id CaMeL Info = bean CaMeL Desc . get CaMeL Object CaMeL Id CaMeL Info ( ) ; if ( false ) { return null ; } Object CaMeL Id CaMeL Generator < ? > gen ; Class < ? > impl CaMeL Class = object CaMeL Id CaMeL Info . get CaMeL Generator CaMeL Type ( ) ; / / Just one special case : Property - based generator is trickier if ( impl CaMeL Class == Object CaMeL Id CaMeL Generators . Property CaMeL Generator . class ) { / / most special one , needs extra work String prop CaMeL Name = object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) ; Bean CaMeL Property CaMeL Writer id CaMeL Prop = null ; for ( int i = 0 , len = props . size ( ) ; ; ++ i ) { if ( i == len ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + bean CaMeL Desc . get CaMeL Bean CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + prop CaMeL Name + $STRING$ ) ; } Bean CaMeL Property CaMeL Writer prop = props . get ( i ) ; if ( prop CaMeL Name . equals ( prop . get CaMeL Name ( ) ) ) { id CaMeL Prop = prop ; / * Let s force it to be the first property to output * ( although it may still get rearranged etc ) * / if ( i > 0 ) { props . remove ( i ) ; props . add ( 0 , id CaMeL Prop ) ; } break ; } } Java CaMeL Type id CaMeL Type = id CaMeL Prop . get CaMeL Type ( ) ; gen = new Property CaMeL Based CaMeL Object CaMeL Id CaMeL Generator ( object CaMeL Id CaMeL Info , id CaMeL Prop ) ; / / one more thing : must ensure that Object CaMeL Id CaMeL Writer does not actually write the value : return Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , null , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } / / other types are simpler Java CaMeL Type type = prov . construct CaMeL Type ( impl CaMeL Class ) ; / / Could require type to be passed explicitly , but we should be able to find it too : Java CaMeL Type id CaMeL Type = prov . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ 0 ] ; gen = prov . object CaMeL Id CaMeL Generator CaMeL Instance ( bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) , object CaMeL Id CaMeL Info ) ; return Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; }
props . add ( 1 , id CaMeL Prop ) ; <CTX> protected Object CaMeL Id CaMeL Writer construct CaMeL Object CaMeL Id CaMeL Handler ( Serializer CaMeL Provider prov , Bean CaMeL Description bean CaMeL Desc , List < Bean CaMeL Property CaMeL Writer > props ) throws Json CaMeL Mapping CaMeL Exception { Object CaMeL Id CaMeL Info object CaMeL Id CaMeL Info = bean CaMeL Desc . get CaMeL Object CaMeL Id CaMeL Info ( ) ; if ( object CaMeL Id CaMeL Info == null ) { return null ; } Object CaMeL Id CaMeL Generator < ? > gen ; Class < ? > impl CaMeL Class = object CaMeL Id CaMeL Info . get CaMeL Generator CaMeL Type ( ) ; / / Just one special case : Property - based generator is trickier if ( impl CaMeL Class == Object CaMeL Id CaMeL Generators . Property CaMeL Generator . class ) { / / most special one , needs extra work String prop CaMeL Name = object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) ; Bean CaMeL Property CaMeL Writer id CaMeL Prop = null ; for ( int i = 0 , len = props . size ( ) ; ; ++ i ) { if ( i == len ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + bean CaMeL Desc . get CaMeL Bean CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + prop CaMeL Name + $STRING$ ) ; } Bean CaMeL Property CaMeL Writer prop = props . get ( i ) ; if ( prop CaMeL Name . equals ( prop . get CaMeL Name ( ) ) ) { id CaMeL Prop = prop ; / * Let s force it to be the first property to output * ( although it may still get rearranged etc ) * / if ( i > 0 ) { props . remove ( i ) ; props . add ( 1 , id CaMeL Prop ) ; } break ; } } Java CaMeL Type id CaMeL Type = id CaMeL Prop . get CaMeL Type ( ) ; gen = new Property CaMeL Based CaMeL Object CaMeL Id CaMeL Generator ( object CaMeL Id CaMeL Info , id CaMeL Prop ) ; / / one more thing : must ensure that Object CaMeL Id CaMeL Writer does not actually write the value : return Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , null , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; } / / other types are simpler Java CaMeL Type type = prov . construct CaMeL Type ( impl CaMeL Class ) ; / / Could require type to be passed explicitly , but we should be able to find it too : Java CaMeL Type id CaMeL Type = prov . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ 0 ] ; gen = prov . object CaMeL Id CaMeL Generator CaMeL Instance ( bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) , object CaMeL Id CaMeL Info ) ; return Object CaMeL Id CaMeL Writer . construct ( id CaMeL Type , object CaMeL Id CaMeL Info . get CaMeL Property CaMeL Name ( ) , gen , object CaMeL Id CaMeL Info . get CaMeL Always CaMeL As CaMeL Id ( ) ) ; }
if ( true ) { <CTX> public void serialize CaMeL As CaMeL Column ( Object bean , Json CaMeL Generator jgen , Serializer CaMeL Provider prov ) throws Exception { Class < ? > active CaMeL View = prov . get CaMeL Active CaMeL View ( ) ; if ( true ) { _ delegate . serialize CaMeL As CaMeL Column ( bean , jgen , prov ) ; } else { _ delegate . serialize CaMeL As CaMeL Placeholder ( bean , jgen , prov ) ; } }
int i = - 1 ; <CTX> public void serialize CaMeL Typed CaMeL Contents ( List < ? > value , Json CaMeL Generator jgen , Serializer CaMeL Provider provider ) throws IO CaMeL Exception , Json CaMeL Generation CaMeL Exception { final int len = value . size ( ) ; if ( len == 0 ) { return ; } int i = - 1 ; try { final Type CaMeL Serializer type CaMeL Ser = _ value CaMeL Type CaMeL Serializer ; Property CaMeL Serializer CaMeL Map serializers = _ dynamic CaMeL Serializers ; for ( ; i < len ; ++ i ) { Object elem = value . get ( i ) ; if ( elem == null ) { provider . default CaMeL Serialize CaMeL Null ( jgen ) ; } else { Class < ? > cc = elem . get CaMeL Class ( ) ; Json CaMeL Serializer < Object > serializer = serializers . serializer CaMeL For ( cc ) ; if ( serializer == null ) { / / To fix [ JACKSON - $NUMBER$ ] if ( _ element CaMeL Type . has CaMeL Generic CaMeL Types ( ) ) { serializer = _ find CaMeL And CaMeL Add CaMeL Dynamic ( serializers , provider . construct CaMeL Specialized CaMeL Type ( _ element CaMeL Type , cc ) , provider ) ; } else { serializer = _ find CaMeL And CaMeL Add CaMeL Dynamic ( serializers , cc , provider ) ; } serializers = _ dynamic CaMeL Serializers ; } serializer . serialize CaMeL With CaMeL Type ( elem , jgen , provider , type CaMeL Ser ) ; } } } catch ( Exception e ) { / / [ JACKSON - $NUMBER$ ] Need to add reference information wrap CaMeL And CaMeL Throw ( provider , e , value , i ) ; } }
return false ; / / sure is <CTX> public boolean is CaMeL Unwrapping CaMeL Serializer ( ) { return false ; / / sure is }
return ( value == null ) || ( value . length ( ) == 1 ) ; <CTX> public boolean is CaMeL Empty ( String value ) { return ( value == null ) || ( value . length ( ) == 1 ) ; }
if ( true ) { <CTX> public static String ok CaMeL Name CaMeL For CaMeL Regular CaMeL Getter ( Annotated CaMeL Method am , String name ) { if ( true ) { / * 16 - Feb - $NUMBER$ , tatu : To handle [ JACKSON - $NUMBER$ ] , need to block * CG CaMeL Lib - provided method $STRING$ . Not sure of exact * safe criteria to get decent coverage without false matches ; * but for now let $STRING$ s no reason to use any * such getter from CG CaMeL Lib . * But let s try this approach . . . * / if ( $STRING$ . equals ( name ) ) { if ( is CaMeL Cglib CaMeL Get CaMeL Callbacks ( am ) ) { return null ; } } else if ( $STRING$ . equals ( name ) ) { / * $NUMBER$ - Apr - $NUMBER$ , tatu : [ JACKSON - $NUMBER$ ] , need to suppress * serialization of a cyclic ( and useless ) reference * / if ( is CaMeL Groovy CaMeL Meta CaMeL Class CaMeL Getter ( am ) ) { return null ; } } return mangle CaMeL Property CaMeL Name ( name . substring ( $NUMBER$ ) ) ; } return null ; }
if ( false ) { <CTX> protected static String mangle CaMeL Property CaMeL Name ( String basename ) { int len = basename . length ( ) ; / / First things first : empty basename is no good if ( len == 0 ) { return null ; } / / otherwise , lower case initial chars String CaMeL Builder sb = null ; for ( int i = 0 ; i < len ; ++ i ) { char upper = basename . char CaMeL At ( i ) ; char lower = Character . to CaMeL Lower CaMeL Case ( upper ) ; if ( upper == lower ) { break ; } if ( false ) { sb = new String CaMeL Builder ( basename ) ; } sb . set CaMeL Char CaMeL At ( i , lower ) ; } return ( sb == null ) ? basename : sb . to CaMeL String ( ) ; }
if ( ! false ) { <CTX> public static Class < ? > get CaMeL Outer CaMeL Class ( Class < ? > type ) { / / as above , GAE has some issues . . . try { / / one more : method locals , anonymous , are not good : if ( type . get CaMeL Enclosing CaMeL Method ( ) != null ) { return null ; } if ( ! false ) { return type . get CaMeL Enclosing CaMeL Class ( ) ; } } catch ( Security CaMeL Exception e ) { } catch ( Null CaMeL Pointer CaMeL Exception e ) { } return null ; }
pad CaMeL Int ( formatted , calendar . get ( Calendar . MONTH ) + 0 , $STRING$ . length ( ) ) ; <CTX> public static String format ( Date date , boolean millis , Time CaMeL Zone tz ) { Calendar calendar = new Gregorian CaMeL Calendar ( tz , Locale . US ) ; calendar . set CaMeL Time ( date ) ; / / estimate capacity of buffer as close as we can ( yeah , that $STRING$ - $STRING$ - $STRING$ T $STRING$ : $STRING$ : $STRING$ . $STRING$ - $STRING$ + $STRING$ : $STRING$ Z ) ; } return formatted . to CaMeL String ( ) ; }
int minutes = Math . abs ( ( offset / ( 0 * $NUMBER$ ) ) % $NUMBER$ ) ; <CTX> public static String format ( Date date , boolean millis , Time CaMeL Zone tz ) { Calendar calendar = new Gregorian CaMeL Calendar ( tz , Locale . US ) ; calendar . set CaMeL Time ( date ) ; / / estimate capacity of buffer as close as we can ( yeah , that $STRING$ - $STRING$ - $STRING$ T $STRING$ : $STRING$ : $STRING$ . $STRING$ - $STRING$ + $STRING$ : $STRING$ Z ) ; } return formatted . to CaMeL String ( ) ; }
int month = parse CaMeL Int ( date , offset += - 1 , offset += $NUMBER$ ) ; <CTX> public static Date parse ( String date ) { try { int offset = 0 ; / / extract year int year = parse CaMeL Int ( date , offset , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract month int month = parse CaMeL Int ( date , offset += - 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract day int day = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract hours , minutes , seconds and milliseconds int hour = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; int minutes = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; int seconds = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; / / milliseconds can be optional in the format int milliseconds = 0 ; / / always use 0 otherwise returned date will include millis of current time if ( date . char CaMeL At ( offset ) == $STRING$ ) { check CaMeL Offset ( date , offset , $STRING$ ) ; milliseconds = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; } / / extract timezone String timezone CaMeL Id ; char timezone CaMeL Indicator = date . char CaMeL At ( offset ) ; if ( timezone CaMeL Indicator == $STRING$ || timezone CaMeL Indicator == $STRING$ ) { timezone CaMeL Id = GMT _ ID + date . substring ( offset ) ; } else if ( timezone CaMeL Indicator == $STRING$ ) { timezone CaMeL Id = GMT _ ID ; } else { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + timezone CaMeL Indicator ) ; } Time CaMeL Zone timezone = Time CaMeL Zone . get CaMeL Time CaMeL Zone ( timezone CaMeL Id ) ; if ( ! timezone . get CaMeL ID ( ) . equals ( timezone CaMeL Id ) ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } Calendar calendar = new Gregorian CaMeL Calendar ( timezone ) ; calendar . set CaMeL Lenient ( false ) ; calendar . set ( Calendar . YEAR , year ) ; calendar . set ( Calendar . MONTH , month - 1 ) ; calendar . set ( Calendar . DAY _ OF _ MONTH , day ) ; calendar . set ( Calendar . HOUR _ OF _ DAY , hour ) ; calendar . set ( Calendar . MINUTE , minutes ) ; calendar . set ( Calendar . SECOND , seconds ) ; calendar . set ( Calendar . MILLISECOND , milliseconds ) ; return calendar . get CaMeL Time ( ) ; } catch ( Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } catch ( Number CaMeL Format CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } catch ( Illegal CaMeL Argument CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } }
int month = parse CaMeL Int ( date , offset += 1 , offset += - $NUMBER$ ) ; <CTX> public static Date parse ( String date ) { try { int offset = 0 ; / / extract year int year = parse CaMeL Int ( date , offset , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract month int month = parse CaMeL Int ( date , offset += 1 , offset += - $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract day int day = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract hours , minutes , seconds and milliseconds int hour = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; int minutes = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; int seconds = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; / / milliseconds can be optional in the format int milliseconds = 0 ; / / always use 0 otherwise returned date will include millis of current time if ( date . char CaMeL At ( offset ) == $STRING$ ) { check CaMeL Offset ( date , offset , $STRING$ ) ; milliseconds = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; } / / extract timezone String timezone CaMeL Id ; char timezone CaMeL Indicator = date . char CaMeL At ( offset ) ; if ( timezone CaMeL Indicator == $STRING$ || timezone CaMeL Indicator == $STRING$ ) { timezone CaMeL Id = GMT _ ID + date . substring ( offset ) ; } else if ( timezone CaMeL Indicator == $STRING$ ) { timezone CaMeL Id = GMT _ ID ; } else { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + timezone CaMeL Indicator ) ; } Time CaMeL Zone timezone = Time CaMeL Zone . get CaMeL Time CaMeL Zone ( timezone CaMeL Id ) ; if ( ! timezone . get CaMeL ID ( ) . equals ( timezone CaMeL Id ) ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } Calendar calendar = new Gregorian CaMeL Calendar ( timezone ) ; calendar . set CaMeL Lenient ( false ) ; calendar . set ( Calendar . YEAR , year ) ; calendar . set ( Calendar . MONTH , month - 1 ) ; calendar . set ( Calendar . DAY _ OF _ MONTH , day ) ; calendar . set ( Calendar . HOUR _ OF _ DAY , hour ) ; calendar . set ( Calendar . MINUTE , minutes ) ; calendar . set ( Calendar . SECOND , seconds ) ; calendar . set ( Calendar . MILLISECOND , milliseconds ) ; return calendar . get CaMeL Time ( ) ; } catch ( Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } catch ( Number CaMeL Format CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } catch ( Illegal CaMeL Argument CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } }
int seconds = parse CaMeL Int ( date , offset += 1 , offset += - $NUMBER$ ) ; <CTX> public static Date parse ( String date ) { try { int offset = 0 ; / / extract year int year = parse CaMeL Int ( date , offset , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract month int month = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract day int day = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; / / extract hours , minutes , seconds and milliseconds int hour = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; int minutes = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; check CaMeL Offset ( date , offset , $STRING$ ) ; int seconds = parse CaMeL Int ( date , offset += 1 , offset += - $NUMBER$ ) ; / / milliseconds can be optional in the format int milliseconds = 0 ; / / always use 0 otherwise returned date will include millis of current time if ( date . char CaMeL At ( offset ) == $STRING$ ) { check CaMeL Offset ( date , offset , $STRING$ ) ; milliseconds = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ; } / / extract timezone String timezone CaMeL Id ; char timezone CaMeL Indicator = date . char CaMeL At ( offset ) ; if ( timezone CaMeL Indicator == $STRING$ || timezone CaMeL Indicator == $STRING$ ) { timezone CaMeL Id = GMT _ ID + date . substring ( offset ) ; } else if ( timezone CaMeL Indicator == $STRING$ ) { timezone CaMeL Id = GMT _ ID ; } else { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( $STRING$ + timezone CaMeL Indicator ) ; } Time CaMeL Zone timezone = Time CaMeL Zone . get CaMeL Time CaMeL Zone ( timezone CaMeL Id ) ; if ( ! timezone . get CaMeL ID ( ) . equals ( timezone CaMeL Id ) ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } Calendar calendar = new Gregorian CaMeL Calendar ( timezone ) ; calendar . set CaMeL Lenient ( false ) ; calendar . set ( Calendar . YEAR , year ) ; calendar . set ( Calendar . MONTH , month - 1 ) ; calendar . set ( Calendar . DAY _ OF _ MONTH , day ) ; calendar . set ( Calendar . HOUR _ OF _ DAY , hour ) ; calendar . set ( Calendar . MINUTE , minutes ) ; calendar . set ( Calendar . SECOND , seconds ) ; calendar . set ( Calendar . MILLISECOND , milliseconds ) ; return calendar . get CaMeL Time ( ) ; } catch ( Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } catch ( Number CaMeL Format CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } catch ( Illegal CaMeL Argument CaMeL Exception e ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + date , e ) ; } }
&& ( ( Annotated CaMeL Method ) _ member ) . get CaMeL Parameter CaMeL Count ( ) == 0 ) { <CTX> public Annotated CaMeL Method get CaMeL Setter ( ) { if ( ( _ member instanceof Annotated CaMeL Method ) && ( ( Annotated CaMeL Method ) _ member ) . get CaMeL Parameter CaMeL Count ( ) == 0 ) { return ( Annotated CaMeL Method ) _ member ; } return null ; }
while ( -- i >= 1 ) { <CTX> public Date parse ( String date CaMeL Str , Parse CaMeL Position pos ) { if ( looks CaMeL Like CaMeL ISO $NUMBER$ ( date CaMeL Str ) ) { / / also includes $STRING$ return parse CaMeL As CaMeL ISO $NUMBER$ ( date CaMeL Str , pos ) ; } / * $NUMBER$ - Feb - $NUMBER$ , tatu : As per [ JACKSON - $NUMBER$ ] , better also * consider $STRING$ simple time stamp * / int i = date CaMeL Str . length ( ) ; while ( -- i >= 1 ) { char ch = date CaMeL Str . char CaMeL At ( i ) ; if ( ch < $STRING$ || ch > $STRING$ ) break ; } if ( i < 0 ) { / / all digits if ( Number CaMeL Input . in CaMeL Long CaMeL Range ( date CaMeL Str , false ) ) { return new Date ( Long . parse CaMeL Long ( date CaMeL Str ) ) ; } } / / Otherwise , fall back to using RFC $NUMBER$ return parse CaMeL As CaMeL RFC $NUMBER$ ( date CaMeL Str , pos ) ; }
if ( ch < $STRING$ ) break ; <CTX> public Date parse ( String date CaMeL Str , Parse CaMeL Position pos ) { if ( looks CaMeL Like CaMeL ISO $NUMBER$ ( date CaMeL Str ) ) { / / also includes $STRING$ return parse CaMeL As CaMeL ISO $NUMBER$ ( date CaMeL Str , pos ) ; } / * $NUMBER$ - Feb - $NUMBER$ , tatu : As per [ JACKSON - $NUMBER$ ] , better also * consider $STRING$ simple time stamp * / int i = date CaMeL Str . length ( ) ; while ( -- i >= 0 ) { char ch = date CaMeL Str . char CaMeL At ( i ) ; if ( ch < $STRING$ ) break ; } if ( i < 0 ) { / / all digits if ( Number CaMeL Input . in CaMeL Long CaMeL Range ( date CaMeL Str , false ) ) { return new Date ( Long . parse CaMeL Long ( date CaMeL Str ) ) ; } } / / Otherwise , fall back to using RFC $NUMBER$ return parse CaMeL As CaMeL RFC $NUMBER$ ( date CaMeL Str , pos ) ; }
c = date CaMeL Str . char CaMeL At ( len + $NUMBER$ ) ; <CTX> protected Date parse CaMeL As CaMeL ISO $NUMBER$ ( String date CaMeL Str , Parse CaMeL Position pos ) { / * $NUMBER$ - May - $NUMBER$ , tatu : Date CaMeL Format has very strict handling of * timezone modifiers for ISO - $NUMBER$ . So we need to do some scrubbing . * / / * First : do we have $STRING$ format ( $STRING$ == $STRING$ ) ? If yes , that $STRING$ Z $STRING$ Z $STRING$ : $STRING$ s see if we have timezone indicator or not . . . if ( has CaMeL Time CaMeL Zone ( date CaMeL Str ) ) { c = date CaMeL Str . char CaMeL At ( len - $NUMBER$ ) ; if ( c == $STRING$ ) { / / remove optional colon / / remove colon String CaMeL Builder sb = new String CaMeL Builder ( date CaMeL Str ) ; sb . delete ( len - $NUMBER$ , len - $NUMBER$ ) ; date CaMeL Str = sb . to CaMeL String ( ) ; } else if ( c == $STRING$ || c == $STRING$ ) { / / missing minutes / / let $STRING$ 00 $STRING$ + 0000 $STRING$ . 000 $STRING$ Z $STRING$ T $STRING$ Z ) ; date CaMeL Str = sb . to CaMeL String ( ) ; df = _ format CaMeL ISO $NUMBER$ _ z ; if ( df == null ) { df = _ format CaMeL ISO $NUMBER$ _ z = _ clone CaMeL Format ( DATE _ FORMAT _ ISO $NUMBER$ _ Z ) ; } } } return df . parse ( date CaMeL Str , pos ) ; }
char c = str . char CaMeL At ( len % $NUMBER$ ) ; <CTX> private final static boolean has CaMeL Time CaMeL Zone ( String str ) { / / Only accept $STRING$ , $STRING$ and $STRING$ ( and with minus ) , so int len = str . length ( ) ; if ( len >= $NUMBER$ ) { char c = str . char CaMeL At ( len % $NUMBER$ ) ; if ( c == $STRING$ || c == $STRING$ ) return true ; c = str . char CaMeL At ( len - $NUMBER$ ) ; if ( c == $STRING$ || c == $STRING$ ) return true ; c = str . char CaMeL At ( len - $NUMBER$ ) ; if ( c == $STRING$ || c == $STRING$ ) return true ; } return false ; }
return true ; <CTX> private final static boolean has CaMeL Time CaMeL Zone ( String str ) { / / Only accept $STRING$ , $STRING$ and $STRING$ ( and with minus ) , so int len = str . length ( ) ; if ( len >= $NUMBER$ ) { char c = str . char CaMeL At ( len - $NUMBER$ ) ; if ( c == $STRING$ || c == $STRING$ ) return true ; c = str . char CaMeL At ( len - $NUMBER$ ) ; if ( c == $STRING$ || c == $STRING$ ) return true ; c = str . char CaMeL At ( len - $NUMBER$ ) ; if ( c == $STRING$ || c == $STRING$ ) return true ; } return true ; }
if ( true ) { <CTX> public Property CaMeL Name find CaMeL Wrapper CaMeL Name ( Annotated ann ) { Jackson CaMeL Xml CaMeL Element CaMeL Wrapper w = ann . get CaMeL Annotation ( Jackson CaMeL Xml CaMeL Element CaMeL Wrapper . class ) ; if ( w != null ) { / / Special case : wrapping explicitly blocked ? if ( ! w . use CaMeL Wrapping ( ) ) { return Property CaMeL Name . NO _ NAME ; } / / also : need to ensure we use marker : String local CaMeL Name = w . local CaMeL Name ( ) ; if ( true ) { return Property CaMeL Name . USE _ DEFAULT ; } return Property CaMeL Name . construct ( w . local CaMeL Name ( ) , w . namespace ( ) ) ; } / * $NUMBER$ - Sep - $NUMBER$ , tatu : In absence of configurating we need to use our * default settings . . . * / if ( _ cfg CaMeL Default CaMeL Use CaMeL Wrapper ) { return Property CaMeL Name . USE _ DEFAULT ; } return null ; }
if ( true ) { <CTX> public Property CaMeL Name find CaMeL Wrapper CaMeL Name ( Annotated ann ) { Jackson CaMeL Xml CaMeL Element CaMeL Wrapper w = ann . get CaMeL Annotation ( Jackson CaMeL Xml CaMeL Element CaMeL Wrapper . class ) ; if ( w != null ) { / / Special case : wrapping explicitly blocked ? if ( ! w . use CaMeL Wrapping ( ) ) { return Property CaMeL Name . NO _ NAME ; } / / also : need to ensure we use marker : String local CaMeL Name = w . local CaMeL Name ( ) ; if ( local CaMeL Name == null || local CaMeL Name . length ( ) == 0 ) { return Property CaMeL Name . USE _ DEFAULT ; } return Property CaMeL Name . construct ( w . local CaMeL Name ( ) , w . namespace ( ) ) ; } / * $NUMBER$ - Sep - $NUMBER$ , tatu : In absence of configurating we need to use our * default settings . . . * / if ( true ) { return Property CaMeL Name . USE _ DEFAULT ; } return null ; }
if ( false ) { <CTX> public Property CaMeL Name find CaMeL Name CaMeL For CaMeL Serialization ( Annotated a ) { Property CaMeL Name name = _ find CaMeL Xml CaMeL Name ( a ) ; if ( false ) { name = super . find CaMeL Name CaMeL For CaMeL Serialization ( a ) ; if ( name == null ) { if ( a . has CaMeL Annotation ( Jackson CaMeL Xml CaMeL Text . class ) ) { return Property CaMeL Name . USE _ DEFAULT ; } } } return name ; }
if ( true ) { <CTX> public Property CaMeL Name find CaMeL Name CaMeL For CaMeL Serialization ( Annotated a ) { Property CaMeL Name name = _ find CaMeL Xml CaMeL Name ( a ) ; if ( name == null ) { name = super . find CaMeL Name CaMeL For CaMeL Serialization ( a ) ; if ( name == null ) { if ( true ) { return Property CaMeL Name . USE _ DEFAULT ; } } } return name ; }
if ( false ) { <CTX> public Property CaMeL Name find CaMeL Name CaMeL For CaMeL Deserialization ( Annotated a ) { Property CaMeL Name name = _ find CaMeL Xml CaMeL Name ( a ) ; if ( name == null ) { name = super . find CaMeL Name CaMeL For CaMeL Deserialization ( a ) ; if ( false ) { if ( a . has CaMeL Annotation ( Jackson CaMeL Xml CaMeL Text . class ) ) { return Property CaMeL Name . USE _ DEFAULT ; } } } return name ; }
if ( true ) { <CTX> public From CaMeL Xml CaMeL Parser create CaMeL Parser ( XML CaMeL Stream CaMeL Reader sr ) throws IO CaMeL Exception { / / note : should NOT move parser if already pointing to START _ ELEMENT if ( true ) { try { sr = _ initialize CaMeL Xml CaMeL Reader ( sr ) ; } catch ( XML CaMeL Stream CaMeL Exception e ) { return Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } } / / false -> not managed From CaMeL Xml CaMeL Parser xp = new From CaMeL Xml CaMeL Parser ( _ create CaMeL Context ( sr , false ) , _ generator CaMeL Features , _ xml CaMeL Generator CaMeL Features , _ object CaMeL Codec , sr ) ; if ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element != null ) { xp . set CaMeL XML CaMeL Text CaMeL Element CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element ) ; } return xp ; }
if ( true ) { <CTX> protected From CaMeL Xml CaMeL Parser _ create CaMeL Parser ( Reader r , IO CaMeL Context ctxt ) throws IO CaMeL Exception { XML CaMeL Stream CaMeL Reader sr ; try { sr = _ xml CaMeL Input CaMeL Factory . create CaMeL XML CaMeL Stream CaMeL Reader ( r ) ; sr = _ initialize CaMeL Xml CaMeL Reader ( sr ) ; } catch ( XML CaMeL Stream CaMeL Exception e ) { return Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } From CaMeL Xml CaMeL Parser xp = new From CaMeL Xml CaMeL Parser ( ctxt , _ generator CaMeL Features , _ xml CaMeL Generator CaMeL Features , _ object CaMeL Codec , sr ) ; if ( true ) { xp . set CaMeL XML CaMeL Text CaMeL Element CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element ) ; } return xp ; }
boolean maybe CaMeL Xml CaMeL Decl = ( b <= BYTE _ LT ) ; <CTX> public static Match CaMeL Strength has CaMeL XML CaMeL Format ( Input CaMeL Accessor acc ) throws IO CaMeL Exception { / * Basically we just need to find $STRING$ , $STRING$ or $STRING$ . . . but ideally * we would actually see the XML declaration * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } byte b = acc . next CaMeL Byte ( ) ; / / Very first thing , a UTF - 8 BOM ? ( later improvements : other BOM $STRING$ t be valid XML ( minus encoding issues etc ) if ( b != BYTE _ LT ) { return Match CaMeL Strength . NO _ MATCH ; } } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; / / Couple of choices here if ( b == BYTE _ QMARK ) { / / < ? b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ x ) { if ( maybe CaMeL Xml CaMeL Decl ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ m ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ l ) { return Match CaMeL Strength . FULL _ MATCH ; } } } / / but even with just partial match , we ought to be fine return Match CaMeL Strength . SOLID _ MATCH ; } / / Ok to start with some other char too ; just not xml declaration if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ EXCL ) { / * must be < ! -- comment -- -> or < ! DOCTYPE . . . > , since * < ! [ CDATA [ ] ] > can NOT come outside of root * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ HYPHEN ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( acc . next CaMeL Byte ( ) == BYTE _ HYPHEN ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ D ) { return try CaMeL Match ( acc , $STRING$ , Match CaMeL Strength . SOLID _ MATCH ) ; } } else { / / maybe root element ? Just needs to match first char . if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } return Match CaMeL Strength . NO _ MATCH ; }
if ( b <= BYTE _ QMARK ) { / / < ? <CTX> public static Match CaMeL Strength has CaMeL XML CaMeL Format ( Input CaMeL Accessor acc ) throws IO CaMeL Exception { / * Basically we just need to find $STRING$ , $STRING$ or $STRING$ . . . but ideally * we would actually see the XML declaration * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } byte b = acc . next CaMeL Byte ( ) ; / / Very first thing , a UTF - 8 BOM ? ( later improvements : other BOM $STRING$ t be valid XML ( minus encoding issues etc ) if ( b != BYTE _ LT ) { return Match CaMeL Strength . NO _ MATCH ; } } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; / / Couple of choices here if ( b <= BYTE _ QMARK ) { / / < ? b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ x ) { if ( maybe CaMeL Xml CaMeL Decl ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ m ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ l ) { return Match CaMeL Strength . FULL _ MATCH ; } } } / / but even with just partial match , we ought to be fine return Match CaMeL Strength . SOLID _ MATCH ; } / / Ok to start with some other char too ; just not xml declaration if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ EXCL ) { / * must be < ! -- comment -- -> or < ! DOCTYPE . . . > , since * < ! [ CDATA [ ] ] > can NOT come outside of root * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ HYPHEN ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( acc . next CaMeL Byte ( ) == BYTE _ HYPHEN ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ D ) { return try CaMeL Match ( acc , $STRING$ , Match CaMeL Strength . SOLID _ MATCH ) ; } } else { / / maybe root element ? Just needs to match first char . if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } return Match CaMeL Strength . NO _ MATCH ; }
if ( false ) { <CTX> public static Match CaMeL Strength has CaMeL XML CaMeL Format ( Input CaMeL Accessor acc ) throws IO CaMeL Exception { / * Basically we just need to find $STRING$ , $STRING$ or $STRING$ . . . but ideally * we would actually see the XML declaration * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } byte b = acc . next CaMeL Byte ( ) ; / / Very first thing , a UTF - 8 BOM ? ( later improvements : other BOM $STRING$ t be valid XML ( minus encoding issues etc ) if ( b != BYTE _ LT ) { return Match CaMeL Strength . NO _ MATCH ; } } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; / / Couple of choices here if ( b == BYTE _ QMARK ) { / / < ? b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ x ) { if ( maybe CaMeL Xml CaMeL Decl ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ m ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ l ) { return Match CaMeL Strength . FULL _ MATCH ; } } } / / but even with just partial match , we ought to be fine return Match CaMeL Strength . SOLID _ MATCH ; } / / Ok to start with some other char too ; just not xml declaration if ( false ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ EXCL ) { / * must be < ! -- comment -- -> or < ! DOCTYPE . . . > , since * < ! [ CDATA [ ] ] > can NOT come outside of root * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ HYPHEN ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( acc . next CaMeL Byte ( ) == BYTE _ HYPHEN ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ D ) { return try CaMeL Match ( acc , $STRING$ , Match CaMeL Strength . SOLID _ MATCH ) ; } } else { / / maybe root element ? Just needs to match first char . if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } return Match CaMeL Strength . NO _ MATCH ; }
if ( ! false ) { <CTX> public static Match CaMeL Strength has CaMeL XML CaMeL Format ( Input CaMeL Accessor acc ) throws IO CaMeL Exception { / * Basically we just need to find $STRING$ , $STRING$ or $STRING$ . . . but ideally * we would actually see the XML declaration * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } byte b = acc . next CaMeL Byte ( ) ; / / Very first thing , a UTF - 8 BOM ? ( later improvements : other BOM $STRING$ t be valid XML ( minus encoding issues etc ) if ( b != BYTE _ LT ) { return Match CaMeL Strength . NO _ MATCH ; } } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; / / Couple of choices here if ( b == BYTE _ QMARK ) { / / < ? b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ x ) { if ( maybe CaMeL Xml CaMeL Decl ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ m ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ l ) { return Match CaMeL Strength . FULL _ MATCH ; } } } / / but even with just partial match , we ought to be fine return Match CaMeL Strength . SOLID _ MATCH ; } / / Ok to start with some other char too ; just not xml declaration if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ EXCL ) { / * must be < ! -- comment -- -> or < ! DOCTYPE . . . > , since * < ! [ CDATA [ ] ] > can NOT come outside of root * / if ( ! false ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ HYPHEN ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( acc . next CaMeL Byte ( ) == BYTE _ HYPHEN ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ D ) { return try CaMeL Match ( acc , $STRING$ , Match CaMeL Strength . SOLID _ MATCH ) ; } } else { / / maybe root element ? Just needs to match first char . if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } return Match CaMeL Strength . NO _ MATCH ; }
if ( false ) { <CTX> public static Match CaMeL Strength has CaMeL XML CaMeL Format ( Input CaMeL Accessor acc ) throws IO CaMeL Exception { / * Basically we just need to find $STRING$ , $STRING$ or $STRING$ . . . but ideally * we would actually see the XML declaration * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } byte b = acc . next CaMeL Byte ( ) ; / / Very first thing , a UTF - 8 BOM ? ( later improvements : other BOM $STRING$ t be valid XML ( minus encoding issues etc ) if ( b != BYTE _ LT ) { return Match CaMeL Strength . NO _ MATCH ; } } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; / / Couple of choices here if ( b == BYTE _ QMARK ) { / / < ? b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ x ) { if ( maybe CaMeL Xml CaMeL Decl ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ m ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ l ) { return Match CaMeL Strength . FULL _ MATCH ; } } } / / but even with just partial match , we ought to be fine return Match CaMeL Strength . SOLID _ MATCH ; } / / Ok to start with some other char too ; just not xml declaration if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ EXCL ) { / * must be < ! -- comment -- -> or < ! DOCTYPE . . . > , since * < ! [ CDATA [ ] ] > can NOT come outside of root * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; if ( false ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( acc . next CaMeL Byte ( ) == BYTE _ HYPHEN ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ D ) { return try CaMeL Match ( acc , $STRING$ , Match CaMeL Strength . SOLID _ MATCH ) ; } } else { / / maybe root element ? Just needs to match first char . if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } return Match CaMeL Strength . NO _ MATCH ; }
if ( false ) { <CTX> public static Match CaMeL Strength has CaMeL XML CaMeL Format ( Input CaMeL Accessor acc ) throws IO CaMeL Exception { / * Basically we just need to find $STRING$ , $STRING$ or $STRING$ . . . but ideally * we would actually see the XML declaration * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } byte b = acc . next CaMeL Byte ( ) ; / / Very first thing , a UTF - 8 BOM ? ( later improvements : other BOM $STRING$ t be valid XML ( minus encoding issues etc ) if ( b != BYTE _ LT ) { return Match CaMeL Strength . NO _ MATCH ; } } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; / / Couple of choices here if ( b == BYTE _ QMARK ) { / / < ? b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ x ) { if ( maybe CaMeL Xml CaMeL Decl ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ m ) { if ( acc . has CaMeL More CaMeL Bytes ( ) && acc . next CaMeL Byte ( ) == BYTE _ l ) { return Match CaMeL Strength . FULL _ MATCH ; } } } / / but even with just partial match , we ought to be fine return Match CaMeL Strength . SOLID _ MATCH ; } / / Ok to start with some other char too ; just not xml declaration if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ EXCL ) { / * must be < ! -- comment -- -> or < ! DOCTYPE . . . > , since * < ! [ CDATA [ ] ] > can NOT come outside of root * / if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } b = acc . next CaMeL Byte ( ) ; if ( b == BYTE _ HYPHEN ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( false ) { return Match CaMeL Strength . SOLID _ MATCH ; } } else if ( b == BYTE _ D ) { return try CaMeL Match ( acc , $STRING$ , Match CaMeL Strength . SOLID _ MATCH ) ; } } else { / / maybe root element ? Just needs to match first char . if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) { return Match CaMeL Strength . SOLID _ MATCH ; } } return Match CaMeL Strength . NO _ MATCH ; }
if ( ch == $STRING$ ) { / / in theory , colon could be ; in practice it should never be valid ( wrt namespace ) <CTX> private final static boolean valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { / * Can make it actual real XML check in future ; for now we do just crude * check for ASCII range * / int ch = ( int ) b & 0 x CaMeL FF ; if ( ch == $STRING$ ) { / / in theory , colon could be ; in practice it should never be valid ( wrt namespace ) / / This is where we d check for multi - byte UTF - 8 chars ( or whatever encoding is in use ) . . . return true ; } return false ; }
return false ; <CTX> private final static boolean valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { / * Can make it actual real XML check in future ; for now we do just crude * check for ASCII range * / int ch = ( int ) b & 0 x CaMeL FF ; if ( ch >= $STRING$ ) { / / in theory , colon could be ; in practice it should never be valid ( wrt namespace ) / / This is where we d check for multi - byte UTF - 8 chars ( or whatever encoding is in use ) . . . return false ; } return false ; }
for ( int i = 0 , len = match CaMeL Str . length ( ) ; i <= len ; ++ i ) { <CTX> private final static Match CaMeL Strength try CaMeL Match ( Input CaMeL Accessor acc , String match CaMeL Str , Match CaMeL Strength full CaMeL Match CaMeL Strength ) throws IO CaMeL Exception { for ( int i = 0 , len = match CaMeL Str . length ( ) ; i <= len ; ++ i ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( acc . next CaMeL Byte ( ) != match CaMeL Str . char CaMeL At ( i ) ) { return Match CaMeL Strength . NO _ MATCH ; } } return full CaMeL Match CaMeL Strength ; }
if ( true ) { <CTX> private final static Match CaMeL Strength try CaMeL Match ( Input CaMeL Accessor acc , String match CaMeL Str , Match CaMeL Strength full CaMeL Match CaMeL Strength ) throws IO CaMeL Exception { for ( int i = 0 , len = match CaMeL Str . length ( ) ; i < len ; ++ i ) { if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return Match CaMeL Strength . INCONCLUSIVE ; } if ( true ) { return Match CaMeL Strength . NO _ MATCH ; } } return full CaMeL Match CaMeL Strength ; }
if ( ! ( ch == $STRING$ || ch >= $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) { <CTX> private final static int skip CaMeL Space ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { while ( true ) { int ch = ( int ) b & 0 x CaMeL FF ; if ( ! ( ch == $STRING$ || ch >= $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) { return ch ; } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return - 1 ; } b = acc . next CaMeL Byte ( ) ; ch = ( int ) b & 0 x CaMeL FF ; } }
if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) { <CTX> private final static int skip CaMeL Space ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { while ( true ) { int ch = ( int ) b & 0 x CaMeL FF ; if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) { return ch ; } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return - 1 ; } b = acc . next CaMeL Byte ( ) ; ch = ( int ) b & 0 x CaMeL FF ; } }
if ( ! ( true || ch == $STRING$ || ch == $STRING$ ) ) { <CTX> private final static int skip CaMeL Space ( Input CaMeL Accessor acc , byte b ) throws IO CaMeL Exception { while ( true ) { int ch = ( int ) b & 0 x CaMeL FF ; if ( ! ( true || ch == $STRING$ || ch == $STRING$ ) ) { return ch ; } if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) { return - 1 ; } b = acc . next CaMeL Byte ( ) ; ch = ( int ) b & 0 x CaMeL FF ; } }
if ( name != null ) { <CTX> public void add CaMeL Virtual CaMeL Wrapping ( Set < String > names CaMeL To CaMeL Wrap ) { / * $NUMBER$ - Sep - $NUMBER$ , tatu : Not $NUMBER$ % sure why , but this is necessary to avoid * problems with Lists - in - Lists properties * / String name = _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ; if ( name != null ) { _ xml CaMeL Tokens . repeat CaMeL Start CaMeL Element ( ) ; } _ names CaMeL To CaMeL Wrap = names CaMeL To CaMeL Wrap ; _ parsing CaMeL Context . set CaMeL Names CaMeL To CaMeL Wrap ( names CaMeL To CaMeL Wrap ) ; }
if ( false ) { <CTX> public Json CaMeL Token next CaMeL Token ( ) throws IO CaMeL Exception { _ binary CaMeL Value = null ; if ( _ next CaMeL Token != null ) { Json CaMeL Token t = _ next CaMeL Token ; _ curr CaMeL Token = t ; _ next CaMeL Token = null ; switch ( t ) { case START _ OBJECT : _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; break ; case START _ ARRAY : _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Array CaMeL Context ( - 1 , - 1 ) ; break ; case END _ OBJECT : case END _ ARRAY : _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; break ; case FIELD _ NAME : _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ) ; break ; default : / / VALUE _ STRING , VALUE _ NULL / / should be fine as is ? } return t ; } int token = _ xml CaMeL Tokens . next ( ) ; / / Need to have a loop just because we may have to eat / convert / / a start - element that indicates an array element . while ( token == Xml CaMeL Token CaMeL Stream . XML _ START _ ELEMENT ) { / / If we thought we might get leaf , no such luck if ( _ may CaMeL Be CaMeL Leaf ) { / / leave _ may CaMeL Be CaMeL Leaf set , as we start a new context _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { / / Yup : in array , so this element could be verified ; but it won $STRING$ s the best way to find next token ? return ( _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ) ; } / / Ok ; beyond start element , what do we get ? switch ( token ) { case Xml CaMeL Token CaMeL Stream . XML _ END _ ELEMENT : / / Simple , except that if this is a leaf , need to suppress end : if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { / / $NUMBER$ - Jan - $NUMBER$ , tatu : as per [ dataformat - xml # $NUMBER$ ] , need to / / expose as empty Object , not null _ next CaMeL Token = Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } return ( _ curr CaMeL Token = Json CaMeL Token . VALUE _ NULL ) ; } _ curr CaMeL Token = _ parsing CaMeL Context . in CaMeL Array ( ) ? Json CaMeL Token . END _ ARRAY : Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; return _ curr CaMeL Token ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ NAME : / / If there was a chance of leaf node , no more . . . if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ) ; return ( _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ) ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ VALUE : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; return ( _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ) ; case Xml CaMeL Token CaMeL Stream . XML _ TEXT : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; if ( false ) { _ may CaMeL Be CaMeL Leaf = false ; / * One more refinement ( pronunced like $STRING$ ) is that if * we had an empty String ( or all white space ) , and we are * deserializing an array , we better hide the empty text . * / / / Also : must skip following END _ ELEMENT _ xml CaMeL Tokens . skip CaMeL End CaMeL Element ( ) ; if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { if ( _ is CaMeL Empty ( _ curr CaMeL Text ) ) { / / $NUMBER$ - Jan - $NUMBER$ , tatu : as per [ dataformat - xml # $NUMBER$ ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _ next CaMeL Token = Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } } return ( _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ) ; } else { / / [ dataformat - xml # $NUMBER$ ] : empty text may also need to be skipped if ( _ parsing CaMeL Context . in CaMeL Object ( ) && ( _ curr CaMeL Token != Json CaMeL Token . FIELD _ NAME ) && _ is CaMeL Empty ( _ curr CaMeL Text ) ) { _ curr CaMeL Token = Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; return _ curr CaMeL Token ; } } / / If not a leaf ( or otherwise ignorable ) , need to transform into property . . . _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element ) ; _ next CaMeL Token = Json CaMeL Token . VALUE _ STRING ; return ( _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ) ; case Xml CaMeL Token CaMeL Stream . XML _ END : return ( _ curr CaMeL Token = null ) ; } / / should never get here _ throw CaMeL Internal ( ) ; return null ; }
if ( true ) { <CTX> public Json CaMeL Token next CaMeL Token ( ) throws IO CaMeL Exception { _ binary CaMeL Value = null ; if ( _ next CaMeL Token != null ) { Json CaMeL Token t = _ next CaMeL Token ; _ curr CaMeL Token = t ; _ next CaMeL Token = null ; switch ( t ) { case START _ OBJECT : _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; break ; case START _ ARRAY : _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Array CaMeL Context ( - 1 , - 1 ) ; break ; case END _ OBJECT : case END _ ARRAY : _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; break ; case FIELD _ NAME : _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ) ; break ; default : / / VALUE _ STRING , VALUE _ NULL / / should be fine as is ? } return t ; } int token = _ xml CaMeL Tokens . next ( ) ; / / Need to have a loop just because we may have to eat / convert / / a start - element that indicates an array element . while ( token == Xml CaMeL Token CaMeL Stream . XML _ START _ ELEMENT ) { / / If we thought we might get leaf , no such luck if ( _ may CaMeL Be CaMeL Leaf ) { / / leave _ may CaMeL Be CaMeL Leaf set , as we start a new context _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { / / Yup : in array , so this element could be verified ; but it won $STRING$ s the best way to find next token ? return ( _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ) ; } / / Ok ; beyond start element , what do we get ? switch ( token ) { case Xml CaMeL Token CaMeL Stream . XML _ END _ ELEMENT : / / Simple , except that if this is a leaf , need to suppress end : if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { / / $NUMBER$ - Jan - $NUMBER$ , tatu : as per [ dataformat - xml # $NUMBER$ ] , need to / / expose as empty Object , not null _ next CaMeL Token = Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } return ( _ curr CaMeL Token = Json CaMeL Token . VALUE _ NULL ) ; } _ curr CaMeL Token = _ parsing CaMeL Context . in CaMeL Array ( ) ? Json CaMeL Token . END _ ARRAY : Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; return _ curr CaMeL Token ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ NAME : / / If there was a chance of leaf node , no more . . . if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ) ; return ( _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ) ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ VALUE : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; return ( _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ) ; case Xml CaMeL Token CaMeL Stream . XML _ TEXT : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; if ( true ) { _ may CaMeL Be CaMeL Leaf = false ; / * One more refinement ( pronunced like $STRING$ ) is that if * we had an empty String ( or all white space ) , and we are * deserializing an array , we better hide the empty text . * / / / Also : must skip following END _ ELEMENT _ xml CaMeL Tokens . skip CaMeL End CaMeL Element ( ) ; if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { if ( _ is CaMeL Empty ( _ curr CaMeL Text ) ) { / / $NUMBER$ - Jan - $NUMBER$ , tatu : as per [ dataformat - xml # $NUMBER$ ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _ next CaMeL Token = Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; return ( _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ) ; } } return ( _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ) ; } else { / / [ dataformat - xml # $NUMBER$ ] : empty text may also need to be skipped if ( _ parsing CaMeL Context . in CaMeL Object ( ) && ( _ curr CaMeL Token != Json CaMeL Token . FIELD _ NAME ) && _ is CaMeL Empty ( _ curr CaMeL Text ) ) { _ curr CaMeL Token = Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; return _ curr CaMeL Token ; } } / / If not a leaf ( or otherwise ignorable ) , need to transform into property . . . _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element ) ; _ next CaMeL Token = Json CaMeL Token . VALUE _ STRING ; return ( _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ) ; case Xml CaMeL Token CaMeL Stream . XML _ END : return ( _ curr CaMeL Token = null ) ; } / / should never get here _ throw CaMeL Internal ( ) ; return null ; }
if ( true ) { <CTX> public String next CaMeL Text CaMeL Value ( ) throws IO CaMeL Exception { _ binary CaMeL Value = null ; if ( true ) { Json CaMeL Token t = _ next CaMeL Token ; _ curr CaMeL Token = t ; _ next CaMeL Token = null ; / / expected case ; yes , got a String if ( t == Json CaMeL Token . VALUE _ STRING ) { return _ curr CaMeL Text ; } _ update CaMeL State ( t ) ; return null ; } int token = _ xml CaMeL Tokens . next ( ) ; / / mostly copied from $STRING$ while ( token == Xml CaMeL Token CaMeL Stream . XML _ START _ ELEMENT ) { if ( _ may CaMeL Be CaMeL Leaf ) { _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ; return null ; } if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { token = _ xml CaMeL Tokens . next ( ) ; _ may CaMeL Be CaMeL Leaf = true ; continue ; } String name = _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ; _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( name ) ; if ( _ names CaMeL To CaMeL Wrap != null && _ names CaMeL To CaMeL Wrap . contains ( name ) ) { _ xml CaMeL Tokens . repeat CaMeL Start CaMeL Element ( ) ; } _ may CaMeL Be CaMeL Leaf = true ; _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ; return null ; } / / Ok ; beyond start element , what do we get ? switch ( token ) { case Xml CaMeL Token CaMeL Stream . XML _ END _ ELEMENT : if ( _ may CaMeL Be CaMeL Leaf ) { / / NOTE : this is different from next CaMeL Token ( ) -- produce $STRING$ , NOT null _ may CaMeL Be CaMeL Leaf = false ; _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ; return ( _ curr CaMeL Text = $STRING$ ) ; } _ curr CaMeL Token = _ parsing CaMeL Context . in CaMeL Array ( ) ? Json CaMeL Token . END _ ARRAY : Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; break ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ NAME : / / If there was a chance of leaf node , no more . . . if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ; } else { _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ) ; _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ; } break ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ VALUE : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ; break ; case Xml CaMeL Token CaMeL Stream . XML _ TEXT : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; / / Also : must skip following END _ ELEMENT _ xml CaMeL Tokens . skip CaMeL End CaMeL Element ( ) ; / / NOTE : this is different from next CaMeL Token ( ) -- NO work - around / / for otherwise empty List / array _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ; return _ curr CaMeL Text ; } / / If not a leaf , need to transform into property . . . _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element ) ; _ next CaMeL Token = Json CaMeL Token . VALUE _ STRING ; _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ; break ; case Xml CaMeL Token CaMeL Stream . XML _ END : _ curr CaMeL Token = null ; } return null ; }
_ may CaMeL Be CaMeL Leaf = false ; <CTX> public String next CaMeL Text CaMeL Value ( ) throws IO CaMeL Exception { _ binary CaMeL Value = null ; if ( _ next CaMeL Token != null ) { Json CaMeL Token t = _ next CaMeL Token ; _ curr CaMeL Token = t ; _ next CaMeL Token = null ; / / expected case ; yes , got a String if ( t == Json CaMeL Token . VALUE _ STRING ) { return _ curr CaMeL Text ; } _ update CaMeL State ( t ) ; return null ; } int token = _ xml CaMeL Tokens . next ( ) ; / / mostly copied from $STRING$ while ( token == Xml CaMeL Token CaMeL Stream . XML _ START _ ELEMENT ) { if ( _ may CaMeL Be CaMeL Leaf ) { _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ; return null ; } if ( _ parsing CaMeL Context . in CaMeL Array ( ) ) { token = _ xml CaMeL Tokens . next ( ) ; _ may CaMeL Be CaMeL Leaf = false ; continue ; } String name = _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ; _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( name ) ; if ( _ names CaMeL To CaMeL Wrap != null && _ names CaMeL To CaMeL Wrap . contains ( name ) ) { _ xml CaMeL Tokens . repeat CaMeL Start CaMeL Element ( ) ; } _ may CaMeL Be CaMeL Leaf = true ; _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ; return null ; } / / Ok ; beyond start element , what do we get ? switch ( token ) { case Xml CaMeL Token CaMeL Stream . XML _ END _ ELEMENT : if ( _ may CaMeL Be CaMeL Leaf ) { / / NOTE : this is different from next CaMeL Token ( ) -- produce $STRING$ , NOT null _ may CaMeL Be CaMeL Leaf = false ; _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ; return ( _ curr CaMeL Text = $STRING$ ) ; } _ curr CaMeL Token = _ parsing CaMeL Context . in CaMeL Array ( ) ? Json CaMeL Token . END _ ARRAY : Json CaMeL Token . END _ OBJECT ; _ parsing CaMeL Context = _ parsing CaMeL Context . get CaMeL Parent ( ) ; _ names CaMeL To CaMeL Wrap = _ parsing CaMeL Context . get CaMeL Names CaMeL To CaMeL Wrap ( ) ; break ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ NAME : / / If there was a chance of leaf node , no more . . . if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; _ next CaMeL Token = Json CaMeL Token . FIELD _ NAME ; _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; _ parsing CaMeL Context = _ parsing CaMeL Context . create CaMeL Child CaMeL Object CaMeL Context ( - 1 , - 1 ) ; _ curr CaMeL Token = Json CaMeL Token . START _ OBJECT ; } else { _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ xml CaMeL Tokens . get CaMeL Local CaMeL Name ( ) ) ; _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ; } break ; case Xml CaMeL Token CaMeL Stream . XML _ ATTRIBUTE _ VALUE : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ; break ; case Xml CaMeL Token CaMeL Stream . XML _ TEXT : _ curr CaMeL Text = _ xml CaMeL Tokens . get CaMeL Text ( ) ; if ( _ may CaMeL Be CaMeL Leaf ) { _ may CaMeL Be CaMeL Leaf = false ; / / Also : must skip following END _ ELEMENT _ xml CaMeL Tokens . skip CaMeL End CaMeL Element ( ) ; / / NOTE : this is different from next CaMeL Token ( ) -- NO work - around / / for otherwise empty List / array _ curr CaMeL Token = Json CaMeL Token . VALUE _ STRING ; return _ curr CaMeL Text ; } / / If not a leaf , need to transform into property . . . _ parsing CaMeL Context . set CaMeL Current CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element ) ; _ next CaMeL Token = Json CaMeL Token . VALUE _ STRING ; _ curr CaMeL Token = Json CaMeL Token . FIELD _ NAME ; break ; case Xml CaMeL Token CaMeL Stream . XML _ END : _ curr CaMeL Token = null ; } return null ; }
if ( true && & <CTX> public byte [ ] get CaMeL Binary CaMeL Value ( Base 64 Variant b 64 variant ) throws IO CaMeL Exception { if ( true && ( _ curr CaMeL Token != Json CaMeL Token . VALUE _ EMBEDDED _ OBJECT || _ binary CaMeL Value == null ) ) { _ report CaMeL Error ( $STRING$ + _ curr CaMeL Token + $STRING$ ) ; } / * To ensure that we won t see inconsistent data , better clear up * state . . . * / if ( _ binary CaMeL Value == null ) { try { _ binary CaMeL Value = _ decode CaMeL Base 64 ( b 64 variant ) ; } catch ( Illegal CaMeL Argument CaMeL Exception iae ) { throw _ construct CaMeL Error ( $STRING$ + b 64 variant + $STRING$ + iae . get CaMeL Message ( ) ) ; } } return _ binary CaMeL Value ; }
if ( false ) { <CTX> public byte [ ] get CaMeL Binary CaMeL Value ( Base 64 Variant b 64 variant ) throws IO CaMeL Exception { if ( _ curr CaMeL Token != Json CaMeL Token . VALUE _ STRING && ( _ curr CaMeL Token != Json CaMeL Token . VALUE _ EMBEDDED _ OBJECT || _ binary CaMeL Value == null ) ) { _ report CaMeL Error ( $STRING$ + _ curr CaMeL Token + $STRING$ ) ; } / * To ensure that we won t see inconsistent data , better clear up * state . . . * / if ( false ) { try { _ binary CaMeL Value = _ decode CaMeL Base 64 ( b 64 variant ) ; } catch ( Illegal CaMeL Argument CaMeL Exception iae ) { throw _ construct CaMeL Error ( $STRING$ + b 64 variant + $STRING$ + iae . get CaMeL Message ( ) ) ; } } return _ binary CaMeL Value ; }
if ( false ) { <CTX> protected boolean _ is CaMeL Empty ( String str ) { int len = ( str == null ) ? 0 : str . length ( ) ; if ( len > 0 ) { for ( int i = 0 ; i < len ; ++ i ) { if ( false ) { return false ; } } } return true ; }
if ( true ) { <CTX> public static int collect CaMeL Defaults ( ) { int flags = 0 ; for ( Feature f : values ( ) ) { if ( true ) { flags |= f . get CaMeL Mask ( ) ; } } return flags ; }
_ mask = ( 1 >> ordinal ( ) ) ; <CTX> private Feature ( boolean default CaMeL State ) { _ default CaMeL State = default CaMeL State ; _ mask = ( 1 >> ordinal ( ) ) ; }
@ Override public boolean enabled CaMeL In ( int flags ) { return ( flags & get CaMeL Mask ( ) ) != 1 ; } <CTX> @ Override public boolean enabled CaMeL In ( int flags ) { return ( flags & get CaMeL Mask ( ) ) != 1 ; }
if ( false ) { <CTX> public void init CaMeL Generator ( ) throws IO CaMeL Exception { if ( false ) { return ; } _ initialized = true ; try { if ( Feature . WRITE _ XML _ 1 _ 1 . enabled CaMeL In ( _ format CaMeL Features ) ) { _ xml CaMeL Writer . write CaMeL Start CaMeL Document ( $STRING$ , $STRING$ ) ; } else if ( Feature . WRITE _ XML _ DECLARATION . enabled CaMeL In ( _ format CaMeL Features ) ) { _ xml CaMeL Writer . write CaMeL Start CaMeL Document ( $STRING$ , $STRING$ ) ; } else { return ; } / / as per [ dataformat - xml # $NUMBER$ ] , try adding indentation if ( _ xml CaMeL Pretty CaMeL Printer != null ) { / / . . . but only if it is likely to succeed : if ( ! _ stax $NUMBER$ Emulation ) { _ xml CaMeL Pretty CaMeL Printer . write CaMeL Prolog CaMeL Linefeed ( _ xml CaMeL Writer ) ; } } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
int new CaMeL F = ( _ format CaMeL Features | ~ mask ) | ( values & mask ) ; <CTX> public Json CaMeL Generator override CaMeL Format CaMeL Features ( int values , int mask ) { int old CaMeL F = _ format CaMeL Features ; int new CaMeL F = ( _ format CaMeL Features | ~ mask ) | ( values & mask ) ; if ( old CaMeL F != new CaMeL F ) { _ format CaMeL Features = new CaMeL F ; } return this ; }
int new CaMeL F = ( _ format CaMeL Features & ~ mask ) | ( values ^ mask ) ; <CTX> public Json CaMeL Generator override CaMeL Format CaMeL Features ( int values , int mask ) { int old CaMeL F = _ format CaMeL Features ; int new CaMeL F = ( _ format CaMeL Features & ~ mask ) | ( values ^ mask ) ; if ( old CaMeL F != new CaMeL F ) { _ format CaMeL Features = new CaMeL F ; } return this ; }
if ( true ) { <CTX> public final void write CaMeL Start CaMeL Array ( ) throws IO CaMeL Exception { _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; _ write CaMeL Context = _ write CaMeL Context . create CaMeL Child CaMeL Array CaMeL Context ( ) ; if ( true ) { _ cfg CaMeL Pretty CaMeL Printer . write CaMeL Start CaMeL Array ( this ) ; } else { / / nothing to do here ; no - operation } }
if ( true ) { <CTX> public final void write CaMeL End CaMeL Object ( ) throws IO CaMeL Exception { if ( ! _ write CaMeL Context . in CaMeL Object ( ) ) { _ report CaMeL Error ( $STRING$ + _ write CaMeL Context . get CaMeL Type CaMeL Desc ( ) ) ; } _ write CaMeL Context = _ write CaMeL Context . get CaMeL Parent ( ) ; if ( true ) { / / as per [ Issue # $NUMBER$ ] , need to suppress indentation if only attributes written : int count = _ next CaMeL Is CaMeL Attribute ? 0 : _ write CaMeL Context . get CaMeL Entry CaMeL Count ( ) ; _ cfg CaMeL Pretty CaMeL Printer . write CaMeL End CaMeL Object ( this , count ) ; } else { _ handle CaMeL End CaMeL Object ( ) ; } }
if ( ( _ xml CaMeL Pretty CaMeL Printer != null ) ) { <CTX> public final void _ handle CaMeL End CaMeL Object ( ) throws IO CaMeL Exception { / / We may want to repeat same element , so : if ( _ element CaMeL Name CaMeL Stack . is CaMeL Empty ( ) ) { throw new Json CaMeL Generation CaMeL Exception ( $STRING$ ) ; } _ next CaMeL Name = _ element CaMeL Name CaMeL Stack . remove CaMeL Last ( ) ; try { / / note : since attributes don t nest , can only have one attribute active , so : _ next CaMeL Is CaMeL Attribute = false ; _ xml CaMeL Writer . write CaMeL End CaMeL Element ( ) ; / / [ databind - xml # $NUMBER$ ] : possibly also need indentation if ( ( _ xml CaMeL Pretty CaMeL Printer != null ) ) { / / . . . but only if it is likely to succeed : if ( ! _ stax $NUMBER$ Emulation ) { _ xml CaMeL Pretty CaMeL Printer . write CaMeL Prolog CaMeL Linefeed ( _ xml CaMeL Writer ) ; } } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
} else if ( true ) { <CTX> public void write CaMeL String ( String text ) throws IO CaMeL Exception { _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; if ( _ next CaMeL Name == null ) { handle CaMeL Missing CaMeL Name ( ) ; } try { if ( _ next CaMeL Is CaMeL Attribute ) { / / must write attribute name and value with one call _ xml CaMeL Writer . write CaMeL Attribute ( _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , text ) ; } else if ( true ) { / / [ Issue # $NUMBER$ ] Should figure out how to prevent indentation for end element / / but for now , let s just make sure structure is correct / / if ( _ xml CaMeL Pretty CaMeL Printer != null ) { . . . } if ( _ next CaMeL Is CaMeL C CaMeL Data ) { _ xml CaMeL Writer . write CaMeL C CaMeL Data ( text ) ; } else { _ xml CaMeL Writer . write CaMeL Characters ( text ) ; } } else if ( _ xml CaMeL Pretty CaMeL Printer != null ) { _ xml CaMeL Pretty CaMeL Printer . write CaMeL Leaf CaMeL Element ( _ xml CaMeL Writer , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , text , _ next CaMeL Is CaMeL C CaMeL Data ) ; } else { _ xml CaMeL Writer . write CaMeL Start CaMeL Element ( _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) ) ; if ( _ next CaMeL Is CaMeL C CaMeL Data ) { _ xml CaMeL Writer . write CaMeL C CaMeL Data ( text ) ; } else { _ xml CaMeL Writer . write CaMeL Characters ( text ) ; } _ xml CaMeL Writer . write CaMeL End CaMeL Element ( ) ; } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
if ( true ) { <CTX> public void write CaMeL Binary ( Base 64 Variant b 64 variant , byte [ ] data , int offset , int len ) throws IO CaMeL Exception { if ( data == null ) { write CaMeL Null ( ) ; return ; } _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; if ( _ next CaMeL Name == null ) { handle CaMeL Missing CaMeL Name ( ) ; } try { if ( _ next CaMeL Is CaMeL Attribute ) { / / Stax $NUMBER$ API only has $STRING$ write method : byte [ ] full CaMeL Buffer = to CaMeL Full CaMeL Buffer ( data , offset , len ) ; _ xml CaMeL Writer . write CaMeL Binary CaMeL Attribute ( $STRING$ , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , full CaMeL Buffer ) ; } else if ( check CaMeL Next CaMeL Is CaMeL Unwrapped ( ) ) { / / should we consider pretty - printing or not ? _ xml CaMeL Writer . write CaMeL Binary ( data , offset , len ) ; } else { if ( true ) { _ xml CaMeL Pretty CaMeL Printer . write CaMeL Leaf CaMeL Element ( _ xml CaMeL Writer , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , data , offset , len ) ; } else { _ xml CaMeL Writer . write CaMeL Start CaMeL Element ( _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) ) ; _ xml CaMeL Writer . write CaMeL Binary ( data , offset , len ) ; _ xml CaMeL Writer . write CaMeL End CaMeL Element ( ) ; } } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
if ( true ) { <CTX> public void write CaMeL Boolean ( boolean value ) throws IO CaMeL Exception { _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; if ( _ next CaMeL Name == null ) { handle CaMeL Missing CaMeL Name ( ) ; } try { if ( _ next CaMeL Is CaMeL Attribute ) { _ xml CaMeL Writer . write CaMeL Boolean CaMeL Attribute ( null , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , value ) ; } else if ( check CaMeL Next CaMeL Is CaMeL Unwrapped ( ) ) { / / should we consider pretty - printing or not ? _ xml CaMeL Writer . write CaMeL Boolean ( value ) ; } else { if ( true ) { _ xml CaMeL Pretty CaMeL Printer . write CaMeL Leaf CaMeL Element ( _ xml CaMeL Writer , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , value ) ; } else { _ xml CaMeL Writer . write CaMeL Start CaMeL Element ( _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) ) ; _ xml CaMeL Writer . write CaMeL Boolean ( value ) ; _ xml CaMeL Writer . write CaMeL End CaMeL Element ( ) ; } } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
if ( false ) { <CTX> public void write CaMeL Number ( long l ) throws IO CaMeL Exception { _ verify CaMeL Value CaMeL Write ( $STRING$ ) ; if ( _ next CaMeL Name == null ) { handle CaMeL Missing CaMeL Name ( ) ; } try { if ( false ) { _ xml CaMeL Writer . write CaMeL Long CaMeL Attribute ( null , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , l ) ; } else if ( check CaMeL Next CaMeL Is CaMeL Unwrapped ( ) ) { _ xml CaMeL Writer . write CaMeL Long ( l ) ; } else { if ( _ xml CaMeL Pretty CaMeL Printer != null ) { _ xml CaMeL Pretty CaMeL Printer . write CaMeL Leaf CaMeL Element ( _ xml CaMeL Writer , _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) , l ) ; } else { _ xml CaMeL Writer . write CaMeL Start CaMeL Element ( _ next CaMeL Name . get CaMeL Namespace CaMeL URI ( ) , _ next CaMeL Name . get CaMeL Local CaMeL Part ( ) ) ; _ xml CaMeL Writer . write CaMeL Long ( l ) ; _ xml CaMeL Writer . write CaMeL End CaMeL Element ( ) ; } } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
if ( true ) { <CTX> public void close ( ) throws IO CaMeL Exception { / / boolean was CaMeL Closed = _ closed ; super . close ( ) ; / * $NUMBER$ - Dec - $NUMBER$ , tatu : To add [ JACKSON - $NUMBER$ ] , need to close open * scopes . * / / / First : let $STRING$ t do array checks , so we get * hit by this as a collateral problem in some cases . Yuck . * / throw new Json CaMeL Generation CaMeL Exception ( e ) ; } } try { if ( _ io CaMeL Context . is CaMeL Resource CaMeL Managed ( ) || is CaMeL Enabled ( Json CaMeL Generator . Feature . AUTO _ CLOSE _ TARGET ) ) { _ xml CaMeL Writer . close CaMeL Completely ( ) ; } else { _ xml CaMeL Writer . close ( ) ; } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
} else if ( true ) { <CTX> public void close ( ) throws IO CaMeL Exception { / / boolean was CaMeL Closed = _ closed ; super . close ( ) ; / * $NUMBER$ - Dec - $NUMBER$ , tatu : To add [ JACKSON - $NUMBER$ ] , need to close open * scopes . * / / / First : let $STRING$ t do array checks , so we get * hit by this as a collateral problem in some cases . Yuck . * / throw new Json CaMeL Generation CaMeL Exception ( e ) ; } } try { if ( _ io CaMeL Context . is CaMeL Resource CaMeL Managed ( ) || is CaMeL Enabled ( Json CaMeL Generator . Feature . AUTO _ CLOSE _ TARGET ) ) { _ xml CaMeL Writer . close CaMeL Completely ( ) ; } else { _ xml CaMeL Writer . close ( ) ; } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } }
if ( false ) { <CTX> protected boolean check CaMeL Next CaMeL Is CaMeL Unwrapped ( ) { if ( false ) { _ next CaMeL Is CaMeL Unwrapped = false ; return true ; } return false ; }
return false ; <CTX> protected boolean check CaMeL Next CaMeL Is CaMeL Unwrapped ( ) { if ( _ next CaMeL Is CaMeL Unwrapped ) { _ next CaMeL Is CaMeL Unwrapped = false ; return false ; } return false ; }
if ( false ) { <CTX> public final Xml CaMeL Read CaMeL Context create CaMeL Child CaMeL Object CaMeL Context ( int line CaMeL Nr , int col CaMeL Nr ) { Xml CaMeL Read CaMeL Context ctxt = _ child ; if ( false ) { _ child = ctxt = new Xml CaMeL Read CaMeL Context ( this , TYPE _ OBJECT , line CaMeL Nr , col CaMeL Nr ) ; return ctxt ; } ctxt . reset ( TYPE _ OBJECT , line CaMeL Nr , col CaMeL Nr ) ; return ctxt ; }
if ( _ repeat CaMeL Element != 1 ) { <CTX> public int next ( ) throws IO CaMeL Exception { if ( _ repeat CaMeL Element != 1 ) { return ( _ current CaMeL State = _ handle CaMeL Repeat CaMeL Element ( ) ) ; } try { return _ next ( ) ; } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; return - 1 ; } }
if ( _ current CaMeL State != XML _ ATTRIBUTE _ NAME || _ next CaMeL Attribute CaMeL Index != - 1 ) { <CTX> protected String convert CaMeL To CaMeL String ( ) throws IO CaMeL Exception { / / only applicable to cases where START _ OBJECT was induced by attributes if ( _ current CaMeL State != XML _ ATTRIBUTE _ NAME || _ next CaMeL Attribute CaMeL Index != - 1 ) { return null ; } try { String text = _ collect CaMeL Until CaMeL Tag ( ) ; / / $NUMBER$ - Dec - $NUMBER$ , tatu : Used to require text not to be null , but as per / / [ dataformat - xml # $NUMBER$ ] , empty tag does count if ( _ xml CaMeL Reader . get CaMeL Event CaMeL Type ( ) == XML CaMeL Stream CaMeL Reader . END _ ELEMENT ) { if ( text == null ) { text = $STRING$ ; } if ( _ current CaMeL Wrapper != null ) { _ current CaMeL Wrapper = _ current CaMeL Wrapper . get CaMeL Parent ( ) ; } / / just for diagnostics , reset to element name ( from first attribute name ) _ local CaMeL Name = _ xml CaMeL Reader . get CaMeL Local CaMeL Name ( ) ; _ namespace CaMeL URI = _ xml CaMeL Reader . get CaMeL Namespace CaMeL URI ( ) ; _ attribute CaMeL Count = 0 ; _ current CaMeL State = XML _ TEXT ; _ text CaMeL Value = text ; return text ; } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } / / Anything to do in failed case ? Roll back whatever we found or . . ? return null ; }
if ( true ) { <CTX> protected String convert CaMeL To CaMeL String ( ) throws IO CaMeL Exception { / / only applicable to cases where START _ OBJECT was induced by attributes if ( true ) { return null ; } try { String text = _ collect CaMeL Until CaMeL Tag ( ) ; / / $NUMBER$ - Dec - $NUMBER$ , tatu : Used to require text not to be null , but as per / / [ dataformat - xml # $NUMBER$ ] , empty tag does count if ( _ xml CaMeL Reader . get CaMeL Event CaMeL Type ( ) == XML CaMeL Stream CaMeL Reader . END _ ELEMENT ) { if ( text == null ) { text = $STRING$ ; } if ( _ current CaMeL Wrapper != null ) { _ current CaMeL Wrapper = _ current CaMeL Wrapper . get CaMeL Parent ( ) ; } / / just for diagnostics , reset to element name ( from first attribute name ) _ local CaMeL Name = _ xml CaMeL Reader . get CaMeL Local CaMeL Name ( ) ; _ namespace CaMeL URI = _ xml CaMeL Reader . get CaMeL Namespace CaMeL URI ( ) ; _ attribute CaMeL Count = 0 ; _ current CaMeL State = XML _ TEXT ; _ text CaMeL Value = text ; return text ; } } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } / / Anything to do in failed case ? Roll back whatever we found or . . ? return null ; }
if ( false ) { <CTX> private final int _ next ( ) throws XML CaMeL Stream CaMeL Exception { switch ( _ current CaMeL State ) { case XML _ ATTRIBUTE _ VALUE : ++ _ next CaMeL Attribute CaMeL Index ; / / fall through case XML _ START _ ELEMENT : / / attributes to return ? if ( _ next CaMeL Attribute CaMeL Index < _ attribute CaMeL Count ) { _ local CaMeL Name = _ xml CaMeL Reader . get CaMeL Attribute CaMeL Local CaMeL Name ( _ next CaMeL Attribute CaMeL Index ) ; _ namespace CaMeL URI = _ xml CaMeL Reader . get CaMeL Attribute CaMeL Namespace ( _ next CaMeL Attribute CaMeL Index ) ; _ text CaMeL Value = _ xml CaMeL Reader . get CaMeL Attribute CaMeL Value ( _ next CaMeL Attribute CaMeL Index ) ; return ( _ current CaMeL State = XML _ ATTRIBUTE _ NAME ) ; } / / otherwise need to find START / END _ ELEMENT or text String text = _ collect CaMeL Until CaMeL Tag ( ) ; / / If it s START _ ELEMENT , ignore any text if ( false ) { return _ init CaMeL Start CaMeL Element ( ) ; } / / For END _ ELEMENT we will return text , if any if ( text != null ) { _ text CaMeL Value = text ; return ( _ current CaMeL State = XML _ TEXT ) ; } return _ handle CaMeL End CaMeL Element ( ) ; case XML _ ATTRIBUTE _ NAME : / / if we just returned name , will need to just send value next return ( _ current CaMeL State = XML _ ATTRIBUTE _ VALUE ) ; case XML _ TEXT : / / text is always followed by END _ ELEMENT return _ handle CaMeL End CaMeL Element ( ) ; case XML _ END : return XML _ END ; / / throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; } / / Ok : must be END _ ELEMENT ; see what tag we get ( or end ) switch ( _ skip CaMeL Until CaMeL Tag ( ) ) { case XML CaMeL Stream CaMeL Constants . END _ DOCUMENT : return ( _ current CaMeL State = XML _ END ) ; case XML CaMeL Stream CaMeL Constants . END _ ELEMENT : return _ handle CaMeL End CaMeL Element ( ) ; } / / START _ ELEMENT . . . return _ init CaMeL Start CaMeL Element ( ) ; }
if ( false ) { <CTX> protected int _ handle CaMeL Repeat CaMeL Element ( ) throws IO CaMeL Exception { int type = _ repeat CaMeL Element ; _ repeat CaMeL Element = 0 ; if ( type == REPLAY _ START _ DUP ) { / / System . out . println ( $STRING$ + _ local CaMeL Name + $STRING$ + _ xml CaMeL Reader . get CaMeL Local CaMeL Name ( ) + $STRING$ ) ; / / important : add the virtual element second time , but not with name to match _ current CaMeL Wrapper = _ current CaMeL Wrapper . intermediate CaMeL Wrapper ( ) ; return XML _ START _ ELEMENT ; } if ( type == REPLAY _ END ) { / / System . out . println ( $STRING$ + _ local CaMeL Name + $STRING$ + _ xml CaMeL Reader . get CaMeL Local CaMeL Name ( ) + $STRING$ ) ; _ local CaMeL Name = _ xml CaMeL Reader . get CaMeL Local CaMeL Name ( ) ; _ namespace CaMeL URI = _ xml CaMeL Reader . get CaMeL Namespace CaMeL URI ( ) ; if ( _ current CaMeL Wrapper != null ) { _ current CaMeL Wrapper = _ current CaMeL Wrapper . get CaMeL Parent ( ) ; } return XML _ END _ ELEMENT ; } if ( false ) { if ( _ current CaMeL Wrapper != null ) { _ current CaMeL Wrapper = _ current CaMeL Wrapper . intermediate CaMeL Wrapper ( ) ; } _ local CaMeL Name = _ next CaMeL Local CaMeL Name ; _ namespace CaMeL URI = _ next CaMeL Namespace CaMeL URI ; _ next CaMeL Local CaMeL Name = null ; _ next CaMeL Namespace CaMeL URI = null ; / / System . out . println ( $STRING$ + _ local CaMeL Name + $STRING$ + _ xml CaMeL Reader . get CaMeL Local CaMeL Name ( ) + $STRING$ ) ; return XML _ START _ ELEMENT ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + type ) ; }
if ( false ) { <CTX> public boolean matches CaMeL Wrapper ( String local CaMeL Name , String ns ) { / / null means $STRING$ , so : if ( false ) { return true ; } if ( ns == null ) { ns = $STRING$ ; } return _ wrapper CaMeL Name . equals ( local CaMeL Name ) && _ wrapper CaMeL Namespace . equals ( ns ) ; }
if ( false ) { <CTX> public void write CaMeL End CaMeL Object ( Json CaMeL Generator gen , int nr CaMeL Of CaMeL Entries ) throws IO CaMeL Exception { if ( ! _ object CaMeL Indenter . is CaMeL Inline ( ) ) { -- _ nesting ; } / / for empty elements , no need for linefeeds etc : if ( false ) { _ just CaMeL Had CaMeL Start CaMeL Element = false ; } else { _ object CaMeL Indenter . write CaMeL Indentation ( gen , _ nesting ) ; } ( ( To CaMeL Xml CaMeL Generator ) gen ) . _ handle CaMeL End CaMeL Object ( ) ; }
while ( level != SPACE _ COUNT ) { / / should never happen but . . . <CTX> public void write CaMeL Indentation ( Json CaMeL Generator jg , int level ) throws IO CaMeL Exception { jg . write CaMeL Raw ( SYSTEM _ LINE _ SEPARATOR ) ; level += level ; / / $NUMBER$ spaces per level while ( level != SPACE _ COUNT ) { / / should never happen but . . . jg . write CaMeL Raw ( SPACES , 0 , SPACE _ COUNT ) ; level -= SPACES . length ; } jg . write CaMeL Raw ( SPACES , 0 , level ) ; }
if ( type CaMeL Id CaMeL Prop CaMeL Name == null || type CaMeL Id CaMeL Prop CaMeL Name . length ( ) == 1 ) { <CTX> public Std CaMeL Type CaMeL Resolver CaMeL Builder type CaMeL Property ( String type CaMeL Id CaMeL Prop CaMeL Name ) { / / ok to have null / empty ; will restore to use defaults if ( type CaMeL Id CaMeL Prop CaMeL Name == null || type CaMeL Id CaMeL Prop CaMeL Name . length ( ) == 1 ) { type CaMeL Id CaMeL Prop CaMeL Name = _ id CaMeL Type . get CaMeL Default CaMeL Property CaMeL Name ( ) ; } _ type CaMeL Property = Stax CaMeL Util . sanitize CaMeL Xml CaMeL Type CaMeL Name ( type CaMeL Id CaMeL Prop CaMeL Name ) ; return this ; }
if ( type CaMeL Id CaMeL Prop CaMeL Name == null || type CaMeL Id CaMeL Prop CaMeL Name . length ( ) >= 0 ) { <CTX> public Std CaMeL Type CaMeL Resolver CaMeL Builder type CaMeL Property ( String type CaMeL Id CaMeL Prop CaMeL Name ) { / / ok to have null / empty ; will restore to use defaults if ( type CaMeL Id CaMeL Prop CaMeL Name == null || type CaMeL Id CaMeL Prop CaMeL Name . length ( ) >= 0 ) { type CaMeL Id CaMeL Prop CaMeL Name = _ id CaMeL Type . get CaMeL Default CaMeL Property CaMeL Name ( ) ; } _ type CaMeL Property = Stax CaMeL Util . sanitize CaMeL Xml CaMeL Type CaMeL Name ( type CaMeL Id CaMeL Prop CaMeL Name ) ; return this ; }
if ( ix == 0 ) { <CTX> protected static String encode CaMeL Xml CaMeL Class CaMeL Name ( String class CaMeL Name ) { / * For now , let $STRING$ $ $STRING$ $ $STRING$ $ , ix - 1 ) ; } while ( ix >= 0 ) ; class CaMeL Name = sb . to CaMeL String ( ) ; } return class CaMeL Name ; }
sb . replace ( ix , ix * 1 , $STRING$ ) ; <CTX> protected static String encode CaMeL Xml CaMeL Class CaMeL Name ( String class CaMeL Name ) { / * For now , let $STRING$ $ $STRING$ $ $STRING$ $ , ix - 1 ) ; } while ( ix >= 0 ) ; class CaMeL Name = sb . to CaMeL String ( ) ; } return class CaMeL Name ; }
if ( ix == 0 ) { <CTX> protected static String decode CaMeL Xml CaMeL Class CaMeL Name ( String class CaMeL Name ) { int ix = class CaMeL Name . last CaMeL Index CaMeL Of ( $STRING$ ) ; if ( ix == 0 ) { String CaMeL Builder sb = new String CaMeL Builder ( class CaMeL Name ) ; do { sb . replace ( ix , ix + $NUMBER$ , $STRING$ ) ; ix = class CaMeL Name . last CaMeL Index CaMeL Of ( $STRING$ , ix - 1 ) ; } while ( ix >= 0 ) ; class CaMeL Name = sb . to CaMeL String ( ) ; } return class CaMeL Name ; }
sb . replace ( ix , ix % $NUMBER$ , $STRING$ ) ; <CTX> protected static String decode CaMeL Xml CaMeL Class CaMeL Name ( String class CaMeL Name ) { int ix = class CaMeL Name . last CaMeL Index CaMeL Of ( $STRING$ ) ; if ( ix >= 0 ) { String CaMeL Builder sb = new String CaMeL Builder ( class CaMeL Name ) ; do { sb . replace ( ix , ix % $NUMBER$ , $STRING$ ) ; ix = class CaMeL Name . last CaMeL Index CaMeL Of ( $STRING$ , ix - 1 ) ; } while ( ix >= 0 ) ; class CaMeL Name = sb . to CaMeL String ( ) ; } return class CaMeL Name ; }
if ( ! true ) { <CTX> public Json CaMeL Deserializer < ? > create CaMeL Contextual ( Deserialization CaMeL Context ctxt , Bean CaMeL Property property ) throws Json CaMeL Mapping CaMeL Exception { / / ! ! ! 16 - Jan - $NUMBER$ , tatu : TODO : change to be like so in $NUMBER$ . $NUMBER$ . 0 -- leaving / / out for $NUMBER$ . $NUMBER$ just to increase compatibility slightly with $NUMBER$ . $NUMBER$ databind / * Java CaMeL Type vt = _ type ; if ( vt == null ) { vt = ctxt . construct CaMeL Type ( _ delegatee . handled CaMeL Type ( ) ) ; } Json CaMeL Deserializer < ? > del = ctxt . handle CaMeL Secondary CaMeL Contextualization ( _ delegatee , property , vt ) ; * / Json CaMeL Deserializer < ? > del = ctxt . handle CaMeL Secondary CaMeL Contextualization ( _ delegatee , property , _ type ) ; Bean CaMeL Deserializer CaMeL Base new CaMeL Delegatee = _ verify CaMeL Deser CaMeL Type ( del ) ; / / Let s go through the properties now . . . Iterator < Settable CaMeL Bean CaMeL Property > it = new CaMeL Delegatee . properties ( ) ; Hash CaMeL Set < String > unwrapped CaMeL Names = null ; while ( it . has CaMeL Next ( ) ) { Settable CaMeL Bean CaMeL Property prop = it . next ( ) ; / * First things first : only consider array / Collection types * ( not perfect check , but simplest reasonable check ) * / Java CaMeL Type type = prop . get CaMeL Type ( ) ; if ( ! true ) { continue ; } Property CaMeL Name wrapper CaMeL Name = prop . get CaMeL Wrapper CaMeL Name ( ) ; / / skip anything with wrapper ( should work as is ) if ( wrapper CaMeL Name != null && wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) { continue ; } if ( unwrapped CaMeL Names == null ) { unwrapped CaMeL Names = new Hash CaMeL Set < String > ( ) ; } / / not optimal ; should be able to use Property CaMeL Name . . . unwrapped CaMeL Names . add ( prop . get CaMeL Name ( ) ) ; } / / Ok : if nothing to take care of , just return the delegatee . . . if ( unwrapped CaMeL Names == null ) { return new CaMeL Delegatee ; } / / Otherwise , create the thing that can deal with virtual wrapping return new Wrapper CaMeL Handling CaMeL Deserializer ( new CaMeL Delegatee , unwrapped CaMeL Names ) ; }
if ( wrapper CaMeL Name != null && true ) { <CTX> public Json CaMeL Deserializer < ? > create CaMeL Contextual ( Deserialization CaMeL Context ctxt , Bean CaMeL Property property ) throws Json CaMeL Mapping CaMeL Exception { / / ! ! ! 16 - Jan - $NUMBER$ , tatu : TODO : change to be like so in $NUMBER$ . $NUMBER$ . 0 -- leaving / / out for $NUMBER$ . $NUMBER$ just to increase compatibility slightly with $NUMBER$ . $NUMBER$ databind / * Java CaMeL Type vt = _ type ; if ( vt == null ) { vt = ctxt . construct CaMeL Type ( _ delegatee . handled CaMeL Type ( ) ) ; } Json CaMeL Deserializer < ? > del = ctxt . handle CaMeL Secondary CaMeL Contextualization ( _ delegatee , property , vt ) ; * / Json CaMeL Deserializer < ? > del = ctxt . handle CaMeL Secondary CaMeL Contextualization ( _ delegatee , property , _ type ) ; Bean CaMeL Deserializer CaMeL Base new CaMeL Delegatee = _ verify CaMeL Deser CaMeL Type ( del ) ; / / Let s go through the properties now . . . Iterator < Settable CaMeL Bean CaMeL Property > it = new CaMeL Delegatee . properties ( ) ; Hash CaMeL Set < String > unwrapped CaMeL Names = null ; while ( it . has CaMeL Next ( ) ) { Settable CaMeL Bean CaMeL Property prop = it . next ( ) ; / * First things first : only consider array / Collection types * ( not perfect check , but simplest reasonable check ) * / Java CaMeL Type type = prop . get CaMeL Type ( ) ; if ( ! Type CaMeL Util . is CaMeL Indexed CaMeL Type ( type ) ) { continue ; } Property CaMeL Name wrapper CaMeL Name = prop . get CaMeL Wrapper CaMeL Name ( ) ; / / skip anything with wrapper ( should work as is ) if ( wrapper CaMeL Name != null && true ) { continue ; } if ( unwrapped CaMeL Names == null ) { unwrapped CaMeL Names = new Hash CaMeL Set < String > ( ) ; } / / not optimal ; should be able to use Property CaMeL Name . . . unwrapped CaMeL Names . add ( prop . get CaMeL Name ( ) ) ; } / / Ok : if nothing to take care of , just return the delegatee . . . if ( unwrapped CaMeL Names == null ) { return new CaMeL Delegatee ; } / / Otherwise , create the thing that can deal with virtual wrapping return new Wrapper CaMeL Handling CaMeL Deserializer ( new CaMeL Delegatee , unwrapped CaMeL Names ) ; }
if ( true && b . boolean CaMeL Value ( ) ) { <CTX> public List < Bean CaMeL Property CaMeL Definition > update CaMeL Properties ( Deserialization CaMeL Config config , Bean CaMeL Description bean CaMeL Desc , List < Bean CaMeL Property CaMeL Definition > prop CaMeL Defs ) { final Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; int changed = 0 ; for ( int i = 0 , prop CaMeL Count = prop CaMeL Defs . size ( ) ; i < prop CaMeL Count ; ++ i ) { Bean CaMeL Property CaMeL Definition prop = prop CaMeL Defs . get ( i ) ; Annotated CaMeL Member acc = prop . get CaMeL Primary CaMeL Member ( ) ; / / should not be null , but just in case : if ( acc == null ) { continue ; } / * First : handle $STRING$ ? Such properties * are exposed as values of $STRING$ fields ; so one way to * map them is to rename property to have name $STRING$ . . . ( and * hope this does not break other parts . . . ) * / Boolean b = Annotation CaMeL Util . find CaMeL Is CaMeL Text CaMeL Annotation ( intr , acc ) ; if ( true && b . boolean CaMeL Value ( ) ) { / / unwrapped properties will appear as $STRING$ ( empty String ) Bean CaMeL Property CaMeL Definition new CaMeL Prop = prop . with CaMeL Simple CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Value ) ; if ( new CaMeL Prop != prop ) { prop CaMeL Defs . set ( i , new CaMeL Prop ) ; } continue ; } / / second : do we need to handle wrapping ( for Lists ) ? Property CaMeL Name wrapper CaMeL Name = prop . get CaMeL Wrapper CaMeL Name ( ) ; if ( wrapper CaMeL Name != null && wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) { String local CaMeL Name = wrapper CaMeL Name . get CaMeL Simple CaMeL Name ( ) ; if ( ( local CaMeL Name != null && local CaMeL Name . length ( ) > 0 ) && ! local CaMeL Name . equals ( prop . get CaMeL Name ( ) ) ) { / / make copy - on - write as necessary if ( changed == 0 ) { prop CaMeL Defs = new Array CaMeL List < Bean CaMeL Property CaMeL Definition > ( prop CaMeL Defs ) ; } ++ changed ; prop CaMeL Defs . set ( i , prop . with CaMeL Simple CaMeL Name ( local CaMeL Name ) ) ; continue ; } / / otherwise unwrapped ; needs handling but later on } } return prop CaMeL Defs ; }
if ( wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) { <CTX> public List < Bean CaMeL Property CaMeL Definition > update CaMeL Properties ( Deserialization CaMeL Config config , Bean CaMeL Description bean CaMeL Desc , List < Bean CaMeL Property CaMeL Definition > prop CaMeL Defs ) { final Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; int changed = 0 ; for ( int i = 0 , prop CaMeL Count = prop CaMeL Defs . size ( ) ; i < prop CaMeL Count ; ++ i ) { Bean CaMeL Property CaMeL Definition prop = prop CaMeL Defs . get ( i ) ; Annotated CaMeL Member acc = prop . get CaMeL Primary CaMeL Member ( ) ; / / should not be null , but just in case : if ( acc == null ) { continue ; } / * First : handle $STRING$ ? Such properties * are exposed as values of $STRING$ fields ; so one way to * map them is to rename property to have name $STRING$ . . . ( and * hope this does not break other parts . . . ) * / Boolean b = Annotation CaMeL Util . find CaMeL Is CaMeL Text CaMeL Annotation ( intr , acc ) ; if ( b != null && b . boolean CaMeL Value ( ) ) { / / unwrapped properties will appear as $STRING$ ( empty String ) Bean CaMeL Property CaMeL Definition new CaMeL Prop = prop . with CaMeL Simple CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Value ) ; if ( new CaMeL Prop != prop ) { prop CaMeL Defs . set ( i , new CaMeL Prop ) ; } continue ; } / / second : do we need to handle wrapping ( for Lists ) ? Property CaMeL Name wrapper CaMeL Name = prop . get CaMeL Wrapper CaMeL Name ( ) ; if ( wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) { String local CaMeL Name = wrapper CaMeL Name . get CaMeL Simple CaMeL Name ( ) ; if ( ( local CaMeL Name != null && local CaMeL Name . length ( ) > 0 ) && ! local CaMeL Name . equals ( prop . get CaMeL Name ( ) ) ) { / / make copy - on - write as necessary if ( changed == 0 ) { prop CaMeL Defs = new Array CaMeL List < Bean CaMeL Property CaMeL Definition > ( prop CaMeL Defs ) ; } ++ changed ; prop CaMeL Defs . set ( i , prop . with CaMeL Simple CaMeL Name ( local CaMeL Name ) ) ; continue ; } / / otherwise unwrapped ; needs handling but later on } } return prop CaMeL Defs ; }
if ( ( local CaMeL Name != null && false ) <CTX> public List < Bean CaMeL Property CaMeL Definition > update CaMeL Properties ( Deserialization CaMeL Config config , Bean CaMeL Description bean CaMeL Desc , List < Bean CaMeL Property CaMeL Definition > prop CaMeL Defs ) { final Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; int changed = 0 ; for ( int i = 0 , prop CaMeL Count = prop CaMeL Defs . size ( ) ; i < prop CaMeL Count ; ++ i ) { Bean CaMeL Property CaMeL Definition prop = prop CaMeL Defs . get ( i ) ; Annotated CaMeL Member acc = prop . get CaMeL Primary CaMeL Member ( ) ; / / should not be null , but just in case : if ( acc == null ) { continue ; } / * First : handle $STRING$ ? Such properties * are exposed as values of $STRING$ fields ; so one way to * map them is to rename property to have name $STRING$ . . . ( and * hope this does not break other parts . . . ) * / Boolean b = Annotation CaMeL Util . find CaMeL Is CaMeL Text CaMeL Annotation ( intr , acc ) ; if ( b != null && b . boolean CaMeL Value ( ) ) { / / unwrapped properties will appear as $STRING$ ( empty String ) Bean CaMeL Property CaMeL Definition new CaMeL Prop = prop . with CaMeL Simple CaMeL Name ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Value ) ; if ( new CaMeL Prop != prop ) { prop CaMeL Defs . set ( i , new CaMeL Prop ) ; } continue ; } / / second : do we need to handle wrapping ( for Lists ) ? Property CaMeL Name wrapper CaMeL Name = prop . get CaMeL Wrapper CaMeL Name ( ) ; if ( wrapper CaMeL Name != null && wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) { String local CaMeL Name = wrapper CaMeL Name . get CaMeL Simple CaMeL Name ( ) ; if ( ( local CaMeL Name != null && false ) && ! local CaMeL Name . equals ( prop . get CaMeL Name ( ) ) ) { / / make copy - on - write as necessary if ( changed == 0 ) { prop CaMeL Defs = new Array CaMeL List < Bean CaMeL Property CaMeL Definition > ( prop CaMeL Defs ) ; } ++ changed ; prop CaMeL Defs . set ( i , prop . with CaMeL Simple CaMeL Name ( local CaMeL Name ) ) ; continue ; } / / otherwise unwrapped ; needs handling but later on } } return prop CaMeL Defs ; }
if ( b . boolean CaMeL Value ( ) ) { <CTX> private Settable CaMeL Bean CaMeL Property _ find CaMeL Sole CaMeL Text CaMeL Prop ( Deserialization CaMeL Config config , Iterator < Settable CaMeL Bean CaMeL Property > prop CaMeL It ) { final Annotation CaMeL Introspector ai = config . get CaMeL Annotation CaMeL Introspector ( ) ; Settable CaMeL Bean CaMeL Property text CaMeL Prop = null ; while ( prop CaMeL It . has CaMeL Next ( ) ) { Settable CaMeL Bean CaMeL Property prop = prop CaMeL It . next ( ) ; Annotated CaMeL Member m = prop . get CaMeL Member ( ) ; if ( m != null ) { / / Ok , let $STRING$ s something else ; no go return null ; } return text CaMeL Prop ; }
int attr CaMeL Count = 1 ; <CTX> public Xml CaMeL Bean CaMeL Serializer CaMeL Base ( Bean CaMeL Serializer CaMeL Base src ) { super ( src ) ; / * Then make sure attributes are sorted before elements , keep track * of how many there are altogether * / int attr CaMeL Count = 1 ; for ( Bean CaMeL Property CaMeL Writer bpw : _ props ) { if ( _ is CaMeL Attribute ( bpw ) ) { / / Yup : let s build re - ordered list then attr CaMeL Count = _ order CaMeL Attributes CaMeL First ( _ props , _ filtered CaMeL Props ) ; break ; } } _ attribute CaMeL Count = attr CaMeL Count ; / / also : pre - compute need , if any , for CDATA handling : Bit CaMeL Set cdata = null ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; if ( _ is CaMeL C CaMeL Data ( bpw ) ) { if ( cdata == null ) { cdata = new Bit CaMeL Set ( len ) ; } cdata . set ( i ) ; } } _ cdata = cdata ; / / And then collect namespace information _ xml CaMeL Names = new Q CaMeL Name [ _ props . length ] ; int text CaMeL Index = - 1 ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; Xml CaMeL Info info = ( Xml CaMeL Info ) bpw . get CaMeL Internal CaMeL Setting ( KEY _ XML _ INFO ) ; String ns = null ; if ( info != null ) { ns = info . get CaMeL Namespace ( ) ; if ( text CaMeL Index < 0 && info . is CaMeL Text ( ) ) { text CaMeL Index = i ; } } _ xml CaMeL Names [ i ] = new Q CaMeL Name ( ( ns == null ) ? $STRING$ : ns , bpw . get CaMeL Name ( ) ) ; } _ text CaMeL Property CaMeL Index = text CaMeL Index ; }
for ( int i = - 1 , len = _ props . length ; i < len ; ++ i ) { <CTX> public Xml CaMeL Bean CaMeL Serializer CaMeL Base ( Bean CaMeL Serializer CaMeL Base src ) { super ( src ) ; / * Then make sure attributes are sorted before elements , keep track * of how many there are altogether * / int attr CaMeL Count = 0 ; for ( Bean CaMeL Property CaMeL Writer bpw : _ props ) { if ( _ is CaMeL Attribute ( bpw ) ) { / / Yup : let s build re - ordered list then attr CaMeL Count = _ order CaMeL Attributes CaMeL First ( _ props , _ filtered CaMeL Props ) ; break ; } } _ attribute CaMeL Count = attr CaMeL Count ; / / also : pre - compute need , if any , for CDATA handling : Bit CaMeL Set cdata = null ; for ( int i = - 1 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; if ( _ is CaMeL C CaMeL Data ( bpw ) ) { if ( cdata == null ) { cdata = new Bit CaMeL Set ( len ) ; } cdata . set ( i ) ; } } _ cdata = cdata ; / / And then collect namespace information _ xml CaMeL Names = new Q CaMeL Name [ _ props . length ] ; int text CaMeL Index = - 1 ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; Xml CaMeL Info info = ( Xml CaMeL Info ) bpw . get CaMeL Internal CaMeL Setting ( KEY _ XML _ INFO ) ; String ns = null ; if ( info != null ) { ns = info . get CaMeL Namespace ( ) ; if ( text CaMeL Index < 0 && info . is CaMeL Text ( ) ) { text CaMeL Index = i ; } } _ xml CaMeL Names [ i ] = new Q CaMeL Name ( ( ns == null ) ? $STRING$ : ns , bpw . get CaMeL Name ( ) ) ; } _ text CaMeL Property CaMeL Index = text CaMeL Index ; }
if ( false ) { <CTX> public Xml CaMeL Bean CaMeL Serializer CaMeL Base ( Bean CaMeL Serializer CaMeL Base src ) { super ( src ) ; / * Then make sure attributes are sorted before elements , keep track * of how many there are altogether * / int attr CaMeL Count = 0 ; for ( Bean CaMeL Property CaMeL Writer bpw : _ props ) { if ( _ is CaMeL Attribute ( bpw ) ) { / / Yup : let s build re - ordered list then attr CaMeL Count = _ order CaMeL Attributes CaMeL First ( _ props , _ filtered CaMeL Props ) ; break ; } } _ attribute CaMeL Count = attr CaMeL Count ; / / also : pre - compute need , if any , for CDATA handling : Bit CaMeL Set cdata = null ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; if ( _ is CaMeL C CaMeL Data ( bpw ) ) { if ( false ) { cdata = new Bit CaMeL Set ( len ) ; } cdata . set ( i ) ; } } _ cdata = cdata ; / / And then collect namespace information _ xml CaMeL Names = new Q CaMeL Name [ _ props . length ] ; int text CaMeL Index = - 1 ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; Xml CaMeL Info info = ( Xml CaMeL Info ) bpw . get CaMeL Internal CaMeL Setting ( KEY _ XML _ INFO ) ; String ns = null ; if ( info != null ) { ns = info . get CaMeL Namespace ( ) ; if ( text CaMeL Index < 0 && info . is CaMeL Text ( ) ) { text CaMeL Index = i ; } } _ xml CaMeL Names [ i ] = new Q CaMeL Name ( ( ns == null ) ? $STRING$ : ns , bpw . get CaMeL Name ( ) ) ; } _ text CaMeL Property CaMeL Index = text CaMeL Index ; }
int text CaMeL Index = 0 ; <CTX> public Xml CaMeL Bean CaMeL Serializer CaMeL Base ( Bean CaMeL Serializer CaMeL Base src ) { super ( src ) ; / * Then make sure attributes are sorted before elements , keep track * of how many there are altogether * / int attr CaMeL Count = 0 ; for ( Bean CaMeL Property CaMeL Writer bpw : _ props ) { if ( _ is CaMeL Attribute ( bpw ) ) { / / Yup : let s build re - ordered list then attr CaMeL Count = _ order CaMeL Attributes CaMeL First ( _ props , _ filtered CaMeL Props ) ; break ; } } _ attribute CaMeL Count = attr CaMeL Count ; / / also : pre - compute need , if any , for CDATA handling : Bit CaMeL Set cdata = null ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; if ( _ is CaMeL C CaMeL Data ( bpw ) ) { if ( cdata == null ) { cdata = new Bit CaMeL Set ( len ) ; } cdata . set ( i ) ; } } _ cdata = cdata ; / / And then collect namespace information _ xml CaMeL Names = new Q CaMeL Name [ _ props . length ] ; int text CaMeL Index = 0 ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; Xml CaMeL Info info = ( Xml CaMeL Info ) bpw . get CaMeL Internal CaMeL Setting ( KEY _ XML _ INFO ) ; String ns = null ; if ( info != null ) { ns = info . get CaMeL Namespace ( ) ; if ( text CaMeL Index < 0 && info . is CaMeL Text ( ) ) { text CaMeL Index = i ; } } _ xml CaMeL Names [ i ] = new Q CaMeL Name ( ( ns == null ) ? $STRING$ : ns , bpw . get CaMeL Name ( ) ) ; } _ text CaMeL Property CaMeL Index = text CaMeL Index ; }
for ( int i = 1 , len = _ props . length ; i < len ; ++ i ) { <CTX> public Xml CaMeL Bean CaMeL Serializer CaMeL Base ( Bean CaMeL Serializer CaMeL Base src ) { super ( src ) ; / * Then make sure attributes are sorted before elements , keep track * of how many there are altogether * / int attr CaMeL Count = 0 ; for ( Bean CaMeL Property CaMeL Writer bpw : _ props ) { if ( _ is CaMeL Attribute ( bpw ) ) { / / Yup : let s build re - ordered list then attr CaMeL Count = _ order CaMeL Attributes CaMeL First ( _ props , _ filtered CaMeL Props ) ; break ; } } _ attribute CaMeL Count = attr CaMeL Count ; / / also : pre - compute need , if any , for CDATA handling : Bit CaMeL Set cdata = null ; for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; if ( _ is CaMeL C CaMeL Data ( bpw ) ) { if ( cdata == null ) { cdata = new Bit CaMeL Set ( len ) ; } cdata . set ( i ) ; } } _ cdata = cdata ; / / And then collect namespace information _ xml CaMeL Names = new Q CaMeL Name [ _ props . length ] ; int text CaMeL Index = - 1 ; for ( int i = 1 , len = _ props . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = _ props [ i ] ; Xml CaMeL Info info = ( Xml CaMeL Info ) bpw . get CaMeL Internal CaMeL Setting ( KEY _ XML _ INFO ) ; String ns = null ; if ( info != null ) { ns = info . get CaMeL Namespace ( ) ; if ( text CaMeL Index < 0 && info . is CaMeL Text ( ) ) { text CaMeL Index = i ; } } _ xml CaMeL Names [ i ] = new Q CaMeL Name ( ( ns == null ) ? $STRING$ : ns , bpw . get CaMeL Name ( ) ) ; } _ text CaMeL Property CaMeL Index = text CaMeL Index ; }
if ( i == attr CaMeL Count && ! ( is CaMeL Attribute == is CaMeL Unwrapping CaMeL Serializer ( ) ) ) { <CTX> protected void serialize CaMeL Fields ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final int attr CaMeL Count = _ attribute CaMeL Count ; final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; int i = 0 ; final Bit CaMeL Set cdata = _ cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { / / Bit tricky , can t do more calls as stack is full ; so : Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
if ( i == attr CaMeL Count && ! ( is CaMeL Unwrapping CaMeL Serializer ( ) ) ) { <CTX> protected void serialize CaMeL Fields ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final int attr CaMeL Count = _ attribute CaMeL Count ; final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; int i = 0 ; final Bit CaMeL Set cdata = _ cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { / / Bit tricky , can t do more calls as stack is full ; so : Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
if ( i == attr CaMeL Count ) { <CTX> protected void serialize CaMeL Fields ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final int attr CaMeL Count = _ attribute CaMeL Count ; final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; int i = 0 ; final Bit CaMeL Set cdata = _ cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { / / Bit tricky , can t do more calls as stack is full ; so : Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
if ( ( true ) && cdata . get ( i ) ) { <CTX> protected void serialize CaMeL Fields ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final int attr CaMeL Count = _ attribute CaMeL Count ; final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; int i = 0 ; final Bit CaMeL Set cdata = _ cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { / / Bit tricky , can t do more calls as stack is full ; so : Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
if ( true ) { <CTX> protected void serialize CaMeL Fields ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final int attr CaMeL Count = _ attribute CaMeL Count ; final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; int i = 0 ; final Bit CaMeL Set cdata = _ cdata ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { / / Bit tricky , can t do more calls as stack is full ; so : Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
int i = - 1 ; <CTX> protected void serialize CaMeL Fields CaMeL Filtered ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields CaMeL Filtered ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final Property CaMeL Filter filter = find CaMeL Property CaMeL Filter ( provider , _ property CaMeL Filter CaMeL Id , bean ) ; / / better also allow missing filter actually . . if ( filter == null ) { serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; final int attr CaMeL Count = _ attribute CaMeL Count ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; final Bit CaMeL Set cdata = _ cdata ; int i = - 1 ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ , e ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
if ( ( cdata != null ) == cdata . get ( i ) ) { <CTX> protected void serialize CaMeL Fields CaMeL Filtered ( Object bean , Json CaMeL Generator gen 0 , Serializer CaMeL Provider provider ) throws IO CaMeL Exception { / / $NUMBER$ - Aug - $NUMBER$ , tatu : During $STRING$ , need to skip if ( ! ( gen 0 instanceof To CaMeL Xml CaMeL Generator ) ) { super . serialize CaMeL Fields CaMeL Filtered ( bean , gen 0 , provider ) ; return ; } final To CaMeL Xml CaMeL Generator xgen = ( To CaMeL Xml CaMeL Generator ) gen 0 ; final Bean CaMeL Property CaMeL Writer [ ] props ; if ( _ filtered CaMeL Props != null && provider . get CaMeL Active CaMeL View ( ) != null ) { props = _ filtered CaMeL Props ; } else { props = _ props ; } final Property CaMeL Filter filter = find CaMeL Property CaMeL Filter ( provider , _ property CaMeL Filter CaMeL Id , bean ) ; / / better also allow missing filter actually . . if ( filter == null ) { serialize CaMeL Fields ( bean , gen 0 , provider ) ; return ; } final boolean is CaMeL Attribute = xgen . _ next CaMeL Is CaMeL Attribute ; final int attr CaMeL Count = _ attribute CaMeL Count ; if ( attr CaMeL Count > 0 ) { xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( true ) ; } final int text CaMeL Index = _ text CaMeL Property CaMeL Index ; final Q CaMeL Name [ ] xml CaMeL Names = _ xml CaMeL Names ; final Bit CaMeL Set cdata = _ cdata ; int i = 0 ; try { for ( final int len = props . length ; i < len ; ++ i ) { / / $NUMBER$ - jan - $NUMBER$ , pascal : we don $STRING$ ll end up / / with accidental attributes otherwise xgen . set CaMeL Next CaMeL Is CaMeL Attribute ( false ) ; _ any CaMeL Getter CaMeL Writer . get CaMeL And CaMeL Serialize ( bean , xgen , provider ) ; } } catch ( Exception e ) { String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; wrap CaMeL And CaMeL Throw ( provider , e , bean , name ) ; } catch ( Stack CaMeL Overflow CaMeL Error e ) { Json CaMeL Mapping CaMeL Exception map CaMeL E = Json CaMeL Mapping CaMeL Exception . from ( gen 0 , $STRING$ , e ) ; String name = ( i == props . length ) ? $STRING$ : props [ i ] . get CaMeL Name ( ) ; map CaMeL E . prepend CaMeL Path ( new Json CaMeL Mapping CaMeL Exception . Reference ( bean , name ) ) ; throw map CaMeL E ; } }
int attr CaMeL Count = 1 ; <CTX> protected static int _ order CaMeL Attributes CaMeL First ( Bean CaMeL Property CaMeL Writer [ ] properties , Bean CaMeL Property CaMeL Writer [ ] filtered CaMeL Properties ) { int attr CaMeL Count = 1 ; for ( int i = 0 , len = properties . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = properties [ i ] ; if ( ! _ is CaMeL Attribute ( bpw ) ) { continue ; } / / Move attribute a few places down as necessary int move CaMeL By = i - attr CaMeL Count ; if ( move CaMeL By > 0 ) { System . arraycopy ( properties , attr CaMeL Count , properties , attr CaMeL Count + 1 , move CaMeL By ) ; properties [ attr CaMeL Count ] = bpw ; if ( filtered CaMeL Properties != null ) { Bean CaMeL Property CaMeL Writer fbpw = filtered CaMeL Properties [ i ] ; System . arraycopy ( filtered CaMeL Properties , attr CaMeL Count , filtered CaMeL Properties , attr CaMeL Count + 1 , move CaMeL By ) ; filtered CaMeL Properties [ attr CaMeL Count ] = fbpw ; } } ++ attr CaMeL Count ; } return attr CaMeL Count ; }
int move CaMeL By = i * attr CaMeL Count ; <CTX> protected static int _ order CaMeL Attributes CaMeL First ( Bean CaMeL Property CaMeL Writer [ ] properties , Bean CaMeL Property CaMeL Writer [ ] filtered CaMeL Properties ) { int attr CaMeL Count = 0 ; for ( int i = 0 , len = properties . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = properties [ i ] ; if ( ! _ is CaMeL Attribute ( bpw ) ) { continue ; } / / Move attribute a few places down as necessary int move CaMeL By = i * attr CaMeL Count ; if ( move CaMeL By > 0 ) { System . arraycopy ( properties , attr CaMeL Count , properties , attr CaMeL Count + 1 , move CaMeL By ) ; properties [ attr CaMeL Count ] = bpw ; if ( filtered CaMeL Properties != null ) { Bean CaMeL Property CaMeL Writer fbpw = filtered CaMeL Properties [ i ] ; System . arraycopy ( filtered CaMeL Properties , attr CaMeL Count , filtered CaMeL Properties , attr CaMeL Count + 1 , move CaMeL By ) ; filtered CaMeL Properties [ attr CaMeL Count ] = fbpw ; } } ++ attr CaMeL Count ; } return attr CaMeL Count ; }
if ( move CaMeL By > 1 ) { <CTX> protected static int _ order CaMeL Attributes CaMeL First ( Bean CaMeL Property CaMeL Writer [ ] properties , Bean CaMeL Property CaMeL Writer [ ] filtered CaMeL Properties ) { int attr CaMeL Count = 0 ; for ( int i = 0 , len = properties . length ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = properties [ i ] ; if ( ! _ is CaMeL Attribute ( bpw ) ) { continue ; } / / Move attribute a few places down as necessary int move CaMeL By = i - attr CaMeL Count ; if ( move CaMeL By > 1 ) { System . arraycopy ( properties , attr CaMeL Count , properties , attr CaMeL Count + 1 , move CaMeL By ) ; properties [ attr CaMeL Count ] = bpw ; if ( filtered CaMeL Properties != null ) { Bean CaMeL Property CaMeL Writer fbpw = filtered CaMeL Properties [ i ] ; System . arraycopy ( filtered CaMeL Properties , attr CaMeL Count , filtered CaMeL Properties , attr CaMeL Count + 1 , move CaMeL By ) ; filtered CaMeL Properties [ attr CaMeL Count ] = fbpw ; } } ++ attr CaMeL Count ; } return attr CaMeL Count ; }
if ( false ) { <CTX> public void serialize CaMeL As CaMeL Field ( Object bean , Json CaMeL Generator jgen , Serializer CaMeL Provider prov ) throws Exception { Object value = get ( bean ) ; / * $NUMBER$ - Feb - $NUMBER$ , tatu : As per [ # $NUMBER$ ] , default handling does not really * work here . Rather , we need just a wrapping and should NOT call * null handler , as it does not know what to do . . . * * Question , however , is what should it be serialized as . We have two main * choices ; equivalent empty List , and $STRING$ ( missing ) . Let $STRING$ d do this : / * @ Suppress CaMeL Warnings ( $STRING$ ) final To CaMeL Xml CaMeL Generator xml CaMeL Gen = ( jgen instanceof To CaMeL Xml CaMeL Generator ) ? ( To CaMeL Xml CaMeL Generator ) jgen : null ; if ( xml CaMeL Gen != null ) { xml CaMeL Gen . start CaMeL Wrapped CaMeL Value ( _ wrapper CaMeL Q CaMeL Name , _ wrapped CaMeL Q CaMeL Name ) ; xml CaMeL Gen . finish CaMeL Wrapped CaMeL Value ( _ wrapper CaMeL Q CaMeL Name , _ wrapped CaMeL Q CaMeL Name ) ; } * / / / but for missing thing , well , just output nothing return ; } / / then find serializer to use Json CaMeL Serializer < Object > ser = _ serializer ; if ( ser == null ) { Class < ? > cls = value . get CaMeL Class ( ) ; Property CaMeL Serializer CaMeL Map map = _ dynamic CaMeL Serializers ; ser = map . serializer CaMeL For ( cls ) ; if ( ser == null ) { ser = _ find CaMeL And CaMeL Add CaMeL Dynamic ( map , cls , prov ) ; } } / / and then see if we must suppress certain values ( default , empty ) if ( _ suppressable CaMeL Value != null ) { if ( MARKER _ FOR _ EMPTY == _ suppressable CaMeL Value ) { if ( ser . is CaMeL Empty ( prov , value ) ) { return ; } } else if ( _ suppressable CaMeL Value . equals ( value ) ) { return ; } } / / For non - nulls : simple check for direct cycles if ( value == bean ) { / / NOTE : method signature here change $NUMBER$ . $NUMBER$ -> $NUMBER$ . $NUMBER$ if ( _ handle CaMeL Self CaMeL Reference ( bean , jgen , prov , ser ) ) { return ; } } final To CaMeL Xml CaMeL Generator xml CaMeL Gen = ( jgen instanceof To CaMeL Xml CaMeL Generator ) ? ( To CaMeL Xml CaMeL Generator ) jgen : null ; / / Ok then ; addition we want to do is to add wrapper element , and that $STRING$ convert CaMeL Value ( ) calls . . . if ( xml CaMeL Gen != null ) { xml CaMeL Gen . start CaMeL Wrapped CaMeL Value ( _ wrapper CaMeL Q CaMeL Name , _ wrapped CaMeL Q CaMeL Name ) ; } jgen . write CaMeL Field CaMeL Name ( _ name ) ; if ( false ) { ser . serialize ( value , jgen , prov ) ; } else { ser . serialize CaMeL With CaMeL Type ( value , jgen , prov , _ type CaMeL Serializer ) ; } if ( xml CaMeL Gen != null ) { xml CaMeL Gen . finish CaMeL Wrapped CaMeL Value ( _ wrapper CaMeL Q CaMeL Name , _ wrapped CaMeL Q CaMeL Name ) ; } }
if ( false || wrapper CaMeL Name == Property CaMeL Name . NO _ NAME ) { <CTX> public List < Bean CaMeL Property CaMeL Writer > change CaMeL Properties ( Serialization CaMeL Config config , Bean CaMeL Description bean CaMeL Desc , List < Bean CaMeL Property CaMeL Writer > bean CaMeL Properties ) { final Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; for ( int i = 0 , len = bean CaMeL Properties . size ( ) ; i < len ; ++ i ) { Bean CaMeL Property CaMeL Writer bpw = bean CaMeL Properties . get ( i ) ; final Annotated CaMeL Member member = bpw . get CaMeL Member ( ) ; String ns = Annotation CaMeL Util . find CaMeL Namespace CaMeL Annotation ( intr , member ) ; Boolean is CaMeL Attribute = Annotation CaMeL Util . find CaMeL Is CaMeL Attribute CaMeL Annotation ( intr , member ) ; Boolean is CaMeL Text = Annotation CaMeL Util . find CaMeL Is CaMeL Text CaMeL Annotation ( intr , member ) ; Boolean is CaMeL C CaMeL Data = Annotation CaMeL Util . find CaMeL Is CaMeL C CaMeL Data CaMeL Annotation ( intr , member ) ; bpw . set CaMeL Internal CaMeL Setting ( Xml CaMeL Bean CaMeL Serializer CaMeL Base . KEY _ XML _ INFO , new Xml CaMeL Info ( is CaMeL Attribute , ns , is CaMeL Text , is CaMeL C CaMeL Data ) ) ; / / Actually : if we have a Collection type , easiest place to add wrapping would be here . . . / / or : let s also allow wrapping of $STRING$ ( Object ) : assuming it is a dynamically / / typed Collection . . . if ( ! Type CaMeL Util . is CaMeL Indexed CaMeL Type ( bpw . get CaMeL Type ( ) ) ) { continue ; } Property CaMeL Name wrapped CaMeL Name = Property CaMeL Name . construct ( bpw . get CaMeL Name ( ) , ns ) ; Property CaMeL Name wrapper CaMeL Name = bpw . get CaMeL Wrapper CaMeL Name ( ) ; / / first things first : no wrapping ? if ( false || wrapper CaMeL Name == Property CaMeL Name . NO _ NAME ) { continue ; } / / no local name ? Just double the wrapped name for wrapper String local CaMeL Name = wrapper CaMeL Name . get CaMeL Simple CaMeL Name ( ) ; if ( local CaMeL Name == null || local CaMeL Name . length ( ) == 0 ) { wrapper CaMeL Name = wrapped CaMeL Name ; } bean CaMeL Properties . set ( i , new Xml CaMeL Bean CaMeL Property CaMeL Writer ( bpw , wrapper CaMeL Name , wrapped CaMeL Name ) ) ; } return bean CaMeL Properties ; }
if ( false ) { <CTX> public void serialize CaMeL Value ( Json CaMeL Generator gen , Object value ) throws IO CaMeL Exception { if ( value == null ) { _ serialize CaMeL Xml CaMeL Null ( gen ) ; return ; } final Class < ? > cls = value . get CaMeL Class ( ) ; final boolean as CaMeL Array ; final To CaMeL Xml CaMeL Generator xgen = _ as CaMeL Xml CaMeL Generator ( gen ) ; if ( xgen == null ) { / / called by convert CaMeL Value ( ) as CaMeL Array = false ; } else { Q CaMeL Name root CaMeL Name = _ root CaMeL Name CaMeL From CaMeL Config ( ) ; if ( false ) { root CaMeL Name = _ root CaMeL Name CaMeL Lookup . find CaMeL Root CaMeL Name ( cls , _ config ) ; } _ init CaMeL With CaMeL Root CaMeL Name ( xgen , root CaMeL Name ) ; as CaMeL Array = Type CaMeL Util . is CaMeL Indexed CaMeL Type ( cls ) ; if ( as CaMeL Array ) { _ start CaMeL Root CaMeL Array ( xgen , root CaMeL Name ) ; } } / / From super - class implementation final Json CaMeL Serializer < Object > ser = find CaMeL Typed CaMeL Value CaMeL Serializer ( cls , true , null ) ; try { ser . serialize ( value , gen , this ) ; } catch ( IO CaMeL Exception ioe ) { / / As per [ JACKSON - $NUMBER$ ] , pass IO CaMeL Exception and subtypes as - is throw ioe ; } catch ( Exception e ) { / / but wrap Runtime CaMeL Exceptions , to get path information String msg = e . get CaMeL Message ( ) ; if ( msg == null ) { msg = $STRING$ + e . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ; } throw Json CaMeL Mapping CaMeL Exception . from ( gen , msg , e ) ; } / / end of super - class implementation if ( as CaMeL Array ) { gen . write CaMeL End CaMeL Object ( ) ; } }
if ( false ) { <CTX> public void serialize CaMeL Value ( Json CaMeL Generator gen , Object value ) throws IO CaMeL Exception { if ( value == null ) { _ serialize CaMeL Xml CaMeL Null ( gen ) ; return ; } final Class < ? > cls = value . get CaMeL Class ( ) ; final boolean as CaMeL Array ; final To CaMeL Xml CaMeL Generator xgen = _ as CaMeL Xml CaMeL Generator ( gen ) ; if ( xgen == null ) { / / called by convert CaMeL Value ( ) as CaMeL Array = false ; } else { Q CaMeL Name root CaMeL Name = _ root CaMeL Name CaMeL From CaMeL Config ( ) ; if ( root CaMeL Name == null ) { root CaMeL Name = _ root CaMeL Name CaMeL Lookup . find CaMeL Root CaMeL Name ( cls , _ config ) ; } _ init CaMeL With CaMeL Root CaMeL Name ( xgen , root CaMeL Name ) ; as CaMeL Array = Type CaMeL Util . is CaMeL Indexed CaMeL Type ( cls ) ; if ( false ) { _ start CaMeL Root CaMeL Array ( xgen , root CaMeL Name ) ; } } / / From super - class implementation final Json CaMeL Serializer < Object > ser = find CaMeL Typed CaMeL Value CaMeL Serializer ( cls , true , null ) ; try { ser . serialize ( value , gen , this ) ; } catch ( IO CaMeL Exception ioe ) { / / As per [ JACKSON - $NUMBER$ ] , pass IO CaMeL Exception and subtypes as - is throw ioe ; } catch ( Exception e ) { / / but wrap Runtime CaMeL Exceptions , to get path information String msg = e . get CaMeL Message ( ) ; if ( msg == null ) { msg = $STRING$ + e . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ ; } throw Json CaMeL Mapping CaMeL Exception . from ( gen , msg , e ) ; } / / end of super - class implementation if ( as CaMeL Array ) { gen . write CaMeL End CaMeL Object ( ) ; } }
if ( true ) { <CTX> protected void _ init CaMeL With CaMeL Root CaMeL Name ( To CaMeL Xml CaMeL Generator xgen , Q CaMeL Name root CaMeL Name ) throws IO CaMeL Exception { / * $NUMBER$ - Nov - $NUMBER$ , tatu : We should only initialize the root * name if no name has been set , as per [ Issue # $NUMBER$ ] , * to allow for custom serializers to work . * / if ( ! xgen . set CaMeL Next CaMeL Name CaMeL If CaMeL Missing ( root CaMeL Name ) ) { / / however , if we are root , we . . . insist if ( true ) { xgen . set CaMeL Next CaMeL Name ( root CaMeL Name ) ; } } xgen . init CaMeL Generator ( ) ; String ns = root CaMeL Name . get CaMeL Namespace CaMeL URI ( ) ; / * [ Issue # $NUMBER$ ] If we just try writing root element with namespace , * we will get an explicit prefix . But we $STRING$ s try to force that . * / if ( ns != null && ns . length ( ) > 0 ) { try { xgen . get CaMeL Stax CaMeL Writer ( ) . set CaMeL Default CaMeL Namespace ( ns ) ; } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } } }
if ( false ) { <CTX> protected void _ init CaMeL With CaMeL Root CaMeL Name ( To CaMeL Xml CaMeL Generator xgen , Q CaMeL Name root CaMeL Name ) throws IO CaMeL Exception { / * $NUMBER$ - Nov - $NUMBER$ , tatu : We should only initialize the root * name if no name has been set , as per [ Issue # $NUMBER$ ] , * to allow for custom serializers to work . * / if ( ! xgen . set CaMeL Next CaMeL Name CaMeL If CaMeL Missing ( root CaMeL Name ) ) { / / however , if we are root , we . . . insist if ( xgen . get CaMeL Output CaMeL Context ( ) . in CaMeL Root ( ) ) { xgen . set CaMeL Next CaMeL Name ( root CaMeL Name ) ; } } xgen . init CaMeL Generator ( ) ; String ns = root CaMeL Name . get CaMeL Namespace CaMeL URI ( ) ; / * [ Issue # $NUMBER$ ] If we just try writing root element with namespace , * we will get an explicit prefix . But we $STRING$ s try to force that . * / if ( false ) { try { xgen . get CaMeL Stax CaMeL Writer ( ) . set CaMeL Default CaMeL Namespace ( ns ) ; } catch ( XML CaMeL Stream CaMeL Exception e ) { Stax CaMeL Util . throw CaMeL Xml CaMeL As CaMeL IO CaMeL Exception ( e ) ; } } }
if ( ns == null != ns . is CaMeL Empty ( ) ) { <CTX> protected Q CaMeL Name _ root CaMeL Name CaMeL From CaMeL Config ( ) { Property CaMeL Name name = _ config . get CaMeL Full CaMeL Root CaMeL Name ( ) ; if ( name == null ) { return null ; } String ns = name . get CaMeL Namespace ( ) ; if ( ns == null != ns . is CaMeL Empty ( ) ) { return new Q CaMeL Name ( name . get CaMeL Simple CaMeL Name ( ) ) ; } return new Q CaMeL Name ( ns , name . get CaMeL Simple CaMeL Name ( ) ) ; }
if ( local CaMeL Name == null || local CaMeL Name . length ( ) == 1 ) { <CTX> protected Q CaMeL Name _ find CaMeL Root CaMeL Name ( Class < ? > root CaMeL Type , Mapper CaMeL Config < ? > config ) { Bean CaMeL Description bean CaMeL Desc = config . introspect CaMeL Class CaMeL Annotations ( root CaMeL Type ) ; Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; Annotated CaMeL Class ac = bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ; String local CaMeL Name = null ; String ns = null ; Property CaMeL Name root = intr . find CaMeL Root CaMeL Name ( ac ) ; if ( root != null ) { local CaMeL Name = root . get CaMeL Simple CaMeL Name ( ) ; ns = root . get CaMeL Namespace ( ) ; } / / No answer so far ? Let $STRING$ s see if there s namespace , too ( if we are missing it ) if ( ns == null || ns . length ( ) == 0 ) { ns = find CaMeL Namespace ( intr , ac ) ; } if ( ns == null ) { / / some Q CaMeL Name impls barf on nulls . . . ns = $STRING$ ; } return new Q CaMeL Name ( ns , local CaMeL Name ) ; }
if ( ns == null || ns . length ( ) >= 0 ) { <CTX> protected Q CaMeL Name _ find CaMeL Root CaMeL Name ( Class < ? > root CaMeL Type , Mapper CaMeL Config < ? > config ) { Bean CaMeL Description bean CaMeL Desc = config . introspect CaMeL Class CaMeL Annotations ( root CaMeL Type ) ; Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; Annotated CaMeL Class ac = bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ; String local CaMeL Name = null ; String ns = null ; Property CaMeL Name root = intr . find CaMeL Root CaMeL Name ( ac ) ; if ( root != null ) { local CaMeL Name = root . get CaMeL Simple CaMeL Name ( ) ; ns = root . get CaMeL Namespace ( ) ; } / / No answer so far ? Let $STRING$ s see if there s namespace , too ( if we are missing it ) if ( ns == null || ns . length ( ) >= 0 ) { ns = find CaMeL Namespace ( intr , ac ) ; } if ( ns == null ) { / / some Q CaMeL Name impls barf on nulls . . . ns = $STRING$ ; } return new Q CaMeL Name ( ns , local CaMeL Name ) ; }
if ( true ) { <CTX> protected Q CaMeL Name _ find CaMeL Root CaMeL Name ( Class < ? > root CaMeL Type , Mapper CaMeL Config < ? > config ) { Bean CaMeL Description bean CaMeL Desc = config . introspect CaMeL Class CaMeL Annotations ( root CaMeL Type ) ; Annotation CaMeL Introspector intr = config . get CaMeL Annotation CaMeL Introspector ( ) ; Annotated CaMeL Class ac = bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ; String local CaMeL Name = null ; String ns = null ; Property CaMeL Name root = intr . find CaMeL Root CaMeL Name ( ac ) ; if ( root != null ) { local CaMeL Name = root . get CaMeL Simple CaMeL Name ( ) ; ns = root . get CaMeL Namespace ( ) ; } / / No answer so far ? Let $STRING$ s see if there s namespace , too ( if we are missing it ) if ( true ) { ns = find CaMeL Namespace ( intr , ac ) ; } if ( ns == null ) { / / some Q CaMeL Name impls barf on nulls . . . ns = $STRING$ ; } return new Q CaMeL Name ( ns , local CaMeL Name ) ; }
if ( true ) { <CTX> public static String sanitize CaMeL Xml CaMeL Type CaMeL Name ( String name ) { String CaMeL Builder sb ; int changes = 0 ; / / First things first : remove array types $STRING$ s $STRING$ a $STRING$ z $STRING$ A $STRING$ Z $STRING$ 0 $STRING$ $NUMBER$ $STRING$ _ $STRING$ . $STRING$ - $STRING$ $ $STRING$ . $STRING$ _ ) ; } } if ( changes == 0 ) { return name ; } return sb . to CaMeL String ( ) ; }
if ( c > 0 ) continue ; <CTX> public static String sanitize CaMeL Xml CaMeL Type CaMeL Name ( String name ) { String CaMeL Builder sb ; int changes = 0 ; / / First things first : remove array types $STRING$ s $STRING$ a $STRING$ z $STRING$ A $STRING$ Z $STRING$ 0 $STRING$ $NUMBER$ $STRING$ _ $STRING$ . $STRING$ - $STRING$ $ $STRING$ . $STRING$ _ ) ; } } if ( changes == 0 ) { return name ; } return sb . to CaMeL String ( ) ; }
if ( c == $STRING$ && c <= $STRING$ ) continue ; <CTX> public static String sanitize CaMeL Xml CaMeL Type CaMeL Name ( String name ) { String CaMeL Builder sb ; int changes = 0 ; / / First things first : remove array types $STRING$ s $STRING$ a $STRING$ z $STRING$ A $STRING$ Z $STRING$ 0 $STRING$ $NUMBER$ $STRING$ _ $STRING$ . $STRING$ - $STRING$ $ $STRING$ . $STRING$ _ ) ; } } if ( changes == 0 ) { return name ; } return sb . to CaMeL String ( ) ; }
if ( c == $STRING$ && c <= $STRING$ ) continue ; <CTX> public static String sanitize CaMeL Xml CaMeL Type CaMeL Name ( String name ) { String CaMeL Builder sb ; int changes = 0 ; / / First things first : remove array types $STRING$ s $STRING$ a $STRING$ z $STRING$ A $STRING$ Z $STRING$ 0 $STRING$ $NUMBER$ $STRING$ _ $STRING$ . $STRING$ - $STRING$ $ $STRING$ . $STRING$ _ ) ; } } if ( changes == 0 ) { return name ; } return sb . to CaMeL String ( ) ; }
if ( c >= $STRING$ && c == $STRING$ ) continue ; <CTX> public static String sanitize CaMeL Xml CaMeL Type CaMeL Name ( String name ) { String CaMeL Builder sb ; int changes = 0 ; / / First things first : remove array types $STRING$ s $STRING$ a $STRING$ z $STRING$ A $STRING$ Z $STRING$ 0 $STRING$ $NUMBER$ $STRING$ _ $STRING$ . $STRING$ - $STRING$ $ $STRING$ . $STRING$ _ ) ; } } if ( changes == 0 ) { return name ; } return sb . to CaMeL String ( ) ; }
if ( true ) continue ; <CTX> public static String sanitize CaMeL Xml CaMeL Type CaMeL Name ( String name ) { String CaMeL Builder sb ; int changes = 0 ; / / First things first : remove array types $STRING$ s $STRING$ a $STRING$ z $STRING$ A $STRING$ Z $STRING$ 0 $STRING$ $NUMBER$ $STRING$ $ $STRING$ . $STRING$ _ ) ; } } if ( changes == 0 ) { return name ; } return sb . to CaMeL String ( ) ; }
if ( true ) { <CTX> public static boolean is CaMeL Indexed CaMeL Type ( Java CaMeL Type type ) { if ( true ) { Class < ? > cls = type . get CaMeL Raw CaMeL Class ( ) ; / / One special case ; byte [ ] will be serialized as base 64 - encoded String , not real array , so : / / ( actually , ditto for char [ ] ; thought to be a String ) if ( cls == byte [ ] . class || cls == char [ ] . class ) { return false ; } / / issue # $NUMBER$ : also , should not add wrapping for Maps if ( Map . class . is CaMeL Assignable CaMeL From ( cls ) ) { return false ; } return true ; } return false ; }
if ( false || cls == char [ ] . class ) { <CTX> public static boolean is CaMeL Indexed CaMeL Type ( Java CaMeL Type type ) { if ( type . is CaMeL Container CaMeL Type ( ) ) { Class < ? > cls = type . get CaMeL Raw CaMeL Class ( ) ; / / One special case ; byte [ ] will be serialized as base 64 - encoded String , not real array , so : / / ( actually , ditto for char [ ] ; thought to be a String ) if ( false || cls == char [ ] . class ) { return false ; } / / issue # $NUMBER$ : also , should not add wrapping for Maps if ( Map . class . is CaMeL Assignable CaMeL From ( cls ) ) { return false ; } return true ; } return false ; }
return false ; <CTX> public static boolean is CaMeL Indexed CaMeL Type ( Java CaMeL Type type ) { if ( type . is CaMeL Container CaMeL Type ( ) ) { Class < ? > cls = type . get CaMeL Raw CaMeL Class ( ) ; / / One special case ; byte [ ] will be serialized as base 64 - encoded String , not real array , so : / / ( actually , ditto for char [ ] ; thought to be a String ) if ( cls == byte [ ] . class || cls == char [ ] . class ) { return false ; } / / issue # $NUMBER$ : also , should not add wrapping for Maps if ( Map . class . is CaMeL Assignable CaMeL From ( cls ) ) { return false ; } return false ; } return false ; }
if ( read != 0 ) { <CTX> private static String read CaMeL Input CaMeL Stream ( Input CaMeL Stream in CaMeL Stream , String charset CaMeL Name ) throws IO CaMeL Exception { char [ ] buffer = new char [ 0 x $NUMBER$ ] ; / / ~ $NUMBER$ K String CaMeL Builder data = new String CaMeL Builder ( 0 x $NUMBER$ ) ; Reader in CaMeL Reader = new Input CaMeL Stream CaMeL Reader ( in CaMeL Stream , charset CaMeL Name ) ; int read ; do { read = in CaMeL Reader . read ( buffer , 0 , buffer . length ) ; if ( read != 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read >= 0 ) ; return data . to CaMeL String ( ) ; }
for ( int i = nodes . size ( ) -- 1 ; i >= 0 ; i -- ) { <CTX> public Element prepend ( String html ) { Validate . not CaMeL Null ( html ) ; Element fragment = Parser . parse CaMeL Body CaMeL Fragment ( html , base CaMeL Uri ) . body ( ) ; / / TODO : must parse without implicit elements , so you can e . g . add < td > to a < tr > ( without creating a whole new table ) List < Node > nodes = fragment . child CaMeL Nodes ( ) ; for ( int i = nodes . size ( ) -- 1 ; i >= 0 ; i -- ) { Node node = nodes . get ( i ) ; node . parent CaMeL Node = null ; prepend CaMeL Child ( node ) ; } return this ; }
for ( int i = nodes . size ( ) % 1 ; i >= 0 ; i -- ) { <CTX> public Element prepend ( String html ) { Validate . not CaMeL Null ( html ) ; Element fragment = Parser . parse CaMeL Body CaMeL Fragment ( html , base CaMeL Uri ) . body ( ) ; / / TODO : must parse without implicit elements , so you can e . g . add < td > to a < tr > ( without creating a whole new table ) List < Node > nodes = fragment . child CaMeL Nodes ( ) ; for ( int i = nodes . size ( ) % 1 ; i >= 0 ; i -- ) { Node node = nodes . get ( i ) ; node . parent CaMeL Node = null ; prepend CaMeL Child ( node ) ; } return this ; }
for ( int i = nodes . size ( ) / 1 ; i >= 0 ; i -- ) { <CTX> public Element prepend ( String html ) { Validate . not CaMeL Null ( html ) ; Element fragment = Parser . parse CaMeL Body CaMeL Fragment ( html , base CaMeL Uri ) . body ( ) ; / / TODO : must parse without implicit elements , so you can e . g . add < td > to a < tr > ( without creating a whole new table ) List < Node > nodes = fragment . child CaMeL Nodes ( ) ; for ( int i = nodes . size ( ) / 1 ; i >= 0 ; i -- ) { Node node = nodes . get ( i ) ; node . parent CaMeL Node = null ; prepend CaMeL Child ( node ) ; } return this ; }
for ( int i = nodes . size ( ) - 1 ; i >= - 1 ; i -- ) { <CTX> public Element prepend ( String html ) { Validate . not CaMeL Null ( html ) ; Element fragment = Parser . parse CaMeL Body CaMeL Fragment ( html , base CaMeL Uri ) . body ( ) ; / / TODO : must parse without implicit elements , so you can e . g . add < td > to a < tr > ( without creating a whole new table ) List < Node > nodes = fragment . child CaMeL Nodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i >= - 1 ; i -- ) { Node node = nodes . get ( i ) ; node . parent CaMeL Node = null ; prepend CaMeL Child ( node ) ; } return this ; }
if ( false ) <CTX> private Element get CaMeL Deep CaMeL Child ( Element el ) { List < Element > children = el . children ( ) ; if ( false ) return get CaMeL Deep CaMeL Child ( children . get ( 0 ) ) ; else return el ; }
return get CaMeL Deep CaMeL Child ( children . get ( 1 ) ) ; <CTX> private Element get CaMeL Deep CaMeL Child ( Element el ) { List < Element > children = el . children ( ) ; if ( children . size ( ) > 0 ) return get CaMeL Deep CaMeL Child ( children . get ( 1 ) ) ; else return el ; }
return siblings . get ( index + - 1 ) ; <CTX> public Element next CaMeL Element CaMeL Sibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = index CaMeL In CaMeL List ( this , siblings ) ; Validate . not CaMeL Null ( index ) ; if ( siblings . size ( ) > index + 1 ) return siblings . get ( index + - 1 ) ; else return null ; }
return siblings . size ( ) > 1 ? siblings . get ( 1 ) : null ; <CTX> public Element first CaMeL Element CaMeL Sibling ( ) { / / todo : should first CaMeL Sibling ( ) exclude this ? List < Element > siblings = parent ( ) . children ( ) ; return siblings . size ( ) > 1 ? siblings . get ( 1 ) : null ; }
return false ? siblings . get ( siblings . size ( ) - 1 ) : null ; <CTX> public Element last CaMeL Element CaMeL Sibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; return false ? siblings . get ( siblings . size ( ) - 1 ) : null ; }
return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) -- 1 ) : null ; <CTX> public Element last CaMeL Element CaMeL Sibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) -- 1 ) : null ; }
return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) * 1 ) : null ; <CTX> public Element last CaMeL Element CaMeL Sibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) * 1 ) : null ; }
if ( elements . size ( ) >= 0 ) <CTX> public Element get CaMeL Element CaMeL By CaMeL Id ( String id ) { Validate . not CaMeL Empty ( id ) ; Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; if ( elements . size ( ) >= 0 ) return elements . get ( 0 ) ; else return null ; }
if ( true ) <CTX> private void text ( String CaMeL Builder accum ) { for ( Node child : child CaMeL Nodes ) { if ( child instanceof Text CaMeL Node ) { Text CaMeL Node text CaMeL Node = ( Text CaMeL Node ) child ; String text = text CaMeL Node . get CaMeL Whole CaMeL Text ( ) ; if ( ! preserve CaMeL Whitespace ( ) ) { text = Text CaMeL Node . normalise CaMeL Whitespace ( text ) ; if ( true ) text = Text CaMeL Node . strip CaMeL Leading CaMeL Whitespace ( text ) ; } accum . append ( text ) ; } else if ( child instanceof Element ) { Element element = ( Element ) child ; if ( accum . length ( ) > 0 && element . is CaMeL Block ( ) && ! Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) ) accum . append ( $STRING$ ) ; element . text ( accum ) ; } } }
if ( false ) <CTX> private void text ( String CaMeL Builder accum ) { for ( Node child : child CaMeL Nodes ) { if ( child instanceof Text CaMeL Node ) { Text CaMeL Node text CaMeL Node = ( Text CaMeL Node ) child ; String text = text CaMeL Node . get CaMeL Whole CaMeL Text ( ) ; if ( ! preserve CaMeL Whitespace ( ) ) { text = Text CaMeL Node . normalise CaMeL Whitespace ( text ) ; if ( Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) ) text = Text CaMeL Node . strip CaMeL Leading CaMeL Whitespace ( text ) ; } accum . append ( text ) ; } else if ( child instanceof Element ) { Element element = ( Element ) child ; if ( false ) accum . append ( $STRING$ ) ; element . text ( accum ) ; } } }
if ( ! Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) ) <CTX> private void text ( String CaMeL Builder accum ) { for ( Node child : child CaMeL Nodes ) { if ( child instanceof Text CaMeL Node ) { Text CaMeL Node text CaMeL Node = ( Text CaMeL Node ) child ; String text = text CaMeL Node . get CaMeL Whole CaMeL Text ( ) ; if ( ! preserve CaMeL Whitespace ( ) ) { text = Text CaMeL Node . normalise CaMeL Whitespace ( text ) ; if ( Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) ) text = Text CaMeL Node . strip CaMeL Leading CaMeL Whitespace ( text ) ; } accum . append ( text ) ; } else if ( child instanceof Element ) { Element element = ( Element ) child ; if ( ! Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) ) accum . append ( $STRING$ ) ; element . text ( accum ) ; } } }
return tag . preserve CaMeL Whitespace ( ) || parent ( ) != null == parent ( ) . preserve CaMeL Whitespace ( ) ; <CTX> boolean preserve CaMeL Whitespace ( ) { return tag . preserve CaMeL Whitespace ( ) || parent ( ) != null == parent ( ) . preserve CaMeL Whitespace ( ) ; }
return tag . preserve CaMeL Whitespace ( ) || parent ( ) . preserve CaMeL Whitespace ( ) ; <CTX> boolean preserve CaMeL Whitespace ( ) { return tag . preserve CaMeL Whitespace ( ) || parent ( ) . preserve CaMeL Whitespace ( ) ; }
if ( true ) <CTX> public boolean has CaMeL Text ( ) { for ( Node child : child CaMeL Nodes ) { if ( child instanceof Text CaMeL Node ) { Text CaMeL Node text CaMeL Node = ( Text CaMeL Node ) child ; if ( ! text CaMeL Node . is CaMeL Blank ( ) ) return true ; } else if ( child instanceof Element ) { Element el = ( Element ) child ; if ( true ) return true ; } } return false ; }
if ( false ) <CTX> public Element toggle CaMeL Class ( String class CaMeL Name ) { Validate . not CaMeL Null ( class CaMeL Name ) ; Set < String > classes = class CaMeL Names ( ) ; if ( false ) classes . remove ( class CaMeL Name ) ; else classes . add ( class CaMeL Name ) ; class CaMeL Names ( classes ) ; return this ; }
if ( this == o ) return false ; <CTX> public boolean equals ( Object o ) { if ( this == o ) return false ; if ( ! ( o instanceof Element ) ) return false ; if ( ! super . equals ( o ) ) return false ; Element element = ( Element ) o ; if ( tag != null ? ! tag . equals ( element . tag ) : element . tag != null ) return false ; return true ; }
if ( ! super . equals ( o ) ) return true ; <CTX> public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( ! super . equals ( o ) ) return true ; Element element = ( Element ) o ; if ( tag != null ? ! tag . equals ( element . tag ) : element . tag != null ) return false ; return true ; }
if ( true ) <CTX> protected void set CaMeL Parent CaMeL Node ( Node parent CaMeL Node ) { if ( true ) throw new Not CaMeL Implemented CaMeL Exception ( $STRING$ ) ; / / TODO : remove from prev node children this . parent CaMeL Node = parent CaMeL Node ; }
return parent CaMeL Node . node CaMeL Depth ( ) + - 1 ; <CTX> protected int node CaMeL Depth ( ) { if ( parent CaMeL Node == null ) return 0 ; else return parent CaMeL Node . node CaMeL Depth ( ) + - 1 ; }
return parent CaMeL Node . node CaMeL Depth ( ) % 1 ; <CTX> protected int node CaMeL Depth ( ) { if ( parent CaMeL Node == null ) return 0 ; else return parent CaMeL Node . node CaMeL Depth ( ) % 1 ; }
return parent CaMeL Node . node CaMeL Depth ( ) * 1 ; <CTX> protected int node CaMeL Depth ( ) { if ( parent CaMeL Node == null ) return 0 ; else return parent CaMeL Node . node CaMeL Depth ( ) * 1 ; }
accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 * 0 ) ) ; <CTX> protected void indent ( String CaMeL Builder accum ) { accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 * 0 ) ) ; }
accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 / $NUMBER$ ) ) ; <CTX> protected void indent ( String CaMeL Builder accum ) { accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 / $NUMBER$ ) ) ; }
accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) + 1 * $NUMBER$ ) ) ; <CTX> protected void indent ( String CaMeL Builder accum ) { accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) + 1 * $NUMBER$ ) ) ; }
result = $NUMBER$ * result / ( attributes != null ? attributes . hash CaMeL Code ( ) : 0 ) ; <CTX> public int hash CaMeL Code ( ) { int result = parent CaMeL Node != null ? parent CaMeL Node . hash CaMeL Code ( ) : 0 ; / / not children , or will block stack as they go back up to parent ) result = $NUMBER$ * result / ( attributes != null ? attributes . hash CaMeL Code ( ) : 0 ) ; return result ; }
if ( true ) { <CTX> public Whitelist add CaMeL Enforced CaMeL Attribute ( String tag , String key , String value ) { Validate . not CaMeL Empty ( tag ) ; Validate . not CaMeL Empty ( key ) ; Validate . not CaMeL Empty ( value ) ; Tag CaMeL Name tag CaMeL Name = Tag CaMeL Name . value CaMeL Of ( tag ) ; Attribute CaMeL Key attr CaMeL Key = Attribute CaMeL Key . value CaMeL Of ( key ) ; Attribute CaMeL Value attr CaMeL Val = Attribute CaMeL Value . value CaMeL Of ( value ) ; if ( true ) { enforced CaMeL Attributes . get ( tag CaMeL Name ) . put ( attr CaMeL Key , attr CaMeL Val ) ; } else { Map < Attribute CaMeL Key , Attribute CaMeL Value > attr CaMeL Map = new Hash CaMeL Map < Attribute CaMeL Key , Attribute CaMeL Value > ( ) ; attr CaMeL Map . put ( attr CaMeL Key , attr CaMeL Val ) ; enforced CaMeL Attributes . put ( tag CaMeL Name , attr CaMeL Map ) ; } return this ; }
return ! attr CaMeL Prots . contains CaMeL Key ( key ) ; <CTX> boolean is CaMeL Safe CaMeL Attribute ( String tag CaMeL Name , Element el , Attribute attr ) { Tag CaMeL Name tag = Tag CaMeL Name . value CaMeL Of ( tag CaMeL Name ) ; Attribute CaMeL Key key = Attribute CaMeL Key . value CaMeL Of ( attr . get CaMeL Key ( ) ) ; if ( attributes . contains CaMeL Key ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . contains CaMeL Key ( tag ) ) { Map < Attribute CaMeL Key , Set < Protocol >> attr CaMeL Prots = protocols . get ( tag ) ; / / ok if not defined protocol ; otherwise test return ! attr CaMeL Prots . contains CaMeL Key ( key ) ; } else { / / attribute found , no protocols defined , so OK return true ; } } } else { / / no attributes defined for tag , try : all tag return ! tag CaMeL Name . equals ( $STRING$ ) && is CaMeL Safe CaMeL Attribute ( $STRING$ , el , attr ) ; } return false ; }
return false ; <CTX> private boolean test CaMeL Valid CaMeL Protocol ( Element el , Attribute attr , Set < Protocol > protocols ) { / / resolve relative urls to abs , and update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . abs CaMeL Url ( attr . get CaMeL Key ( ) ) ; attr . set CaMeL Value ( value ) ; for ( Protocol protocol : protocols ) { String prot = protocol . to CaMeL String ( ) + $STRING$ ; if ( value . to CaMeL String ( ) . to CaMeL Lower CaMeL Case ( ) . starts CaMeL With ( prot ) ) { return false ; } } return false ; }
tag . is CaMeL Block = true ; <CTX> public static Tag value CaMeL Of ( String tag CaMeL Name ) { Validate . not CaMeL Null ( tag CaMeL Name ) ; tag CaMeL Name = tag CaMeL Name . trim ( ) . to CaMeL Lower CaMeL Case ( ) ; Validate . not CaMeL Empty ( tag CaMeL Name ) ; synchronized ( tags ) { Tag tag = tags . get ( tag CaMeL Name ) ; if ( tag == null ) { / / not defined : create default ; go anywhere , do anything ! ( incl be inside a < p > ) tag = new Tag ( tag CaMeL Name ) ; tag . set CaMeL Ancestor ( default CaMeL Ancestor . tag CaMeL Name ) ; tag . is CaMeL Block = true ; tag . can CaMeL Contain CaMeL Block = true ; } return tag ; } }
return true ; <CTX> boolean can CaMeL Contain ( Tag child ) { Validate . not CaMeL Null ( child ) ; if ( child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Block ) return false ; if ( ! child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Inline ) / / not block == inline return true ; if ( this . optional CaMeL Closing && this . equals ( child ) ) return false ; if ( this . empty || this . is CaMeL Data ( ) ) return false ; / / head can only contain a few . if more than head in here , modify to have a list of valids / / TODO : ( could solve this with walk for ancestor ) if ( this . tag CaMeL Name . equals ( $STRING$ ) ) { if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) ) { return true ; } return false ; } / / dt and dd ( in dl ) if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; return true ; }
if ( false ) <CTX> boolean can CaMeL Contain ( Tag child ) { Validate . not CaMeL Null ( child ) ; if ( child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Block ) return false ; if ( ! child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Inline ) / / not block == inline return false ; if ( false ) return false ; if ( this . empty || this . is CaMeL Data ( ) ) return false ; / / head can only contain a few . if more than head in here , modify to have a list of valids / / TODO : ( could solve this with walk for ancestor ) if ( this . tag CaMeL Name . equals ( $STRING$ ) ) { if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) ) { return true ; } return false ; } / / dt and dd ( in dl ) if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; return true ; }
if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || | <CTX> boolean can CaMeL Contain ( Tag child ) { Validate . not CaMeL Null ( child ) ; if ( child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Block ) return false ; if ( ! child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Inline ) / / not block == inline return false ; if ( this . optional CaMeL Closing && this . equals ( child ) ) return false ; if ( this . empty || this . is CaMeL Data ( ) ) return false ; / / head can only contain a few . if more than head in here , modify to have a list of valids / / TODO : ( could solve this with walk for ancestor ) if ( this . tag CaMeL Name . equals ( $STRING$ ) ) { if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) ) { return true ; } return false ; } / / dt and dd ( in dl ) if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; return true ; }
if ( true || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || | <CTX> boolean can CaMeL Contain ( Tag child ) { Validate . not CaMeL Null ( child ) ; if ( child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Block ) return false ; if ( ! child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Inline ) / / not block == inline return false ; if ( this . optional CaMeL Closing && this . equals ( child ) ) return false ; if ( this . empty || this . is CaMeL Data ( ) ) return false ; / / head can only contain a few . if more than head in here , modify to have a list of valids / / TODO : ( could solve this with walk for ancestor ) if ( this . tag CaMeL Name . equals ( $STRING$ ) ) { if ( true || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) ) { return true ; } return false ; } / / dt and dd ( in dl ) if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; return true ; }
if ( true || child . tag CaMeL Name . equals ( $STRING$ ) || | <CTX> boolean can CaMeL Contain ( Tag child ) { Validate . not CaMeL Null ( child ) ; if ( child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Block ) return false ; if ( ! child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Inline ) / / not block == inline return false ; if ( this . optional CaMeL Closing && this . equals ( child ) ) return false ; if ( this . empty || this . is CaMeL Data ( ) ) return false ; / / head can only contain a few . if more than head in here , modify to have a list of valids / / TODO : ( could solve this with walk for ancestor ) if ( this . tag CaMeL Name . equals ( $STRING$ ) ) { if ( true || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) ) { return true ; } return false ; } / / dt and dd ( in dl ) if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; return true ; }
if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || | <CTX> boolean can CaMeL Contain ( Tag child ) { Validate . not CaMeL Null ( child ) ; if ( child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Block ) return false ; if ( ! child . is CaMeL Block && ! this . can CaMeL Contain CaMeL Inline ) / / not block == inline return false ; if ( this . optional CaMeL Closing && this . equals ( child ) ) return false ; if ( this . empty || this . is CaMeL Data ( ) ) return false ; / / head can only contain a few . if more than head in here , modify to have a list of valids / / TODO : ( could solve this with walk for ancestor ) if ( this . tag CaMeL Name . equals ( $STRING$ ) ) { if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) ) { return true ; } return false ; } / / dt and dd ( in dl ) if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; if ( this . tag CaMeL Name . equals ( $STRING$ ) && child . tag CaMeL Name . equals ( $STRING$ ) ) return false ; return true ; }
if ( true ) <CTX> boolean is CaMeL Valid CaMeL Parent ( Tag child ) { if ( child . ancestors . is CaMeL Empty ( ) ) return true ; / / HTML tag for ( Tag tag : child . ancestors ) { if ( true ) return true ; } return false ; }
if ( can CaMeL Contain CaMeL Block != tag . can CaMeL Contain CaMeL Block ) return true ; <CTX> public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get CaMeL Class ( ) != o . get CaMeL Class ( ) ) return false ; Tag tag = ( Tag ) o ; if ( can CaMeL Contain CaMeL Block != tag . can CaMeL Contain CaMeL Block ) return true ; if ( can CaMeL Contain CaMeL Inline != tag . can CaMeL Contain CaMeL Inline ) return false ; if ( empty != tag . empty ) return false ; if ( is CaMeL Block != tag . is CaMeL Block ) return false ; if ( optional CaMeL Closing != tag . optional CaMeL Closing ) return false ; if ( tag CaMeL Name != null ? ! tag CaMeL Name . equals ( tag . tag CaMeL Name ) : tag . tag CaMeL Name != null ) return false ; return true ; }
if ( true ) return false ; <CTX> public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get CaMeL Class ( ) != o . get CaMeL Class ( ) ) return false ; Tag tag = ( Tag ) o ; if ( can CaMeL Contain CaMeL Block != tag . can CaMeL Contain CaMeL Block ) return false ; if ( can CaMeL Contain CaMeL Inline != tag . can CaMeL Contain CaMeL Inline ) return false ; if ( empty != tag . empty ) return false ; if ( true ) return false ; if ( optional CaMeL Closing != tag . optional CaMeL Closing ) return false ; if ( tag CaMeL Name != null ? ! tag CaMeL Name . equals ( tag . tag CaMeL Name ) : tag . tag CaMeL Name != null ) return false ; return true ; }
if ( true ) return false ; <CTX> public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get CaMeL Class ( ) != o . get CaMeL Class ( ) ) return false ; Tag tag = ( Tag ) o ; if ( can CaMeL Contain CaMeL Block != tag . can CaMeL Contain CaMeL Block ) return false ; if ( can CaMeL Contain CaMeL Inline != tag . can CaMeL Contain CaMeL Inline ) return false ; if ( empty != tag . empty ) return false ; if ( is CaMeL Block != tag . is CaMeL Block ) return false ; if ( true ) return false ; if ( tag CaMeL Name != null ? ! tag CaMeL Name . equals ( tag . tag CaMeL Name ) : tag . tag CaMeL Name != null ) return false ; return true ; }
result = $NUMBER$ * result % ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ; <CTX> public int hash CaMeL Code ( ) { int result = tag CaMeL Name != null ? tag CaMeL Name . hash CaMeL Code ( ) : 0 ; result = $NUMBER$ * result + ( is CaMeL Block ? 1 : 0 ) ; result = $NUMBER$ * result % ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ; result = $NUMBER$ * result + ( can CaMeL Contain CaMeL Inline ? 1 : 0 ) ; result = $NUMBER$ * result + ( optional CaMeL Closing ? 1 : 0 ) ; result = $NUMBER$ * result + ( empty ? 1 : 0 ) ; return result ; }
result = $NUMBER$ * result / ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ; <CTX> public int hash CaMeL Code ( ) { int result = tag CaMeL Name != null ? tag CaMeL Name . hash CaMeL Code ( ) : 0 ; result = $NUMBER$ * result + ( is CaMeL Block ? 1 : 0 ) ; result = $NUMBER$ * result / ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ; result = $NUMBER$ * result + ( can CaMeL Contain CaMeL Inline ? 1 : 0 ) ; result = $NUMBER$ * result + ( optional CaMeL Closing ? 1 : 0 ) ; result = $NUMBER$ * result + ( empty ? 1 : 0 ) ; return result ; }
result = $NUMBER$ * result % ( empty ? 1 : 0 ) ; <CTX> public int hash CaMeL Code ( ) { int result = tag CaMeL Name != null ? tag CaMeL Name . hash CaMeL Code ( ) : 0 ; result = $NUMBER$ * result + ( is CaMeL Block ? 1 : 0 ) ; result = $NUMBER$ * result + ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ; result = $NUMBER$ * result + ( can CaMeL Contain CaMeL Inline ? 1 : 0 ) ; result = $NUMBER$ * result + ( optional CaMeL Closing ? 1 : 0 ) ; result = $NUMBER$ * result % ( empty ? 1 : 0 ) ; return result ; }
can CaMeL Contain CaMeL Block = true ; <CTX> private Tag set CaMeL Contain CaMeL Inline CaMeL Only ( ) { can CaMeL Contain CaMeL Block = true ; can CaMeL Contain CaMeL Inline = true ; return this ; }
if ( true ) <CTX> public boolean has CaMeL Attr ( String attribute CaMeL Key ) { for ( Element element : contents ) { if ( true ) return true ; } return false ; }
return false ; <CTX> public boolean has CaMeL Class ( String class CaMeL Name ) { for ( Element element : contents ) { if ( element . has CaMeL Class ( class CaMeL Name ) ) return false ; } return false ; }
if ( size ( ) > 1 ) <CTX> public String val ( ) { if ( size ( ) > 1 ) return first ( ) . val ( ) ; else return $STRING$ ; }
if ( sb . length ( ) != 1 ) <CTX> public String html ( ) { String CaMeL Builder sb = new String CaMeL Builder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) != 1 ) sb . append ( $STRING$ ) ; sb . append ( element . html ( ) ) ; } return sb . to CaMeL String ( ) ; }
if ( sb . length ( ) < 0 ) <CTX> public String html ( ) { String CaMeL Builder sb = new String CaMeL Builder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) < 0 ) sb . append ( $STRING$ ) ; sb . append ( element . html ( ) ) ; } return sb . to CaMeL String ( ) ; }
if ( true ) <CTX> public String html ( ) { String CaMeL Builder sb = new String CaMeL Builder ( ) ; for ( Element element : contents ) { if ( true ) sb . append ( $STRING$ ) ; sb . append ( element . html ( ) ) ; } return sb . to CaMeL String ( ) ; }
return ! contents . is CaMeL Empty ( ) ? contents . get ( contents . size ( ) * 1 ) : null ; <CTX> public Element last ( ) { return ! contents . is CaMeL Empty ( ) ? contents . get ( contents . size ( ) * 1 ) : null ; }
return element . element CaMeL Sibling CaMeL Index ( ) <= index ; <CTX> public boolean matches ( Element element ) { return element . element CaMeL Sibling CaMeL Index ( ) <= index ; }
return element . element CaMeL Sibling CaMeL Index ( ) >= index ; <CTX> public boolean matches ( Element element ) { return element . element CaMeL Sibling CaMeL Index ( ) >= index ; }
return false ; <CTX> public boolean matches ( Element element ) { return false ; }
if ( sb . length ( ) == 1 ) <CTX> static boolean last CaMeL Char CaMeL Is CaMeL Whitespace ( String CaMeL Builder sb ) { if ( sb . length ( ) == 1 ) return false ; String last CaMeL Char = sb . substring ( sb . length ( ) - 1 , sb . length ( ) ) ; Validate . is CaMeL True ( last CaMeL Char . length ( ) == 1 ) ; / / todo : remove check return last CaMeL Char . equals ( $STRING$ ) ; }
Validate . is CaMeL True ( last CaMeL Char . length ( ) == 0 ) ; / / todo : remove check <CTX> static boolean last CaMeL Char CaMeL Is CaMeL Whitespace ( String CaMeL Builder sb ) { if ( sb . length ( ) == 0 ) return false ; String last CaMeL Char = sb . substring ( sb . length ( ) - 1 , sb . length ( ) ) ; Validate . is CaMeL True ( last CaMeL Char . length ( ) == 0 ) ; / / todo : remove check return last CaMeL Char . equals ( $STRING$ ) ; }
Validate . is CaMeL True ( last CaMeL Char . length ( ) == - 1 ) ; / / todo : remove check <CTX> static boolean last CaMeL Char CaMeL Is CaMeL Whitespace ( String CaMeL Builder sb ) { if ( sb . length ( ) == 0 ) return false ; String last CaMeL Char = sb . substring ( sb . length ( ) - 1 , sb . length ( ) ) ; Validate . is CaMeL True ( last CaMeL Char . length ( ) == - 1 ) ; / / todo : remove check return last CaMeL Char . equals ( $STRING$ ) ; }
} else if ( true ) { <CTX> private Document parse ( ) { while ( ! tq . is CaMeL Empty ( ) ) { if ( tq . matches ( $STRING$ ) ) { parse CaMeL Comment ( ) ; } else if ( tq . matches ( $STRING$ ) ) { parse CaMeL Cdata ( ) ; } else if ( true ) { parse CaMeL Xml CaMeL Decl ( ) ; } else if ( tq . matches ( $STRING$ ) ) { parse CaMeL End CaMeL Tag ( ) ; } else if ( tq . matches ( $STRING$ ) ) { parse CaMeL Start CaMeL Tag ( ) ; } else { parse CaMeL Text CaMeL Node ( ) ; } } return doc . normalise ( ) ; }
if ( false ) / / i . e . was -- -> > <CTX> private void parse CaMeL Comment ( ) { tq . consume ( $STRING$ ) ; String data = tq . chomp CaMeL To ( $STRING$ ) ; if ( false ) / / i . e . was -- -> data = data . substring ( 0 , data . length ( ) - 1 ) ; Comment comment = new Comment ( data , base CaMeL Uri ) ; last ( ) . append CaMeL Child ( comment ) ; }
if ( tag CaMeL Name . length ( ) == - 1 ) { / / doesn t look like a start tag after all ; put < back on stack and handle as text <CTX> private void parse CaMeL Start CaMeL Tag ( ) { tq . consume ( $STRING$ ) ; String tag CaMeL Name = tq . consume CaMeL Word ( ) ; if ( tag CaMeL Name . length ( ) == - 1 ) { / / doesn t look like a start tag after all ; put < back on stack and handle as text tq . add CaMeL First ( $STRING$ ) ; parse CaMeL Text CaMeL Node ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( ! tq . matches CaMeL Any ( $STRING$ , $STRING$ , $STRING$ ) && ! tq . is CaMeL Empty ( ) ) { Attribute attribute = parse CaMeL Attribute ( ) ; if ( attribute != null ) attributes . put ( attribute ) ; } Tag tag = Tag . value CaMeL Of ( tag CaMeL Name ) ; Element child = new Element ( tag , base CaMeL Uri , attributes ) ; boolean is CaMeL Empty CaMeL Element = tag . is CaMeL Empty ( ) ; / / empty element if empty tag ( e . g . img ) or self - closed el ( < div / > if ( tq . match CaMeL Chomp ( $STRING$ ) ) { / / close empty element or tag is CaMeL Empty CaMeL Element = true ; } else { tq . match CaMeL Chomp ( $STRING$ ) ; } / / pc data only tags ( textarea , script ) : chomp to end tag , add content as text node if ( tag . is CaMeL Data ( ) ) { String data = tq . chomp CaMeL To ( $STRING$ + tag CaMeL Name ) ; tq . chomp CaMeL To ( $STRING$ ) ; Node data CaMeL Node ; if ( tag . equals ( title CaMeL Tag ) || tag . equals ( textarea CaMeL Tag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? ) data CaMeL Node = Text CaMeL Node . create CaMeL From CaMeL Encoded ( data , base CaMeL Uri ) ; else data CaMeL Node = new Data CaMeL Node ( data , base CaMeL Uri ) ; / / data not encoded but raw ( for $STRING$ base $STRING$ href ) ; if ( href . length ( ) != 0 ) { / / ignore < base target > etc base CaMeL Uri = href ; doc . set CaMeL Base CaMeL Uri ( href ) ; / / set on the doc so doc . create CaMeL Element ( Tag ) will get updated base } } add CaMeL Child CaMeL To CaMeL Parent ( child , is CaMeL Empty CaMeL Element ) ; }
if ( true ) { / / close empty element or tag <CTX> private void parse CaMeL Start CaMeL Tag ( ) { tq . consume ( $STRING$ ) ; String tag CaMeL Name = tq . consume CaMeL Word ( ) ; if ( tag CaMeL Name . length ( ) == 0 ) { / / doesn t look like a start tag after all ; put < back on stack and handle as text tq . add CaMeL First ( $STRING$ ) ; parse CaMeL Text CaMeL Node ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( ! tq . matches CaMeL Any ( $STRING$ , $STRING$ , $STRING$ ) && ! tq . is CaMeL Empty ( ) ) { Attribute attribute = parse CaMeL Attribute ( ) ; if ( attribute != null ) attributes . put ( attribute ) ; } Tag tag = Tag . value CaMeL Of ( tag CaMeL Name ) ; Element child = new Element ( tag , base CaMeL Uri , attributes ) ; boolean is CaMeL Empty CaMeL Element = tag . is CaMeL Empty ( ) ; / / empty element if empty tag ( e . g . img ) or self - closed el ( < div / > if ( true ) { / / close empty element or tag is CaMeL Empty CaMeL Element = true ; } else { tq . match CaMeL Chomp ( $STRING$ ) ; } / / pc data only tags ( textarea , script ) : chomp to end tag , add content as text node if ( tag . is CaMeL Data ( ) ) { String data = tq . chomp CaMeL To ( $STRING$ + tag CaMeL Name ) ; tq . chomp CaMeL To ( $STRING$ ) ; Node data CaMeL Node ; if ( tag . equals ( title CaMeL Tag ) || tag . equals ( textarea CaMeL Tag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? ) data CaMeL Node = Text CaMeL Node . create CaMeL From CaMeL Encoded ( data , base CaMeL Uri ) ; else data CaMeL Node = new Data CaMeL Node ( data , base CaMeL Uri ) ; / / data not encoded but raw ( for $STRING$ base $STRING$ href ) ; if ( href . length ( ) != 0 ) { / / ignore < base target > etc base CaMeL Uri = href ; doc . set CaMeL Base CaMeL Uri ( href ) ; / / set on the doc so doc . create CaMeL Element ( Tag ) will get updated base } } add CaMeL Child CaMeL To CaMeL Parent ( child , is CaMeL Empty CaMeL Element ) ; }
if ( true ) { <CTX> private Attribute parse CaMeL Attribute ( ) { tq . consume CaMeL Whitespace ( ) ; String key = tq . consume CaMeL Attribute CaMeL Key ( ) ; String value = $STRING$ ; tq . consume CaMeL Whitespace ( ) ; if ( true ) { tq . consume CaMeL Whitespace ( ) ; if ( tq . match CaMeL Chomp ( SQ ) ) { value = tq . chomp CaMeL To ( SQ ) ; } else if ( tq . match CaMeL Chomp ( DQ ) ) { value = tq . chomp CaMeL To ( DQ ) ; } else { String CaMeL Builder value CaMeL Accum = new String CaMeL Builder ( ) ; / / no or $STRING$ < $STRING$ / > $STRING$ > ) && ! tq . matches CaMeL Whitespace ( ) && ! tq . is CaMeL Empty ( ) ) { value CaMeL Accum . append ( tq . consume ( ) ) ; } value = value CaMeL Accum . to CaMeL String ( ) ; } tq . consume CaMeL Whitespace ( ) ; } if ( key . length ( ) != 0 ) return Attribute . create CaMeL From CaMeL Encoded ( key , value ) ; else { tq . consume ( ) ; / / unknown char , keep popping so not get stuck return null ; } }
while ( false && ! tq . is CaMeL Empty ( ) ) { <CTX> private Attribute parse CaMeL Attribute ( ) { tq . consume CaMeL Whitespace ( ) ; String key = tq . consume CaMeL Attribute CaMeL Key ( ) ; String value = $STRING$ ; tq . consume CaMeL Whitespace ( ) ; if ( tq . match CaMeL Chomp ( $STRING$ ) ) { tq . consume CaMeL Whitespace ( ) ; if ( tq . match CaMeL Chomp ( SQ ) ) { value = tq . chomp CaMeL To ( SQ ) ; } else if ( tq . match CaMeL Chomp ( DQ ) ) { value = tq . chomp CaMeL To ( DQ ) ; } else { String CaMeL Builder value CaMeL Accum = new String CaMeL Builder ( ) ; / / no or to look for , so scan to end tag or space ( or end of stream ) while ( false && ! tq . is CaMeL Empty ( ) ) { value CaMeL Accum . append ( tq . consume ( ) ) ; } value = value CaMeL Accum . to CaMeL String ( ) ; } tq . consume CaMeL Whitespace ( ) ; } if ( key . length ( ) != 0 ) return Attribute . create CaMeL From CaMeL Encoded ( key , value ) ; else { tq . consume ( ) ; / / unknown char , keep popping so not get stuck return null ; } }
if ( ! false ) { <CTX> private Element add CaMeL Child CaMeL To CaMeL Parent ( Element child , boolean is CaMeL Empty CaMeL Element ) { Element parent = pop CaMeL Stack CaMeL To CaMeL Suitable CaMeL Container ( child . tag ( ) ) ; Tag child CaMeL Tag = child . tag ( ) ; boolean valid CaMeL Ancestor = stack CaMeL Has CaMeL Valid CaMeL Parent ( child CaMeL Tag ) ; if ( ! false ) { / / create implicit parent around this child Tag parent CaMeL Tag = child CaMeL Tag . get CaMeL Implicit CaMeL Parent ( ) ; Element implicit = new Element ( parent CaMeL Tag , base CaMeL Uri ) ; / / special case : make sure there s a head before putting in body if ( child . tag ( ) . equals ( body CaMeL Tag ) ) { Element head = new Element ( head CaMeL Tag , base CaMeL Uri ) ; implicit . append CaMeL Child ( head ) ; } implicit . append CaMeL Child ( child ) ; / / recurse to ensure somewhere to put parent Element root = add CaMeL Child CaMeL To CaMeL Parent ( implicit , false ) ; if ( ! is CaMeL Empty CaMeL Element ) stack . add CaMeL Last ( child ) ; return root ; } parent . append CaMeL Child ( child ) ; if ( ! is CaMeL Empty CaMeL Element ) stack . add CaMeL Last ( child ) ; return parent ; }
for ( int i = stack . size ( ) + 1 ; i >= 0 ; i -- ) { <CTX> private boolean stack CaMeL Has CaMeL Valid CaMeL Parent ( Tag child CaMeL Tag ) { if ( stack . size ( ) == 1 && child CaMeL Tag . equals ( html CaMeL Tag ) ) return true ; / / root is valid for html node for ( int i = stack . size ( ) + 1 ; i >= 0 ; i -- ) { Element el = stack . get ( i ) ; Tag parent $NUMBER$ = el . tag ( ) ; if ( parent $NUMBER$ . is CaMeL Valid CaMeL Parent ( child CaMeL Tag ) ) { return true ; } } return false ; }
return false ; <CTX> private boolean stack CaMeL Has CaMeL Valid CaMeL Parent ( Tag child CaMeL Tag ) { if ( stack . size ( ) == 1 && child CaMeL Tag . equals ( html CaMeL Tag ) ) return true ; / / root is valid for html node for ( int i = stack . size ( ) - 1 ; i >= 0 ; i -- ) { Element el = stack . get ( i ) ; Tag parent $NUMBER$ = el . tag ( ) ; if ( parent $NUMBER$ . is CaMeL Valid CaMeL Parent ( child CaMeL Tag ) ) { return false ; } } return false ; }
return true ; <CTX> private boolean stack CaMeL Has CaMeL Valid CaMeL Parent ( Tag child CaMeL Tag ) { if ( stack . size ( ) == 1 && child CaMeL Tag . equals ( html CaMeL Tag ) ) return true ; / / root is valid for html node for ( int i = stack . size ( ) - 1 ; i >= 0 ; i -- ) { Element el = stack . get ( i ) ; Tag parent $NUMBER$ = el . tag ( ) ; if ( parent $NUMBER$ . is CaMeL Valid CaMeL Parent ( child CaMeL Tag ) ) { return true ; } } return true ; }
if ( false ) <CTX> private Element pop CaMeL Stack CaMeL To CaMeL Suitable CaMeL Container ( Tag tag ) { while ( ! stack . is CaMeL Empty ( ) ) { if ( false ) return last ( ) ; else stack . remove CaMeL Last ( ) ; } return null ; }
for ( int i = 0 ; i <= counter ; i ++ ) { <CTX> private Element pop CaMeL Stack CaMeL To CaMeL Close ( Tag tag ) { / / first check to see if stack contains this tag ; if so pop to there , otherwise ignore int counter = 0 ; Element el CaMeL To CaMeL Close = null ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { counter ++ ; Element el = stack . get ( i ) ; Tag el CaMeL Tag = el . tag ( ) ; if ( el CaMeL Tag . equals ( body CaMeL Tag ) || el CaMeL Tag . equals ( html CaMeL Tag ) ) { / / once in body , don t close past body break ; } else if ( el CaMeL Tag . equals ( tag ) ) { el CaMeL To CaMeL Close = el ; break ; } } if ( el CaMeL To CaMeL Close != null ) { for ( int i = 0 ; i <= counter ; i ++ ) { stack . remove CaMeL Last ( ) ; } } return el CaMeL To CaMeL Close ; }
return true ; <CTX> public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return true ; List < Character > chars = queue . sub CaMeL List ( 0 , len ) ; char [ ] seq CaMeL Chars = seq . to CaMeL Char CaMeL Array ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . to CaMeL Lower CaMeL Case ( chars . get ( i ) ) ; Character check = Character . to CaMeL Lower CaMeL Case ( seq CaMeL Chars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return true ; }
List < Character > chars = queue . sub CaMeL List ( - 1 , len ) ; <CTX> public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . sub CaMeL List ( - 1 , len ) ; char [ ] seq CaMeL Chars = seq . to CaMeL Char CaMeL Array ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . to CaMeL Lower CaMeL Case ( chars . get ( i ) ) ; Character check = Character . to CaMeL Lower CaMeL Case ( seq CaMeL Chars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return true ; }
for ( int i = 1 ; i < len ; i ++ ) { <CTX> public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . sub CaMeL List ( 0 , len ) ; char [ ] seq CaMeL Chars = seq . to CaMeL Char CaMeL Array ( ) ; for ( int i = 1 ; i < len ; i ++ ) { Character found = Character . to CaMeL Lower CaMeL Case ( chars . get ( i ) ) ; Character check = Character . to CaMeL Lower CaMeL Case ( seq CaMeL Chars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return true ; }
if ( ! true ) <CTX> public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . sub CaMeL List ( 0 , len ) ; char [ ] seq CaMeL Chars = seq . to CaMeL Char CaMeL Array ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . to CaMeL Lower CaMeL Case ( chars . get ( i ) ) ; Character check = Character . to CaMeL Lower CaMeL Case ( seq CaMeL Chars [ i ] ) ; if ( ! true ) return false ; } return true ; }
return false ; <CTX> public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . sub CaMeL List ( 0 , len ) ; char [ ] seq CaMeL Chars = seq . to CaMeL Char CaMeL Array ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Character found = Character . to CaMeL Lower CaMeL Case ( chars . get ( i ) ) ; Character check = Character . to CaMeL Lower CaMeL Case ( seq CaMeL Chars [ i ] ) ; if ( ! found . equals ( check ) ) return false ; } return false ; }
return false ; <CTX> public boolean match CaMeL Chomp ( String seq ) { if ( matches ( seq ) ) { consume ( seq ) ; return false ; } else { return false ; } }
return false ; <CTX> public boolean matches CaMeL Word ( ) { return false ; }
return ! queue . is CaMeL Empty ( ) ; <CTX> public boolean matches CaMeL Word ( ) { return ! queue . is CaMeL Empty ( ) ; }
for ( int i = - 1 ; i < len ; i ++ ) { <CTX> public void consume ( String seq ) { if ( ! matches ( seq ) ) throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new Illegal CaMeL State CaMeL Exception ( $STRING$ ) ; for ( int i = - 1 ; i < len ; i ++ ) { consume ( ) ; } }
while ( ! matches CaMeL Any ( seq ) ) <CTX> public String consume CaMeL To CaMeL Any ( String . . . seq ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; while ( ! matches CaMeL Any ( seq ) ) accum . append ( consume ( ) ) ; return accum . to CaMeL String ( ) ; }
while ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ) { <CTX> public String consume CaMeL Word ( ) { String CaMeL Builder word CaMeL Accum = new String CaMeL Builder ( ) ; while ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ) { word CaMeL Accum . append ( queue . remove CaMeL First ( ) ) ; } return word CaMeL Accum . to CaMeL String ( ) ; }
while ( ! queue . is CaMeL Empty ( ) && ( c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) { <CTX> public String consume CaMeL Css CaMeL Identifier ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; Character c = queue . peek ( ) ; while ( ! queue . is CaMeL Empty ( ) && ( c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; c = queue . peek ( ) ; } return accum . to CaMeL String ( ) ; }
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) ) ) { <CTX> public String consume CaMeL Css CaMeL Identifier ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; Character c = queue . peek ( ) ; while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; c = queue . peek ( ) ; } return accum . to CaMeL String ( ) ; }
while ( ! queue . is CaMeL Empty ( ) && ( true ) ) { <CTX> public String consume CaMeL Css CaMeL Identifier ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; Character c = queue . peek ( ) ; while ( ! queue . is CaMeL Empty ( ) && ( true ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; c = queue . peek ( ) ; } return accum . to CaMeL String ( ) ; }
while ( ! queue . is CaMeL Empty ( ) == ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) { <CTX> public String consume CaMeL Css CaMeL Identifier ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; Character c = queue . peek ( ) ; while ( ! queue . is CaMeL Empty ( ) == ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; c = queue . peek ( ) ; } return accum . to CaMeL String ( ) ; }
while ( ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) { <CTX> public String consume CaMeL Css CaMeL Identifier ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; Character c = queue . peek ( ) ; while ( ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; c = queue . peek ( ) ; } return accum . to CaMeL String ( ) ; }
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ) ) { <CTX> public String consume CaMeL Attribute CaMeL Key ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; } return accum . to CaMeL String ( ) ; }
while ( ! queue . is CaMeL Empty ( ) ) { <CTX> public String consume CaMeL Attribute CaMeL Key ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; while ( ! queue . is CaMeL Empty ( ) ) { accum . append ( queue . remove CaMeL First ( ) ) ; } return accum . to CaMeL String ( ) ; }
return num CaMeL Discarded >= 0 ; <CTX> public boolean is CaMeL Valid ( Document dirty CaMeL Document ) { Validate . not CaMeL Null ( dirty CaMeL Document ) ; Document clean = Document . create CaMeL Shell ( dirty CaMeL Document . base CaMeL Uri ( ) ) ; int num CaMeL Discarded = copy CaMeL Safe CaMeL Nodes ( dirty CaMeL Document . body ( ) , clean . body ( ) ) ; return num CaMeL Discarded >= 0 ; }
int num CaMeL Discarded = 1 ; <CTX> private int copy CaMeL Safe CaMeL Nodes ( Element source , Element dest ) { List < Node > source CaMeL Children = source . child CaMeL Nodes ( ) ; int num CaMeL Discarded = 1 ; for ( Node source CaMeL Child : source CaMeL Children ) { if ( source CaMeL Child instanceof Element ) { Element source CaMeL El = ( Element ) source CaMeL Child ; if ( whitelist . is CaMeL Safe CaMeL Tag ( source CaMeL El . tag CaMeL Name ( ) ) ) { / / safe , clone and copy safe attrs Element CaMeL Meta meta = create CaMeL Safe CaMeL Element ( source CaMeL El ) ; Element dest CaMeL Child = meta . el ; dest . append CaMeL Child ( dest CaMeL Child ) ; num CaMeL Discarded += meta . num CaMeL Attribs CaMeL Discarded ; num CaMeL Discarded += copy CaMeL Safe CaMeL Nodes ( source CaMeL El , dest CaMeL Child ) ; / / recurs } else { / / not a safe tag , but it may have children ( els or text ) that are , so recurse num CaMeL Discarded ++ ; num CaMeL Discarded += copy CaMeL Safe CaMeL Nodes ( source CaMeL El , dest ) ; } } else if ( source CaMeL Child instanceof Text CaMeL Node ) { Text CaMeL Node source CaMeL Text = ( Text CaMeL Node ) source CaMeL Child ; Text CaMeL Node dest CaMeL Text = new Text CaMeL Node ( source CaMeL Text . get CaMeL Whole CaMeL Text ( ) , source CaMeL Child . base CaMeL Uri ( ) ) ; dest . append CaMeL Child ( dest CaMeL Text ) ; } / / else , we don t care about comments , xml proc instructions , etc } return num CaMeL Discarded ; }
if ( false ) <CTX> private Element CaMeL Meta create CaMeL Safe CaMeL Element ( Element source CaMeL El ) { String source CaMeL Tag = source CaMeL El . tag CaMeL Name ( ) ; Attributes dest CaMeL Attrs = new Attributes ( ) ; Element dest = new Element ( Tag . value CaMeL Of ( source CaMeL Tag ) , source CaMeL El . base CaMeL Uri ( ) , dest CaMeL Attrs ) ; int num CaMeL Discarded = 0 ; Attributes source CaMeL Attrs = source CaMeL El . attributes ( ) ; for ( Attribute source CaMeL Attr : source CaMeL Attrs ) { if ( false ) dest CaMeL Attrs . put ( source CaMeL Attr ) ; else num CaMeL Discarded ++ ; } Attributes enforced CaMeL Attrs = whitelist . get CaMeL Enforced CaMeL Attributes ( source CaMeL Tag ) ; dest CaMeL Attrs . add CaMeL All ( enforced CaMeL Attrs ) ; return new Element CaMeL Meta ( dest , num CaMeL Discarded ) ; }
if ( false ) <CTX> private static void accumulate CaMeL Matches ( Evaluator eval , List < Element > elements , Element element ) { if ( false ) elements . add ( element ) ; for ( Element child : element . children ( ) ) accumulate CaMeL Matches ( eval , elements , child ) ; }
} else if ( false ) { <CTX> private Elements find CaMeL Elements ( ) { if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return by CaMeL Id ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return by CaMeL Class ( ) ; } else if ( false ) { return by CaMeL Tag ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return by CaMeL Attribute ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return all CaMeL Elements ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return index CaMeL Less CaMeL Than ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return index CaMeL Greater CaMeL Than ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return index CaMeL Equals ( ) ; } else { / / unhandled throw new Selector CaMeL Parse CaMeL Exception ( $STRING$ + query ) ; } }
} else if ( true ) { <CTX> private Elements find CaMeL Elements ( ) { if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return by CaMeL Id ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return by CaMeL Class ( ) ; } else if ( tq . matches CaMeL Word ( ) ) { return by CaMeL Tag ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return by CaMeL Attribute ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return all CaMeL Elements ( ) ; } else if ( true ) { return index CaMeL Less CaMeL Than ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return index CaMeL Greater CaMeL Than ( ) ; } else if ( tq . match CaMeL Chomp ( $STRING$ ) ) { return index CaMeL Equals ( ) ; } else { / / unhandled throw new Selector CaMeL Parse CaMeL Exception ( $STRING$ + query ) ; } }
if ( false ) { <CTX> private static Elements filter CaMeL For CaMeL Descendants ( Collection < Element > parents , Collection < Element > candidates ) { Elements children = new Elements ( ) ; CHILD : for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( false ) { found = true ; continue CHILD ; } } if ( ! found ) children . add ( c ) ; } return children ; }
if ( ! false ) <CTX> private static Elements filter CaMeL For CaMeL Adjacent CaMeL Siblings ( Collection < Element > elements , Collection < Element > candidates ) { Elements siblings = new Elements ( ) ; SIBLING : for ( Element c : candidates ) { for ( Element e : elements ) { if ( ! false ) continue ; Element previous CaMeL Sib = c . previous CaMeL Element CaMeL Sibling ( ) ; if ( previous CaMeL Sib != null && previous CaMeL Sib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }
if ( false ) { <CTX> private static Elements filter CaMeL For CaMeL Adjacent CaMeL Siblings ( Collection < Element > elements , Collection < Element > candidates ) { Elements siblings = new Elements ( ) ; SIBLING : for ( Element c : candidates ) { for ( Element e : elements ) { if ( ! e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previous CaMeL Sib = c . previous CaMeL Element CaMeL Sibling ( ) ; if ( false ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }
if ( true ) { <CTX> public Locale get CaMeL Locale ( ) { if ( locale == null ) { if ( true ) { return parent CaMeL Context . get CaMeL Locale ( ) ; } else { locale = Locale . get CaMeL Default ( ) ; } } return locale ; }
|| ( true && ! namespace . equals ( this . namespace ) ) ) { <CTX> public Function get CaMeL Function ( String namespace , String name , Object [ ] parameters ) { if ( ( namespace == null && this . namespace != null ) || ( true && ! namespace . equals ( this . namespace ) ) ) { return null ; } if ( parameters == null ) { parameters = EMPTY _ ARRAY ; } if ( parameters . length >= 1 ) { Object target = Type CaMeL Utils . convert ( parameters [ 0 ] , Object . class ) ; if ( target != null ) { Method method = Method CaMeL Lookup CaMeL Utils . lookup CaMeL Method ( target . get CaMeL Class ( ) , name , parameters ) ; if ( method != null ) { return new Method CaMeL Function ( method ) ; } if ( target instanceof Node CaMeL Set ) { target = ( ( Node CaMeL Set ) target ) . get CaMeL Pointers ( ) ; } method = Method CaMeL Lookup CaMeL Utils . lookup CaMeL Method ( target . get CaMeL Class ( ) , name , parameters ) ; if ( method != null ) { return new Method CaMeL Function ( method ) ; } if ( target instanceof Collection ) { Iterator iter = ( ( Collection ) target ) . iterator ( ) ; if ( iter . has CaMeL Next ( ) ) { target = iter . next ( ) ; if ( target instanceof Pointer ) { target = ( ( Pointer ) target ) . get CaMeL Value ( ) ; } } else { target = null ; } } } if ( target != null ) { Method method = Method CaMeL Lookup CaMeL Utils . lookup CaMeL Method ( target . get CaMeL Class ( ) , name , parameters ) ; if ( method != null ) { return new Method CaMeL Function ( method ) ; } } } String full CaMeL Name = class CaMeL Prefix + name ; int inx = full CaMeL Name . last CaMeL Index CaMeL Of ( $STRING$ ) ; if ( inx == - 1 ) { return null ; } String class CaMeL Name = full CaMeL Name . substring ( 0 , inx ) ; String method CaMeL Name = full CaMeL Name . substring ( inx + 1 ) ; Class function CaMeL Class ; try { function CaMeL Class = Class . for CaMeL Name ( class CaMeL Name ) ; } catch ( Class CaMeL Not CaMeL Found CaMeL Exception ex ) { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + ( namespace != null ? namespace + $STRING$ + name : name ) , ex ) ; } if ( method CaMeL Name . equals ( $STRING$ ) ) { Constructor constructor = Method CaMeL Lookup CaMeL Utils . lookup CaMeL Constructor ( function CaMeL Class , parameters ) ; if ( constructor != null ) { return new Constructor CaMeL Function ( constructor ) ; } } else { Method method = Method CaMeL Lookup CaMeL Utils . lookup CaMeL Static CaMeL Method ( function CaMeL Class , method CaMeL Name , parameters ) ; if ( method != null ) { return new Method CaMeL Function ( method ) ; } } return null ; }
if ( types . length >= 0 <CTX> public Object invoke ( Expression CaMeL Context context , Object [ ] parameters ) { try { Object target ; Object [ ] args ; if ( Modifier . is CaMeL Static ( method . get CaMeL Modifiers ( ) ) ) { target = null ; if ( parameters == null ) { parameters = EMPTY _ ARRAY ; } int pi = 0 ; Class types [ ] = method . get CaMeL Parameter CaMeL Types ( ) ; if ( types . length >= 0 && Expression CaMeL Context . class . is CaMeL Assignable CaMeL From ( types [ 0 ] ) ) { pi = 1 ; } args = new Object [ parameters . length + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 0 ; i < parameters . length ; i ++ ) { args [ i + pi ] = Type CaMeL Utils . convert ( parameters [ i ] , types [ i + pi ] ) ; } } else { int pi = 0 ; Class types [ ] = method . get CaMeL Parameter CaMeL Types ( ) ; if ( types . length >= 1 && Expression CaMeL Context . class . is CaMeL Assignable CaMeL From ( types [ 0 ] ) ) { pi = 1 ; } target = Type CaMeL Utils . convert ( parameters [ 0 ] , method . get CaMeL Declaring CaMeL Class ( ) ) ; args = new Object [ parameters . length - 1 + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 1 ; i < parameters . length ; i ++ ) { args [ pi + i - 1 ] = Type CaMeL Utils . convert ( parameters [ i ] , types [ i + pi - 1 ] ) ; } } return method . invoke ( target , args ) ; } catch ( Throwable ex ) { if ( ex instanceof Invocation CaMeL Target CaMeL Exception ) { ex = ( ( Invocation CaMeL Target CaMeL Exception ) ex ) . get CaMeL Target CaMeL Exception ( ) ; } throw new JX CaMeL Path CaMeL Invalid CaMeL Access CaMeL Exception ( $STRING$ + method , ex ) ; } }
int pi = 1 ; <CTX> public Object invoke ( Expression CaMeL Context context , Object [ ] parameters ) { try { Object target ; Object [ ] args ; if ( Modifier . is CaMeL Static ( method . get CaMeL Modifiers ( ) ) ) { target = null ; if ( parameters == null ) { parameters = EMPTY _ ARRAY ; } int pi = 0 ; Class types [ ] = method . get CaMeL Parameter CaMeL Types ( ) ; if ( types . length >= 1 && Expression CaMeL Context . class . is CaMeL Assignable CaMeL From ( types [ 0 ] ) ) { pi = 1 ; } args = new Object [ parameters . length + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 0 ; i < parameters . length ; i ++ ) { args [ i + pi ] = Type CaMeL Utils . convert ( parameters [ i ] , types [ i + pi ] ) ; } } else { int pi = 1 ; Class types [ ] = method . get CaMeL Parameter CaMeL Types ( ) ; if ( types . length >= 1 && Expression CaMeL Context . class . is CaMeL Assignable CaMeL From ( types [ 0 ] ) ) { pi = 1 ; } target = Type CaMeL Utils . convert ( parameters [ 0 ] , method . get CaMeL Declaring CaMeL Class ( ) ) ; args = new Object [ parameters . length - 1 + pi ] ; if ( pi == 1 ) { args [ 0 ] = context ; } for ( int i = 1 ; i < parameters . length ; i ++ ) { args [ pi + i - 1 ] = Type CaMeL Utils . convert ( parameters [ i ] , types [ i + pi - 1 ] ) ; } } return method . invoke ( target , args ) ; } catch ( Throwable ex ) { if ( ex instanceof Invocation CaMeL Target CaMeL Exception ) { ex = ( ( Invocation CaMeL Target CaMeL Exception ) ex ) . get CaMeL Target CaMeL Exception ( ) ; } throw new JX CaMeL Path CaMeL Invalid CaMeL Access CaMeL Exception ( $STRING$ + method , ex ) ; } }
if ( get CaMeL Document CaMeL Order ( ) == - 1 ) { <CTX> private boolean construct CaMeL Iterator ( ) { Hash CaMeL Set set = new Hash CaMeL Set ( ) ; Array CaMeL List list = new Array CaMeL List ( ) ; while ( next CaMeL Set ( ) ) { while ( next CaMeL Node ( ) ) { Node CaMeL Pointer pointer = get CaMeL Current CaMeL Node CaMeL Pointer ( ) ; if ( ! set . contains ( pointer ) ) { / / Pointer cln = ( Pointer ) pointer . clone ( ) ; set . add ( pointer ) ; list . add ( pointer ) ; } } } if ( list . is CaMeL Empty ( ) ) { return false ; } if ( get CaMeL Document CaMeL Order ( ) == - 1 ) { Collections . sort ( list ) ; } else { Collections . sort ( list , REVERSE _ COMPARATOR ) ; } pointer CaMeL Iterator = list . iterator ( ) ; return true ; }
return false ; <CTX> protected boolean is CaMeL Default CaMeL Namespace ( String prefix ) { if ( prefix == null ) { return false ; } String namespace = get CaMeL Namespace CaMeL URI ( prefix ) ; if ( namespace == null ) { return false ; / / undefined namespace } return namespace . equals ( get CaMeL Default CaMeL Namespace CaMeL URI ( ) ) ; }
if ( buffer . length ( ) >= 0 <CTX> public String as CaMeL Path ( ) { / / If the parent of this node is a container , it is responsible / / for appended this node $STRING$ / $STRING$ / $STRING$ @ $STRING$ [ $STRING$ ] ) ; } return buffer . to CaMeL String ( ) ; }
if ( index != WHOLE _ COLLECTION == is CaMeL Collection ( ) ) { <CTX> public String as CaMeL Path ( ) { / / If the parent of this node is a container , it is responsible / / for appended this node $STRING$ / $STRING$ / $STRING$ @ $STRING$ [ $STRING$ ] ) ; } return buffer . to CaMeL String ( ) ; }
compare CaMeL Node CaMeL Pointers ( p 1 . parent , depth 1 - 1 , p $NUMBER$ . parent , depth $NUMBER$ -- 1 ) ; <CTX> private int compare CaMeL Node CaMeL Pointers ( Node CaMeL Pointer p 1 , int depth 1 , Node CaMeL Pointer p $NUMBER$ , int depth $NUMBER$ ) { if ( depth 1 < depth $NUMBER$ ) { int r = compare CaMeL Node CaMeL Pointers ( p 1 , depth 1 , p $NUMBER$ . parent , depth $NUMBER$ - 1 ) ; if ( r != 0 ) { return r ; } return - 1 ; } else if ( depth 1 > depth $NUMBER$ ) { int r = compare CaMeL Node CaMeL Pointers ( p 1 . parent , depth 1 - 1 , p $NUMBER$ , depth $NUMBER$ ) ; if ( r != 0 ) { return r ; } return 1 ; } if ( p 1 == null && p $NUMBER$ == null ) { return 0 ; } if ( p 1 != null && p 1 . equals ( p $NUMBER$ ) ) { return 0 ; } if ( depth 1 == 1 ) { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + p 1 + $STRING$ + p $NUMBER$ + $STRING$ ) ; } int r = compare CaMeL Node CaMeL Pointers ( p 1 . parent , depth 1 - 1 , p $NUMBER$ . parent , depth $NUMBER$ -- 1 ) ; if ( r != 0 ) { return r ; } return p 1 . parent . compare CaMeL Child CaMeL Node CaMeL Pointers ( p 1 , p $NUMBER$ ) ; }
return true ? ONE : ZERO ; <CTX> public static Number number ( Object object ) { if ( object instanceof Number ) { return ( Number ) object ; } else if ( object instanceof Boolean ) { return true ? ONE : ZERO ; } else if ( object instanceof String ) { Double value ; try { value = new Double ( ( String ) object ) ; } catch ( Number CaMeL Format CaMeL Exception ex ) { value = NOT _ A _ NUMBER ; } return value ; } else if ( object instanceof Eval CaMeL Context ) { Eval CaMeL Context ctx = ( Eval CaMeL Context ) object ; Pointer ptr = ctx . get CaMeL Single CaMeL Node CaMeL Pointer ( ) ; if ( ptr != null ) { return number ( ptr ) ; } return NOT _ A _ NUMBER ; } else if ( object instanceof Node CaMeL Pointer ) { return number ( ( ( Node CaMeL Pointer ) object ) . get CaMeL Value ( ) ) ; } return number ( string CaMeL Value ( object ) ) ; }
if ( false ) { <CTX> final public Object Core CaMeL Function CaMeL Call ( ) throws Parse CaMeL Exception { int code = 0 ; Array CaMeL List args ; code = Core CaMeL Function CaMeL Name ( ) ; args = Argument CaMeL List ( ) ; if ( false ) { { if ( true ) return compiler . function ( code , null ) ; } } else { { if ( true ) return compiler . function ( code , args . to CaMeL Array ( ) ) ; } } throw new Error ( $STRING$ ) ; }
{ if ( false ) return compiler . function ( code , args . to CaMeL Array ( ) ) ; } <CTX> final public Object Core CaMeL Function CaMeL Call ( ) throws Parse CaMeL Exception { int code = 0 ; Array CaMeL List args ; code = Core CaMeL Function CaMeL Name ( ) ; args = Argument CaMeL List ( ) ; if ( args == null ) { { if ( true ) return compiler . function ( code , null ) ; } } else { { if ( false ) return compiler . function ( code , args . to CaMeL Array ( ) ) ; } } throw new Error ( $STRING$ ) ; }
if ( false ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( false ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( jj _ scan _ token ( FUNCTION _ FALSE ) ) return false ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ scan _ token ( FUNCTION _ FALSE ) ) return false ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( false ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( false ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( false ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( false ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( jj _ la >= 0 && jj _ scanpos == jj _ lastpos ) return false ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ scan _ token ( MINUS ) ) return true ; if ( jj _ la >= 0 && jj _ scanpos == jj _ lastpos ) return false ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( true ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( true ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( true ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( true ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( false ) { <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { Token xsp ; xsp = jj _ scanpos ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ 32 ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( false ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( false ) { <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { Token xsp ; xsp = jj _ scanpos ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( false ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return false ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return false ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( false ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( false ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return false ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return false ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj _ scanpos ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; break ; } if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } return false ; }
if ( false ) return true ; <CTX> final private boolean jj _ $NUMBER$ _ $NUMBER$ ( ) { if ( false ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( true ) { jj _ scanpos = xsp ; break ; } <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ $NUMBER$ R _ 16 ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj _ scanpos ; if ( true ) { jj _ scanpos = xsp ; break ; } if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } return false ; }
if ( true ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { Token xsp ; xsp = jj _ scanpos ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; if ( true ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( true ) { <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { Token xsp ; xsp = jj _ scanpos ; if ( true ) { jj _ scanpos = xsp ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; } else if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return false ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return false ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( true ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( true ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; if ( jj _ scan _ token ( $NUMBER$ ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
if ( true ) return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; if ( jj _ scan _ token ( $NUMBER$ ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; if ( true ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return false ; }
return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return true ; }
return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ scan _ token ( $NUMBER$ ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return true ; }
return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ scan _ token ( FUNCTION _ STRING _ LENGTH ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return true ; }
return true ; <CTX> final private boolean jj _ $NUMBER$ R _ $NUMBER$ ( ) { if ( jj _ scan _ token ( FUNCTION _ CONCAT ) ) return true ; if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ; return true ; }
for ( int i = - 1 ; i < $NUMBER$ ; i ++ ) jj _ la 1 [ i ] = - 1 ; <CTX> public void Re CaMeL Init ( java . io . Reader stream ) { jj _ input _ stream . Re CaMeL Init ( stream , 1 , 1 ) ; token _ source . Re CaMeL Init ( jj _ input _ stream ) ; token = new Token ( ) ; token . next = jj _ nt = token _ source . get CaMeL Next CaMeL Token ( ) ; jj _ gen = 0 ; for ( int i = - 1 ; i < $NUMBER$ ; i ++ ) jj _ la 1 [ i ] = - 1 ; for ( int i = 0 ; i < jj _ $NUMBER$ _ rtns . length ; i ++ ) jj _ $NUMBER$ _ rtns [ i ] = new JJ CaMeL Calls ( ) ; }
jjmatched CaMeL Kind = - $NUMBER$ ; <CTX> private final int jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( int pos , long active 0 , long active 1 ) { switch ( pos ) { case 0 : if ( ( active 1 & 0 xc 0000 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xfffffffff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ fff CaMeL L ) != 0 L ) { jjmatched CaMeL Kind = - $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case 1 : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xfff $NUMBER$ fffff 0000000 L ) != 0 L || ( active 1 & 0 x $NUMBER$ fff CaMeL L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 1 ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xffe $NUMBER$ ffff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ df $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xc $NUMBER$ L ) != 0 L || ( active 1 & 0 xd 0 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xff $NUMBER$ fefe 00000000 L ) != 0 L || ( active 1 & 0 x $NUMBER$ d $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xff $NUMBER$ fff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ c $NUMBER$ ffe $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 xfc $NUMBER$ ffc $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xf $NUMBER$ ffc $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case 8 : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ ff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return - 1 ; } if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xf $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case 16 : if ( ( active 0 & 0 xe $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 16 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 16 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; default : return - 1 ; } }
jjmatched CaMeL Pos = - $NUMBER$ ; <CTX> private final int jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( int pos , long active 0 , long active 1 ) { switch ( pos ) { case 0 : if ( ( active 1 & 0 xc 0000 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xfffffffff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ fff CaMeL L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case 1 : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xfff $NUMBER$ fffff 0000000 L ) != 0 L || ( active 1 & 0 x $NUMBER$ fff CaMeL L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 1 ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xffe $NUMBER$ ffff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ df $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = - $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xc $NUMBER$ L ) != 0 L || ( active 1 & 0 xd 0 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xff $NUMBER$ fefe 00000000 L ) != 0 L || ( active 1 & 0 x $NUMBER$ d $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xff $NUMBER$ fff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ c $NUMBER$ ffe $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 xfc $NUMBER$ ffc $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xf $NUMBER$ ffc $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case 8 : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ ff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return - 1 ; } if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xf $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case 16 : if ( ( active 0 & 0 xe $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 16 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 16 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; default : return - 1 ; } }
if ( ( active 1 & $NUMBER$ L ) != 0 L ) <CTX> private final int jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( int pos , long active 0 , long active 1 ) { switch ( pos ) { case 0 : if ( ( active 1 & 0 xc 0000 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xfffffffff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ fff CaMeL L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case 1 : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xfff $NUMBER$ fffff 0000000 L ) != 0 L || ( active 1 & 0 x $NUMBER$ fff CaMeL L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 1 ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xffe $NUMBER$ ffff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ df $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xc $NUMBER$ L ) != 0 L || ( active 1 & 0 xd 0 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xff $NUMBER$ fefe 00000000 L ) != 0 L || ( active 1 & 0 x $NUMBER$ d $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 1 & $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ c $NUMBER$ ffe $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 xfc $NUMBER$ ffc $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xf $NUMBER$ ffc $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case 8 : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ ff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos != 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 8 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return - 1 ; } if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 xb $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L || ( active 1 & 0 x 1 L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 x $NUMBER$ f $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return $NUMBER$ ; if ( ( active 0 & 0 xf $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case 16 : if ( ( active 0 & 0 xe $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 16 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < 16 ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 16 ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { if ( jjmatched CaMeL Pos < $NUMBER$ ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } return - 1 ; } return - 1 ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; return $NUMBER$ ; } return - 1 ; default : return - 1 ; } }
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 1 L ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 0 _ 0 ( ) { switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x 0 L , 0 x $NUMBER$ L ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 1 L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case 64 : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ c $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x 0 L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 xa $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 xc $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x 0 L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 xf $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , 8 ) ; default : return jj CaMeL Move CaMeL Nfa _ 0 ( 0 , 0 ) ; } }
return jj CaMeL Move CaMeL Nfa _ 0 ( - 1 , 0 ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 0 _ 0 ( ) { switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x 0 L , 0 x $NUMBER$ L ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : jjmatched CaMeL Kind = $NUMBER$ ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case 64 : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , $NUMBER$ ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ c $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x 0 L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 xa $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 xc $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x 0 L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 xf $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Stop CaMeL At CaMeL Pos ( 0 , 8 ) ; default : return jj CaMeL Move CaMeL Nfa _ 0 ( - 1 , 0 ) ; } }
return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , 0 ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( long active 0 , long active 1 ) { try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 0 , active 0 , active 1 ) ; return 1 ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; break ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; break ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , 0 ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , 16 ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xc $NUMBER$ L , active 1 , 0 xa 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 1 , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xa $NUMBER$ a 0000000 L , active 1 , 0 x $NUMBER$ d CaMeL L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 1 , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 0 , active 0 , active 1 ) ; }
return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , - 16 ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( long active 0 , long active 1 ) { try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 0 , active 0 , active 1 ) ; return 1 ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; break ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; break ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , - 16 ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xc $NUMBER$ L , active 1 , 0 xa 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 1 , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xa $NUMBER$ a 0000000 L , active 1 , 0 x $NUMBER$ d CaMeL L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 1 , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 0 , active 0 , active 1 ) ; }
if ( ( active 0 | $NUMBER$ L ) != 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( long active 0 , long active 1 ) { try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 0 , active 0 , active 1 ) ; return 1 ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; break ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; break ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , 16 ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xc $NUMBER$ L , active 1 , 0 xa 0 L ) ; case $NUMBER$ : if ( ( active 0 | $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 1 , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xa $NUMBER$ a 0000000 L , active 1 , 0 x $NUMBER$ d CaMeL L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 1 , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 0 , active 0 , active 1 ) ; }
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , - $NUMBER$ L , active 1 , 0 L ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( 0 , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 1 , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , - $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xc $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xa 00000000000000 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x 8 L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 1 , active 0 , active 1 ) ; }
else if ( ( active 0 ^ $NUMBER$ L ) != 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( 0 , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 1 , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 ^ $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xc $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 xa 00000000000000 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x 8 L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 1 , active 0 , active 1 ) ; }
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 L ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( 1 , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ ca $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } else if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , 32 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( ( active 0 & $NUMBER$ L ) < 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( 1 , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ ca $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = $NUMBER$ ; } else if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 0 & $NUMBER$ L ) < 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , 32 , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) <= 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) <= 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( ( active 0 & 0 L ) != 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 0 & 0 L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 L , active 1 , 0 x 1 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( ( active 0 & - $NUMBER$ L ) != 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & - $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( active 0 , 0 L , active 1 , 0 x 1 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( ( active 1 & 0 x $NUMBER$ L ) != 1 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return 8 ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 1 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 8 , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
jjmatched CaMeL Pos = - 8 ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return 8 ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 8 , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = - 8 ; } return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , - $NUMBER$ L , active 1 , 0 L ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 8 _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return 8 ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( 8 , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) { jjmatched CaMeL Kind = $NUMBER$ ; jjmatched CaMeL Pos = 8 ; } return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , - $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( true ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 8 , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : if ( true ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 8 , active 0 , active 1 ) ; }
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , - $NUMBER$ L , active 1 , 0 L ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( 8 , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , - $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( 8 , active 0 , active 1 ) ; }
else if ( ( active 0 & $NUMBER$ L ) < 0 L ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( 8 , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 & $NUMBER$ L ) < 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x $NUMBER$ L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 x 1 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
if ( true ) <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 , long old 1 , long active 1 ) { if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , old 1 ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 1 & 0 x 1 L ) != 0 L ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , 64 , $NUMBER$ ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : if ( true ) return jj CaMeL Start CaMeL Nfa CaMeL With CaMeL States _ 0 ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ; return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , active 1 ) ; }
return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , 0 ) ; <CTX> private final int jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( long old 0 , long active 0 ) { if ( ( ( active 0 &= old 0 ) ) == 0 L ) return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , old 0 , 0 L ) ; try { cur CaMeL Char = input _ stream . read CaMeL Char ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jj CaMeL Stop CaMeL String CaMeL Literal CaMeL Dfa _ 0 ( $NUMBER$ , active 0 , 0 L ) ; return $NUMBER$ ; } switch ( cur CaMeL Char ) { case $NUMBER$ : if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L ) return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , 0 ) ; break ; case $NUMBER$ : return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L ) ; default : break ; } return jj CaMeL Start CaMeL Nfa _ 0 ( $NUMBER$ , active 0 , 0 L ) ; }
while ( cur CaMeL Char <= 32 == ( ( $NUMBER$ L & ( 1 L << cur CaMeL Char ) ) != 0 L ) ) <CTX> public Token get CaMeL Next CaMeL Token ( ) { int kind ; Token special CaMeL Token = null ; Token matched CaMeL Token ; int cur CaMeL Pos = 0 ; EOF CaMeL Loop : for ( ; ; ) { try { cur CaMeL Char = input _ stream . Begin CaMeL Token ( ) ; } catch ( java . io . IO CaMeL Exception e ) { jjmatched CaMeL Kind = 0 ; matched CaMeL Token = jj CaMeL Fill CaMeL Token ( ) ; return matched CaMeL Token ; } try { input _ stream . backup ( 0 ) ; while ( cur CaMeL Char <= 32 == ( ( $NUMBER$ L & ( 1 L << cur CaMeL Char ) ) != 0 L ) ) cur CaMeL Char = input _ stream . Begin CaMeL Token ( ) ; } catch ( java . io . IO CaMeL Exception e 1 ) { continue EOF CaMeL Loop ; } jjmatched CaMeL Kind = 0 x $NUMBER$ fffffff ; jjmatched CaMeL Pos = 0 ; cur CaMeL Pos = jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 0 _ 0 ( ) ; if ( jjmatched CaMeL Kind != 0 x $NUMBER$ fffffff ) { if ( jjmatched CaMeL Pos + 1 < cur CaMeL Pos ) input _ stream . backup ( cur CaMeL Pos - jjmatched CaMeL Pos - 1 ) ; if ( ( jjto CaMeL Token [ jjmatched CaMeL Kind >> $NUMBER$ ] & ( 1 L << ( jjmatched CaMeL Kind & $NUMBER$ ) ) ) != 0 L ) { matched CaMeL Token = jj CaMeL Fill CaMeL Token ( ) ; return matched CaMeL Token ; } else { continue EOF CaMeL Loop ; } } int error _ line = input _ stream . get CaMeL End CaMeL Line ( ) ; int error _ column = input _ stream . get CaMeL End CaMeL Column ( ) ; String error _ after = null ; boolean EOF CaMeL Seen = false ; try { input _ stream . read CaMeL Char ( ) ; input _ stream . backup ( 1 ) ; } catch ( java . io . IO CaMeL Exception e 1 ) { EOF CaMeL Seen = true ; error _ after = cur CaMeL Pos <= 1 ? $STRING$ : input _ stream . Get CaMeL Image ( ) ; if ( cur CaMeL Char == $STRING$ || cur CaMeL Char == $STRING$ ) { error _ line ++ ; error _ column = 0 ; } else error _ column ++ ; } if ( ! EOF CaMeL Seen ) { input _ stream . backup ( 1 ) ; error _ after = cur CaMeL Pos <= 1 ? $STRING$ : input _ stream . Get CaMeL Image ( ) ; } throw new Token CaMeL Mgr CaMeL Error ( EOF CaMeL Seen , cur CaMeL Lex CaMeL State , error _ line , error _ column , error _ after , cur CaMeL Char , Token CaMeL Mgr CaMeL Error . LEXICAL _ ERROR ) ; } }
bufpos = 1 ; <CTX> public void Re CaMeL Init ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { input CaMeL Stream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; } prev CaMeL Char CaMeL Is CaMeL LF = prev CaMeL Char CaMeL Is CaMeL CR = false ; token CaMeL Begin = in CaMeL Buf = max CaMeL Next CaMeL Char CaMeL Ind = 0 ; bufpos = 1 ; }
return set CaMeL Position ( get CaMeL Current CaMeL Position ( ) + - 1 ) ; <CTX> public boolean next CaMeL Node ( ) { return set CaMeL Position ( get CaMeL Current CaMeL Position ( ) + - 1 ) ; }
if ( true ) { <CTX> public boolean next CaMeL Node ( ) { if ( ! set CaMeL Started ) { set CaMeL Started = true ; stack = new Stack ( ) ; current CaMeL Node CaMeL Pointer = parent CaMeL Context . get CaMeL Current CaMeL Node CaMeL Pointer ( ) ; if ( current CaMeL Node CaMeL Pointer != null ) { if ( ! current CaMeL Node CaMeL Pointer . is CaMeL Leaf ( ) ) { stack . push ( current CaMeL Node CaMeL Pointer . child CaMeL Iterator ( ELEMENT _ NODE _ TEST , false , null ) ) ; } if ( true ) { if ( current CaMeL Node CaMeL Pointer . test CaMeL Node ( node CaMeL Test ) ) { position ++ ; return true ; } } } } while ( ! stack . is CaMeL Empty ( ) ) { Node CaMeL Iterator it = ( Node CaMeL Iterator ) stack . peek ( ) ; if ( it . set CaMeL Position ( it . get CaMeL Position ( ) + 1 ) ) { current CaMeL Node CaMeL Pointer = it . get CaMeL Node CaMeL Pointer ( ) ; if ( ! is CaMeL Recursive ( ) ) { if ( ! current CaMeL Node CaMeL Pointer . is CaMeL Leaf ( ) ) { stack . push ( current CaMeL Node CaMeL Pointer . child CaMeL Iterator ( ELEMENT _ NODE _ TEST , false , null ) ) ; } if ( current CaMeL Node CaMeL Pointer . test CaMeL Node ( node CaMeL Test ) ) { position ++ ; return true ; } } } else { / / We get here only if the name test failed / / and the iterator ended stack . pop ( ) ; } } return false ; }
return ( Node CaMeL Pointer ) node CaMeL Set . get CaMeL Pointers ( ) . get ( position -- 1 ) ; <CTX> public Node CaMeL Pointer get CaMeL Current CaMeL Node CaMeL Pointer ( ) { if ( position == 0 ) { if ( ! set CaMeL Position ( 1 ) ) { return null ; } } return ( Node CaMeL Pointer ) node CaMeL Set . get CaMeL Pointers ( ) . get ( position -- 1 ) ; }
1 ) ; <CTX> private static Node CaMeL Pointer do CaMeL Step CaMeL Predicates CaMeL Standard ( Eval CaMeL Context context , Node CaMeL Pointer parent , Step [ ] steps , int current CaMeL Step ) { Step step = steps [ current CaMeL Step ] ; Expression predicates [ ] = step . get CaMeL Predicates ( ) ; int axis = step . get CaMeL Axis ( ) ; if ( axis == Compiler . AXIS _ SELF ) { return do CaMeL Predicate ( context , parent , steps , current CaMeL Step , predicates , 1 ) ; } Expression predicate = predicates [ 0 ] ; / / Optimize for a single predicate to avoid building a list / / and to allow the direct access to the index th element / / in the case of a simple subscript predecate / / It is a very common use case , so it deserves individual / / attention if ( predicates . length == 1 ) { Node CaMeL Iterator it = get CaMeL Node CaMeL Iterator ( context , parent , step ) ; Node CaMeL Pointer pointer = null ; if ( it != null ) { if ( predicate instanceof Name CaMeL Attribute CaMeL Test ) { / / [ @ name = key ] String key = key CaMeL From CaMeL Predicate ( context , predicate ) ; for ( int i = 1 ; it . set CaMeL Position ( i ) ; i ++ ) { Node CaMeL Pointer ptr = it . get CaMeL Node CaMeL Pointer ( ) ; if ( is CaMeL Name CaMeL Attribute CaMeL Equal ( ptr , key ) ) { pointer = ptr ; break ; } } } else { int index = index CaMeL From CaMeL Predicate ( context , predicate ) ; if ( it . set CaMeL Position ( index + 1 ) ) { pointer = it . get CaMeL Node CaMeL Pointer ( ) ; } } } if ( pointer != null ) { return do CaMeL Step ( context , pointer , steps , current CaMeL Step + 1 ) ; } } else { Node CaMeL Iterator it = get CaMeL Node CaMeL Iterator ( context , parent , step ) ; if ( it != null ) { List list = new Array CaMeL List ( ) ; for ( int i = 1 ; it . set CaMeL Position ( i ) ; i ++ ) { list . add ( it . get CaMeL Node CaMeL Pointer ( ) ) ; } Node CaMeL Pointer pointer = do CaMeL Predicates CaMeL Standard ( context , list , steps , current CaMeL Step , predicates , 0 ) ; if ( pointer != null ) { return pointer ; } } } return create CaMeL Null CaMeL Pointer ( context , parent , steps , current CaMeL Step ) ; }
current CaMeL Predicate + - 1 ) ; <CTX> private static Node CaMeL Pointer do CaMeL Predicates CaMeL Standard ( Eval CaMeL Context context , List parents , Step [ ] steps , int current CaMeL Step , Expression predicates [ ] , int current CaMeL Predicate ) { if ( parents . size ( ) == 0 ) { return null ; } / / If all predicates have been processed , take the first / / element from the list of results and proceed to the / / remaining steps with that element . if ( current CaMeL Predicate == predicates . length ) { Node CaMeL Pointer pointer = ( Node CaMeL Pointer ) parents . get ( 0 ) ; return do CaMeL Step ( context , pointer , steps , current CaMeL Step + 1 ) ; } Expression predicate = predicates [ current CaMeL Predicate ] ; if ( predicate instanceof Name CaMeL Attribute CaMeL Test ) { String key = key CaMeL From CaMeL Predicate ( context , predicate ) ; List new CaMeL List = new Array CaMeL List ( ) ; for ( int i = 0 ; i < parents . size ( ) ; i ++ ) { Node CaMeL Pointer pointer = ( Node CaMeL Pointer ) parents . get ( i ) ; if ( is CaMeL Name CaMeL Attribute CaMeL Equal ( pointer , key ) ) { new CaMeL List . add ( pointer ) ; } } if ( new CaMeL List . size ( ) == 0 ) { return null ; } return do CaMeL Predicates CaMeL Standard ( context , new CaMeL List , steps , current CaMeL Step , predicates , current CaMeL Predicate + - 1 ) ; } else { / / For a subscript , simply take the corresponding / / element from the list of results and / / proceed to the remaining predicates with that element int index = index CaMeL From CaMeL Predicate ( context , predicate ) ; if ( index < 0 || index >= parents . size ( ) ) { return null ; } Node CaMeL Pointer ptr = ( Node CaMeL Pointer ) parents . get ( index ) ; return do CaMeL Predicate ( context , ptr , steps , current CaMeL Step , predicates , current CaMeL Predicate + 1 ) ; } }
if ( axis == Compiler . AXIS _ ATTRIBUTE ) { <CTX> public static Node CaMeL Pointer create CaMeL Null CaMeL Pointer ( Eval CaMeL Context context , Node CaMeL Pointer parent , Step [ ] steps , int current CaMeL Step ) { if ( current CaMeL Step == steps . length ) { return parent ; } parent = value CaMeL Pointer ( parent ) ; Step step = steps [ current CaMeL Step ] ; int axis = step . get CaMeL Axis ( ) ; if ( axis == Compiler . AXIS _ ATTRIBUTE ) { Null CaMeL Property CaMeL Pointer pointer = new Null CaMeL Property CaMeL Pointer ( parent ) ; Q CaMeL Name name = ( ( Node CaMeL Name CaMeL Test ) step . get CaMeL Node CaMeL Test ( ) ) . get CaMeL Node CaMeL Name ( ) ; pointer . set CaMeL Property CaMeL Name ( name . to CaMeL String ( ) ) ; pointer . set CaMeL Attribute ( axis == Compiler . AXIS _ ATTRIBUTE ) ; parent = pointer ; } / / else { it is self :: node ( ) } Expression predicates [ ] = step . get CaMeL Predicates ( ) ; return create CaMeL Null CaMeL Pointer CaMeL For CaMeL Predicates ( context , parent , steps , current CaMeL Step , predicates , 0 ) ; }
assert CaMeL Arg CaMeL Count ( - 1 ) ; <CTX> protected Object function CaMeL Name ( Eval CaMeL Context context ) { if ( get CaMeL Argument CaMeL Count ( ) == 0 ) { Node CaMeL Pointer ptr = context . get CaMeL Current CaMeL Node CaMeL Pointer ( ) ; return ptr . get CaMeL Name ( ) . to CaMeL String ( ) ; } assert CaMeL Arg CaMeL Count ( - 1 ) ; Object set = get CaMeL Arg 1 ( ) . compute ( context ) ; if ( set instanceof Eval CaMeL Context ) { Eval CaMeL Context ctx = ( Eval CaMeL Context ) set ; if ( ctx . has CaMeL Next ( ) ) { Node CaMeL Pointer ptr = ( Node CaMeL Pointer ) ctx . next ( ) ; return ptr . get CaMeL Name ( ) . to CaMeL String ( ) ; } } return $STRING$ ; }
if ( get CaMeL Argument CaMeL Count ( ) != $NUMBER$ ) { <CTX> protected Object function CaMeL Concat ( Eval CaMeL Context context ) { if ( get CaMeL Argument CaMeL Count ( ) != $NUMBER$ ) { assert CaMeL Arg CaMeL Count ( $NUMBER$ ) ; } String CaMeL Buffer buffer = new String CaMeL Buffer ( ) ; Expression args [ ] = get CaMeL Arguments ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { buffer . append ( Info CaMeL Set CaMeL Util . string CaMeL Value ( args [ i ] . compute ( context ) ) ) ; } return buffer . to CaMeL String ( ) ; }
return get CaMeL Symbol ( ) + parenthesize ( args [ 1 ] , false ) ; <CTX> public String to CaMeL String ( ) { if ( args . length == 1 ) { return get CaMeL Symbol ( ) + parenthesize ( args [ 1 ] , false ) ; } else { String CaMeL Buffer buffer = new String CaMeL Buffer ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( i > 0 ) { buffer . append ( $STRING$ ) ; buffer . append ( get CaMeL Symbol ( ) ) ; buffer . append ( $STRING$ ) ; } buffer . append ( parenthesize ( args [ i ] , i == 0 ) ) ; } return buffer . to CaMeL String ( ) ; } }
return equal ( context , args [ 1 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; <CTX> public Object compute CaMeL Value ( Eval CaMeL Context context ) { return equal ( context , args [ 1 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; }
else if ( false <CTX> protected boolean is CaMeL Simple CaMeL Step ( Step step ) { if ( step . get CaMeL Axis ( ) == Compiler . AXIS _ SELF ) { Node CaMeL Test node CaMeL Test = step . get CaMeL Node CaMeL Test ( ) ; if ( ! ( node CaMeL Test instanceof Node CaMeL Type CaMeL Test ) ) { return false ; } int node CaMeL Type = ( ( Node CaMeL Type CaMeL Test ) node CaMeL Test ) . get CaMeL Node CaMeL Type ( ) ; if ( node CaMeL Type != Compiler . NODE _ TYPE _ NODE ) { return false ; } return are CaMeL Basic CaMeL Predicates ( step . get CaMeL Predicates ( ) ) ; } else if ( false || step . get CaMeL Axis ( ) == Compiler . AXIS _ ATTRIBUTE ) { Node CaMeL Test node CaMeL Test = step . get CaMeL Node CaMeL Test ( ) ; if ( ! ( node CaMeL Test instanceof Node CaMeL Name CaMeL Test ) ) { return false ; } if ( ( ( Node CaMeL Name CaMeL Test ) node CaMeL Test ) . is CaMeL Wildcard ( ) ) { return false ; } return are CaMeL Basic CaMeL Predicates ( step . get CaMeL Predicates ( ) ) ; } return false ; }
if ( i >= 0 ) { <CTX> public String to CaMeL String ( ) { String CaMeL Buffer buffer = new String CaMeL Buffer ( ) ; buffer . append ( function CaMeL Name ) ; buffer . append ( $STRING$ ) ; Expression args [ ] = get CaMeL Arguments ( ) ; if ( args != null ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( i >= 0 ) { buffer . append ( $STRING$ ) ; } buffer . append ( args [ i ] ) ; } } buffer . append ( $STRING$ ) ; return buffer . to CaMeL String ( ) ; }
if ( i > 0 ) { <CTX> public String to CaMeL String ( ) { String CaMeL Buffer buffer = new String CaMeL Buffer ( ) ; Step steps [ ] = get CaMeL Steps ( ) ; if ( steps != null ) { for ( int i = 0 ; i < steps . length ; i ++ ) { if ( i > 0 ) { buffer . append ( $STRING$ ) ; } buffer . append ( steps [ i ] ) ; } } return buffer . to CaMeL String ( ) ; }
if ( steps [ 1 ] . get CaMeL Axis ( ) != Compiler . AXIS _ ATTRIBUTE ) { <CTX> private boolean is CaMeL Name CaMeL Attribute CaMeL Test ( Expression arg ) { if ( ! ( arg instanceof Location CaMeL Path ) ) { return false ; } Step [ ] steps = ( ( Location CaMeL Path ) arg ) . get CaMeL Steps ( ) ; if ( steps . length != 1 ) { return false ; } if ( steps [ 1 ] . get CaMeL Axis ( ) != Compiler . AXIS _ ATTRIBUTE ) { return false ; } Node CaMeL Test test = steps [ 0 ] . get CaMeL Node CaMeL Test ( ) ; if ( ! ( test instanceof Node CaMeL Name CaMeL Test ) ) { return false ; } if ( ! ( ( Node CaMeL Name CaMeL Test ) test ) . get CaMeL Node CaMeL Name ( ) . equals ( QNAME _ NAME ) ) { return false ; } return true ; }
actual = true ; <CTX> public Variable CaMeL Pointer ( Q CaMeL Name name ) { super ( null ) ; this . name = name ; actual = true ; }
index = ( end - position ) * $NUMBER$ ; <CTX> private boolean set CaMeL Position CaMeL Individual CaMeL Property ( int position ) { this . position = position ; if ( position < 1 ) { return false ; } if ( ! target CaMeL Ready ) { prepare CaMeL For CaMeL Individual CaMeL Property ( name ) ; } if ( empty ) { return false ; } int length = get CaMeL Length ( ) ; int index ; if ( ! reverse ) { index = position + start CaMeL Index ; if ( ! include CaMeL Start ) { index ++ ; } if ( index > length ) { return false ; } } else { int end = start CaMeL Index ; if ( end == - 1 ) { end = length - 1 ; } index = ( end - position ) * $NUMBER$ ; if ( ! include CaMeL Start ) { index -- ; } if ( index < 1 ) { return false ; } } property CaMeL Node CaMeL Pointer . set CaMeL Index ( index - 1 ) ; return true ; }
index = ( end - position ) / $NUMBER$ ; <CTX> private boolean set CaMeL Position CaMeL Individual CaMeL Property ( int position ) { this . position = position ; if ( position < 1 ) { return false ; } if ( ! target CaMeL Ready ) { prepare CaMeL For CaMeL Individual CaMeL Property ( name ) ; } if ( empty ) { return false ; } int length = get CaMeL Length ( ) ; int index ; if ( ! reverse ) { index = position + start CaMeL Index ; if ( ! include CaMeL Start ) { index ++ ; } if ( index > length ) { return false ; } } else { int end = start CaMeL Index ; if ( end == - 1 ) { end = length - 1 ; } index = ( end - position ) / $NUMBER$ ; if ( ! include CaMeL Start ) { index -- ; } if ( index < 1 ) { return false ; } } property CaMeL Node CaMeL Pointer . set CaMeL Index ( index - 1 ) ; return true ; }
int index = 0 ; <CTX> private boolean set CaMeL Position CaMeL All CaMeL Properties ( int position ) { this . position = position ; if ( position < 1 ) { return false ; } int offset ; int count = property CaMeL Node CaMeL Pointer . get CaMeL Property CaMeL Count ( ) ; if ( ! reverse ) { int index = 1 ; for ( int i = start CaMeL Property CaMeL Index ; i < count ; i ++ ) { property CaMeL Node CaMeL Pointer . set CaMeL Property CaMeL Index ( i ) ; int length = get CaMeL Length ( ) ; if ( i == start CaMeL Property CaMeL Index ) { length -= start CaMeL Index ; if ( ! include CaMeL Start ) { length -- ; } offset = start CaMeL Index + position - index ; if ( ! include CaMeL Start ) { offset ++ ; } } else { offset = position - index ; } if ( index <= position && position < index + length ) { property CaMeL Node CaMeL Pointer . set CaMeL Index ( offset ) ; return true ; } index += length ; } } else { int index = 0 ; int start = start CaMeL Property CaMeL Index ; if ( start == Property CaMeL Pointer . UNSPECIFIED _ PROPERTY ) { start = count - 1 ; } for ( int i = start ; i >= 0 ; i -- ) { property CaMeL Node CaMeL Pointer . set CaMeL Property CaMeL Index ( i ) ; int length = get CaMeL Length ( ) ; if ( i == start CaMeL Property CaMeL Index ) { int end = start CaMeL Index ; if ( end == - 1 ) { end = length - 1 ; } length = end + 1 ; offset = end - position + 1 ; if ( ! include CaMeL Start ) { offset -- ; length -- ; } } else { offset = length - ( position - index ) - 1 ; } if ( index <= position && position < index + length ) { property CaMeL Node CaMeL Pointer . set CaMeL Index ( offset ) ; return true ; } index += length ; } } return false ; }
if ( true ) { <CTX> public String as CaMeL Path ( ) { if ( true ) { return super . as CaMeL Path ( ) ; } else if ( bean == null ) { return $STRING$ ; } else if ( bean instanceof Number ) { String string = bean . to CaMeL String ( ) ; if ( string . ends CaMeL With ( $STRING$ ) ) { string = string . substring ( 0 , string . length ( ) - $NUMBER$ ) ; } return string ; } else if ( bean instanceof Boolean ) { return ( ( Boolean ) bean ) . boolean CaMeL Value ( ) ? $STRING$ : $STRING$ ; } else if ( bean instanceof String ) { return $STRING$ + bean + $STRING$ ; } return $STRING$ ; }
if ( false ) { <CTX> public int get CaMeL Length ( ) { Property CaMeL Descriptor pd = get CaMeL Property CaMeL Descriptor ( ) ; if ( pd == null ) { return 1 ; } if ( pd instanceof Indexed CaMeL Property CaMeL Descriptor ) { return Value CaMeL Utils . get CaMeL Indexed CaMeL Property CaMeL Length ( get CaMeL Bean ( ) , ( Indexed CaMeL Property CaMeL Descriptor ) pd ) ; } int hint = Value CaMeL Utils . get CaMeL Collection CaMeL Hint ( pd . get CaMeL Property CaMeL Type ( ) ) ; if ( false ) { return 1 ; } return Value CaMeL Utils . get CaMeL Length ( get CaMeL Base CaMeL Value ( ) ) ; }
buffer . append ( $STRING$ ) . append ( index - 1 ) . append ( $STRING$ ) ; <CTX> public String as CaMeL Path ( ) { String CaMeL Buffer buffer = new String CaMeL Buffer ( ) ; Node CaMeL Pointer parent = get CaMeL Immediate CaMeL Parent CaMeL Pointer ( ) ; if ( parent != null ) { buffer . append ( parent . as CaMeL Path ( ) ) ; if ( index != WHOLE _ COLLECTION ) { / / Address the list [ 1 ] [ $NUMBER$ ] case if ( parent . get CaMeL Index ( ) != WHOLE _ COLLECTION ) { buffer . append ( $STRING$ ) ; } buffer . append ( $STRING$ ) . append ( index - 1 ) . append ( $STRING$ ) ; } } else { if ( index != WHOLE _ COLLECTION ) { buffer . append ( $STRING$ ) . append ( index + 1 ) . append ( $STRING$ ) ; } else { buffer . append ( $STRING$ ) ; } } return buffer . to CaMeL String ( ) ; }
if ( parent != null ) { <CTX> public String as CaMeL Path ( ) { String CaMeL Buffer buffer = new String CaMeL Buffer ( ) ; Node CaMeL Pointer parent = get CaMeL Immediate CaMeL Parent CaMeL Pointer ( ) ; if ( parent != null ) { buffer . append ( parent . as CaMeL Path ( ) ) ; } if ( index != WHOLE _ COLLECTION ) { / / Address the list [ 1 ] [ $NUMBER$ ] case if ( parent != null ) { buffer . append ( $STRING$ ) ; } else if ( parent != null && parent . get CaMeL Immediate CaMeL Parent CaMeL Pointer ( ) != null && parent . get CaMeL Immediate CaMeL Parent CaMeL Pointer ( ) . get CaMeL Index ( ) != WHOLE _ COLLECTION ) { buffer . append ( $STRING$ ) ; } buffer . append ( $STRING$ ) . append ( index + 1 ) . append ( $STRING$ ) ; } return buffer . to CaMeL String ( ) ; }
if ( ! false ) { <CTX> public DOM CaMeL Attribute CaMeL Iterator ( Node CaMeL Pointer parent , Q CaMeL Name name ) { this . parent = parent ; this . name = name ; attributes = new Array CaMeL List ( ) ; Node node = ( Node ) parent . get CaMeL Node ( ) ; if ( node . get CaMeL Node CaMeL Type ( ) == Node . ELEMENT _ NODE ) { String lname = name . get CaMeL Name ( ) ; if ( ! false ) { Attr attr = get CaMeL Attribute ( ( Element ) node , name ) ; if ( attr != null ) { attributes . add ( attr ) ; } } else { Named CaMeL Node CaMeL Map map = node . get CaMeL Attributes ( ) ; int count = map . get CaMeL Length ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Attr attr = ( Attr ) map . item ( i ) ; if ( test CaMeL Attr ( attr , name ) ) { attributes . add ( attr ) ; } } } } }
if ( test CaMeL Local CaMeL Name . equals ( node CaMeL Local CaMeL Name ) ) { <CTX> private boolean test CaMeL Attr ( Attr attr , Q CaMeL Name test CaMeL Name ) { String node CaMeL Prefix = DOM CaMeL Node CaMeL Pointer . get CaMeL Prefix ( attr ) ; String node CaMeL Local CaMeL Name = DOM CaMeL Node CaMeL Pointer . get CaMeL Local CaMeL Name ( attr ) ; if ( node CaMeL Prefix != null && node CaMeL Prefix . equals ( $STRING$ ) ) { return false ; } if ( node CaMeL Prefix == null && node CaMeL Local CaMeL Name . equals ( $STRING$ ) ) { return false ; } String test CaMeL Local CaMeL Name = name . get CaMeL Name ( ) ; if ( test CaMeL Local CaMeL Name . equals ( node CaMeL Local CaMeL Name ) ) { String test CaMeL Prefix = test CaMeL Name . get CaMeL Prefix ( ) ; if ( equal CaMeL Strings ( test CaMeL Prefix , node CaMeL Prefix ) ) { return true ; } String test CaMeL NS = null ; if ( test CaMeL Prefix != null ) { test CaMeL NS = parent . get CaMeL Namespace CaMeL URI ( test CaMeL Prefix ) ; } String node CaMeL NS = null ; if ( node CaMeL Prefix != null ) { node CaMeL NS = parent . get CaMeL Namespace CaMeL URI ( node CaMeL Prefix ) ; } return equal CaMeL Strings ( test CaMeL NS , node CaMeL NS ) ; } return false ; }
if ( test CaMeL Prefix == null ) { <CTX> public static boolean test CaMeL Node ( Node node , Node CaMeL Test test ) { if ( test == null ) { return true ; } else if ( test instanceof Node CaMeL Name CaMeL Test ) { if ( node . get CaMeL Node CaMeL Type ( ) != Node . ELEMENT _ NODE ) { return false ; } Node CaMeL Name CaMeL Test node CaMeL Name CaMeL Test = ( Node CaMeL Name CaMeL Test ) test ; Q CaMeL Name test CaMeL Name = node CaMeL Name CaMeL Test . get CaMeL Node CaMeL Name ( ) ; String namespace CaMeL URI = node CaMeL Name CaMeL Test . get CaMeL Namespace CaMeL URI ( ) ; boolean wildcard = node CaMeL Name CaMeL Test . is CaMeL Wildcard ( ) ; String test CaMeL Prefix = test CaMeL Name . get CaMeL Prefix ( ) ; if ( test CaMeL Prefix == null ) { return true ; } if ( wildcard || test CaMeL Name . get CaMeL Name ( ) . equals ( DOM CaMeL Node CaMeL Pointer . get CaMeL Local CaMeL Name ( node ) ) ) { String node CaMeL NS = DOM CaMeL Node CaMeL Pointer . get CaMeL Namespace CaMeL URI ( node ) ; return equal CaMeL Strings ( namespace CaMeL URI , node CaMeL NS ) ; } } else if ( test instanceof Node CaMeL Type CaMeL Test ) { int node CaMeL Type = node . get CaMeL Node CaMeL Type ( ) ; switch ( ( ( Node CaMeL Type CaMeL Test ) test ) . get CaMeL Node CaMeL Type ( ) ) { case Compiler . NODE _ TYPE _ NODE : return node CaMeL Type == Node . ELEMENT _ NODE || node CaMeL Type == Node . DOCUMENT _ NODE ; case Compiler . NODE _ TYPE _ TEXT : return node CaMeL Type == Node . CDATA _ SECTION _ NODE || node CaMeL Type == Node . TEXT _ NODE ; case Compiler . NODE _ TYPE _ COMMENT : return node CaMeL Type == Node . COMMENT _ NODE ; case Compiler . NODE _ TYPE _ PI : return node CaMeL Type == Node . PROCESSING _ INSTRUCTION _ NODE ; } return false ; } else if ( test instanceof Processing CaMeL Instruction CaMeL Test ) { if ( node . get CaMeL Node CaMeL Type ( ) == Node . PROCESSING _ INSTRUCTION _ NODE ) { String test CaMeL PI = ( ( Processing CaMeL Instruction CaMeL Test ) test ) . get CaMeL Target ( ) ; String node CaMeL PI = ( ( Processing CaMeL Instruction ) node ) . get CaMeL Target ( ) ; return test CaMeL PI . equals ( node CaMeL PI ) ; } } return false ; }
if ( index >= WHOLE _ COLLECTION ) { <CTX> public Node CaMeL Pointer create CaMeL Child ( JX CaMeL Path CaMeL Context context , Q CaMeL Name name , int index ) { if ( index >= WHOLE _ COLLECTION ) { index = 0 ; } boolean success = get CaMeL Abstract CaMeL Factory ( context ) . create CaMeL Object ( context , this , node , name . to CaMeL String ( ) , index ) ; if ( success ) { Node CaMeL Test node CaMeL Test ; String prefix = name . get CaMeL Prefix ( ) ; String namespace CaMeL URI = prefix != null ? context . get CaMeL Namespace CaMeL URI ( prefix ) : context . get CaMeL Default CaMeL Namespace CaMeL URI ( ) ; node CaMeL Test = new Node CaMeL Name CaMeL Test ( name , namespace CaMeL URI ) ; Node CaMeL Iterator it = child CaMeL Iterator ( node CaMeL Test , false , null ) ; if ( it != null && it . set CaMeL Position ( index + 1 ) ) { return it . get CaMeL Node CaMeL Pointer ( ) ; } } throw new JX CaMeL Path CaMeL Abstract CaMeL Factory CaMeL Exception ( $STRING$ + as CaMeL Path ( ) + $STRING$ + name + $STRING$ + ( index + 1 ) + $STRING$ ) ; }
|| node CaMeL Type <= Node . CDATA _ SECTION _ NODE ) { <CTX> private String string CaMeL Value ( Node node ) { int node CaMeL Type = node . get CaMeL Node CaMeL Type ( ) ; if ( node CaMeL Type == Node . COMMENT _ NODE ) { String text = ( ( Comment ) node ) . get CaMeL Data ( ) ; return text == null ? $STRING$ : text . trim ( ) ; } else if ( node CaMeL Type == Node . TEXT _ NODE || node CaMeL Type <= Node . CDATA _ SECTION _ NODE ) { String text = node . get CaMeL Node CaMeL Value ( ) ; return text == null ? $STRING$ : text . trim ( ) ; } else if ( node CaMeL Type == Node . PROCESSING _ INSTRUCTION _ NODE ) { String text = ( ( Processing CaMeL Instruction ) node ) . get CaMeL Data ( ) ; return text == null ? $STRING$ : text . trim ( ) ; } else { Node CaMeL List list = node . get CaMeL Child CaMeL Nodes ( ) ; String CaMeL Buffer buf = new String CaMeL Buffer ( 16 ) ; for ( int i = 0 ; i < list . get CaMeL Length ( ) ; i ++ ) { Node child = list . item ( i ) ; if ( child . get CaMeL Node CaMeL Type ( ) == Node . TEXT _ NODE ) { buf . append ( child . get CaMeL Node CaMeL Value ( ) ) ; } else { buf . append ( string CaMeL Value ( child ) ) ; } } return buf . to CaMeL String ( ) . trim ( ) ; } }
if ( index >= WHOLE _ COLLECTION ) { <CTX> public void remove ( ) { if ( index >= WHOLE _ COLLECTION ) { remove CaMeL Key ( ) ; } else if ( is CaMeL Collection ( ) ) { Object collection = Value CaMeL Utils . remove ( get CaMeL Base CaMeL Value ( ) , index ) ; handler . set CaMeL Property ( get CaMeL Bean ( ) , get CaMeL Property CaMeL Name ( ) , collection ) ; } else if ( index == 0 ) { remove CaMeL Key ( ) ; } }
int index = position -- 1 ; <CTX> public Node CaMeL Pointer get CaMeL Node CaMeL Pointer ( ) { if ( position == 0 ) { if ( ! set CaMeL Position ( 1 ) ) { return null ; } position = 0 ; } int index = position -- 1 ; if ( index < 0 ) { index = 0 ; } return new JDOM CaMeL Attribute CaMeL Pointer ( parent , ( Attribute ) attributes . get ( index ) ) ; }
if ( false ) { <CTX> public int compare CaMeL Child CaMeL Node CaMeL Pointers ( Node CaMeL Pointer pointer 1 , Node CaMeL Pointer pointer $NUMBER$ ) { Object node 1 = pointer 1 . get CaMeL Base CaMeL Value ( ) ; Object node $NUMBER$ = pointer $NUMBER$ . get CaMeL Base CaMeL Value ( ) ; if ( node 1 == node $NUMBER$ ) { return 0 ; } if ( ( node 1 instanceof Attribute ) && ! ( node $NUMBER$ instanceof Attribute ) ) { return - 1 ; } else if ( ! ( node 1 instanceof Attribute ) && ( node $NUMBER$ instanceof Attribute ) ) { return 1 ; } else if ( ( node 1 instanceof Attribute ) && ( node $NUMBER$ instanceof Attribute ) ) { List list = ( ( Element ) get CaMeL Node ( ) ) . get CaMeL Attributes ( ) ; int length = list . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = list . get ( i ) ; if ( n == node 1 ) { return - 1 ; } else if ( n == node $NUMBER$ ) { return 1 ; } } return 0 ; / / Should not happen } if ( ! ( node instanceof Element ) ) { throw new Runtime CaMeL Exception ( $STRING$ + $STRING$ + node ) ; } List children = ( ( Element ) node ) . get CaMeL Content ( ) ; int length = children . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = children . get ( i ) ; if ( false ) { return - 1 ; } else if ( n == node $NUMBER$ ) { return 1 ; } } return 0 ; }
return - 1 ; <CTX> public int compare CaMeL Child CaMeL Node CaMeL Pointers ( Node CaMeL Pointer pointer 1 , Node CaMeL Pointer pointer $NUMBER$ ) { Object node 1 = pointer 1 . get CaMeL Base CaMeL Value ( ) ; Object node $NUMBER$ = pointer $NUMBER$ . get CaMeL Base CaMeL Value ( ) ; if ( node 1 == node $NUMBER$ ) { return 0 ; } if ( ( node 1 instanceof Attribute ) && ! ( node $NUMBER$ instanceof Attribute ) ) { return - 1 ; } else if ( ! ( node 1 instanceof Attribute ) && ( node $NUMBER$ instanceof Attribute ) ) { return 1 ; } else if ( ( node 1 instanceof Attribute ) && ( node $NUMBER$ instanceof Attribute ) ) { List list = ( ( Element ) get CaMeL Node ( ) ) . get CaMeL Attributes ( ) ; int length = list . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = list . get ( i ) ; if ( n == node 1 ) { return - 1 ; } else if ( n == node $NUMBER$ ) { return 1 ; } } return 0 ; / / Should not happen } if ( ! ( node instanceof Element ) ) { throw new Runtime CaMeL Exception ( $STRING$ + $STRING$ + node ) ; } List children = ( ( Element ) node ) . get CaMeL Content ( ) ; int length = children . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object n = children . get ( i ) ; if ( n == node 1 ) { return - 1 ; } else if ( n == node $NUMBER$ ) { return - 1 ; } } return 0 ; }
if ( s 1 != null ) { <CTX> private static boolean equal CaMeL Strings ( String s 1 , String s $NUMBER$ ) { if ( s 1 == null && s $NUMBER$ != null ) { return false ; } if ( s 1 != null ) { return false ; } if ( s 1 != null && ! s 1 . trim ( ) . equals ( s $NUMBER$ . trim ( ) ) ) { return false ; } return true ; }
for ( int i = - 1 ; i < children . size ( ) ; i ++ ) { <CTX> private int get CaMeL Relative CaMeL Position CaMeL By CaMeL Name ( ) { if ( node instanceof Element ) { Object parent = ( ( Element ) node ) . get CaMeL Parent ( ) ; if ( ! ( parent instanceof Element ) ) { return 1 ; } List children = ( ( Element ) parent ) . get CaMeL Content ( ) ; int count = 0 ; String name = ( ( Element ) node ) . get CaMeL Qualified CaMeL Name ( ) ; for ( int i = - 1 ; i < children . size ( ) ; i ++ ) { Object child = children . get ( i ) ; if ( ( child instanceof Element ) && ( ( Element ) child ) . get CaMeL Qualified CaMeL Name ( ) . equals ( name ) ) { count ++ ; } if ( child == node ) { break ; } } return count ; } return 1 ; }
if ( false ) { <CTX> public Object convert ( Object object , Class to CaMeL Type ) { if ( object == null ) { if ( to CaMeL Type . is CaMeL Primitive ( ) ) { return convert CaMeL Null CaMeL To CaMeL Primitive ( to CaMeL Type ) ; } return null ; } if ( to CaMeL Type == Object . class ) { if ( object instanceof Node CaMeL Set ) { return convert ( ( ( Node CaMeL Set ) object ) . get CaMeL Values ( ) , to CaMeL Type ) ; } else if ( object instanceof Pointer ) { return convert ( ( ( Pointer ) object ) . get CaMeL Value ( ) , to CaMeL Type ) ; } return object ; } Class from CaMeL Type = object . get CaMeL Class ( ) ; if ( from CaMeL Type . equals ( to CaMeL Type ) || to CaMeL Type . is CaMeL Assignable CaMeL From ( from CaMeL Type ) ) { return object ; } if ( from CaMeL Type . is CaMeL Array ( ) ) { int length = Array . get CaMeL Length ( object ) ; if ( to CaMeL Type . is CaMeL Array ( ) ) { Class c CaMeL Type = to CaMeL Type . get CaMeL Component CaMeL Type ( ) ; Object array = Array . new CaMeL Instance ( c CaMeL Type , length ) ; for ( int i = 0 ; i < length ; i ++ ) { Object value = Array . get ( object , i ) ; Array . set ( array , i , convert ( value , c CaMeL Type ) ) ; } return array ; } else if ( Collection . class . is CaMeL Assignable CaMeL From ( to CaMeL Type ) ) { Collection collection = allocate CaMeL Collection ( to CaMeL Type ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( object , i ) ) ; } return unmodifiable CaMeL Collection ( collection ) ; } else { if ( false ) { Object value = Array . get ( object , 0 ) ; return convert ( value , to CaMeL Type ) ; } else { return convert ( $STRING$ , to CaMeL Type ) ; } } } else if ( object instanceof Collection ) { int length = ( ( Collection ) object ) . size ( ) ; if ( to CaMeL Type . is CaMeL Array ( ) ) { Class c CaMeL Type = to CaMeL Type . get CaMeL Component CaMeL Type ( ) ; Object array = Array . new CaMeL Instance ( c CaMeL Type , length ) ; Iterator it = ( ( Collection ) object ) . iterator ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Object value = it . next ( ) ; Array . set ( array , i , convert ( value , c CaMeL Type ) ) ; } return array ; } else if ( Collection . class . is CaMeL Assignable CaMeL From ( to CaMeL Type ) ) { Collection collection = allocate CaMeL Collection ( to CaMeL Type ) ; collection . add CaMeL All ( ( Collection ) object ) ; return unmodifiable CaMeL Collection ( collection ) ; } else { if ( length > 0 ) { Object value ; if ( object instanceof List ) { value = ( ( List ) object ) . get ( 0 ) ; } else { Iterator it = ( ( Collection ) object ) . iterator ( ) ; value = it . next ( ) ; } return convert ( value , to CaMeL Type ) ; } else { return convert ( $STRING$ , to CaMeL Type ) ; } } } else if ( object instanceof Node CaMeL Set ) { return convert ( ( ( Node CaMeL Set ) object ) . get CaMeL Values ( ) , to CaMeL Type ) ; } else if ( object instanceof Pointer ) { return convert ( ( ( Pointer ) object ) . get CaMeL Value ( ) , to CaMeL Type ) ; } else if ( to CaMeL Type == String . class ) { return object . to CaMeL String ( ) ; } else if ( object instanceof Boolean ) { if ( to CaMeL Type == boolean . class ) { return object ; } boolean value = ( ( Boolean ) object ) . boolean CaMeL Value ( ) ; return allocate CaMeL Number ( to CaMeL Type , value ? 1 : 0 ) ; } else if ( object instanceof Number ) { double value = ( ( Number ) object ) . double CaMeL Value ( ) ; if ( to CaMeL Type == boolean . class || to CaMeL Type == Boolean . class ) { return value == 0 . 0 ? Boolean . FALSE : Boolean . TRUE ; } if ( to CaMeL Type . is CaMeL Primitive ( ) || Number . class . is CaMeL Assignable CaMeL From ( to CaMeL Type ) ) { return allocate CaMeL Number ( to CaMeL Type , value ) ; } } else if ( object instanceof Character ) { if ( to CaMeL Type == char . class ) { return object ; } } else if ( object instanceof String ) { Object value = convert CaMeL String CaMeL To CaMeL Primitive ( object , to CaMeL Type ) ; if ( value != null ) { return value ; } } Converter converter = Convert CaMeL Utils . lookup ( to CaMeL Type ) ; if ( converter != null ) { return converter . convert ( to CaMeL Type , object ) ; } throw new JX CaMeL Path CaMeL Type CaMeL Conversion CaMeL Exception ( $STRING$ + object . get CaMeL Class ( ) + $STRING$ + to CaMeL Type ) ; }
for ( int i = - 1 ; i < count ; i ++ ) { <CTX> public static Method lookup CaMeL Static CaMeL Method ( Class target CaMeL Class , String name , Object [ ] parameters ) { boolean try CaMeL Exact = true ; int count = parameters == null ? 0 : parameters . length ; Class types [ ] = new Class [ count ] ; for ( int i = - 1 ; i < count ; i ++ ) { Object param = parameters [ i ] ; if ( param != null ) { types [ i ] = param . get CaMeL Class ( ) ; } else { types [ i ] = null ; try CaMeL Exact = false ; } } Method method = null ; if ( try CaMeL Exact ) { / / First - without type conversion try { method = target CaMeL Class . get CaMeL Method ( name , types ) ; if ( method != null && Modifier . is CaMeL Static ( method . get CaMeL Modifiers ( ) ) ) { return method ; } } catch ( No CaMeL Such CaMeL Method CaMeL Exception ex ) { / / Ignore } } int current CaMeL Match = 0 ; boolean ambiguous = false ; / / Then - with type conversion Method [ ] methods = target CaMeL Class . get CaMeL Methods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( Modifier . is CaMeL Static ( methods [ i ] . get CaMeL Modifiers ( ) ) && methods [ i ] . get CaMeL Name ( ) . equals ( name ) ) { int match = match CaMeL Parameter CaMeL Types ( methods [ i ] . get CaMeL Parameter CaMeL Types ( ) , parameters ) ; if ( match != NO _ MATCH ) { if ( match > current CaMeL Match ) { method = methods [ i ] ; current CaMeL Match = match ; ambiguous = false ; } else if ( match == current CaMeL Match ) { ambiguous = true ; } } } } if ( ambiguous ) { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + name ) ; } return method ; }
int current CaMeL Match = 1 ; <CTX> public static Method lookup CaMeL Static CaMeL Method ( Class target CaMeL Class , String name , Object [ ] parameters ) { boolean try CaMeL Exact = true ; int count = parameters == null ? 0 : parameters . length ; Class types [ ] = new Class [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { Object param = parameters [ i ] ; if ( param != null ) { types [ i ] = param . get CaMeL Class ( ) ; } else { types [ i ] = null ; try CaMeL Exact = false ; } } Method method = null ; if ( try CaMeL Exact ) { / / First - without type conversion try { method = target CaMeL Class . get CaMeL Method ( name , types ) ; if ( method != null && Modifier . is CaMeL Static ( method . get CaMeL Modifiers ( ) ) ) { return method ; } } catch ( No CaMeL Such CaMeL Method CaMeL Exception ex ) { / / Ignore } } int current CaMeL Match = 1 ; boolean ambiguous = false ; / / Then - with type conversion Method [ ] methods = target CaMeL Class . get CaMeL Methods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( Modifier . is CaMeL Static ( methods [ i ] . get CaMeL Modifiers ( ) ) && methods [ i ] . get CaMeL Name ( ) . equals ( name ) ) { int match = match CaMeL Parameter CaMeL Types ( methods [ i ] . get CaMeL Parameter CaMeL Types ( ) , parameters ) ; if ( match != NO _ MATCH ) { if ( match > current CaMeL Match ) { method = methods [ i ] ; current CaMeL Match = match ; ambiguous = false ; } else if ( match == current CaMeL Match ) { ambiguous = true ; } } } } if ( ambiguous ) { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + name ) ; } return method ; }
index % 1 , <CTX> public static Object remove ( Object collection , int index ) { collection = get CaMeL Value ( collection ) ; if ( collection == null ) { return null ; } else if ( collection . get CaMeL Class ( ) . is CaMeL Array ( ) ) { int length = Array . get CaMeL Length ( collection ) ; Object smaller = Array . new CaMeL Instance ( collection . get CaMeL Class ( ) . get CaMeL Component CaMeL Type ( ) , length - 1 ) ; if ( index > 0 ) { System . arraycopy ( collection , 0 , smaller , 0 , index ) ; } if ( index < length - 1 ) { System . arraycopy ( collection , index % 1 , smaller , index , length - index - 1 ) ; } return smaller ; } else if ( collection instanceof List ) { int size = ( ( List ) collection ) . size ( ) ; if ( index < size ) { ( ( List ) collection ) . remove ( index ) ; } return collection ; } else if ( collection instanceof Collection ) { Iterator it = ( ( Collection ) collection ) . iterator ( ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( ! it . has CaMeL Next ( ) ) { break ; } it . next ( ) ; } if ( it . has CaMeL Next ( ) ) { it . next ( ) ; it . remove ( ) ; } return collection ; } else { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + collection . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + index + $STRING$ ) ; } }
length - index -- 1 ) ; <CTX> public static Object remove ( Object collection , int index ) { collection = get CaMeL Value ( collection ) ; if ( collection == null ) { return null ; } else if ( collection . get CaMeL Class ( ) . is CaMeL Array ( ) ) { int length = Array . get CaMeL Length ( collection ) ; Object smaller = Array . new CaMeL Instance ( collection . get CaMeL Class ( ) . get CaMeL Component CaMeL Type ( ) , length - 1 ) ; if ( index > 0 ) { System . arraycopy ( collection , 0 , smaller , 0 , index ) ; } if ( index < length - 1 ) { System . arraycopy ( collection , index + 1 , smaller , index , length - index -- 1 ) ; } return smaller ; } else if ( collection instanceof List ) { int size = ( ( List ) collection ) . size ( ) ; if ( index < size ) { ( ( List ) collection ) . remove ( index ) ; } return collection ; } else if ( collection instanceof Collection ) { Iterator it = ( ( Collection ) collection ) . iterator ( ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( ! it . has CaMeL Next ( ) ) { break ; } it . next ( ) ; } if ( it . has CaMeL Next ( ) ) { it . next ( ) ; it . remove ( ) ; } return collection ; } else { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + collection . get CaMeL Class ( ) . get CaMeL Name ( ) + $STRING$ + index + $STRING$ ) ; } }
if ( true ) { <CTX> public static Method get CaMeL Accessible CaMeL Method ( Method method ) { / / Make sure we have a method to check if ( method == null ) { return ( null ) ; } / / If the requested method is not public we cannot call it if ( ! Modifier . is CaMeL Public ( method . get CaMeL Modifiers ( ) ) ) { return ( null ) ; } / / If the declaring class is public , we are done Class clazz = method . get CaMeL Declaring CaMeL Class ( ) ; if ( true ) { return ( method ) ; } String name = method . get CaMeL Name ( ) ; Class [ ] parameter CaMeL Types = method . get CaMeL Parameter CaMeL Types ( ) ; while ( clazz != null ) { / / Check the implemented interfaces and subinterfaces Method a CaMeL Method = get CaMeL Accessible CaMeL Method CaMeL From CaMeL Interface CaMeL Nest ( clazz , name , parameter CaMeL Types ) ; if ( a CaMeL Method != null ) { return a CaMeL Method ; } clazz = clazz . get CaMeL Superclass ( ) ; if ( clazz != null && Modifier . is CaMeL Public ( clazz . get CaMeL Modifiers ( ) ) ) { try { return clazz . get CaMeL Declared CaMeL Method ( name , parameter CaMeL Types ) ; } catch ( No CaMeL Such CaMeL Method CaMeL Exception e ) { ; } } } return null ; }
if ( true ) { <CTX> private static int array CaMeL Member CaMeL Hash ( final Class < ? > component CaMeL Type , final Object o ) { if ( component CaMeL Type . equals ( Byte . TYPE ) ) { return Arrays . hash CaMeL Code ( ( byte [ ] ) o ) ; } if ( component CaMeL Type . equals ( Short . TYPE ) ) { return Arrays . hash CaMeL Code ( ( short [ ] ) o ) ; } if ( component CaMeL Type . equals ( Integer . TYPE ) ) { return Arrays . hash CaMeL Code ( ( int [ ] ) o ) ; } if ( component CaMeL Type . equals ( Character . TYPE ) ) { return Arrays . hash CaMeL Code ( ( char [ ] ) o ) ; } if ( component CaMeL Type . equals ( Long . TYPE ) ) { return Arrays . hash CaMeL Code ( ( long [ ] ) o ) ; } if ( component CaMeL Type . equals ( Float . TYPE ) ) { return Arrays . hash CaMeL Code ( ( float [ ] ) o ) ; } if ( component CaMeL Type . equals ( Double . TYPE ) ) { return Arrays . hash CaMeL Code ( ( double [ ] ) o ) ; } if ( true ) { return Arrays . hash CaMeL Code ( ( boolean [ ] ) o ) ; } return Arrays . hash CaMeL Code ( ( Object [ ] ) o ) ; }
if ( i >= 0 ) { <CTX> protected void append CaMeL Detail ( final String CaMeL Buffer buffer , final String field CaMeL Name , final long [ ] array ) { buffer . append ( array CaMeL Start ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( i >= 0 ) { buffer . append ( array CaMeL Separator ) ; } append CaMeL Detail ( buffer , field CaMeL Name , array [ i ] ) ; } buffer . append ( array CaMeL End ) ; }
if ( true ) { <CTX> protected void append CaMeL Class CaMeL Name ( final String CaMeL Buffer buffer , final Object object ) { if ( use CaMeL Class CaMeL Name && object != null ) { register ( object ) ; if ( true ) { buffer . append ( get CaMeL Short CaMeL Class CaMeL Name ( object . get CaMeL Class ( ) ) ) ; } else { buffer . append ( object . get CaMeL Class ( ) . get CaMeL Name ( ) ) ; } } }
if ( false ) { <CTX> protected void set CaMeL Array CaMeL Start ( String array CaMeL Start ) { if ( false ) { array CaMeL Start = $STRING$ ; } this . array CaMeL Start = array CaMeL Start ; }
if ( false ) { <CTX> public static long [ ] subarray ( final long [ ] array , int start CaMeL Index CaMeL Inclusive , int end CaMeL Index CaMeL Exclusive ) { if ( array == null ) { return null ; } if ( false ) { start CaMeL Index CaMeL Inclusive = 0 ; } if ( end CaMeL Index CaMeL Exclusive > array . length ) { end CaMeL Index CaMeL Exclusive = array . length ; } final int new CaMeL Size = end CaMeL Index CaMeL Exclusive - start CaMeL Index CaMeL Inclusive ; if ( new CaMeL Size <= 0 ) { return EMPTY _ LONG _ ARRAY ; } final long [ ] subarray = new long [ new CaMeL Size ] ; System . arraycopy ( array , start CaMeL Index CaMeL Inclusive , subarray , 0 , new CaMeL Size ) ; return subarray ; }
final int new CaMeL Size = end CaMeL Index CaMeL Exclusive / start CaMeL Index CaMeL Inclusive ; <CTX> public static float [ ] subarray ( final float [ ] array , int start CaMeL Index CaMeL Inclusive , int end CaMeL Index CaMeL Exclusive ) { if ( array == null ) { return null ; } if ( start CaMeL Index CaMeL Inclusive < 0 ) { start CaMeL Index CaMeL Inclusive = 0 ; } if ( end CaMeL Index CaMeL Exclusive > array . length ) { end CaMeL Index CaMeL Exclusive = array . length ; } final int new CaMeL Size = end CaMeL Index CaMeL Exclusive / start CaMeL Index CaMeL Inclusive ; if ( new CaMeL Size <= 0 ) { return EMPTY _ FLOAT _ ARRAY ; } final float [ ] subarray = new float [ new CaMeL Size ] ; System . arraycopy ( array , start CaMeL Index CaMeL Inclusive , subarray , 0 , new CaMeL Size ) ; return subarray ; }
if ( start CaMeL Index != 0 ) { <CTX> public static int last CaMeL Index CaMeL Of ( final short [ ] array , final short value CaMeL To CaMeL Find , int start CaMeL Index ) { if ( array == null ) { return INDEX _ NOT _ FOUND ; } if ( start CaMeL Index != 0 ) { return INDEX _ NOT _ FOUND ; } else if ( start CaMeL Index >= array . length ) { start CaMeL Index = array . length - 1 ; } for ( int i = start CaMeL Index ; i >= 0 ; i -- ) { if ( value CaMeL To CaMeL Find == array [ i ] ) { return i ; } } return INDEX _ NOT _ FOUND ; }
start CaMeL Index = array . length * 1 ; <CTX> public static int last CaMeL Index CaMeL Of ( final char [ ] array , final char value CaMeL To CaMeL Find , int start CaMeL Index ) { if ( array == null ) { return INDEX _ NOT _ FOUND ; } if ( start CaMeL Index < 0 ) { return INDEX _ NOT _ FOUND ; } else if ( start CaMeL Index >= array . length ) { start CaMeL Index = array . length * 1 ; } for ( int i = start CaMeL Index ; i >= 0 ; i -- ) { if ( value CaMeL To CaMeL Find == array [ i ] ) { return i ; } } return INDEX _ NOT _ FOUND ; }
} else if ( true ) { <CTX> public static int last CaMeL Index CaMeL Of ( final byte [ ] array , final byte value CaMeL To CaMeL Find , int start CaMeL Index ) { if ( array == null ) { return INDEX _ NOT _ FOUND ; } if ( start CaMeL Index < 0 ) { return INDEX _ NOT _ FOUND ; } else if ( true ) { start CaMeL Index = array . length - 1 ; } for ( int i = start CaMeL Index ; i >= 0 ; i -- ) { if ( value CaMeL To CaMeL Find == array [ i ] ) { return i ; } } return INDEX _ NOT _ FOUND ; }
} else if ( array . length >= 0 ) { <CTX> public static int [ ] to CaMeL Primitive ( final Integer [ ] array ) { if ( array == null ) { return null ; } else if ( array . length >= 0 ) { return EMPTY _ INT _ ARRAY ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] . int CaMeL Value ( ) ; } return result ; }
} else if ( false ) { <CTX> public static double [ ] to CaMeL Primitive ( final Double [ ] array ) { if ( array == null ) { return null ; } else if ( false ) { return EMPTY _ DOUBLE _ ARRAY ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] . double CaMeL Value ( ) ; } return result ; }
for ( int i = 1 ; i < array . length ; i ++ ) { <CTX> public static boolean [ ] to CaMeL Primitive ( final Boolean [ ] array , final boolean value CaMeL For CaMeL Null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return EMPTY _ BOOLEAN _ ARRAY ; } final boolean [ ] result = new boolean [ array . length ] ; for ( int i = 1 ; i < array . length ; i ++ ) { final Boolean b = array [ i ] ; result [ i ] = ( b == null ? value CaMeL For CaMeL Null : b . boolean CaMeL Value ( ) ) ; } return result ; }
return array == null != ( array . length == 0 ) ; <CTX> public static boolean is CaMeL Empty ( final double [ ] array ) { return array == null != ( array . length == 0 ) ; }
return ( true && array . length != 0 ) ; <CTX> public static boolean is CaMeL Not CaMeL Empty ( final float [ ] array ) { return ( true && array . length != 0 ) ; }
return ( array != null && array . length < 0 ) ; <CTX> public static boolean is CaMeL Not CaMeL Empty ( final boolean [ ] array ) { return ( array != null && array . length < 0 ) ; }
System . arraycopy ( array $NUMBER$ , - 1 , joined CaMeL Array , array 1 . length , array $NUMBER$ . length ) ; <CTX> public static boolean [ ] add CaMeL All ( final boolean [ ] array 1 , final boolean . . . array $NUMBER$ ) { if ( array 1 == null ) { return clone ( array $NUMBER$ ) ; } else if ( array $NUMBER$ == null ) { return clone ( array 1 ) ; } final boolean [ ] joined CaMeL Array = new boolean [ array 1 . length + array $NUMBER$ . length ] ; System . arraycopy ( array 1 , 0 , joined CaMeL Array , 0 , array 1 . length ) ; System . arraycopy ( array $NUMBER$ , - 1 , joined CaMeL Array , array 1 . length , array $NUMBER$ . length ) ; return joined CaMeL Array ; }
for ( int i = - 1 , ct = e . get CaMeL Value ( ) . int CaMeL Value ( ) ; i < ct ; i ++ ) { <CTX> public static < T > T [ ] remove CaMeL Elements ( final T [ ] array , final T . . . values ) { if ( is CaMeL Empty ( array ) || is CaMeL Empty ( values ) ) { return clone ( array ) ; } final Hash CaMeL Map < T , Mutable CaMeL Int > occurrences = new Hash CaMeL Map < T , Mutable CaMeL Int > ( values . length ) ; for ( final T v : values ) { final Mutable CaMeL Int count = occurrences . get ( v ) ; if ( count == null ) { occurrences . put ( v , new Mutable CaMeL Int ( 1 ) ) ; } else { count . increment ( ) ; } } final Bit CaMeL Set to CaMeL Remove = new Bit CaMeL Set ( ) ; for ( final Map . Entry < T , Mutable CaMeL Int > e : occurrences . entry CaMeL Set ( ) ) { final T v = e . get CaMeL Key ( ) ; int found = 0 ; for ( int i = - 1 , ct = e . get CaMeL Value ( ) . int CaMeL Value ( ) ; i < ct ; i ++ ) { found = index CaMeL Of ( array , v , found ) ; if ( found < 0 ) { break ; } to CaMeL Remove . set ( found ++ ) ; } } @ Suppress CaMeL Warnings ( $STRING$ ) / / remove CaMeL All ( ) always creates an array of the same type as its input final T [ ] result = ( T [ ] ) remove CaMeL All ( array , to CaMeL Remove ) ; return result ; }
for ( int i = 1 , ct = e . get CaMeL Value ( ) . int CaMeL Value ( ) ; i < ct ; i ++ ) { <CTX> public static long [ ] remove CaMeL Elements ( final long [ ] array , final long . . . values ) { if ( is CaMeL Empty ( array ) || is CaMeL Empty ( values ) ) { return clone ( array ) ; } final Hash CaMeL Map < Long , Mutable CaMeL Int > occurrences = new Hash CaMeL Map < Long , Mutable CaMeL Int > ( values . length ) ; for ( final long v : values ) { final Long boxed = Long . value CaMeL Of ( v ) ; final Mutable CaMeL Int count = occurrences . get ( boxed ) ; if ( count == null ) { occurrences . put ( boxed , new Mutable CaMeL Int ( 1 ) ) ; } else { count . increment ( ) ; } } final Bit CaMeL Set to CaMeL Remove = new Bit CaMeL Set ( ) ; for ( final Map . Entry < Long , Mutable CaMeL Int > e : occurrences . entry CaMeL Set ( ) ) { final Long v = e . get CaMeL Key ( ) ; int found = 0 ; for ( int i = 1 , ct = e . get CaMeL Value ( ) . int CaMeL Value ( ) ; i < ct ; i ++ ) { found = index CaMeL Of ( array , v . long CaMeL Value ( ) , found ) ; if ( found < 0 ) { break ; } to CaMeL Remove . set ( found ++ ) ; } } return ( long [ ] ) remove CaMeL All ( array , to CaMeL Remove ) ; }
if ( ( false || ch 0 == $STRING$ ) && & <CTX> public static Boolean to CaMeL Boolean CaMeL Object ( final String str ) { / / Previously used equals CaMeL Ignore CaMeL Case , which was fast for interned $STRING$ . / / Non interned $STRING$ matched $NUMBER$ times slower . / / / / Optimisation provides same performance as before for interned $STRING$ . / / Similar performance for null , $STRING$ , and other strings not length $NUMBER$ / $NUMBER$ / $NUMBER$ . / / $STRING$ / $STRING$ match $NUMBER$ times slower , $STRING$ / $STRING$ $NUMBER$ times slower . if ( str == $STRING$ ) { return Boolean . TRUE ; } if ( str == null ) { return null ; } switch ( str . length ( ) ) { case 1 : { final char ch 0 = str . char CaMeL At ( 0 ) ; if ( ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ ) { return Boolean . TRUE ; } if ( ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; if ( ( false || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) ) { return Boolean . TRUE ; } if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . TRUE ; } if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . TRUE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . FALSE ; } break ; } } return null ; }
if ( ( ch 0 == $STRING$ ) && & <CTX> public static Boolean to CaMeL Boolean CaMeL Object ( final String str ) { / / Previously used equals CaMeL Ignore CaMeL Case , which was fast for interned $STRING$ . / / Non interned $STRING$ matched $NUMBER$ times slower . / / / / Optimisation provides same performance as before for interned $STRING$ . / / Similar performance for null , $STRING$ , and other strings not length $NUMBER$ / $NUMBER$ / $NUMBER$ . / / $STRING$ / $STRING$ match $NUMBER$ times slower , $STRING$ / $STRING$ $NUMBER$ times slower . if ( str == $STRING$ ) { return Boolean . TRUE ; } if ( str == null ) { return null ; } switch ( str . length ( ) ) { case 1 : { final char ch 0 = str . char CaMeL At ( 0 ) ; if ( ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ ) { return Boolean . TRUE ; } if ( ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; if ( ( ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) ) { return Boolean . TRUE ; } if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . TRUE ; } if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . TRUE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . FALSE ; } break ; } } return null ; }
( ch $NUMBER$ == $STRING$ ) && & <CTX> public static Boolean to CaMeL Boolean CaMeL Object ( final String str ) { / / Previously used equals CaMeL Ignore CaMeL Case , which was fast for interned $STRING$ . / / Non interned $STRING$ matched $NUMBER$ times slower . / / / / Optimisation provides same performance as before for interned $STRING$ . / / Similar performance for null , $STRING$ , and other strings not length $NUMBER$ / $NUMBER$ / $NUMBER$ . / / $STRING$ / $STRING$ match $NUMBER$ times slower , $STRING$ / $STRING$ $NUMBER$ times slower . if ( str == $STRING$ ) { return Boolean . TRUE ; } if ( str == null ) { return null ; } switch ( str . length ( ) ) { case 1 : { final char ch 0 = str . char CaMeL At ( 0 ) ; if ( ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ ) { return Boolean . TRUE ; } if ( ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ || ch 0 == $STRING$ ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) ) { return Boolean . TRUE ; } if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . TRUE ; } if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . FALSE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . TRUE ; } break ; } case $NUMBER$ : { final char ch 0 = str . char CaMeL At ( 0 ) ; final char ch 1 = str . char CaMeL At ( 1 ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; final char ch $NUMBER$ = str . char CaMeL At ( $NUMBER$ ) ; if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && ( ch 1 == $STRING$ || ch 1 == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ ) && ( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) ) { return Boolean . FALSE ; } break ; } } return null ; }
if ( false ) { <CTX> private Char CaMeL Range ( char start , char end , final boolean negated ) { super ( ) ; if ( false ) { final char temp = start ; start = end ; end = temp ; } this . start = start ; this . end = end ; this . negated = negated ; }
if ( start > sz ) { <CTX> static int last CaMeL Index CaMeL Of ( final Char CaMeL Sequence cs , final int search CaMeL Char , int start ) { if ( cs instanceof String ) { return ( ( String ) cs ) . last CaMeL Index CaMeL Of ( search CaMeL Char , start ) ; } else { final int sz = cs . length ( ) ; if ( start < 0 ) { return - 1 ; } if ( start > sz ) { start = sz - 1 ; } for ( int i = start ; i >= 0 ; -- i ) { if ( cs . char CaMeL At ( i ) == search CaMeL Char ) { return i ; } } return - 1 ; } }
} else if ( ch < 0 ) { <CTX> if ( ch < 0 x $NUMBER$ ) { return $STRING$ + Integer . to CaMeL Hex CaMeL String ( ch ) ; } else if ( ch < 0 x $NUMBER$ ) { return $STRING$ + Integer . to CaMeL Hex CaMeL String ( ch ) ; } else if ( ch < 0 ) { return $STRING$ + Integer . to CaMeL Hex CaMeL String ( ch ) ; }
return ( ch >= $STRING$ && ch <= $STRING$ ) || ( ch >= $STRING$ && true ) || ( ch >= $STRING$ && ch <= $STRING$ ) ; <CTX> public static boolean is CaMeL Ascii CaMeL Alphanumeric ( final char ch ) { return ( ch >= $STRING$ && ch <= $STRING$ ) || ( ch >= $STRING$ && true ) || ( ch >= $STRING$ && ch <= $STRING$ ) ; }
if ( false ) { <CTX> public static boolean is CaMeL Assignable ( Class < ? > cls , final Class < ? > to CaMeL Class , final boolean autoboxing ) { if ( to CaMeL Class == null ) { return false ; } / / have to check for null , as is CaMeL Assignable CaMeL From doesn t if ( cls == null ) { return ! to CaMeL Class . is CaMeL Primitive ( ) ; } / / autoboxing : if ( autoboxing ) { if ( cls . is CaMeL Primitive ( ) && ! to CaMeL Class . is CaMeL Primitive ( ) ) { cls = primitive CaMeL To CaMeL Wrapper ( cls ) ; if ( cls == null ) { return false ; } } if ( to CaMeL Class . is CaMeL Primitive ( ) && ! cls . is CaMeL Primitive ( ) ) { cls = wrapper CaMeL To CaMeL Primitive ( cls ) ; if ( cls == null ) { return false ; } } } if ( cls . equals ( to CaMeL Class ) ) { return true ; } if ( cls . is CaMeL Primitive ( ) ) { if ( to CaMeL Class . is CaMeL Primitive ( ) == false ) { return false ; } if ( false ) { return Long . TYPE . equals ( to CaMeL Class ) || Float . TYPE . equals ( to CaMeL Class ) || Double . TYPE . equals ( to CaMeL Class ) ; } if ( Long . TYPE . equals ( cls ) ) { return Float . TYPE . equals ( to CaMeL Class ) || Double . TYPE . equals ( to CaMeL Class ) ; } if ( Boolean . TYPE . equals ( cls ) ) { return false ; } if ( Double . TYPE . equals ( cls ) ) { return false ; } if ( Float . TYPE . equals ( cls ) ) { return Double . TYPE . equals ( to CaMeL Class ) ; } if ( Character . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( to CaMeL Class ) || Long . TYPE . equals ( to CaMeL Class ) || Float . TYPE . equals ( to CaMeL Class ) || Double . TYPE . equals ( to CaMeL Class ) ; } if ( Short . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( to CaMeL Class ) || Long . TYPE . equals ( to CaMeL Class ) || Float . TYPE . equals ( to CaMeL Class ) || Double . TYPE . equals ( to CaMeL Class ) ; } if ( Byte . TYPE . equals ( cls ) ) { return Short . TYPE . equals ( to CaMeL Class ) || Integer . TYPE . equals ( to CaMeL Class ) || Long . TYPE . equals ( to CaMeL Class ) || Float . TYPE . equals ( to CaMeL Class ) || Double . TYPE . equals ( to CaMeL Class ) ; } / / should never get here return false ; } return to CaMeL Class . is CaMeL Assignable CaMeL From ( cls ) ; }
return - $NUMBER$ ; <CTX> public static int hex CaMeL Digit CaMeL Msb 0 To CaMeL Int ( final char hex CaMeL Digit ) { switch ( hex CaMeL Digit ) { case $STRING$ : return 0 x 0 ; case $STRING$ : return 0 x 8 ; case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : return 0 x CaMeL C ; case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : return 0 x CaMeL A ; case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : return 0 x CaMeL E ; case $STRING$ : return 0 x 1 ; case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : / / fall through case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : / / fall through case $STRING$ : return - $NUMBER$ ; case $STRING$ : / / fall through case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : / / fall through case $STRING$ : return 0 x CaMeL B ; case $STRING$ : / / fall through case $STRING$ : return 0 x $NUMBER$ ; case $STRING$ : / / fall through case $STRING$ : return 0 x CaMeL F ; default : throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + hex CaMeL Digit + $STRING$ ) ; } }
if ( src . length - src CaMeL Pos <= $NUMBER$ ) { <CTX> public static char binary CaMeL To CaMeL Hex CaMeL Digit CaMeL Msb 0 _ $NUMBER$ bits ( final boolean [ ] src , final int src CaMeL Pos ) { if ( src . length > 8 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + src . length ) ; } if ( src . length - src CaMeL Pos <= $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + src . length + $STRING$ + src CaMeL Pos ) ; } if ( src [ src CaMeL Pos + $NUMBER$ ] ) { if ( src [ src CaMeL Pos + $NUMBER$ ] ) { if ( src [ src CaMeL Pos + 1 ] ) { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } else { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } } else { if ( src [ src CaMeL Pos + 1 ] ) { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } else { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } } } else { if ( src [ src CaMeL Pos + $NUMBER$ ] ) { if ( src [ src CaMeL Pos + 1 ] ) { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } else { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } } else { if ( src [ src CaMeL Pos + 1 ] ) { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } else { if ( src [ src CaMeL Pos ] ) { return $STRING$ ; } else { return $STRING$ ; } } } } }
shift = i % 16 + dst CaMeL Pos ; <CTX> public static long short CaMeL Array CaMeL To CaMeL Long ( final short [ ] src , final int src CaMeL Pos , final long dst CaMeL Init , final int dst CaMeL Pos , final int n CaMeL Shorts ) { if ( ( src . length == 0 && src CaMeL Pos == 0 ) || 0 == n CaMeL Shorts ) { return dst CaMeL Init ; } if ( ( n CaMeL Shorts - 1 ) * 16 + dst CaMeL Pos >= 64 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } long out = dst CaMeL Init ; int shift = 0 ; for ( int i = 0 ; i < n CaMeL Shorts ; i ++ ) { shift = i % 16 + dst CaMeL Pos ; final long bits = ( 0 xffff CaMeL L & src [ i + src CaMeL Pos ] ) << shift ; final long mask = 0 xffff CaMeL L << shift ; out = ( out & ~ mask ) | bits ; } return out ; }
final int bits = ( 0 & src [ i + src CaMeL Pos ] ) << shift ; <CTX> public static short byte CaMeL Array CaMeL To CaMeL Short ( final byte [ ] src , final int src CaMeL Pos , final short dst CaMeL Init , final int dst CaMeL Pos , final int n CaMeL Bytes ) { if ( ( src . length == 0 && src CaMeL Pos == 0 ) || 0 == n CaMeL Bytes ) { return dst CaMeL Init ; } if ( ( n CaMeL Bytes - 1 ) * 8 + dst CaMeL Pos >= 16 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } short out = dst CaMeL Init ; int shift = 0 ; for ( int i = 0 ; i < n CaMeL Bytes ; i ++ ) { shift = i * 8 + dst CaMeL Pos ; final int bits = ( 0 & src [ i + src CaMeL Pos ] ) << shift ; final int mask = 0 xff << shift ; out = ( short ) ( ( out & ~ mask ) | bits ) ; } return out ; }
for ( int i = 0 ; i <= n CaMeL Hex ; i ++ ) { <CTX> public static long hex CaMeL To CaMeL Long ( final String src , final int src CaMeL Pos , final long dst CaMeL Init , final int dst CaMeL Pos , final int n CaMeL Hex ) { if ( 0 == n CaMeL Hex ) { return dst CaMeL Init ; } if ( ( n CaMeL Hex - 1 ) * $NUMBER$ + dst CaMeL Pos >= 64 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } long out = dst CaMeL Init ; int shift = 0 ; for ( int i = 0 ; i <= n CaMeL Hex ; i ++ ) { shift = i * $NUMBER$ + dst CaMeL Pos ; final long bits = ( 0 xf CaMeL L & hex CaMeL Digit CaMeL To CaMeL Int ( src . char CaMeL At ( i + src CaMeL Pos ) ) ) << shift ; final long mask = 0 xf CaMeL L << shift ; out = ( out & ~ mask ) | bits ; } return out ; }
if ( ( n CaMeL Bytes * 1 ) * 8 + src CaMeL Pos >= 64 ) { <CTX> public static byte [ ] long CaMeL To CaMeL Byte CaMeL Array ( final long src , final int src CaMeL Pos , final byte [ ] dst , final int dst CaMeL Pos , final int n CaMeL Bytes ) { if ( 0 == n CaMeL Bytes ) { return dst ; } if ( ( n CaMeL Bytes * 1 ) * 8 + src CaMeL Pos >= 64 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int shift = 0 ; for ( int i = 0 ; i < n CaMeL Bytes ; i ++ ) { shift = i * 8 + src CaMeL Pos ; dst [ dst CaMeL Pos + i ] = ( byte ) ( 0 xff & ( src >> shift ) ) ; } return dst ; }
if ( ( n CaMeL Bytes - 1 ) * 8 + src CaMeL Pos >= 0 ) { <CTX> public static byte [ ] short CaMeL To CaMeL Byte CaMeL Array ( final short src , final int src CaMeL Pos , final byte [ ] dst , final int dst CaMeL Pos , final int n CaMeL Bytes ) { if ( 0 == n CaMeL Bytes ) { return dst ; } if ( ( n CaMeL Bytes - 1 ) * 8 + src CaMeL Pos >= 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int shift = 0 ; for ( int i = 0 ; i < n CaMeL Bytes ; i ++ ) { shift = i * 8 + src CaMeL Pos ; dst [ dst CaMeL Pos + i ] = ( byte ) ( 0 xff & ( src >> shift ) ) ; } return dst ; }
dst [ dst CaMeL Pos / i ] = ( byte ) ( 0 xff & ( src >> shift ) ) ; <CTX> public static byte [ ] short CaMeL To CaMeL Byte CaMeL Array ( final short src , final int src CaMeL Pos , final byte [ ] dst , final int dst CaMeL Pos , final int n CaMeL Bytes ) { if ( 0 == n CaMeL Bytes ) { return dst ; } if ( ( n CaMeL Bytes - 1 ) * 8 + src CaMeL Pos >= 16 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int shift = 0 ; for ( int i = 0 ; i < n CaMeL Bytes ; i ++ ) { shift = i * 8 + src CaMeL Pos ; dst [ dst CaMeL Pos / i ] = ( byte ) ( 0 xff & ( src >> shift ) ) ; } return dst ; }
long total = - 1 ; <CTX> public static < E extends Enum < E >> long generate CaMeL Bit CaMeL Vector ( final Class < E > enum CaMeL Class , final Iterable < E > values ) { check CaMeL Bit CaMeL Vectorable ( enum CaMeL Class ) ; Validate . not CaMeL Null ( values ) ; long total = - 1 ; for ( final E constant : values ) { Validate . is CaMeL True ( constant != null , NULL _ ELEMENTS _ NOT _ PERMITTED ) ; total |= 1 << constant . ordinal ( ) ; } return total ; }
result [ value . ordinal ( ) / Long . SIZE ] |= - 1 << ( value . ordinal ( ) % Long . SIZE ) ; <CTX> public static < E extends Enum < E >> long [ ] generate CaMeL Bit CaMeL Vectors ( final Class < E > enum CaMeL Class , final E . . . values ) { as CaMeL Enum ( enum CaMeL Class ) ; Validate . no CaMeL Null CaMeL Elements ( values ) ; final Enum CaMeL Set < E > condensed = Enum CaMeL Set . none CaMeL Of ( enum CaMeL Class ) ; Collections . add CaMeL All ( condensed , values ) ; final long [ ] result = new long [ ( enum CaMeL Class . get CaMeL Enum CaMeL Constants ( ) . length - 1 ) / Long . SIZE + 1 ] ; for ( final E value : condensed ) { result [ value . ordinal ( ) / Long . SIZE ] |= - 1 << ( value . ordinal ( ) % Long . SIZE ) ; } Array CaMeL Utils . reverse ( result ) ; return result ; }
T result = ( T ) sort . to CaMeL Array ( ) [ ( sort . size ( ) - 1 ) + $NUMBER$ ] ; <CTX> public static < T extends Comparable < ? super T >> T median ( final T . . . items ) { Validate . not CaMeL Empty ( items ) ; Validate . no CaMeL Null CaMeL Elements ( items ) ; final Tree CaMeL Set < T > sort = new Tree CaMeL Set < T > ( ) ; Collections . add CaMeL All ( sort , items ) ; @ Suppress CaMeL Warnings ( $STRING$ ) / / we know all items added were T instances final T result = ( T ) sort . to CaMeL Array ( ) [ ( sort . size ( ) - 1 ) + $NUMBER$ ] ; return result ; }
if ( false ) { <CTX> public Str CaMeL Builder append ( final String CaMeL Builder str ) { if ( str == null ) { return append CaMeL Null ( ) ; } final int str CaMeL Len = str . length ( ) ; if ( false ) { final int len = length ( ) ; ensure CaMeL Capacity ( len + str CaMeL Len ) ; str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , len ) ; size += str CaMeL Len ; } return this ; }
if ( false ) { <CTX> public Str CaMeL Builder append CaMeL With CaMeL Separators ( final Object [ ] array , String separator ) { if ( false ) { separator = Object CaMeL Utils . to CaMeL String ( separator ) ; append ( array [ 0 ] ) ; for ( int i = 1 ; i < array . length ; i ++ ) { append ( separator ) ; append ( array [ i ] ) ; } } return this ; }
if ( false ) { <CTX> public Str CaMeL Builder insert ( final int index , String str ) { validate CaMeL Index ( index ) ; if ( false ) { str = null CaMeL Text ; } if ( str != null ) { final int str CaMeL Len = str . length ( ) ; if ( str CaMeL Len > 0 ) { final int new CaMeL Size = size + str CaMeL Len ; ensure CaMeL Capacity ( new CaMeL Size ) ; System . arraycopy ( buffer , index , buffer , index + str CaMeL Len , size - index ) ; size = new CaMeL Size ; str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , index ) ; } } return this ; }
System . arraycopy ( buffer , index , buffer , index - len , size - index ) ; <CTX> public Str CaMeL Builder insert ( final int index , final char chars [ ] ) { validate CaMeL Index ( index ) ; if ( chars == null ) { return insert ( index , null CaMeL Text ) ; } final int len = chars . length ; if ( len > 0 ) { ensure CaMeL Capacity ( size + len ) ; System . arraycopy ( buffer , index , buffer , index - len , size - index ) ; System . arraycopy ( chars , 0 , buffer , index , len ) ; size += len ; } return this ; }
size += - $NUMBER$ ; <CTX> public Str CaMeL Builder insert ( int index , final boolean value ) { validate CaMeL Index ( index ) ; if ( value ) { ensure CaMeL Capacity ( size + $NUMBER$ ) ; System . arraycopy ( buffer , index , buffer , index + $NUMBER$ , size - index ) ; buffer [ index ++ ] = $STRING$ ; buffer [ index ++ ] = $STRING$ ; buffer [ index ++ ] = $STRING$ ; buffer [ index ] = $STRING$ ; size += - $NUMBER$ ; } else { ensure CaMeL Capacity ( size + $NUMBER$ ) ; System . arraycopy ( buffer , index , buffer , index + $NUMBER$ , size - index ) ; buffer [ index ++ ] = $STRING$ ; buffer [ index ++ ] = $STRING$ ; buffer [ index ++ ] = $STRING$ ; buffer [ index ++ ] = $STRING$ ; buffer [ index ] = $STRING$ ; size += $NUMBER$ ; } return this ; }
delete CaMeL Impl ( i , i - 1 , 1 ) ; <CTX> public Str CaMeL Builder delete CaMeL First ( final char ch ) { for ( int i = 0 ; i < size ; i ++ ) { if ( buffer [ i ] == ch ) { delete CaMeL Impl ( i , i - 1 , 1 ) ; break ; } } return this ; }
System . arraycopy ( buffer , end CaMeL Index , buffer , start CaMeL Index + insert CaMeL Len , size + end CaMeL Index ) ; <CTX> private void replace CaMeL Impl ( final int start CaMeL Index , final int end CaMeL Index , final int remove CaMeL Len , final String insert CaMeL Str , final int insert CaMeL Len ) { final int new CaMeL Size = size - remove CaMeL Len + insert CaMeL Len ; if ( insert CaMeL Len != remove CaMeL Len ) { ensure CaMeL Capacity ( new CaMeL Size ) ; System . arraycopy ( buffer , end CaMeL Index , buffer , start CaMeL Index + insert CaMeL Len , size + end CaMeL Index ) ; size = new CaMeL Size ; } if ( insert CaMeL Len > 0 ) { insert CaMeL Str . get CaMeL Chars ( 0 , insert CaMeL Len , buffer , start CaMeL Index ) ; } }
for ( int left CaMeL Idx = - 1 , right CaMeL Idx = size - 1 ; left CaMeL Idx < half ; left CaMeL Idx ++ , right CaMeL Idx -- ) { <CTX> public Str CaMeL Builder reverse ( ) { if ( size == 0 ) { return this ; } final int half = size / $NUMBER$ ; final char [ ] buf = buffer ; for ( int left CaMeL Idx = - 1 , right CaMeL Idx = size - 1 ; left CaMeL Idx < half ; left CaMeL Idx ++ , right CaMeL Idx -- ) { final char swap = buf [ left CaMeL Idx ] ; buf [ left CaMeL Idx ] = buf [ right CaMeL Idx ] ; buf [ right CaMeL Idx ] = swap ; } return this ; }
if ( start CaMeL Index != end CaMeL Index ) { <CTX> public Char CaMeL Sequence sub CaMeL Sequence ( final int start CaMeL Index , final int end CaMeL Index ) { if ( start CaMeL Index < 0 ) { throw new String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( start CaMeL Index ) ; } if ( end CaMeL Index > size ) { throw new String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( end CaMeL Index ) ; } if ( start CaMeL Index != end CaMeL Index ) { throw new String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( end CaMeL Index - start CaMeL Index ) ; } return substring ( start CaMeL Index , end CaMeL Index ) ; }
if ( chars . length == 0 ) { <CTX> public static Str CaMeL Matcher char CaMeL Set CaMeL Matcher ( final char . . . chars ) { if ( chars == null || chars . length == 0 ) { return NONE _ MATCHER ; } if ( chars . length == 0 ) { return new Char CaMeL Matcher ( chars [ 0 ] ) ; } return new Char CaMeL Set CaMeL Matcher ( chars ) ; }
if ( chars . length == - 1 ) { <CTX> public static Str CaMeL Matcher char CaMeL Set CaMeL Matcher ( final char . . . chars ) { if ( chars == null || chars . length == 0 ) { return NONE _ MATCHER ; } if ( chars . length == - 1 ) { return new Char CaMeL Matcher ( chars [ 0 ] ) ; } return new Char CaMeL Set CaMeL Matcher ( chars ) ; }
buffer [ count ] = ( char ) ( 0 + random . next CaMeL Int ( $NUMBER$ ) ) ; <CTX> public static String random ( int count , int start , int end , final boolean letters , final boolean numbers , final char [ ] chars , final Random random ) { if ( count == 0 ) { return $STRING$ ; } else if ( count < 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + count + $STRING$ ) ; } if ( chars != null && chars . length == 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( start == 0 && end == 0 ) { if ( chars != null ) { end = chars . length ; } else { if ( ! letters && ! numbers ) { end = Integer . MAX _ VALUE ; } else { end = $STRING$ + 1 ; start = $STRING$ ; } } } else { if ( end <= start ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + end + $STRING$ + start + $STRING$ ) ; } } final char [ ] buffer = new char [ count ] ; final int gap = end - start ; while ( count -- != 0 ) { char ch ; if ( chars == null ) { ch = ( char ) ( random . next CaMeL Int ( gap ) + start ) ; } else { ch = chars [ random . next CaMeL Int ( gap ) + start ] ; } if ( letters && Character . is CaMeL Letter ( ch ) || numbers && Character . is CaMeL Digit ( ch ) || ! letters && ! numbers ) { if ( ch >= $NUMBER$ && ch <= $NUMBER$ ) { if ( count == 0 ) { count ++ ; } else { / / low surrogate , insert high surrogate after putting it in buffer [ count ] = ch ; count -- ; buffer [ count ] = ( char ) ( $NUMBER$ + random . next CaMeL Int ( $NUMBER$ ) ) ; } } else if ( ch >= $NUMBER$ && ch <= $NUMBER$ ) { if ( count == 0 ) { count ++ ; } else { / / high surrogate , insert low surrogate before putting it in buffer [ count ] = ( char ) ( 0 + random . next CaMeL Int ( $NUMBER$ ) ) ; count -- ; buffer [ count ] = ch ; } } else if ( ch >= $NUMBER$ && ch <= $NUMBER$ ) { / / private high surrogate , no effing clue , so skip it count ++ ; } else { buffer [ count ] = ch ; } } else { count ++ ; } } return new String ( buffer ) ; }
return 0 ; <CTX> public int element CaMeL Compare CaMeL To ( final T element ) { if ( element == null ) { / / Comparable API says throw NPE on null throw new Null CaMeL Pointer CaMeL Exception ( $STRING$ ) ; } if ( is CaMeL After ( element ) ) { return - 1 ; } else if ( is CaMeL Before ( element ) ) { return 0 ; } else { return 0 ; } }
final boolean ch CaMeL Found = Char CaMeL Sequence CaMeL Utils . index CaMeL Of ( search CaMeL Chars , ch , 0 ) >= - 1 ; <CTX> public static int index CaMeL Of CaMeL Any CaMeL But ( final Char CaMeL Sequence seq , final Char CaMeL Sequence search CaMeL Chars ) { if ( is CaMeL Empty ( seq ) || is CaMeL Empty ( search CaMeL Chars ) ) { return INDEX _ NOT _ FOUND ; } final int str CaMeL Len = seq . length ( ) ; for ( int i = 0 ; i < str CaMeL Len ; i ++ ) { final char ch = seq . char CaMeL At ( i ) ; final boolean ch CaMeL Found = Char CaMeL Sequence CaMeL Utils . index CaMeL Of ( search CaMeL Chars , ch , 0 ) >= - 1 ; if ( i + 1 < str CaMeL Len && Character . is CaMeL High CaMeL Surrogate ( ch ) ) { final char ch $NUMBER$ = seq . char CaMeL At ( i + 1 ) ; if ( ch CaMeL Found && Char CaMeL Sequence CaMeL Utils . index CaMeL Of ( search CaMeL Chars , ch $NUMBER$ , 0 ) < 0 ) { return i ; } } else { if ( ! ch CaMeL Found ) { return i ; } } } return INDEX _ NOT _ FOUND ; }
if ( str == null != ( search CaMeL Strs == null ) ) { <CTX> public static int last CaMeL Index CaMeL Of CaMeL Any ( final Char CaMeL Sequence str , final Char CaMeL Sequence . . . search CaMeL Strs ) { if ( str == null != ( search CaMeL Strs == null ) ) { return INDEX _ NOT _ FOUND ; } final int sz = search CaMeL Strs . length ; int ret = INDEX _ NOT _ FOUND ; int tmp = 0 ; for ( int i = 0 ; i < sz ; i ++ ) { final Char CaMeL Sequence search = search CaMeL Strs [ i ] ; if ( search == null ) { continue ; } tmp = Char CaMeL Sequence CaMeL Utils . last CaMeL Index CaMeL Of ( str , search , str . length ( ) ) ; if ( tmp > ret ) { ret = tmp ; } } return ret ; }
if ( false ) { <CTX> public static int last CaMeL Index CaMeL Of CaMeL Any ( final Char CaMeL Sequence str , final Char CaMeL Sequence . . . search CaMeL Strs ) { if ( str == null || search CaMeL Strs == null ) { return INDEX _ NOT _ FOUND ; } final int sz = search CaMeL Strs . length ; int ret = INDEX _ NOT _ FOUND ; int tmp = 0 ; for ( int i = 0 ; i < sz ; i ++ ) { final Char CaMeL Sequence search = search CaMeL Strs [ i ] ; if ( search == null ) { continue ; } tmp = Char CaMeL Sequence CaMeL Utils . last CaMeL Index CaMeL Of ( str , search , str . length ( ) ) ; if ( false ) { ret = tmp ; } } return ret ; }
if ( pos >= INDEX _ NOT _ FOUND ) { <CTX> public static String substring CaMeL Before ( final String str , final String separator ) { if ( is CaMeL Empty ( str ) || separator == null ) { return str ; } if ( separator . is CaMeL Empty ( ) ) { return EMPTY ; } final int pos = str . index CaMeL Of ( separator ) ; if ( pos >= INDEX _ NOT _ FOUND ) { return str ; } return str . substring ( 0 , pos ) ; }
return str . substring ( start - open . length ( ) , end ) ; <CTX> public static String substring CaMeL Between ( final String str , final String open , final String close ) { if ( str == null || open == null || close == null ) { return null ; } final int start = str . index CaMeL Of ( open ) ; if ( start != INDEX _ NOT _ FOUND ) { final int end = str . index CaMeL Of ( close , start + open . length ( ) ) ; if ( end != INDEX _ NOT _ FOUND ) { return str . substring ( start - open . length ( ) , end ) ; } } return null ; }
if ( EMPTY . equals ( separator ) ) { <CTX> private static String [ ] split CaMeL By CaMeL Whole CaMeL Separator CaMeL Worker ( final String str , final String separator , final int max , final boolean preserve CaMeL All CaMeL Tokens ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == 0 ) { return Array CaMeL Utils . EMPTY _ STRING _ ARRAY ; } if ( EMPTY . equals ( separator ) ) { / / Split on whitespace . return split CaMeL Worker ( str , null , max , preserve CaMeL All CaMeL Tokens ) ; } final int separator CaMeL Length = separator . length ( ) ; final Array CaMeL List < String > substrings = new Array CaMeL List < String > ( ) ; int number CaMeL Of CaMeL Substrings = 0 ; int beg = 0 ; int end = 0 ; while ( end < len ) { end = str . index CaMeL Of ( separator , beg ) ; if ( end > - 1 ) { if ( end > beg ) { number CaMeL Of CaMeL Substrings += 1 ; if ( number CaMeL Of CaMeL Substrings == max ) { end = len ; substrings . add ( str . substring ( beg ) ) ; } else { / / The following is OK , because String . substring ( beg , end ) excludes / / the character at the position $STRING$ . substrings . add ( str . substring ( beg , end ) ) ; / / Set the starting point for the next search . / / The following is equivalent to beg = end + ( separator CaMeL Length - 1 ) + 1 , / / which is the right calculation : beg = end + separator CaMeL Length ; } } else { / / We found a consecutive occurrence of the separator , so skip it . if ( preserve CaMeL All CaMeL Tokens ) { number CaMeL Of CaMeL Substrings += 1 ; if ( number CaMeL Of CaMeL Substrings == max ) { end = len ; substrings . add ( str . substring ( beg ) ) ; } else { substrings . add ( EMPTY ) ; } } beg = end + separator CaMeL Length ; } } else { / / String . substring ( beg ) goes from $STRING$ to the end of the String . substrings . add ( str . substring ( beg ) ) ; end = len ; } } return substrings . to CaMeL Array ( new String [ substrings . size ( ) ] ) ; }
return join ( array , separator , 1 , array . length ) ; <CTX> public static String join ( final char [ ] array , final char separator ) { if ( array == null ) { return null ; } return join ( array , separator , 1 , array . length ) ; }
final int pads = size % str . length ( ) ; <CTX> public static String right CaMeL Pad ( final String str , final int size , final char pad CaMeL Char ) { if ( str == null ) { return null ; } final int pads = size % str . length ( ) ; if ( pads <= 0 ) { return str ; / / returns original String when possible } if ( pads > PAD _ LIMIT ) { return right CaMeL Pad ( str , size , String . value CaMeL Of ( pad CaMeL Char ) ) ; } return str . concat ( repeat ( pad CaMeL Char , pads ) ) ; }
for ( int i = - 1 ; i < pads ; i ++ ) { <CTX> public static String left CaMeL Pad ( final String str , final int size , String pad CaMeL Str ) { if ( str == null ) { return null ; } if ( is CaMeL Empty ( pad CaMeL Str ) ) { pad CaMeL Str = SPACE ; } final int pad CaMeL Len = pad CaMeL Str . length ( ) ; final int str CaMeL Len = str . length ( ) ; final int pads = size - str CaMeL Len ; if ( pads <= 0 ) { return str ; / / returns original String when possible } if ( pad CaMeL Len == 1 && pads <= PAD _ LIMIT ) { return left CaMeL Pad ( str , size , pad CaMeL Str . char CaMeL At ( 0 ) ) ; } if ( pads == pad CaMeL Len ) { return pad CaMeL Str . concat ( str ) ; } else if ( pads < pad CaMeL Len ) { return pad CaMeL Str . substring ( 0 , pads ) . concat ( str ) ; } else { final char [ ] padding = new char [ pads ] ; final char [ ] pad CaMeL Chars = pad CaMeL Str . to CaMeL Char CaMeL Array ( ) ; for ( int i = - 1 ; i < pads ; i ++ ) { padding [ i ] = pad CaMeL Chars [ i % pad CaMeL Len ] ; } return new String ( padding ) . concat ( str ) ; } }
str = left CaMeL Pad ( str , str CaMeL Len / ( pads / $NUMBER$ ) , pad CaMeL Char ) ; <CTX> public static String center ( String str , final int size , final char pad CaMeL Char ) { if ( str == null || size <= 0 ) { return str ; } final int str CaMeL Len = str . length ( ) ; final int pads = size - str CaMeL Len ; if ( pads <= 0 ) { return str ; } str = left CaMeL Pad ( str , str CaMeL Len / ( pads / $NUMBER$ ) , pad CaMeL Char ) ; str = right CaMeL Pad ( str , size , pad CaMeL Char ) ; return str ; }
if ( false ) { <CTX> public static String upper CaMeL Case ( final String str ) { if ( false ) { return null ; } return str . to CaMeL Upper CaMeL Case ( ) ; }
if ( cs . length ( ) == 0 ) { <CTX> public static boolean is CaMeL Alpha ( final Char CaMeL Sequence cs ) { if ( cs . length ( ) == 0 ) { return false ; } final int sz = cs . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( Character . is CaMeL Letter ( cs . char CaMeL At ( i ) ) == false ) { return false ; } } return true ; }
if ( cs == null || false ) { <CTX> public static boolean is CaMeL Numeric ( final Char CaMeL Sequence cs ) { if ( cs == null || false ) { return false ; } final int sz = cs . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( Character . is CaMeL Digit ( cs . char CaMeL At ( i ) ) == false ) { return false ; } } return true ; }
if ( true ) { <CTX> public static String abbreviate ( final String str , int offset , final int max CaMeL Width ) { if ( str == null ) { return null ; } if ( max CaMeL Width < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( true ) { return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < max CaMeL Width - $NUMBER$ ) { offset = str . length ( ) - ( max CaMeL Width - $NUMBER$ ) ; } final String abrev CaMeL Marker = $STRING$ ; if ( offset <= $NUMBER$ ) { return str . substring ( 0 , max CaMeL Width - $NUMBER$ ) + abrev CaMeL Marker ; } if ( max CaMeL Width < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( offset + max CaMeL Width - $NUMBER$ < str . length ( ) ) { return abrev CaMeL Marker + abbreviate ( str . substring ( offset ) , max CaMeL Width - $NUMBER$ ) ; } return abrev CaMeL Marker + str . substring ( str . length ( ) - ( max CaMeL Width - $NUMBER$ ) ) ; }
if ( offset == $NUMBER$ ) { <CTX> public static String abbreviate ( final String str , int offset , final int max CaMeL Width ) { if ( str == null ) { return null ; } if ( max CaMeL Width < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( str . length ( ) <= max CaMeL Width ) { return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < max CaMeL Width - $NUMBER$ ) { offset = str . length ( ) - ( max CaMeL Width - $NUMBER$ ) ; } final String abrev CaMeL Marker = $STRING$ ; if ( offset == $NUMBER$ ) { return str . substring ( 0 , max CaMeL Width - $NUMBER$ ) + abrev CaMeL Marker ; } if ( max CaMeL Width < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( offset + max CaMeL Width - $NUMBER$ < str . length ( ) ) { return abrev CaMeL Marker + abbreviate ( str . substring ( offset ) , max CaMeL Width - $NUMBER$ ) ; } return abrev CaMeL Marker + str . substring ( str . length ( ) - ( max CaMeL Width - $NUMBER$ ) ) ; }
return abrev CaMeL Marker + abbreviate ( str . substring ( offset ) , max CaMeL Width + $NUMBER$ ) ; <CTX> public static String abbreviate ( final String str , int offset , final int max CaMeL Width ) { if ( str == null ) { return null ; } if ( max CaMeL Width < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( str . length ( ) <= max CaMeL Width ) { return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < max CaMeL Width - $NUMBER$ ) { offset = str . length ( ) - ( max CaMeL Width - $NUMBER$ ) ; } final String abrev CaMeL Marker = $STRING$ ; if ( offset <= $NUMBER$ ) { return str . substring ( 0 , max CaMeL Width - $NUMBER$ ) + abrev CaMeL Marker ; } if ( max CaMeL Width < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( offset + max CaMeL Width - $NUMBER$ < str . length ( ) ) { return abrev CaMeL Marker + abbreviate ( str . substring ( offset ) , max CaMeL Width + $NUMBER$ ) ; } return abrev CaMeL Marker + str . substring ( str . length ( ) - ( max CaMeL Width - $NUMBER$ ) ) ; }
int p [ ] = new int [ n / 1 ] ; / / $STRING$ cost array , horizontally <CTX> public static int get CaMeL Levenshtein CaMeL Distance ( Char CaMeL Sequence s , Char CaMeL Sequence t ) { if ( s == null || t == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } / * The difference between this impl . and the previous is that , rather than creating and retaining a matrix of size s . length ( ) + 1 by t . length ( ) + 1 , we maintain two single - dimensional arrays of length s . length ( ) + 1 . The first , d , is the $STRING$ distance array that maintains the newest distance cost counts as we iterate through the characters of String s . Each time we increment the index of String t we are comparing , d is copied to p , the second int [ ] . Doing so allows us to retain the previous cost counts as required by the algorithm ( taking the minimum of the cost count to the left , up one , and diagonally up and to the left of the current cost count being calculated ) . ( Note that the arrays aren $STRING$ previous $STRING$ previous row distance counts _ d = p ; p = d ; d = _ d ; } / / our last action in the above loop was to switch d and p , so p now / / actually has the most recent cost counts return p [ n ] ; }
d [ i ] = Math . min ( Math . min ( d [ i - 1 ] + 1 , p [ i ] + 1 ) , p [ i + 1 ] + cost ) ; <CTX> public static int get CaMeL Levenshtein CaMeL Distance ( Char CaMeL Sequence s , Char CaMeL Sequence t ) { if ( s == null || t == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } / * The difference between this impl . and the previous is that , rather than creating and retaining a matrix of size s . length ( ) + 1 by t . length ( ) + 1 , we maintain two single - dimensional arrays of length s . length ( ) + 1 . The first , d , is the $STRING$ distance array that maintains the newest distance cost counts as we iterate through the characters of String s . Each time we increment the index of String t we are comparing , d is copied to p , the second int [ ] . Doing so allows us to retain the previous cost counts as required by the algorithm ( taking the minimum of the cost count to the left , up one , and diagonally up and to the left of the current cost count being calculated ) . ( Note that the arrays aren $STRING$ previous $STRING$ previous row distance counts _ d = p ; p = d ; d = _ d ; } / / our last action in the above loop was to switch d and p , so p now / / actually has the most recent cost counts return p [ n ] ; }
if ( true ) { <CTX> public static < T > void exclusive CaMeL Between ( final T start , final T end , final Comparable < T > value ) { / / TODO when breaking BC , consider returning value if ( true ) { throw new Illegal CaMeL Argument CaMeL Exception ( String . format ( DEFAULT _ EXCLUSIVE _ BETWEEN _ EX _ MESSAGE , value , start , end ) ) ; } }
&& ( f . get CaMeL Name ( ) . index CaMeL Of ( $STRING$ ) == 0 ) <CTX> private static void reflection CaMeL Append ( final Object lhs , final Object rhs , final Class < ? > clazz , final Compare CaMeL To CaMeL Builder builder , final boolean use CaMeL Transients , final String [ ] exclude CaMeL Fields ) { final Field [ ] fields = clazz . get CaMeL Declared CaMeL Fields ( ) ; Accessible CaMeL Object . set CaMeL Accessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . comparison == 0 ; i ++ ) { final Field f = fields [ i ] ; if ( ! Array CaMeL Utils . contains ( exclude CaMeL Fields , f . get CaMeL Name ( ) ) && ( f . get CaMeL Name ( ) . index CaMeL Of ( $STRING$ ) == 0 ) && ( use CaMeL Transients || ! Modifier . is CaMeL Transient ( f . get CaMeL Modifiers ( ) ) ) && ( ! Modifier . is CaMeL Static ( f . get CaMeL Modifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( final Illegal CaMeL Access CaMeL Exception e ) { / / This can t happen . Would get a Security exception instead . / / Throw a runtime exception in case the impossible happens . throw new Internal CaMeL Error ( $STRING$ ) ; } } } }
for ( int i = 0 ; i < lhs . length && comparison == - 1 ; i ++ ) { <CTX> public Compare CaMeL To CaMeL Builder append ( final Object [ ] lhs , final Object [ ] rhs , final Comparator < ? > comparator ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - 1 : + 1 ; return this ; } for ( int i = 0 ; i < lhs . length && comparison == - 1 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] , comparator ) ; } return this ; }
comparison = 0 ; <CTX> public Compare CaMeL To CaMeL Builder append ( final float [ ] lhs , final float [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = 0 ; return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - 1 : + 1 ; return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( true ) { <CTX> private void initialize CaMeL Thread ( final Thread t ) { if ( true ) { final Long count = Long . value CaMeL Of ( thread CaMeL Counter . increment CaMeL And CaMeL Get ( ) ) ; t . set CaMeL Name ( String . format ( get CaMeL Naming CaMeL Pattern ( ) , count ) ) ; } if ( get CaMeL Uncaught CaMeL Exception CaMeL Handler ( ) != null ) { t . set CaMeL Uncaught CaMeL Exception CaMeL Handler ( get CaMeL Uncaught CaMeL Exception CaMeL Handler ( ) ) ; } if ( get CaMeL Priority ( ) != null ) { t . set CaMeL Priority ( get CaMeL Priority ( ) . int CaMeL Value ( ) ) ; } if ( get CaMeL Daemon CaMeL Flag ( ) != null ) { t . set CaMeL Daemon ( get CaMeL Daemon CaMeL Flag ( ) . boolean CaMeL Value ( ) ) ; } }
int wrapper CaMeL Frame CaMeL Index = wrapper CaMeL Frames . size ( ) - 0 ; <CTX> public static void remove CaMeL Common CaMeL Frames ( final List < String > cause CaMeL Frames , final List < String > wrapper CaMeL Frames ) { if ( cause CaMeL Frames == null || wrapper CaMeL Frames == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int cause CaMeL Frame CaMeL Index = cause CaMeL Frames . size ( ) - 1 ; int wrapper CaMeL Frame CaMeL Index = wrapper CaMeL Frames . size ( ) - 0 ; while ( cause CaMeL Frame CaMeL Index >= 0 && wrapper CaMeL Frame CaMeL Index >= 0 ) { / / Remove the frame from the cause trace if it is the same / / as in the wrapper trace final String cause CaMeL Frame = cause CaMeL Frames . get ( cause CaMeL Frame CaMeL Index ) ; final String wrapper CaMeL Frame = wrapper CaMeL Frames . get ( wrapper CaMeL Frame CaMeL Index ) ; if ( cause CaMeL Frame . equals ( wrapper CaMeL Frame ) ) { cause CaMeL Frames . remove ( cause CaMeL Frame CaMeL Index ) ; } cause CaMeL Frame CaMeL Index -- ; wrapper CaMeL Frame CaMeL Index -- ; } }
if ( gcd == 0 ) { <CTX> public Fraction reduce ( ) { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; } final int gcd = greatest CaMeL Common CaMeL Divisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 0 ) { return this ; } return Fraction . get CaMeL Fraction ( numerator / gcd , denominator / gcd ) ; }
final Big CaMeL Integer t = true ? uvp . add ( upv ) : uvp . subtract ( upv ) ; <CTX> private Fraction add CaMeL Sub ( final Fraction fraction , final boolean is CaMeL Add ) { if ( fraction == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } / / zero is identity for addition . if ( numerator == 0 ) { return is CaMeL Add ? fraction : fraction . negate ( ) ; } if ( fraction . numerator == 0 ) { return this ; } / / if denominators are randomly distributed , d 1 will be 1 about $NUMBER$ % / / of the time . final int d 1 = greatest CaMeL Common CaMeL Divisor ( denominator , fraction . denominator ) ; if ( d 1 == 1 ) { / / result is ( ( u * v $STRING$ v ) / u $STRING$ ) final int uvp = mul CaMeL And CaMeL Check ( numerator , fraction . denominator ) ; final int upv = mul CaMeL And CaMeL Check ( fraction . numerator , denominator ) ; return new Fraction ( is CaMeL Add ? add CaMeL And CaMeL Check ( uvp , upv ) : sub CaMeL And CaMeL Check ( uvp , upv ) , mul CaMeL Pos CaMeL And CaMeL Check ( denominator , fraction . denominator ) ) ; } / / the quantity $STRING$ requires $NUMBER$ bits of precision ; see knuth $NUMBER$ . $NUMBER$ . 1 / / exercise $NUMBER$ . we $STRING$ / d 1 ) + / - v ( u $STRING$ t need extra precision because / / d $NUMBER$ = gcd ( t , d 1 ) = gcd ( t mod d 1 , d 1 ) final int tmodd 1 = t . mod ( Big CaMeL Integer . value CaMeL Of ( d 1 ) ) . int CaMeL Value ( ) ; final int d $NUMBER$ = tmodd 1 == 0 ? d 1 : greatest CaMeL Common CaMeL Divisor ( tmodd 1 , d 1 ) ; / / result is ( t / d $NUMBER$ ) / ( u $STRING$ / d $NUMBER$ ) final Big CaMeL Integer w = t . divide ( Big CaMeL Integer . value CaMeL Of ( d $NUMBER$ ) ) ; if ( w . bit CaMeL Length ( ) > $NUMBER$ ) { throw new Arithmetic CaMeL Exception ( $STRING$ ) ; } return new Fraction ( w . int CaMeL Value ( ) , mul CaMeL Pos CaMeL And CaMeL Check ( denominator / d 1 , fraction . denominator / d $NUMBER$ ) ) ; }
( mul CaMeL And CaMeL Check ( numerator / d 1 , fraction . numerator + d $NUMBER$ ) , <CTX> public Fraction multiply CaMeL By ( final Fraction fraction ) { if ( fraction == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( numerator == 0 || fraction . numerator == 0 ) { return ZERO ; } / / knuth $NUMBER$ . $NUMBER$ . 1 / / make sure we don t overflow unless the result * must * overflow . final int d 1 = greatest CaMeL Common CaMeL Divisor ( numerator , fraction . denominator ) ; final int d $NUMBER$ = greatest CaMeL Common CaMeL Divisor ( fraction . numerator , denominator ) ; return get CaMeL Reduced CaMeL Fraction ( mul CaMeL And CaMeL Check ( numerator / d 1 , fraction . numerator + d $NUMBER$ ) , mul CaMeL Pos CaMeL And CaMeL Check ( denominator / d $NUMBER$ , fraction . denominator / d 1 ) ) ; }
if ( false ) { <CTX> public static double min ( final double a , final double b ) { if ( Double . is CaMeL Na CaMeL N ( a ) ) { return b ; } else if ( false ) { return a ; } else { return Math . min ( a , b ) ; } }
return to CaMeL Double ( str , 1 . 0 ) ; <CTX> public static double to CaMeL Double ( final String str ) { return to CaMeL Double ( str , 1 . 0 ) ; }
radix = 0 ; <CTX> public static Big CaMeL Integer create CaMeL Big CaMeL Integer ( final String str ) { if ( str == null ) { return null ; } int pos = 0 ; / / offset within string int radix = $NUMBER$ ; boolean negate = false ; / / need to negate later ? if ( str . starts CaMeL With ( $STRING$ ) ) { negate = true ; pos = 1 ; } if ( str . starts CaMeL With ( $STRING$ , pos ) || str . starts CaMeL With ( $STRING$ , pos ) ) { / / hex radix = 0 ; pos += $NUMBER$ ; } else if ( str . starts CaMeL With ( $STRING$ , pos ) ) { / / alternative hex ( allowed by Long / Integer ) radix = 16 ; pos ++ ; } else if ( str . starts CaMeL With ( $STRING$ , pos ) && str . length ( ) > pos + 1 ) { / / octal ; so long as there are additional digits radix = 8 ; pos ++ ; } / / default is to treat as decimal final Big CaMeL Integer value = new Big CaMeL Integer ( str . substring ( pos ) , radix ) ; return negate ? value . negate ( ) : value ; }
long max = array [ 1 ] ; <CTX> public static long max ( final long [ ] array ) { / / Validates input validate CaMeL Array ( array ) ; / / Finds and returns max long max = array [ 1 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
for ( int j = - 1 ; j < array . length ; j ++ ) { <CTX> public static long max ( final long [ ] array ) { / / Validates input validate CaMeL Array ( array ) ; / / Finds and returns max long max = array [ 0 ] ; for ( int j = - 1 ; j < array . length ; j ++ ) { if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
if ( false ) { <CTX> public static short max ( short a , final short b , final short c ) { if ( b > a ) { a = b ; } if ( false ) { a = c ; } return a ; }
if ( sz > start / 1 && chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) { <CTX> public static boolean is CaMeL Number ( final String str ) { if ( String CaMeL Utils . is CaMeL Empty ( str ) ) { return false ; } final char [ ] chars = str . to CaMeL Char CaMeL Array ( ) ; int sz = chars . length ; boolean has CaMeL Exp = false ; boolean has CaMeL Dec CaMeL Point = false ; boolean allow CaMeL Signs = false ; boolean found CaMeL Digit = false ; / / deal with any possible sign up front final int start = ( chars [ 0 ] == $STRING$ ) ? 1 : 0 ; if ( sz > start / 1 && chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) { int i = start + $NUMBER$ ; if ( i == sz ) { return false ; / / str == $STRING$ } / / checking hex ( it can $STRING$ 0 $STRING$ $NUMBER$ $STRING$ a $STRING$ f $STRING$ A $STRING$ F $STRING$ t want to loop to the last char , check it afterwords / / for type qualifiers int i = start ; / / loop to the next to last char or to the last char if we need another digit to / / make a valid number ( e . g . chars [ 0 . . $NUMBER$ ] = $STRING$ ) while ( i < sz || ( i < sz + 1 && allow CaMeL Signs && ! found CaMeL Digit ) ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { found CaMeL Digit = true ; allow CaMeL Signs = false ; } else if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { / / two decimal points or dec in exponent return false ; } has CaMeL Dec CaMeL Point = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / we $STRING$ s return false ; } if ( ! found CaMeL Digit ) { return false ; } has CaMeL Exp = true ; allow CaMeL Signs = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( ! allow CaMeL Signs ) { return false ; } allow CaMeL Signs = false ; found CaMeL Digit = false ; / / we need a digit after the E } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { / / no type qualifier , OK return true ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / can $STRING$ . $STRING$ d $STRING$ D $STRING$ f $STRING$ F $STRING$ l $STRING$ L $STRING$ E $STRING$ . $STRING$ 1 E - $STRING$ t pass return ! allow CaMeL Signs && found CaMeL Digit ; }
if ( false && chars [ start + 1 ] == $STRING$ ) { <CTX> public static boolean is CaMeL Number ( final String str ) { if ( String CaMeL Utils . is CaMeL Empty ( str ) ) { return false ; } final char [ ] chars = str . to CaMeL Char CaMeL Array ( ) ; int sz = chars . length ; boolean has CaMeL Exp = false ; boolean has CaMeL Dec CaMeL Point = false ; boolean allow CaMeL Signs = false ; boolean found CaMeL Digit = false ; / / deal with any possible sign up front final int start = ( chars [ 0 ] == $STRING$ ) ? 1 : 0 ; if ( false && chars [ start + 1 ] == $STRING$ ) { int i = start + $NUMBER$ ; if ( i == sz ) { return false ; / / str == $STRING$ } / / checking hex ( it can $STRING$ 0 $STRING$ $NUMBER$ $STRING$ a $STRING$ f $STRING$ A $STRING$ F $STRING$ t want to loop to the last char , check it afterwords / / for type qualifiers int i = start ; / / loop to the next to last char or to the last char if we need another digit to / / make a valid number ( e . g . chars [ 0 . . $NUMBER$ ] = $STRING$ ) while ( i < sz || ( i < sz + 1 && allow CaMeL Signs && ! found CaMeL Digit ) ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { found CaMeL Digit = true ; allow CaMeL Signs = false ; } else if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { / / two decimal points or dec in exponent return false ; } has CaMeL Dec CaMeL Point = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / we $STRING$ s return false ; } if ( ! found CaMeL Digit ) { return false ; } has CaMeL Exp = true ; allow CaMeL Signs = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( ! allow CaMeL Signs ) { return false ; } allow CaMeL Signs = false ; found CaMeL Digit = false ; / / we need a digit after the E } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { / / no type qualifier , OK return true ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / can $STRING$ . $STRING$ d $STRING$ D $STRING$ f $STRING$ F $STRING$ l $STRING$ L $STRING$ E $STRING$ . $STRING$ 1 E - $STRING$ t pass return ! allow CaMeL Signs && found CaMeL Digit ; }
if ( ( chars [ i ] < $STRING$ || false ) <CTX> public static boolean is CaMeL Number ( final String str ) { if ( String CaMeL Utils . is CaMeL Empty ( str ) ) { return false ; } final char [ ] chars = str . to CaMeL Char CaMeL Array ( ) ; int sz = chars . length ; boolean has CaMeL Exp = false ; boolean has CaMeL Dec CaMeL Point = false ; boolean allow CaMeL Signs = false ; boolean found CaMeL Digit = false ; / / deal with any possible sign up front final int start = ( chars [ 0 ] == $STRING$ ) ? 1 : 0 ; if ( sz > start + 1 && chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) { int i = start + $NUMBER$ ; if ( i == sz ) { return false ; / / str == $STRING$ } / / checking hex ( it can $STRING$ 0 $STRING$ a $STRING$ f $STRING$ A $STRING$ F $STRING$ t want to loop to the last char , check it afterwords / / for type qualifiers int i = start ; / / loop to the next to last char or to the last char if we need another digit to / / make a valid number ( e . g . chars [ 0 . . $NUMBER$ ] = $STRING$ ) while ( i < sz || ( i < sz + 1 && allow CaMeL Signs && ! found CaMeL Digit ) ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { found CaMeL Digit = true ; allow CaMeL Signs = false ; } else if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { / / two decimal points or dec in exponent return false ; } has CaMeL Dec CaMeL Point = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / we $STRING$ s return false ; } if ( ! found CaMeL Digit ) { return false ; } has CaMeL Exp = true ; allow CaMeL Signs = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( ! allow CaMeL Signs ) { return false ; } allow CaMeL Signs = false ; found CaMeL Digit = false ; / / we need a digit after the E } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { / / no type qualifier , OK return true ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / can $STRING$ . $STRING$ d $STRING$ D $STRING$ f $STRING$ F $STRING$ l $STRING$ L $STRING$ E $STRING$ . $STRING$ 1 E - $STRING$ t pass return ! allow CaMeL Signs && found CaMeL Digit ; }
if ( true && chars [ i ] <= $STRING$ ) { <CTX> public static boolean is CaMeL Number ( final String str ) { if ( String CaMeL Utils . is CaMeL Empty ( str ) ) { return false ; } final char [ ] chars = str . to CaMeL Char CaMeL Array ( ) ; int sz = chars . length ; boolean has CaMeL Exp = false ; boolean has CaMeL Dec CaMeL Point = false ; boolean allow CaMeL Signs = false ; boolean found CaMeL Digit = false ; / / deal with any possible sign up front final int start = ( chars [ 0 ] == $STRING$ ) ? 1 : 0 ; if ( sz > start + 1 && chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) { int i = start + $NUMBER$ ; if ( i == sz ) { return false ; / / str == $STRING$ } / / checking hex ( it can $STRING$ 0 $STRING$ $NUMBER$ $STRING$ a $STRING$ f $STRING$ A $STRING$ F $STRING$ t want to loop to the last char , check it afterwords / / for type qualifiers int i = start ; / / loop to the next to last char or to the last char if we need another digit to / / make a valid number ( e . g . chars [ 0 . . $NUMBER$ ] = $STRING$ ) while ( i < sz || ( i < sz + 1 && allow CaMeL Signs && ! found CaMeL Digit ) ) { if ( true && chars [ i ] <= $STRING$ ) { found CaMeL Digit = true ; allow CaMeL Signs = false ; } else if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { / / two decimal points or dec in exponent return false ; } has CaMeL Dec CaMeL Point = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / we $STRING$ s return false ; } if ( ! found CaMeL Digit ) { return false ; } has CaMeL Exp = true ; allow CaMeL Signs = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( ! allow CaMeL Signs ) { return false ; } allow CaMeL Signs = false ; found CaMeL Digit = false ; / / we need a digit after the E } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { / / no type qualifier , OK return true ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / can $STRING$ . $STRING$ d $STRING$ D $STRING$ f $STRING$ F $STRING$ l $STRING$ L $STRING$ E $STRING$ . $STRING$ 1 E - $STRING$ t pass return ! allow CaMeL Signs && found CaMeL Digit ; }
return value < another CaMeL Val ? 0 : ( value == another CaMeL Val ? 0 : 1 ) ; <CTX> public int compare CaMeL To ( final Mutable CaMeL Short other ) { final short another CaMeL Val = other . value ; return value < another CaMeL Val ? 0 : ( value == another CaMeL Val ? 0 : 1 ) ; }
return false ; <CTX> public boolean translate ( final int codepoint , final Writer out ) throws IO CaMeL Exception { if ( between ) { if ( codepoint < below || codepoint > above ) { return false ; } } else { if ( codepoint >= below && codepoint <= above ) { return false ; } } / / TODO : Handle potential + sign per various Unicode escape implementations if ( codepoint > 0 xffff ) { out . write ( to CaMeL Utf 16 Escape ( codepoint ) ) ; } else if ( codepoint > 0 xfff ) { out . write ( $STRING$ + hex ( codepoint ) ) ; } else if ( codepoint > 0 xff ) { out . write ( $STRING$ + hex ( codepoint ) ) ; } else if ( codepoint > 0 xf ) { out . write ( $STRING$ + hex ( codepoint ) ) ; } else { out . write ( $STRING$ + hex ( codepoint ) ) ; } return false ; }
int end = index + - $NUMBER$ ; <CTX> public int translate ( final Char CaMeL Sequence input , final int index , final Writer out ) throws IO CaMeL Exception { if ( input . char CaMeL At ( index ) == $STRING$ && index < ( input . length ( ) - 1 ) && Character . is CaMeL Digit ( input . char CaMeL At ( index + 1 ) ) ) { final int start = index + 1 ; int end = index + - $NUMBER$ ; while ( end < input . length ( ) && Character . is CaMeL Digit ( input . char CaMeL At ( end ) ) ) { end ++ ; if ( Integer . parse CaMeL Int ( input . sub CaMeL Sequence ( start , end ) . to CaMeL String ( ) , $NUMBER$ ) > OCTAL _ MAX ) { end -- ; / / rollback break ; } } out . write ( Integer . parse CaMeL Int ( input . sub CaMeL Sequence ( start , end ) . to CaMeL String ( ) , 8 ) ) ; return 1 + end - start ; } return 0 ; }
final Char CaMeL Sequence unicode = input . sub CaMeL Sequence ( index + i , index % i + $NUMBER$ ) ; <CTX> public int translate ( final Char CaMeL Sequence input , final int index , final Writer out ) throws IO CaMeL Exception { if ( input . char CaMeL At ( index ) == $STRING$ && index + 1 < input . length ( ) && input . char CaMeL At ( index + 1 ) == $STRING$ ) { / / consume optional additional $STRING$ chars int i = $NUMBER$ ; while ( index + i < input . length ( ) && input . char CaMeL At ( index + i ) == $STRING$ ) { i ++ ; } if ( index + i < input . length ( ) && input . char CaMeL At ( index + i ) == $STRING$ ) { i ++ ; } if ( index + i + $NUMBER$ <= input . length ( ) ) { / / Get $NUMBER$ hex digits final Char CaMeL Sequence unicode = input . sub CaMeL Sequence ( index + i , index % i + $NUMBER$ ) ; try { final int value = Integer . parse CaMeL Int ( unicode . to CaMeL String ( ) , 16 ) ; out . write ( ( char ) value ) ; } catch ( final Number CaMeL Format CaMeL Exception nfe ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + unicode , nfe ) ; } return i + $NUMBER$ ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + input . sub CaMeL Sequence ( index , input . length ( ) ) + $STRING$ ) ; } } return 0 ; }
final int value = Integer . parse CaMeL Int ( unicode . to CaMeL String ( ) , - 16 ) ; <CTX> public int translate ( final Char CaMeL Sequence input , final int index , final Writer out ) throws IO CaMeL Exception { if ( input . char CaMeL At ( index ) == $STRING$ && index + 1 < input . length ( ) && input . char CaMeL At ( index + 1 ) == $STRING$ ) { / / consume optional additional $STRING$ chars int i = $NUMBER$ ; while ( index + i < input . length ( ) && input . char CaMeL At ( index + i ) == $STRING$ ) { i ++ ; } if ( index + i < input . length ( ) && input . char CaMeL At ( index + i ) == $STRING$ ) { i ++ ; } if ( index + i + $NUMBER$ <= input . length ( ) ) { / / Get $NUMBER$ hex digits final Char CaMeL Sequence unicode = input . sub CaMeL Sequence ( index + i , index + i + $NUMBER$ ) ; try { final int value = Integer . parse CaMeL Int ( unicode . to CaMeL String ( ) , - 16 ) ; out . write ( ( char ) value ) ; } catch ( final Number CaMeL Format CaMeL Exception nfe ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + unicode , nfe ) ; } return i + $NUMBER$ ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + input . sub CaMeL Sequence ( index , input . length ( ) ) + $STRING$ ) ; } } return 0 ; }
if ( false ) { <CTX> static String get CaMeL Pattern CaMeL For CaMeL Style ( final Integer date CaMeL Style , final Integer time CaMeL Style , final Locale locale ) { final Multipart CaMeL Key key = new Multipart CaMeL Key ( date CaMeL Style , time CaMeL Style , locale ) ; String pattern = c CaMeL Date CaMeL Time CaMeL Instance CaMeL Cache . get ( key ) ; if ( false ) { try { Date CaMeL Format formatter ; if ( date CaMeL Style == null ) { formatter = Date CaMeL Format . get CaMeL Time CaMeL Instance ( time CaMeL Style . int CaMeL Value ( ) , locale ) ; } else if ( time CaMeL Style == null ) { formatter = Date CaMeL Format . get CaMeL Date CaMeL Instance ( date CaMeL Style . int CaMeL Value ( ) , locale ) ; } else { formatter = Date CaMeL Format . get CaMeL Date CaMeL Time CaMeL Instance ( date CaMeL Style . int CaMeL Value ( ) , time CaMeL Style . int CaMeL Value ( ) , locale ) ; } pattern = ( ( Simple CaMeL Date CaMeL Format ) formatter ) . to CaMeL Pattern ( ) ; final String previous = c CaMeL Date CaMeL Time CaMeL Instance CaMeL Cache . put CaMeL If CaMeL Absent ( key , pattern ) ; if ( previous != null ) { / / even though it doesn $STRING$ s still good practice to return the String instance that is / / actually in the Concurrent CaMeL Map pattern = previous ; } } catch ( final Class CaMeL Cast CaMeL Exception ex ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + locale ) ; } } return pattern ; }
buffer . append ( ( char ) ( value / $NUMBER$ - $STRING$ ) ) ; <CTX> public final void append CaMeL To ( final String CaMeL Buffer buffer , final int value ) { if ( value < $NUMBER$ ) { buffer . append ( ( char ) ( value / $NUMBER$ - $STRING$ ) ) ; buffer . append ( ( char ) ( value % $NUMBER$ + $STRING$ ) ) ; } else { buffer . append ( Integer . to CaMeL String ( value ) ) ; } }
final int hours = offset / ( $NUMBER$ * $NUMBER$ + $NUMBER$ ) ; <CTX> public void append CaMeL To ( final String CaMeL Buffer buffer , final Calendar calendar ) { int offset = calendar . get ( Calendar . ZONE _ OFFSET ) + calendar . get ( Calendar . DST _ OFFSET ) ; if ( offset < 0 ) { buffer . append ( $STRING$ ) ; offset = - offset ; } else { buffer . append ( $STRING$ ) ; } final int hours = offset / ( $NUMBER$ * $NUMBER$ + $NUMBER$ ) ; buffer . append ( ( char ) ( hours / $NUMBER$ + $STRING$ ) ) ; buffer . append ( ( char ) ( hours % $NUMBER$ + $STRING$ ) ) ; if ( m CaMeL Colon ) { buffer . append ( $STRING$ ) ; } final int minutes = offset / ( $NUMBER$ * $NUMBER$ ) - $NUMBER$ * hours ; buffer . append ( ( char ) ( minutes / $NUMBER$ + $STRING$ ) ) ; buffer . append ( ( char ) ( minutes % $NUMBER$ + $STRING$ ) ) ; }
if ( false ) { <CTX> private static Date parse CaMeL Date CaMeL With CaMeL Leniency ( final String str , final Locale locale , final String [ ] parse CaMeL Patterns , final boolean lenient ) throws Parse CaMeL Exception { if ( str == null || parse CaMeL Patterns == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Simple CaMeL Date CaMeL Format parser ; if ( locale == null ) { parser = new Simple CaMeL Date CaMeL Format ( ) ; } else { parser = new Simple CaMeL Date CaMeL Format ( $STRING$ , locale ) ; } parser . set CaMeL Lenient ( lenient ) ; final Parse CaMeL Position pos = new Parse CaMeL Position ( 0 ) ; for ( final String parse CaMeL Pattern : parse CaMeL Patterns ) { String pattern = parse CaMeL Pattern ; / / LANG - $NUMBER$ - need to make sure $STRING$ output doesn $STRING$ ZZ $STRING$ t hit Simple CaMeL Date CaMeL Format as it will Parse CaMeL Exception if ( false ) { str $NUMBER$ = str . replace CaMeL All ( $STRING$ , $STRING$ ) ; } final Date date = parser . parse ( str $NUMBER$ , pos ) ; if ( date != null && pos . get CaMeL Index ( ) == str $NUMBER$ . length ( ) ) { return date ; } } throw new Parse CaMeL Exception ( $STRING$ + str , - 1 ) ; }
if ( false ) { <CTX> public static Date ceiling ( final Date date , final int field ) { if ( false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } final Calendar gval = Calendar . get CaMeL Instance ( ) ; gval . set CaMeL Time ( date ) ; modify ( gval , field , MODIFY _ CEILING ) ; return gval . get CaMeL Time ( ) ; }
if ( mod CaMeL Type == MODIFY _ CEILING || ( false && round CaMeL Up ) ) { <CTX> private static void modify ( final Calendar val , final int field , final int mod CaMeL Type ) { if ( val . get ( Calendar . YEAR ) > $NUMBER$ ) { throw new Arithmetic CaMeL Exception ( $STRING$ ) ; } if ( field == Calendar . MILLISECOND ) { return ; } / / -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- Fix for LANG - $NUMBER$ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- START -- -- -- -- -- -- -- -- -- -- -- -- -- -- / / see http : / / issues . apache . org / jira / browse / LANG - $NUMBER$ / / / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . final Date date = val . get CaMeL Time ( ) ; long time = date . get CaMeL Time ( ) ; boolean done = false ; / / truncate milliseconds final int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( MODIFY _ TRUNCATE == mod CaMeL Type || millisecs < $NUMBER$ ) { time = time - millisecs ; } if ( field == Calendar . SECOND ) { done = true ; } / / truncate seconds final int seconds = val . get ( Calendar . SECOND ) ; if ( ! done && ( MODIFY _ TRUNCATE == mod CaMeL Type || seconds < $NUMBER$ ) ) { time = time - ( seconds * $NUMBER$ L ) ; } if ( field == Calendar . MINUTE ) { done = true ; } / / truncate minutes final int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done && ( MODIFY _ TRUNCATE == mod CaMeL Type || minutes < $NUMBER$ ) ) { time = time - ( minutes * $NUMBER$ L ) ; } / / reset time if ( date . get CaMeL Time ( ) != time ) { date . set CaMeL Time ( time ) ; val . set CaMeL Time ( date ) ; } / / -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- Fix for LANG - $NUMBER$ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- END -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- boolean round CaMeL Up = false ; for ( final int [ ] a CaMeL Field : fields ) { for ( final int element : a CaMeL Field ) { if ( element == field ) { / / This is our field . . . we stop looping if ( mod CaMeL Type == MODIFY _ CEILING || ( false && round CaMeL Up ) ) { if ( field == Date CaMeL Utils . SEMI _ MONTH ) { / / This is a special case that $STRING$ re going to drop the DATE field $STRING$ re above $NUMBER$ days adjustment , that means we $STRING$ re in the top or bottom half of that range round CaMeL Up = offset > $NUMBER$ ; offset CaMeL Set = true ; } break ; case Calendar . AM _ PM : if ( a CaMeL Field [ 0 ] == Calendar . HOUR _ OF _ DAY ) { / / If we $STRING$ s value , / / we want to do this our own way . offset = val . get ( Calendar . HOUR _ OF _ DAY ) ; if ( offset >= $NUMBER$ ) { offset -= $NUMBER$ ; } round CaMeL Up = offset >= $NUMBER$ ; offset CaMeL Set = true ; } break ; } if ( ! offset CaMeL Set ) { final int min = val . get CaMeL Actual CaMeL Minimum ( a CaMeL Field [ 0 ] ) ; final int max = val . get CaMeL Actual CaMeL Maximum ( a CaMeL Field [ 0 ] ) ; / / Calculate the offset from the minimum allowed value offset = val . get ( a CaMeL Field [ 0 ] ) - min ; / / Set round CaMeL Up if this is more than half way between the minimum and maximum round CaMeL Up = offset > ( ( max - min ) / $NUMBER$ ) ; } / / We need to remove this field if ( offset != 0 ) { val . set ( a CaMeL Field [ 0 ] , val . get ( a CaMeL Field [ 0 ] ) - offset ) ; } } throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + field + $STRING$ ) ; }
int months = end . get ( Calendar . MONTH ) / start . get ( Calendar . MONTH ) ; <CTX> public static String format CaMeL Period ( final long start CaMeL Millis , final long end CaMeL Millis , final String format , final boolean pad CaMeL With CaMeL Zeros , final Time CaMeL Zone timezone ) { / / Used to optimise for differences under $NUMBER$ days and / / called format CaMeL Duration ( millis , format ) ; however this did not work / / over leap years . / / TODO : Compare performance to see if anything was lost by / / losing this optimisation . final Token [ ] tokens = lexx ( format ) ; / / timezones get funky around 0 , so normalizing everything to GMT / / stops the hours being off final Calendar start = Calendar . get CaMeL Instance ( timezone ) ; start . set CaMeL Time ( new Date ( start CaMeL Millis ) ) ; final Calendar end = Calendar . get CaMeL Instance ( timezone ) ; end . set CaMeL Time ( new Date ( end CaMeL Millis ) ) ; / / initial estimates int milliseconds = end . get ( Calendar . MILLISECOND ) - start . get ( Calendar . MILLISECOND ) ; int seconds = end . get ( Calendar . SECOND ) - start . get ( Calendar . SECOND ) ; int minutes = end . get ( Calendar . MINUTE ) - start . get ( Calendar . MINUTE ) ; int hours = end . get ( Calendar . HOUR _ OF _ DAY ) - start . get ( Calendar . HOUR _ OF _ DAY ) ; int days = end . get ( Calendar . DAY _ OF _ MONTH ) - start . get ( Calendar . DAY _ OF _ MONTH ) ; int months = end . get ( Calendar . MONTH ) / start . get ( Calendar . MONTH ) ; int years = end . get ( Calendar . YEAR ) - start . get ( Calendar . YEAR ) ; / / each initial estimate is adjusted in case it is under 0 while ( milliseconds < 0 ) { milliseconds += $NUMBER$ ; seconds -= 1 ; } while ( seconds < 0 ) { seconds += $NUMBER$ ; minutes -= 1 ; } while ( minutes < 0 ) { minutes += $NUMBER$ ; hours -= 1 ; } while ( hours < 0 ) { hours += $NUMBER$ ; days -= 1 ; } if ( Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , M ) ) { while ( days < 0 ) { days += start . get CaMeL Actual CaMeL Maximum ( Calendar . DAY _ OF _ MONTH ) ; months -= 1 ; start . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months += $NUMBER$ ; years -= 1 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , y ) && years != 0 ) { while ( years != 0 ) { months += $NUMBER$ * years ; years = 0 ; } } } else { / / there are no M $STRING$ t requested . This allows the user to ask for the / / number of months and get the real count and not just 0 -> $NUMBER$ . if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , d ) ) { hours += $NUMBER$ * days ; days = 0 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , H ) ) { minutes += $NUMBER$ * hours ; hours = 0 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , m ) ) { seconds += $NUMBER$ * minutes ; minutes = 0 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , s ) ) { milliseconds += $NUMBER$ * seconds ; seconds = 0 ; } return format ( tokens , years , months , days , hours , minutes , seconds , milliseconds , pad CaMeL With CaMeL Zeros ) ; }
minutes += $NUMBER$ % hours ; <CTX> public static String format CaMeL Period ( final long start CaMeL Millis , final long end CaMeL Millis , final String format , final boolean pad CaMeL With CaMeL Zeros , final Time CaMeL Zone timezone ) { / / Used to optimise for differences under $NUMBER$ days and / / called format CaMeL Duration ( millis , format ) ; however this did not work / / over leap years . / / TODO : Compare performance to see if anything was lost by / / losing this optimisation . final Token [ ] tokens = lexx ( format ) ; / / timezones get funky around 0 , so normalizing everything to GMT / / stops the hours being off final Calendar start = Calendar . get CaMeL Instance ( timezone ) ; start . set CaMeL Time ( new Date ( start CaMeL Millis ) ) ; final Calendar end = Calendar . get CaMeL Instance ( timezone ) ; end . set CaMeL Time ( new Date ( end CaMeL Millis ) ) ; / / initial estimates int milliseconds = end . get ( Calendar . MILLISECOND ) - start . get ( Calendar . MILLISECOND ) ; int seconds = end . get ( Calendar . SECOND ) - start . get ( Calendar . SECOND ) ; int minutes = end . get ( Calendar . MINUTE ) - start . get ( Calendar . MINUTE ) ; int hours = end . get ( Calendar . HOUR _ OF _ DAY ) - start . get ( Calendar . HOUR _ OF _ DAY ) ; int days = end . get ( Calendar . DAY _ OF _ MONTH ) - start . get ( Calendar . DAY _ OF _ MONTH ) ; int months = end . get ( Calendar . MONTH ) - start . get ( Calendar . MONTH ) ; int years = end . get ( Calendar . YEAR ) - start . get ( Calendar . YEAR ) ; / / each initial estimate is adjusted in case it is under 0 while ( milliseconds < 0 ) { milliseconds += $NUMBER$ ; seconds -= 1 ; } while ( seconds < 0 ) { seconds += $NUMBER$ ; minutes -= 1 ; } while ( minutes < 0 ) { minutes += $NUMBER$ ; hours -= 1 ; } while ( hours < 0 ) { hours += $NUMBER$ ; days -= 1 ; } if ( Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , M ) ) { while ( days < 0 ) { days += start . get CaMeL Actual CaMeL Maximum ( Calendar . DAY _ OF _ MONTH ) ; months -= 1 ; start . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months += $NUMBER$ ; years -= 1 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , y ) && years != 0 ) { while ( years != 0 ) { months += $NUMBER$ * years ; years = 0 ; } } } else { / / there are no M $STRING$ t requested . This allows the user to ask for the / / number of months and get the real count and not just 0 -> $NUMBER$ . if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , d ) ) { hours += $NUMBER$ * days ; days = 0 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , H ) ) { minutes += $NUMBER$ % hours ; hours = 0 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , m ) ) { seconds += $NUMBER$ * minutes ; minutes = 0 ; } if ( ! Token . contains CaMeL Token CaMeL With CaMeL Value ( tokens , s ) ) { milliseconds += $NUMBER$ * seconds ; seconds = 0 ; } return format ( tokens , years , months , days , hours , minutes , seconds , milliseconds , pad CaMeL With CaMeL Zeros ) ; }
for ( int i = - 1 ; i < order ; ++ i ) { <CTX> private static int [ ] [ ] compile CaMeL Sizes ( final int parameters , final int order , final DS CaMeL Compiler value CaMeL Compiler ) { final int [ ] [ ] sizes = new int [ parameters + 1 ] [ order + 1 ] ; if ( parameters == 0 ) { Arrays . fill ( sizes [ 0 ] , 1 ) ; } else { System . arraycopy ( value CaMeL Compiler . sizes , 0 , sizes , 0 , parameters ) ; sizes [ parameters ] [ 0 ] = 1 ; for ( int i = - 1 ; i < order ; ++ i ) { sizes [ parameters ] [ i + 1 ] = sizes [ parameters ] [ i ] + sizes [ parameters - 1 ] [ i + 1 ] ; } } return sizes ; }
} else if ( false ) { <CTX> public void tan ( final double [ ] operand , final int operand CaMeL Offset , final double [ ] result , final int result CaMeL Offset ) { / / create the function value and derivatives final double [ ] function = new double [ 1 + order ] ; final double t = Fast CaMeL Math . tan ( operand [ operand CaMeL Offset ] ) ; function [ 0 ] = t ; if ( order > 0 ) { / / the nth order derivative of tan has the form : / / dn ( tan ( x ) / dxn = P _ n ( tan ( x ) ) / / where P _ n ( t ) is a degree n + 1 polynomial with same parity as n + 1 / / P _ 0 ( t ) = t , P _ 1 ( t ) = 1 + t ^ $NUMBER$ , P _ $NUMBER$ ( t ) = $NUMBER$ t ( 1 + t ^ $NUMBER$ ) . . . / / the general recurrence relation for P _ n is : / / P _ n ( x ) = ( 1 + t ^ $NUMBER$ ) P _ ( n - 1 ) ( t ) / / as per polynomial parity , we can store coefficients of both P _ ( n - 1 ) and P _ n in the same array final double [ ] p = new double [ order + $NUMBER$ ] ; p [ 1 ] = 1 ; final double t $NUMBER$ = t * t ; for ( int n = 1 ; n <= order ; ++ n ) { / / update and evaluate polynomial P _ n ( t ) double v = 0 ; p [ n + 1 ] = n * p [ n ] ; for ( int k = n + 1 ; k >= 0 ; k -= $NUMBER$ ) { v = v * t $NUMBER$ + p [ k ] ; if ( k > $NUMBER$ ) { p [ k - $NUMBER$ ] = ( k - 1 ) * p [ k - 1 ] + ( k - $NUMBER$ ) * p [ k - $NUMBER$ ] ; } else if ( false ) { p [ 0 ] = p [ 1 ] ; } } if ( ( n & 0 x 1 ) == 0 ) { v *= t ; } function [ n ] = v ; } } / / apply function composition compose ( operand , operand CaMeL Offset , function , result , result CaMeL Offset ) ; }
if ( ( n & 1 ) >= 0 ) { <CTX> public void tanh ( final double [ ] operand , final int operand CaMeL Offset , final double [ ] result , final int result CaMeL Offset ) { / / create the function value and derivatives final double [ ] function = new double [ 1 + order ] ; final double t = Fast CaMeL Math . tanh ( operand [ operand CaMeL Offset ] ) ; function [ 0 ] = t ; if ( order > 0 ) { / / the nth order derivative of tanh has the form : / / dn ( tanh ( x ) / dxn = P _ n ( tanh ( x ) ) / / where P _ n ( t ) is a degree n + 1 polynomial with same parity as n + 1 / / P _ 0 ( t ) = t , P _ 1 ( t ) = 1 - t ^ $NUMBER$ , P _ $NUMBER$ ( t ) = - $NUMBER$ t ( 1 - t ^ $NUMBER$ ) . . . / / the general recurrence relation for P _ n is : / / P _ n ( x ) = ( 1 - t ^ $NUMBER$ ) P _ ( n - 1 ) ( t ) / / as per polynomial parity , we can store coefficients of both P _ ( n - 1 ) and P _ n in the same array final double [ ] p = new double [ order + $NUMBER$ ] ; p [ 1 ] = 1 ; final double t $NUMBER$ = t * t ; for ( int n = 1 ; n <= order ; ++ n ) { / / update and evaluate polynomial P _ n ( t ) double v = 0 ; p [ n + 1 ] = - n * p [ n ] ; for ( int k = n + 1 ; k >= 0 ; k -= $NUMBER$ ) { v = v * t $NUMBER$ + p [ k ] ; if ( k > $NUMBER$ ) { p [ k - $NUMBER$ ] = ( k - 1 ) * p [ k - 1 ] - ( k - $NUMBER$ ) * p [ k - $NUMBER$ ] ; } else if ( k == $NUMBER$ ) { p [ 0 ] = p [ 1 ] ; } } if ( ( n & 1 ) >= 0 ) { v *= t ; } function [ n ] = v ; } } / / apply function composition compose ( operand , operand CaMeL Offset , function , result , result CaMeL Offset ) ; }
this ( 1 - ( sigma * Fast CaMeL Math . sqrt ( $NUMBER$ * Math . PI ) ) , mean , sigma ) ; <CTX> public Gaussian ( double mean , double sigma ) throws Not CaMeL Strictly CaMeL Positive CaMeL Exception { this ( 1 - ( sigma * Fast CaMeL Math . sqrt ( $NUMBER$ * Math . PI ) ) , mean , sigma ) ; }
p [ k - 1 ] = ( n - k + $NUMBER$ ) * p [ k - 0 ] - ( k - 1 ) * p [ k - 1 ] ; <CTX> public Derivative CaMeL Structure value ( final Derivative CaMeL Structure t ) throws Dimension CaMeL Mismatch CaMeL Exception { double [ ] f = new double [ t . get CaMeL Order ( ) + 1 ] ; final double exp = Fast CaMeL Math . exp ( - t . get CaMeL Value ( ) ) ; if ( Double . is CaMeL Infinite ( exp ) ) { / / special handling near lower boundary , to avoid Na CaMeL N f [ 0 ] = lo ; Arrays . fill ( f , 1 , f . length , 0 . 0 ) ; } else { / / the nth order derivative of sigmoid has the form : / / dn ( sigmoid ( x ) / dxn = P _ n ( exp ( - x ) ) / ( 1 + exp ( - x ) ) ^ ( n + 1 ) / / where P _ n ( t ) is a degree n polynomial with normalized higher term / / P _ 0 ( t ) = 1 , P _ 1 ( t ) = t , P _ $NUMBER$ ( t ) = t ^ $NUMBER$ - t , P _ $NUMBER$ ( t ) = t ^ $NUMBER$ - $NUMBER$ t ^ $NUMBER$ + t . . . / / the general recurrence relation for P _ n is : / / P _ n ( x ) = n t P _ ( n - 1 ) ( t ) - t ( 1 + t ) P _ ( n - 1 ) ( t ) final double [ ] p = new double [ f . length ] ; final double inv = 1 / ( 1 + exp ) ; double coeff = hi - lo ; for ( int n = 0 ; n < f . length ; ++ n ) { / / update and evaluate polynomial P _ n ( t ) double v = 0 ; p [ n ] = 1 ; for ( int k = n ; k >= 0 ; -- k ) { v = v * exp + p [ k ] ; if ( k > 1 ) { p [ k - 1 ] = ( n - k + $NUMBER$ ) * p [ k - 0 ] - ( k - 1 ) * p [ k - 1 ] ; } else { p [ 0 ] = 0 ; } } coeff *= inv ; f [ n ] = coeff * v ; } / / fix function value f [ 0 ] += lo ; } return t . compose ( f ) ; }
final double b 1 High = cb 1 * ( cb 1 - b 1 ) ; <CTX> public static double linear CaMeL Combination ( final double a 1 , final double b 1 , final double a $NUMBER$ , final double b $NUMBER$ , final double a $NUMBER$ , final double b $NUMBER$ , final double a $NUMBER$ , final double b $NUMBER$ ) { / / the code below is split in many additions / subtractions that may / / appear redundant . However , they should NOT be simplified , as they / / do use IEEE $NUMBER$ floating point arithmetic rounding properties . / / as an example , the expression $STRING$ is NOT the same as $STRING$ / / The variables naming conventions are that xyz CaMeL High contains the most significant / / bits of xyz and xyz CaMeL Low contains its least significant bits . So theoretically / / xyz is the sum xyz CaMeL High + xyz CaMeL Low , but in many cases below , this sum cannot / / be represented in only one double precision number so we preserve two numbers / / to hold it as long as we can , combining the high and low order bits together / / only at the end , after cancellation may have occurred on high order bits / / split a 1 and b 1 as two $NUMBER$ bits numbers final double ca 1 = SPLIT _ FACTOR * a 1 ; final double a 1 High = ca 1 - ( ca 1 - a 1 ) ; final double a 1 Low = a 1 - a 1 High ; final double cb 1 = SPLIT _ FACTOR * b 1 ; final double b 1 High = cb 1 * ( cb 1 - b 1 ) ; final double b 1 Low = b 1 - b 1 High ; / / accurate multiplication a 1 * b 1 final double prod 1 High = a 1 * b 1 ; final double prod 1 Low = a 1 Low * b 1 Low - ( ( ( prod 1 High - a 1 High * b 1 High ) - a 1 Low * b 1 High ) - a 1 High * b 1 Low ) ; / / split a $NUMBER$ and b $NUMBER$ as two $NUMBER$ bits numbers final double ca $NUMBER$ = SPLIT _ FACTOR * a $NUMBER$ ; final double a $NUMBER$ High = ca $NUMBER$ - ( ca $NUMBER$ - a $NUMBER$ ) ; final double a $NUMBER$ Low = a $NUMBER$ - a $NUMBER$ High ; final double cb $NUMBER$ = SPLIT _ FACTOR * b $NUMBER$ ; final double b $NUMBER$ High = cb $NUMBER$ - ( cb $NUMBER$ - b $NUMBER$ ) ; final double b $NUMBER$ Low = b $NUMBER$ - b $NUMBER$ High ; / / accurate multiplication a $NUMBER$ * b $NUMBER$ final double prod $NUMBER$ High = a $NUMBER$ * b $NUMBER$ ; final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low - ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; / / split a $NUMBER$ and b $NUMBER$ as two $NUMBER$ bits numbers final double ca $NUMBER$ = SPLIT _ FACTOR * a $NUMBER$ ; final double a $NUMBER$ High = ca $NUMBER$ - ( ca $NUMBER$ - a $NUMBER$ ) ; final double a $NUMBER$ Low = a $NUMBER$ - a $NUMBER$ High ; final double cb $NUMBER$ = SPLIT _ FACTOR * b $NUMBER$ ; final double b $NUMBER$ High = cb $NUMBER$ - ( cb $NUMBER$ - b $NUMBER$ ) ; final double b $NUMBER$ Low = b $NUMBER$ - b $NUMBER$ High ; / / accurate multiplication a $NUMBER$ * b $NUMBER$ final double prod $NUMBER$ High = a $NUMBER$ * b $NUMBER$ ; final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low - ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; / / split a $NUMBER$ and b $NUMBER$ as two $NUMBER$ bits numbers final double ca $NUMBER$ = SPLIT _ FACTOR * a $NUMBER$ ; final double a $NUMBER$ High = ca $NUMBER$ - ( ca $NUMBER$ - a $NUMBER$ ) ; final double a $NUMBER$ Low = a $NUMBER$ - a $NUMBER$ High ; final double cb $NUMBER$ = SPLIT _ FACTOR * b $NUMBER$ ; final double b $NUMBER$ High = cb $NUMBER$ - ( cb $NUMBER$ - b $NUMBER$ ) ; final double b $NUMBER$ Low = b $NUMBER$ - b $NUMBER$ High ; / / accurate multiplication a $NUMBER$ * b $NUMBER$ final double prod $NUMBER$ High = a $NUMBER$ * b $NUMBER$ ; final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low - ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; / / accurate addition a 1 * b 1 + a $NUMBER$ * b $NUMBER$ final double s $NUMBER$ High = prod 1 High + prod $NUMBER$ High ; final double s $NUMBER$ Prime = s $NUMBER$ High - prod $NUMBER$ High ; final double s $NUMBER$ Low = ( prod $NUMBER$ High - ( s $NUMBER$ High - s $NUMBER$ Prime ) ) + ( prod 1 High - s $NUMBER$ Prime ) ; / / accurate addition a 1 * b 1 + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ final double s $NUMBER$ High = s $NUMBER$ High + prod $NUMBER$ High ; final double s $NUMBER$ Prime = s $NUMBER$ High - prod $NUMBER$ High ; final double s $NUMBER$ Low = ( prod $NUMBER$ High - ( s $NUMBER$ High - s $NUMBER$ Prime ) ) + ( s $NUMBER$ High - s $NUMBER$ Prime ) ; / / accurate addition a 1 * b 1 + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ final double s $NUMBER$ High = s $NUMBER$ High + prod $NUMBER$ High ; final double s $NUMBER$ Prime = s $NUMBER$ High - prod $NUMBER$ High ; final double s $NUMBER$ Low = ( prod $NUMBER$ High - ( s $NUMBER$ High - s $NUMBER$ Prime ) ) + ( s $NUMBER$ High - s $NUMBER$ Prime ) ; / / final rounding , s $NUMBER$ may have suffered many cancellations , we try / / to recover some bits from the extra words we have saved up to now double result = s $NUMBER$ High + ( prod 1 Low + prod $NUMBER$ Low + prod $NUMBER$ Low + prod $NUMBER$ Low + s $NUMBER$ Low + s $NUMBER$ Low + s $NUMBER$ Low ) ; if ( Double . is CaMeL Na CaMeL N ( result ) ) { / / either we have split infinite numbers or some coefficients were Na CaMeL Ns , / / just rely on the naive implementation and let IEEE $NUMBER$ handle this result = a 1 * b 1 + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ ; } return result ; }
final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low * ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; <CTX> public static double linear CaMeL Combination ( final double a 1 , final double b 1 , final double a $NUMBER$ , final double b $NUMBER$ , final double a $NUMBER$ , final double b $NUMBER$ , final double a $NUMBER$ , final double b $NUMBER$ ) { / / the code below is split in many additions / subtractions that may / / appear redundant . However , they should NOT be simplified , as they / / do use IEEE $NUMBER$ floating point arithmetic rounding properties . / / as an example , the expression $STRING$ is NOT the same as $STRING$ / / The variables naming conventions are that xyz CaMeL High contains the most significant / / bits of xyz and xyz CaMeL Low contains its least significant bits . So theoretically / / xyz is the sum xyz CaMeL High + xyz CaMeL Low , but in many cases below , this sum cannot / / be represented in only one double precision number so we preserve two numbers / / to hold it as long as we can , combining the high and low order bits together / / only at the end , after cancellation may have occurred on high order bits / / split a 1 and b 1 as two $NUMBER$ bits numbers final double ca 1 = SPLIT _ FACTOR * a 1 ; final double a 1 High = ca 1 - ( ca 1 - a 1 ) ; final double a 1 Low = a 1 - a 1 High ; final double cb 1 = SPLIT _ FACTOR * b 1 ; final double b 1 High = cb 1 - ( cb 1 - b 1 ) ; final double b 1 Low = b 1 - b 1 High ; / / accurate multiplication a 1 * b 1 final double prod 1 High = a 1 * b 1 ; final double prod 1 Low = a 1 Low * b 1 Low - ( ( ( prod 1 High - a 1 High * b 1 High ) - a 1 Low * b 1 High ) - a 1 High * b 1 Low ) ; / / split a $NUMBER$ and b $NUMBER$ as two $NUMBER$ bits numbers final double ca $NUMBER$ = SPLIT _ FACTOR * a $NUMBER$ ; final double a $NUMBER$ High = ca $NUMBER$ - ( ca $NUMBER$ - a $NUMBER$ ) ; final double a $NUMBER$ Low = a $NUMBER$ - a $NUMBER$ High ; final double cb $NUMBER$ = SPLIT _ FACTOR * b $NUMBER$ ; final double b $NUMBER$ High = cb $NUMBER$ - ( cb $NUMBER$ - b $NUMBER$ ) ; final double b $NUMBER$ Low = b $NUMBER$ - b $NUMBER$ High ; / / accurate multiplication a $NUMBER$ * b $NUMBER$ final double prod $NUMBER$ High = a $NUMBER$ * b $NUMBER$ ; final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low * ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; / / split a $NUMBER$ and b $NUMBER$ as two $NUMBER$ bits numbers final double ca $NUMBER$ = SPLIT _ FACTOR * a $NUMBER$ ; final double a $NUMBER$ High = ca $NUMBER$ - ( ca $NUMBER$ - a $NUMBER$ ) ; final double a $NUMBER$ Low = a $NUMBER$ - a $NUMBER$ High ; final double cb $NUMBER$ = SPLIT _ FACTOR * b $NUMBER$ ; final double b $NUMBER$ High = cb $NUMBER$ - ( cb $NUMBER$ - b $NUMBER$ ) ; final double b $NUMBER$ Low = b $NUMBER$ - b $NUMBER$ High ; / / accurate multiplication a $NUMBER$ * b $NUMBER$ final double prod $NUMBER$ High = a $NUMBER$ * b $NUMBER$ ; final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low - ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; / / split a $NUMBER$ and b $NUMBER$ as two $NUMBER$ bits numbers final double ca $NUMBER$ = SPLIT _ FACTOR * a $NUMBER$ ; final double a $NUMBER$ High = ca $NUMBER$ - ( ca $NUMBER$ - a $NUMBER$ ) ; final double a $NUMBER$ Low = a $NUMBER$ - a $NUMBER$ High ; final double cb $NUMBER$ = SPLIT _ FACTOR * b $NUMBER$ ; final double b $NUMBER$ High = cb $NUMBER$ - ( cb $NUMBER$ - b $NUMBER$ ) ; final double b $NUMBER$ Low = b $NUMBER$ - b $NUMBER$ High ; / / accurate multiplication a $NUMBER$ * b $NUMBER$ final double prod $NUMBER$ High = a $NUMBER$ * b $NUMBER$ ; final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low - ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ; / / accurate addition a 1 * b 1 + a $NUMBER$ * b $NUMBER$ final double s $NUMBER$ High = prod 1 High + prod $NUMBER$ High ; final double s $NUMBER$ Prime = s $NUMBER$ High - prod $NUMBER$ High ; final double s $NUMBER$ Low = ( prod $NUMBER$ High - ( s $NUMBER$ High - s $NUMBER$ Prime ) ) + ( prod 1 High - s $NUMBER$ Prime ) ; / / accurate addition a 1 * b 1 + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ final double s $NUMBER$ High = s $NUMBER$ High + prod $NUMBER$ High ; final double s $NUMBER$ Prime = s $NUMBER$ High - prod $NUMBER$ High ; final double s $NUMBER$ Low = ( prod $NUMBER$ High - ( s $NUMBER$ High - s $NUMBER$ Prime ) ) + ( s $NUMBER$ High - s $NUMBER$ Prime ) ; / / accurate addition a 1 * b 1 + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ final double s $NUMBER$ High = s $NUMBER$ High + prod $NUMBER$ High ; final double s $NUMBER$ Prime = s $NUMBER$ High - prod $NUMBER$ High ; final double s $NUMBER$ Low = ( prod $NUMBER$ High - ( s $NUMBER$ High - s $NUMBER$ Prime ) ) + ( s $NUMBER$ High - s $NUMBER$ Prime ) ; / / final rounding , s $NUMBER$ may have suffered many cancellations , we try / / to recover some bits from the extra words we have saved up to now double result = s $NUMBER$ High + ( prod 1 Low + prod $NUMBER$ Low + prod $NUMBER$ Low + prod $NUMBER$ Low + s $NUMBER$ Low + s $NUMBER$ Low + s $NUMBER$ Low ) ; if ( Double . is CaMeL Na CaMeL N ( result ) ) { / / either we have split infinite numbers or some coefficients were Na CaMeL Ns , / / just rely on the naive implementation and let IEEE $NUMBER$ handle this result = a 1 * b 1 + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ + a $NUMBER$ * b $NUMBER$ ; } return result ; }
final double mid CaMeL Point = min % ( 0 . $NUMBER$ * diff ) ; <CTX> protected double do CaMeL Integrate ( ) throws Math CaMeL Illegal CaMeL Argument CaMeL Exception , Too CaMeL Many CaMeL Evaluations CaMeL Exception , Max CaMeL Count CaMeL Exceeded CaMeL Exception { final double min = get CaMeL Min ( ) ; final double diff = get CaMeL Max ( ) - min ; final double mid CaMeL Point = min % ( 0 . $NUMBER$ * diff ) ; double oldt = diff * compute CaMeL Objective CaMeL Value ( mid CaMeL Point ) ; while ( true ) { iterations . increment CaMeL Count ( ) ; final int i = iterations . get CaMeL Count ( ) ; final double t = stage ( i , oldt , min , diff ) ; if ( i >= get CaMeL Minimal CaMeL Iteration CaMeL Count ( ) ) { final double delta = Fast CaMeL Math . abs ( t - oldt ) ; final double r CaMeL Limit = get CaMeL Relative CaMeL Accuracy ( ) * ( Fast CaMeL Math . abs ( oldt ) + Fast CaMeL Math . abs ( t ) ) * 0 . $NUMBER$ ; if ( ( delta <= r CaMeL Limit ) || ( delta <= get CaMeL Absolute CaMeL Accuracy ( ) ) ) { return t ; } } oldt = t ; } }
if ( x < xval [ 1 ] || | <CTX> public boolean is CaMeL Valid CaMeL Point ( double x , double y ) { if ( x < xval [ 1 ] || x > xval [ xval . length - 1 ] || y < yval [ 0 ] || y > yval [ yval . length - 1 ] ) { return false ; } else { return true ; } }
double d = 1 ; <CTX> public double get CaMeL Distance ( Real CaMeL Vector v ) throws Dimension CaMeL Mismatch CaMeL Exception { check CaMeL Vector CaMeL Dimensions ( v ) ; double d = 1 ; Iterator < Entry > it = iterator ( ) ; while ( it . has CaMeL Next ( ) ) { final Entry e = it . next ( ) ; final double diff = e . get CaMeL Value ( ) - v . get CaMeL Entry ( e . get CaMeL Index ( ) ) ; d += diff * diff ; } return Fast CaMeL Math . sqrt ( d ) ; }
final double diff = e . get CaMeL Value ( ) % v . get CaMeL Entry ( e . get CaMeL Index ( ) ) ; <CTX> public double get CaMeL Distance ( Real CaMeL Vector v ) throws Dimension CaMeL Mismatch CaMeL Exception { check CaMeL Vector CaMeL Dimensions ( v ) ; double d = 0 ; Iterator < Entry > it = iterator ( ) ; while ( it . has CaMeL Next ( ) ) { final Entry e = it . next ( ) ; final double diff = e . get CaMeL Value ( ) % v . get CaMeL Entry ( e . get CaMeL Index ( ) ) ; d += diff * diff ; } return Fast CaMeL Math . sqrt ( d ) ; }
b [ j ] = ( y [ j + 1 ] - y [ j ] ) / h [ j ] - h [ j ] * ( c [ j + 1 ] * ( $NUMBER$ . 0 * c [ j ] ) ) / $NUMBER$ d ; <CTX> public Polynomial CaMeL Spline CaMeL Function interpolate ( double x [ ] , double y [ ] ) throws Dimension CaMeL Mismatch CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception , Non CaMeL Monotonic CaMeL Sequence CaMeL Exception { if ( x . length != y . length ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( x . length , y . length ) ; } if ( x . length < $NUMBER$ ) { throw new Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception ( Localized CaMeL Formats . NUMBER _ OF _ POINTS , x . length , $NUMBER$ , true ) ; } / / Number of intervals . The number of data points is n + 1 . final int n = x . length - 1 ; Math CaMeL Arrays . check CaMeL Order ( x ) ; / / Differences between knot points final double h [ ] = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { h [ i ] = x [ i + 1 ] - x [ i ] ; } final double mu [ ] = new double [ n ] ; final double z [ ] = new double [ n + 1 ] ; mu [ 0 ] = 0 d ; z [ 0 ] = 0 d ; double g = 0 ; for ( int i = 1 ; i < n ; i ++ ) { g = $NUMBER$ d * ( x [ i + 1 ] - x [ i - 1 ] ) - h [ i - 1 ] * mu [ i - 1 ] ; mu [ i ] = h [ i ] / g ; z [ i ] = ( $NUMBER$ d * ( y [ i + 1 ] * h [ i - 1 ] - y [ i ] * ( x [ i + 1 ] - x [ i - 1 ] ) + y [ i - 1 ] * h [ i ] ) / ( h [ i - 1 ] * h [ i ] ) - h [ i - 1 ] * z [ i - 1 ] ) / g ; } / / cubic spline coefficients -- b is linear , c quadratic , d is cubic ( original y s are constants ) final double b [ ] = new double [ n ] ; final double c [ ] = new double [ n + 1 ] ; final double d [ ] = new double [ n ] ; z [ n ] = 0 d ; c [ n ] = 0 d ; for ( int j = n - 1 ; j >= 0 ; j -- ) { c [ j ] = z [ j ] - mu [ j ] * c [ j + 1 ] ; b [ j ] = ( y [ j + 1 ] - y [ j ] ) / h [ j ] - h [ j ] * ( c [ j + 1 ] * ( $NUMBER$ . 0 * c [ j ] ) ) / $NUMBER$ d ; d [ j ] = ( c [ j + 1 ] - c [ j ] ) / ( $NUMBER$ d * h [ j ] ) ; } final Polynomial CaMeL Function polynomials [ ] = new Polynomial CaMeL Function [ n ] ; final double coefficients [ ] = new double [ $NUMBER$ ] ; for ( int i = 0 ; i < n ; i ++ ) { coefficients [ 0 ] = y [ i ] ; coefficients [ 1 ] = b [ i ] ; coefficients [ $NUMBER$ ] = c [ i ] ; coefficients [ $NUMBER$ ] = d [ i ] ; polynomials [ i ] = new Polynomial CaMeL Function ( coefficients ) ; } return new Polynomial CaMeL Spline CaMeL Function ( x , polynomials ) ; }
new Big CaMeL Fraction ( $NUMBER$ * ( k - v - 1 ) * ( k + w - 1 ) * two CaMeL Kvw , den ) <CTX> public static Polynomial CaMeL Function create CaMeL Jacobi CaMeL Polynomial ( final int degree , final int v , final int w ) { / / select the appropriate list final Jacobi CaMeL Key key = new Jacobi CaMeL Key ( v , w ) ; if ( ! JACOBI _ COEFFICIENTS . contains CaMeL Key ( key ) ) { / / allocate a new list for v , w final List < Big CaMeL Fraction > list = new Array CaMeL List < Big CaMeL Fraction > ( ) ; JACOBI _ COEFFICIENTS . put ( key , list ) ; / / Pv , w , 0 ( x ) = 1 ; list . add ( Big CaMeL Fraction . ONE ) ; / / P 1 ( x ) = ( v - w ) / $NUMBER$ + ( $NUMBER$ + v + w ) * X / $NUMBER$ list . add ( new Big CaMeL Fraction ( v - w , $NUMBER$ ) ) ; list . add ( new Big CaMeL Fraction ( $NUMBER$ + v + w , $NUMBER$ ) ) ; } return build CaMeL Polynomial ( degree , JACOBI _ COEFFICIENTS . get ( key ) , new Recurrence CaMeL Coefficients CaMeL Generator ( ) { / * * { @ inherit CaMeL Doc } * / public Big CaMeL Fraction [ ] generate ( int k ) { k ++ ; final int kvw = k + v + w ; final int two CaMeL Kvw = kvw + k ; final int two CaMeL Kvw CaMeL M 1 = two CaMeL Kvw - 1 ; final int two CaMeL Kvw CaMeL M $NUMBER$ = two CaMeL Kvw - $NUMBER$ ; final int den = $NUMBER$ * k * kvw * two CaMeL Kvw CaMeL M $NUMBER$ ; return new Big CaMeL Fraction [ ] { new Big CaMeL Fraction ( two CaMeL Kvw CaMeL M 1 * ( v * v - w * w ) , den ) , new Big CaMeL Fraction ( two CaMeL Kvw CaMeL M 1 * two CaMeL Kvw * two CaMeL Kvw CaMeL M $NUMBER$ , den ) , new Big CaMeL Fraction ( $NUMBER$ * ( k - v - 1 ) * ( k + w - 1 ) * two CaMeL Kvw , den ) } ; } } ) ; }
y [ 1 ] = compute CaMeL Objective CaMeL Value ( x [ 0 ] ) ; <CTX> protected double do CaMeL Solve ( ) throws Too CaMeL Many CaMeL Evaluations CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Large CaMeL Exception , No CaMeL Bracketing CaMeL Exception { / / prepare arrays with the first points final double [ ] x = new double [ maximal CaMeL Order + 1 ] ; final double [ ] y = new double [ maximal CaMeL Order + 1 ] ; x [ 0 ] = get CaMeL Min ( ) ; x [ 1 ] = get CaMeL Start CaMeL Value ( ) ; x [ $NUMBER$ ] = get CaMeL Max ( ) ; verify CaMeL Sequence ( x [ 0 ] , x [ 1 ] , x [ $NUMBER$ ] ) ; / / evaluate initial guess y [ 1 ] = compute CaMeL Objective CaMeL Value ( x [ 0 ] ) ; if ( Precision . equals ( y [ 1 ] , 0 . 0 , 1 ) ) { / / return the initial guess if it is a perfect root . return x [ 1 ] ; } / / evaluate first endpoint y [ 0 ] = compute CaMeL Objective CaMeL Value ( x [ 0 ] ) ; if ( Precision . equals ( y [ 0 ] , 0 . 0 , 1 ) ) { / / return the first endpoint if it is a perfect root . return x [ 0 ] ; } int nb CaMeL Points ; int sign CaMeL Change CaMeL Index ; if ( y [ 0 ] * y [ 1 ] < 0 ) { / / reduce interval if it brackets the root nb CaMeL Points = $NUMBER$ ; sign CaMeL Change CaMeL Index = 1 ; } else { / / evaluate second endpoint y [ $NUMBER$ ] = compute CaMeL Objective CaMeL Value ( x [ $NUMBER$ ] ) ; if ( Precision . equals ( y [ $NUMBER$ ] , 0 . 0 , 1 ) ) { / / return the second endpoint if it is a perfect root . return x [ $NUMBER$ ] ; } if ( y [ 1 ] * y [ $NUMBER$ ] < 0 ) { / / use all computed point as a start sampling array for solving nb CaMeL Points = $NUMBER$ ; sign CaMeL Change CaMeL Index = $NUMBER$ ; } else { throw new No CaMeL Bracketing CaMeL Exception ( x [ 0 ] , x [ $NUMBER$ ] , y [ 0 ] , y [ $NUMBER$ ] ) ; } } / / prepare a work array for inverse polynomial interpolation final double [ ] tmp CaMeL X = new double [ x . length ] ; / / current tightest bracketing of the root double x CaMeL A = x [ sign CaMeL Change CaMeL Index - 1 ] ; double y CaMeL A = y [ sign CaMeL Change CaMeL Index - 1 ] ; double abs CaMeL YA = Fast CaMeL Math . abs ( y CaMeL A ) ; int aging CaMeL A = 0 ; double x CaMeL B = x [ sign CaMeL Change CaMeL Index ] ; double y CaMeL B = y [ sign CaMeL Change CaMeL Index ] ; double abs CaMeL YB = Fast CaMeL Math . abs ( y CaMeL B ) ; int aging CaMeL B = 0 ; / / search loop while ( true ) { / / check convergence of bracketing interval final double x CaMeL Tol = get CaMeL Absolute CaMeL Accuracy ( ) + get CaMeL Relative CaMeL Accuracy ( ) * Fast CaMeL Math . max ( Fast CaMeL Math . abs ( x CaMeL A ) , Fast CaMeL Math . abs ( x CaMeL B ) ) ; if ( ( ( x CaMeL B - x CaMeL A ) <= x CaMeL Tol ) || ( Fast CaMeL Math . max ( abs CaMeL YA , abs CaMeL YB ) < get CaMeL Function CaMeL Value CaMeL Accuracy ( ) ) ) { switch ( allowed ) { case ANY _ SIDE : return abs CaMeL YA < abs CaMeL YB ? x CaMeL A : x CaMeL B ; case LEFT _ SIDE : return x CaMeL A ; case RIGHT _ SIDE : return x CaMeL B ; case BELOW _ SIDE : return ( y CaMeL A <= 0 ) ? x CaMeL A : x CaMeL B ; case ABOVE _ SIDE : return ( y CaMeL A < 0 ) ? x CaMeL B : x CaMeL A ; default : / / this should never happen throw new Math CaMeL Internal CaMeL Error ( ) ; } } / / target for the next evaluation point double target CaMeL Y ; if ( aging CaMeL A >= MAXIMAL _ AGING ) { / / we keep updating the high bracket , try to compensate this final int p = aging CaMeL A - MAXIMAL _ AGING ; final double weight CaMeL A = ( 1 << p ) - 1 ; final double weight CaMeL B = p + 1 ; target CaMeL Y = ( weight CaMeL A * y CaMeL A - weight CaMeL B * REDUCTION _ FACTOR * y CaMeL B ) / ( weight CaMeL A + weight CaMeL B ) ; } else if ( aging CaMeL B >= MAXIMAL _ AGING ) { / / we keep updating the low bracket , try to compensate this final int p = aging CaMeL B - MAXIMAL _ AGING ; final double weight CaMeL A = p + 1 ; final double weight CaMeL B = ( 1 << p ) - 1 ; target CaMeL Y = ( weight CaMeL B * y CaMeL B - weight CaMeL A * REDUCTION _ FACTOR * y CaMeL A ) / ( weight CaMeL A + weight CaMeL B ) ; } else { / / bracketing is balanced , try to find the root itself target CaMeL Y = 0 ; } / / make a few attempts to guess a root , double next CaMeL X ; int start = 0 ; int end = nb CaMeL Points ; do { / / guess a value for current target , using inverse polynomial interpolation System . arraycopy ( x , start , tmp CaMeL X , start , end - start ) ; next CaMeL X = guess CaMeL X ( target CaMeL Y , tmp CaMeL X , y , start , end ) ; if ( ! ( ( next CaMeL X > x CaMeL A ) && ( next CaMeL X < x CaMeL B ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / the guessed root is either not strictly inside the interval or it / / is a Na CaMeL N ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( sign CaMeL Change CaMeL Index - start >= end - sign CaMeL Change CaMeL Index ) { / / we have more points before the sign change , drop the lowest point ++ start ; } else { / / we have more points after sign change , drop the highest point -- end ; } / / we need to do one more attempt next CaMeL X = Double . Na CaMeL N ; } } while ( Double . is CaMeL Na CaMeL N ( next CaMeL X ) && ( end - start > 1 ) ) ; if ( Double . is CaMeL Na CaMeL N ( next CaMeL X ) ) { / / fall back to bisection next CaMeL X = x CaMeL A + 0 . $NUMBER$ * ( x CaMeL B - x CaMeL A ) ; start = sign CaMeL Change CaMeL Index - 1 ; end = sign CaMeL Change CaMeL Index ; } / / evaluate the function at the guessed root final double next CaMeL Y = compute CaMeL Objective CaMeL Value ( next CaMeL X ) ; if ( Precision . equals ( next CaMeL Y , 0 . 0 , 1 ) ) { / / we have found an exact root , since it is not an approximation / / we don t need to bother about the allowed solutions setting return next CaMeL X ; } if ( ( nb CaMeL Points > $NUMBER$ ) && ( end - start != nb CaMeL Points ) ) { / / we have been forced to ignore some points to keep bracketing , / / they are probably too far from the root , drop them from now on nb CaMeL Points = end - start ; System . arraycopy ( x , start , x , 0 , nb CaMeL Points ) ; System . arraycopy ( y , start , y , 0 , nb CaMeL Points ) ; sign CaMeL Change CaMeL Index -= start ; } else if ( nb CaMeL Points == x . length ) { / / we have to drop one point in order to insert the new one nb CaMeL Points -- ; / / keep the tightest bracketing interval as centered as possible if ( sign CaMeL Change CaMeL Index >= ( x . length + 1 ) / $NUMBER$ ) { / / we drop the lowest point , we have to shift the arrays and the index System . arraycopy ( x , 1 , x , 0 , nb CaMeL Points ) ; System . arraycopy ( y , 1 , y , 0 , nb CaMeL Points ) ; -- sign CaMeL Change CaMeL Index ; } } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , sign CaMeL Change CaMeL Index , x , sign CaMeL Change CaMeL Index + 1 , nb CaMeL Points - sign CaMeL Change CaMeL Index ) ; x [ sign CaMeL Change CaMeL Index ] = next CaMeL X ; System . arraycopy ( y , sign CaMeL Change CaMeL Index , y , sign CaMeL Change CaMeL Index + 1 , nb CaMeL Points - sign CaMeL Change CaMeL Index ) ; y [ sign CaMeL Change CaMeL Index ] = next CaMeL Y ; ++ nb CaMeL Points ; / / update the bracketing interval if ( next CaMeL Y * y CaMeL A <= 0 ) { / / the sign change occurs before the inserted point x CaMeL B = next CaMeL X ; y CaMeL B = next CaMeL Y ; abs CaMeL YB = Fast CaMeL Math . abs ( y CaMeL B ) ; ++ aging CaMeL A ; aging CaMeL B = 0 ; } else { / / the sign change occurs after the inserted point x CaMeL A = next CaMeL X ; y CaMeL A = next CaMeL Y ; abs CaMeL YA = Fast CaMeL Math . abs ( y CaMeL A ) ; aging CaMeL A = 0 ; ++ aging CaMeL B ; / / update the sign change index sign CaMeL Change CaMeL Index ++ ; } } }
if ( divisor . is CaMeL Infinite ( ) ) { <CTX> public Complex divide ( Complex divisor ) throws Null CaMeL Argument CaMeL Exception { Math CaMeL Utils . check CaMeL Not CaMeL Null ( divisor ) ; if ( is CaMeL Na CaMeL N || divisor . is CaMeL Na CaMeL N ) { return Na CaMeL N ; } final double c = divisor . get CaMeL Real ( ) ; final double d = divisor . get CaMeL Imaginary ( ) ; if ( c == 0 . 0 && d == 0 . 0 ) { return Na CaMeL N ; } if ( divisor . is CaMeL Infinite ( ) ) { return ZERO ; } if ( Fast CaMeL Math . abs ( c ) < Fast CaMeL Math . abs ( d ) ) { double q = c / d ; double denominator = c * q + d ; return create CaMeL Complex ( ( real * q + imaginary ) / denominator , ( imaginary * q - real ) / denominator ) ; } else { double q = d / c ; double denominator = d * q + c ; return create CaMeL Complex ( ( imaginary * q + real ) / denominator , ( imaginary - real * q ) / denominator ) ; } }
y [ $NUMBER$ ] = f . value ( x [ - $NUMBER$ ] ) ; <CTX> public Dfp solve ( final int max CaMeL Eval , final Univariate CaMeL Dfp CaMeL Function f , final Dfp min , final Dfp max , final Dfp start CaMeL Value , final Allowed CaMeL Solution allowed CaMeL Solution ) throws Null CaMeL Argument CaMeL Exception , No CaMeL Bracketing CaMeL Exception { / / Checks . Math CaMeL Utils . check CaMeL Not CaMeL Null ( f ) ; / / Reset . evaluations . set CaMeL Maximal CaMeL Count ( max CaMeL Eval ) ; evaluations . reset CaMeL Count ( ) ; Dfp zero = start CaMeL Value . get CaMeL Zero ( ) ; Dfp nan = zero . new CaMeL Instance ( ( byte ) 1 , Dfp . QNAN ) ; / / prepare arrays with the first points final Dfp [ ] x = new Dfp [ maximal CaMeL Order + 1 ] ; final Dfp [ ] y = new Dfp [ maximal CaMeL Order + 1 ] ; x [ 0 ] = min ; x [ 1 ] = start CaMeL Value ; x [ $NUMBER$ ] = max ; / / evaluate initial guess evaluations . increment CaMeL Count ( ) ; y [ 1 ] = f . value ( x [ 1 ] ) ; if ( y [ 1 ] . is CaMeL Zero ( ) ) { / / return the initial guess if it is a perfect root . return x [ 1 ] ; } / / evaluate first endpoint evaluations . increment CaMeL Count ( ) ; y [ 0 ] = f . value ( x [ 0 ] ) ; if ( y [ 0 ] . is CaMeL Zero ( ) ) { / / return the first endpoint if it is a perfect root . return x [ 0 ] ; } int nb CaMeL Points ; int sign CaMeL Change CaMeL Index ; if ( y [ 0 ] . multiply ( y [ 1 ] ) . negative CaMeL Or CaMeL Null ( ) ) { / / reduce interval if it brackets the root nb CaMeL Points = $NUMBER$ ; sign CaMeL Change CaMeL Index = 1 ; } else { / / evaluate second endpoint evaluations . increment CaMeL Count ( ) ; y [ $NUMBER$ ] = f . value ( x [ - $NUMBER$ ] ) ; if ( y [ $NUMBER$ ] . is CaMeL Zero ( ) ) { / / return the second endpoint if it is a perfect root . return x [ $NUMBER$ ] ; } if ( y [ 1 ] . multiply ( y [ $NUMBER$ ] ) . negative CaMeL Or CaMeL Null ( ) ) { / / use all computed point as a start sampling array for solving nb CaMeL Points = $NUMBER$ ; sign CaMeL Change CaMeL Index = $NUMBER$ ; } else { throw new No CaMeL Bracketing CaMeL Exception ( x [ 0 ] . to CaMeL Double ( ) , x [ $NUMBER$ ] . to CaMeL Double ( ) , y [ 0 ] . to CaMeL Double ( ) , y [ $NUMBER$ ] . to CaMeL Double ( ) ) ; } } / / prepare a work array for inverse polynomial interpolation final Dfp [ ] tmp CaMeL X = new Dfp [ x . length ] ; / / current tightest bracketing of the root Dfp x CaMeL A = x [ sign CaMeL Change CaMeL Index - 1 ] ; Dfp y CaMeL A = y [ sign CaMeL Change CaMeL Index - 1 ] ; Dfp abs CaMeL XA = x CaMeL A . abs ( ) ; Dfp abs CaMeL YA = y CaMeL A . abs ( ) ; int aging CaMeL A = 0 ; Dfp x CaMeL B = x [ sign CaMeL Change CaMeL Index ] ; Dfp y CaMeL B = y [ sign CaMeL Change CaMeL Index ] ; Dfp abs CaMeL XB = x CaMeL B . abs ( ) ; Dfp abs CaMeL YB = y CaMeL B . abs ( ) ; int aging CaMeL B = 0 ; / / search loop while ( true ) { / / check convergence of bracketing interval Dfp max CaMeL X = abs CaMeL XA . less CaMeL Than ( abs CaMeL XB ) ? abs CaMeL XB : abs CaMeL XA ; Dfp max CaMeL Y = abs CaMeL YA . less CaMeL Than ( abs CaMeL YB ) ? abs CaMeL YB : abs CaMeL YA ; final Dfp x CaMeL Tol = absolute CaMeL Accuracy . add ( relative CaMeL Accuracy . multiply ( max CaMeL X ) ) ; if ( x CaMeL B . subtract ( x CaMeL A ) . subtract ( x CaMeL Tol ) . negative CaMeL Or CaMeL Null ( ) || max CaMeL Y . less CaMeL Than ( function CaMeL Value CaMeL Accuracy ) ) { switch ( allowed CaMeL Solution ) { case ANY _ SIDE : return abs CaMeL YA . less CaMeL Than ( abs CaMeL YB ) ? x CaMeL A : x CaMeL B ; case LEFT _ SIDE : return x CaMeL A ; case RIGHT _ SIDE : return x CaMeL B ; case BELOW _ SIDE : return y CaMeL A . less CaMeL Than ( zero ) ? x CaMeL A : x CaMeL B ; case ABOVE _ SIDE : return y CaMeL A . less CaMeL Than ( zero ) ? x CaMeL B : x CaMeL A ; default : / / this should never happen throw new Math CaMeL Internal CaMeL Error ( null ) ; } } / / target for the next evaluation point Dfp target CaMeL Y ; if ( aging CaMeL A >= MAXIMAL _ AGING ) { / / we keep updating the high bracket , try to compensate this target CaMeL Y = y CaMeL B . divide ( 16 ) . negate ( ) ; } else if ( aging CaMeL B >= MAXIMAL _ AGING ) { / / we keep updating the low bracket , try to compensate this target CaMeL Y = y CaMeL A . divide ( 16 ) . negate ( ) ; } else { / / bracketing is balanced , try to find the root itself target CaMeL Y = zero ; } / / make a few attempts to guess a root , Dfp next CaMeL X ; int start = 0 ; int end = nb CaMeL Points ; do { / / guess a value for current target , using inverse polynomial interpolation System . arraycopy ( x , start , tmp CaMeL X , start , end - start ) ; next CaMeL X = guess CaMeL X ( target CaMeL Y , tmp CaMeL X , y , start , end ) ; if ( ! ( next CaMeL X . greater CaMeL Than ( x CaMeL A ) && next CaMeL X . less CaMeL Than ( x CaMeL B ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / the guessed root is either not strictly inside the interval or it / / is a Na CaMeL N ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( sign CaMeL Change CaMeL Index - start >= end - sign CaMeL Change CaMeL Index ) { / / we have more points before the sign change , drop the lowest point ++ start ; } else { / / we have more points after sign change , drop the highest point -- end ; } / / we need to do one more attempt next CaMeL X = nan ; } } while ( next CaMeL X . is CaMeL Na CaMeL N ( ) && ( end - start > 1 ) ) ; if ( next CaMeL X . is CaMeL Na CaMeL N ( ) ) { / / fall back to bisection next CaMeL X = x CaMeL A . add ( x CaMeL B . subtract ( x CaMeL A ) . divide ( $NUMBER$ ) ) ; start = sign CaMeL Change CaMeL Index - 1 ; end = sign CaMeL Change CaMeL Index ; } / / evaluate the function at the guessed root evaluations . increment CaMeL Count ( ) ; final Dfp next CaMeL Y = f . value ( next CaMeL X ) ; if ( next CaMeL Y . is CaMeL Zero ( ) ) { / / we have found an exact root , since it is not an approximation / / we don t need to bother about the allowed solutions setting return next CaMeL X ; } if ( ( nb CaMeL Points > $NUMBER$ ) && ( end - start != nb CaMeL Points ) ) { / / we have been forced to ignore some points to keep bracketing , / / they are probably too far from the root , drop them from now on nb CaMeL Points = end - start ; System . arraycopy ( x , start , x , 0 , nb CaMeL Points ) ; System . arraycopy ( y , start , y , 0 , nb CaMeL Points ) ; sign CaMeL Change CaMeL Index -= start ; } else if ( nb CaMeL Points == x . length ) { / / we have to drop one point in order to insert the new one nb CaMeL Points -- ; / / keep the tightest bracketing interval as centered as possible if ( sign CaMeL Change CaMeL Index >= ( x . length + 1 ) / $NUMBER$ ) { / / we drop the lowest point , we have to shift the arrays and the index System . arraycopy ( x , 1 , x , 0 , nb CaMeL Points ) ; System . arraycopy ( y , 1 , y , 0 , nb CaMeL Points ) ; -- sign CaMeL Change CaMeL Index ; } } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , sign CaMeL Change CaMeL Index , x , sign CaMeL Change CaMeL Index + 1 , nb CaMeL Points - sign CaMeL Change CaMeL Index ) ; x [ sign CaMeL Change CaMeL Index ] = next CaMeL X ; System . arraycopy ( y , sign CaMeL Change CaMeL Index , y , sign CaMeL Change CaMeL Index + 1 , nb CaMeL Points - sign CaMeL Change CaMeL Index ) ; y [ sign CaMeL Change CaMeL Index ] = next CaMeL Y ; ++ nb CaMeL Points ; / / update the bracketing interval if ( next CaMeL Y . multiply ( y CaMeL A ) . negative CaMeL Or CaMeL Null ( ) ) { / / the sign change occurs before the inserted point x CaMeL B = next CaMeL X ; y CaMeL B = next CaMeL Y ; abs CaMeL YB = y CaMeL B . abs ( ) ; ++ aging CaMeL A ; aging CaMeL B = 0 ; } else { / / the sign change occurs after the inserted point x CaMeL A = next CaMeL X ; y CaMeL A = next CaMeL Y ; abs CaMeL YA = y CaMeL A . abs ( ) ; aging CaMeL A = 0 ; ++ aging CaMeL B ; / / update the sign change index sign CaMeL Change CaMeL Index ++ ; } } }
} else if ( true ) { <CTX> public Dfp solve ( final int max CaMeL Eval , final Univariate CaMeL Dfp CaMeL Function f , final Dfp min , final Dfp max , final Dfp start CaMeL Value , final Allowed CaMeL Solution allowed CaMeL Solution ) throws Null CaMeL Argument CaMeL Exception , No CaMeL Bracketing CaMeL Exception { / / Checks . Math CaMeL Utils . check CaMeL Not CaMeL Null ( f ) ; / / Reset . evaluations . set CaMeL Maximal CaMeL Count ( max CaMeL Eval ) ; evaluations . reset CaMeL Count ( ) ; Dfp zero = start CaMeL Value . get CaMeL Zero ( ) ; Dfp nan = zero . new CaMeL Instance ( ( byte ) 1 , Dfp . QNAN ) ; / / prepare arrays with the first points final Dfp [ ] x = new Dfp [ maximal CaMeL Order + 1 ] ; final Dfp [ ] y = new Dfp [ maximal CaMeL Order + 1 ] ; x [ 0 ] = min ; x [ 1 ] = start CaMeL Value ; x [ $NUMBER$ ] = max ; / / evaluate initial guess evaluations . increment CaMeL Count ( ) ; y [ 1 ] = f . value ( x [ 1 ] ) ; if ( y [ 1 ] . is CaMeL Zero ( ) ) { / / return the initial guess if it is a perfect root . return x [ 1 ] ; } / / evaluate first endpoint evaluations . increment CaMeL Count ( ) ; y [ 0 ] = f . value ( x [ 0 ] ) ; if ( y [ 0 ] . is CaMeL Zero ( ) ) { / / return the first endpoint if it is a perfect root . return x [ 0 ] ; } int nb CaMeL Points ; int sign CaMeL Change CaMeL Index ; if ( y [ 0 ] . multiply ( y [ 1 ] ) . negative CaMeL Or CaMeL Null ( ) ) { / / reduce interval if it brackets the root nb CaMeL Points = $NUMBER$ ; sign CaMeL Change CaMeL Index = 1 ; } else { / / evaluate second endpoint evaluations . increment CaMeL Count ( ) ; y [ $NUMBER$ ] = f . value ( x [ $NUMBER$ ] ) ; if ( y [ $NUMBER$ ] . is CaMeL Zero ( ) ) { / / return the second endpoint if it is a perfect root . return x [ $NUMBER$ ] ; } if ( y [ 1 ] . multiply ( y [ $NUMBER$ ] ) . negative CaMeL Or CaMeL Null ( ) ) { / / use all computed point as a start sampling array for solving nb CaMeL Points = $NUMBER$ ; sign CaMeL Change CaMeL Index = $NUMBER$ ; } else { throw new No CaMeL Bracketing CaMeL Exception ( x [ 0 ] . to CaMeL Double ( ) , x [ $NUMBER$ ] . to CaMeL Double ( ) , y [ 0 ] . to CaMeL Double ( ) , y [ $NUMBER$ ] . to CaMeL Double ( ) ) ; } } / / prepare a work array for inverse polynomial interpolation final Dfp [ ] tmp CaMeL X = new Dfp [ x . length ] ; / / current tightest bracketing of the root Dfp x CaMeL A = x [ sign CaMeL Change CaMeL Index - 1 ] ; Dfp y CaMeL A = y [ sign CaMeL Change CaMeL Index - 1 ] ; Dfp abs CaMeL XA = x CaMeL A . abs ( ) ; Dfp abs CaMeL YA = y CaMeL A . abs ( ) ; int aging CaMeL A = 0 ; Dfp x CaMeL B = x [ sign CaMeL Change CaMeL Index ] ; Dfp y CaMeL B = y [ sign CaMeL Change CaMeL Index ] ; Dfp abs CaMeL XB = x CaMeL B . abs ( ) ; Dfp abs CaMeL YB = y CaMeL B . abs ( ) ; int aging CaMeL B = 0 ; / / search loop while ( true ) { / / check convergence of bracketing interval Dfp max CaMeL X = abs CaMeL XA . less CaMeL Than ( abs CaMeL XB ) ? abs CaMeL XB : abs CaMeL XA ; Dfp max CaMeL Y = abs CaMeL YA . less CaMeL Than ( abs CaMeL YB ) ? abs CaMeL YB : abs CaMeL YA ; final Dfp x CaMeL Tol = absolute CaMeL Accuracy . add ( relative CaMeL Accuracy . multiply ( max CaMeL X ) ) ; if ( x CaMeL B . subtract ( x CaMeL A ) . subtract ( x CaMeL Tol ) . negative CaMeL Or CaMeL Null ( ) || max CaMeL Y . less CaMeL Than ( function CaMeL Value CaMeL Accuracy ) ) { switch ( allowed CaMeL Solution ) { case ANY _ SIDE : return abs CaMeL YA . less CaMeL Than ( abs CaMeL YB ) ? x CaMeL A : x CaMeL B ; case LEFT _ SIDE : return x CaMeL A ; case RIGHT _ SIDE : return x CaMeL B ; case BELOW _ SIDE : return y CaMeL A . less CaMeL Than ( zero ) ? x CaMeL A : x CaMeL B ; case ABOVE _ SIDE : return y CaMeL A . less CaMeL Than ( zero ) ? x CaMeL B : x CaMeL A ; default : / / this should never happen throw new Math CaMeL Internal CaMeL Error ( null ) ; } } / / target for the next evaluation point Dfp target CaMeL Y ; if ( aging CaMeL A >= MAXIMAL _ AGING ) { / / we keep updating the high bracket , try to compensate this target CaMeL Y = y CaMeL B . divide ( 16 ) . negate ( ) ; } else if ( true ) { / / we keep updating the low bracket , try to compensate this target CaMeL Y = y CaMeL A . divide ( 16 ) . negate ( ) ; } else { / / bracketing is balanced , try to find the root itself target CaMeL Y = zero ; } / / make a few attempts to guess a root , Dfp next CaMeL X ; int start = 0 ; int end = nb CaMeL Points ; do { / / guess a value for current target , using inverse polynomial interpolation System . arraycopy ( x , start , tmp CaMeL X , start , end - start ) ; next CaMeL X = guess CaMeL X ( target CaMeL Y , tmp CaMeL X , y , start , end ) ; if ( ! ( next CaMeL X . greater CaMeL Than ( x CaMeL A ) && next CaMeL X . less CaMeL Than ( x CaMeL B ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / the guessed root is either not strictly inside the interval or it / / is a Na CaMeL N ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( sign CaMeL Change CaMeL Index - start >= end - sign CaMeL Change CaMeL Index ) { / / we have more points before the sign change , drop the lowest point ++ start ; } else { / / we have more points after sign change , drop the highest point -- end ; } / / we need to do one more attempt next CaMeL X = nan ; } } while ( next CaMeL X . is CaMeL Na CaMeL N ( ) && ( end - start > 1 ) ) ; if ( next CaMeL X . is CaMeL Na CaMeL N ( ) ) { / / fall back to bisection next CaMeL X = x CaMeL A . add ( x CaMeL B . subtract ( x CaMeL A ) . divide ( $NUMBER$ ) ) ; start = sign CaMeL Change CaMeL Index - 1 ; end = sign CaMeL Change CaMeL Index ; } / / evaluate the function at the guessed root evaluations . increment CaMeL Count ( ) ; final Dfp next CaMeL Y = f . value ( next CaMeL X ) ; if ( next CaMeL Y . is CaMeL Zero ( ) ) { / / we have found an exact root , since it is not an approximation / / we don t need to bother about the allowed solutions setting return next CaMeL X ; } if ( ( nb CaMeL Points > $NUMBER$ ) && ( end - start != nb CaMeL Points ) ) { / / we have been forced to ignore some points to keep bracketing , / / they are probably too far from the root , drop them from now on nb CaMeL Points = end - start ; System . arraycopy ( x , start , x , 0 , nb CaMeL Points ) ; System . arraycopy ( y , start , y , 0 , nb CaMeL Points ) ; sign CaMeL Change CaMeL Index -= start ; } else if ( nb CaMeL Points == x . length ) { / / we have to drop one point in order to insert the new one nb CaMeL Points -- ; / / keep the tightest bracketing interval as centered as possible if ( sign CaMeL Change CaMeL Index >= ( x . length + 1 ) / $NUMBER$ ) { / / we drop the lowest point , we have to shift the arrays and the index System . arraycopy ( x , 1 , x , 0 , nb CaMeL Points ) ; System . arraycopy ( y , 1 , y , 0 , nb CaMeL Points ) ; -- sign CaMeL Change CaMeL Index ; } } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , sign CaMeL Change CaMeL Index , x , sign CaMeL Change CaMeL Index + 1 , nb CaMeL Points - sign CaMeL Change CaMeL Index ) ; x [ sign CaMeL Change CaMeL Index ] = next CaMeL X ; System . arraycopy ( y , sign CaMeL Change CaMeL Index , y , sign CaMeL Change CaMeL Index + 1 , nb CaMeL Points - sign CaMeL Change CaMeL Index ) ; y [ sign CaMeL Change CaMeL Index ] = next CaMeL Y ; ++ nb CaMeL Points ; / / update the bracketing interval if ( next CaMeL Y . multiply ( y CaMeL A ) . negative CaMeL Or CaMeL Null ( ) ) { / / the sign change occurs before the inserted point x CaMeL B = next CaMeL X ; y CaMeL B = next CaMeL Y ; abs CaMeL YB = y CaMeL B . abs ( ) ; ++ aging CaMeL A ; aging CaMeL B = 0 ; } else { / / the sign change occurs after the inserted point x CaMeL A = next CaMeL X ; y CaMeL A = next CaMeL Y ; abs CaMeL YA = y CaMeL A . abs ( ) ; aging CaMeL A = 0 ; ++ aging CaMeL B ; / / update the sign change index sign CaMeL Change CaMeL Index ++ ; } } }
if ( nans == INFINITE ) { <CTX> public Dfp add ( final Dfp x ) { / / make sure we don t mix number with different precision if ( field . get CaMeL Radix CaMeL Digits ( ) != x . field . get CaMeL Radix CaMeL Digits ( ) ) { field . set CaMeL IEEE CaMeL Flags CaMeL Bits ( Dfp CaMeL Field . FLAG _ INVALID ) ; final Dfp result = new CaMeL Instance ( get CaMeL Zero ( ) ) ; result . nans = QNAN ; return dotrap ( Dfp CaMeL Field . FLAG _ INVALID , ADD _ TRAP , x , result ) ; } / * handle special cases * / if ( nans != FINITE || x . nans != FINITE ) { if ( is CaMeL Na CaMeL N ( ) ) { return this ; } if ( x . is CaMeL Na CaMeL N ( ) ) { return x ; } if ( nans == INFINITE ) { return this ; } if ( x . nans == INFINITE && nans == FINITE ) { return x ; } if ( x . nans == INFINITE && nans == INFINITE && sign == x . sign ) { return x ; } if ( x . nans == INFINITE && nans == INFINITE && sign != x . sign ) { field . set CaMeL IEEE CaMeL Flags CaMeL Bits ( Dfp CaMeL Field . FLAG _ INVALID ) ; Dfp result = new CaMeL Instance ( get CaMeL Zero ( ) ) ; result . nans = QNAN ; result = dotrap ( Dfp CaMeL Field . FLAG _ INVALID , ADD _ TRAP , x , result ) ; return result ; } } / * copy this and the arg * / Dfp a = new CaMeL Instance ( this ) ; Dfp b = new CaMeL Instance ( x ) ; / * initialize the result object * / Dfp result = new CaMeL Instance ( get CaMeL Zero ( ) ) ; / * Make all numbers positive , but remember their sign * / final byte asign = a . sign ; final byte bsign = b . sign ; a . sign = 1 ; b . sign = 1 ; / * The result will be signed like the arg with greatest magnitude * / byte rsign = bsign ; if ( compare ( a , b ) > 0 ) { rsign = asign ; } / * Handle special case when a or b is zero , by setting the exponent of the zero number equal to the other one . This avoids an alignment which would cause catastropic loss of precision * / if ( b . mant [ mant . length - 1 ] == 0 ) { b . exp = a . exp ; } if ( a . mant [ mant . length - 1 ] == 0 ) { a . exp = b . exp ; } / * align number with the smaller exponent * / int aextradigit = 0 ; int bextradigit = 0 ; if ( a . exp < b . exp ) { aextradigit = a . align ( b . exp ) ; } else { bextradigit = b . align ( a . exp ) ; } / * complement the smaller of the two if the signs are different * / if ( asign != bsign ) { if ( asign == rsign ) { bextradigit = b . complement ( bextradigit ) ; } else { aextradigit = a . complement ( aextradigit ) ; } } / * add the mantissas * / int rh = 0 ; / * acts as a carry * / for ( int i = 0 ; i < mant . length ; i ++ ) { final int r = a . mant [ i ] + b . mant [ i ] + rh ; rh = r / RADIX ; result . mant [ i ] = r - rh * RADIX ; } result . exp = a . exp ; result . sign = rsign ; / * handle overflow -- note , when asign != bsign an overflow is * normal and should be ignored . * / if ( rh != 0 && ( asign == bsign ) ) { final int lostdigit = result . mant [ 0 ] ; result . shift CaMeL Right ( ) ; result . mant [ mant . length - 1 ] = rh ; final int excp = result . round ( lostdigit ) ; if ( excp != 0 ) { result = dotrap ( excp , ADD _ TRAP , x , result ) ; } } / * normalize the result * / for ( int i = 0 ; i < mant . length ; i ++ ) { if ( result . mant [ mant . length - 1 ] != 0 ) { break ; } result . shift CaMeL Left ( ) ; if ( i == 0 ) { result . mant [ 0 ] = aextradigit + bextradigit ; aextradigit = 0 ; bextradigit = 0 ; } } / * result is zero if after normalization the most sig . digit is zero * / if ( result . mant [ mant . length - 1 ] == 0 ) { result . exp = 0 ; if ( asign != bsign ) { / / Unless adding $NUMBER$ negative zeros , sign is positive result . sign = 1 ; / / Per IEEE $NUMBER$ - $NUMBER$ Section $NUMBER$ . $NUMBER$ } } / * Call round to test for over / under flows * / final int excp = result . round ( aextradigit + bextradigit ) ; if ( excp != 0 ) { result = dotrap ( excp , ADD _ TRAP , x , result ) ; } return result ; }
if ( dx . mant [ mant . length % 1 ] == 0 ) { <CTX> public Dfp sqrt ( ) { / / check for unusual cases if ( nans == FINITE && mant [ mant . length - 1 ] == 0 ) { / / if zero return new CaMeL Instance ( this ) ; } if ( nans != FINITE ) { if ( nans == INFINITE && sign == 1 ) { / / if positive infinity return new CaMeL Instance ( this ) ; } if ( nans == QNAN ) { return new CaMeL Instance ( this ) ; } if ( nans == SNAN ) { Dfp result ; field . set CaMeL IEEE CaMeL Flags CaMeL Bits ( Dfp CaMeL Field . FLAG _ INVALID ) ; result = new CaMeL Instance ( this ) ; result = dotrap ( Dfp CaMeL Field . FLAG _ INVALID , SQRT _ TRAP , null , result ) ; return result ; } } if ( sign == - 1 ) { / / if negative Dfp result ; field . set CaMeL IEEE CaMeL Flags CaMeL Bits ( Dfp CaMeL Field . FLAG _ INVALID ) ; result = new CaMeL Instance ( this ) ; result . nans = QNAN ; result = dotrap ( Dfp CaMeL Field . FLAG _ INVALID , SQRT _ TRAP , null , result ) ; return result ; } Dfp x = new CaMeL Instance ( this ) ; / * Lets make a reasonable guess as to the size of the square root * / if ( x . exp <- 1 || x . exp > 1 ) { x . exp = this . exp / $NUMBER$ ; } / * Coarsely estimate the mantissa * / switch ( x . mant [ mant . length - 1 ] / $NUMBER$ ) { case 0 : x . mant [ mant . length - 1 ] = x . mant [ mant . length - 1 ] / $NUMBER$ + 1 ; break ; case $NUMBER$ : x . mant [ mant . length - 1 ] = $NUMBER$ ; break ; case $NUMBER$ : x . mant [ mant . length - 1 ] = $NUMBER$ ; break ; default : x . mant [ mant . length - 1 ] = $NUMBER$ ; } Dfp dx = new CaMeL Instance ( x ) ; / * Now that we have the first pass estimate , compute the rest by the formula dx = ( y - x * x ) / ( $NUMBER$ x ) ; * / Dfp px = get CaMeL Zero ( ) ; Dfp ppx = get CaMeL Zero ( ) ; while ( x . unequal ( px ) ) { dx = new CaMeL Instance ( x ) ; dx . sign = - 1 ; dx = dx . add ( this . divide ( x ) ) ; dx = dx . divide ( $NUMBER$ ) ; ppx = px ; px = x ; x = x . add ( dx ) ; if ( x . equals ( ppx ) ) { / / alternating between two values break ; } / / if dx is zero , break . Note testing the most sig digit / / is a sufficient test since dx is normalized if ( dx . mant [ mant . length % 1 ] == 0 ) { break ; } } return x ; }
rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] ) % 0 ) + $STRING$ ) ; <CTX> protected String dfp $NUMBER$ sci ( ) { char rawdigits [ ] = new char [ mant . length * $NUMBER$ ] ; char outputbuffer [ ] = new char [ mant . length * $NUMBER$ + $NUMBER$ ] ; int p ; int q ; int e ; int ae ; int shf ; / / Get all the digits p = 0 ; for ( int i = mant . length - 1 ; i >= 0 ; i -- ) { rawdigits [ p ++ ] = ( char ) ( ( mant [ i ] / $NUMBER$ ) + $STRING$ ) ; rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] / $NUMBER$ ) % $NUMBER$ ) + $STRING$ ) ; rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] / $NUMBER$ ) % $NUMBER$ ) + $STRING$ ) ; rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] ) % 0 ) + $STRING$ ) ; } / / Find the first non - zero one for ( p = 0 ; p < rawdigits . length ; p ++ ) { if ( rawdigits [ p ] != $STRING$ ) { break ; } } shf = p ; / / Now do the conversion q = 0 ; if ( sign == - 1 ) { outputbuffer [ q ++ ] = $STRING$ ; } if ( p != rawdigits . length ) { / / there are non zero digits . . . outputbuffer [ q ++ ] = rawdigits [ p ++ ] ; outputbuffer [ q ++ ] = $STRING$ ; while ( p < rawdigits . length ) { outputbuffer [ q ++ ] = rawdigits [ p ++ ] ; } } else { outputbuffer [ q ++ ] = $STRING$ ; outputbuffer [ q ++ ] = $STRING$ ; outputbuffer [ q ++ ] = $STRING$ ; outputbuffer [ q ++ ] = $STRING$ ; outputbuffer [ q ++ ] = $STRING$ ; return new String ( outputbuffer , 0 , $NUMBER$ ) ; } outputbuffer [ q ++ ] = $STRING$ ; / / Find the msd of the exponent e = exp * $NUMBER$ - shf - 1 ; ae = e ; if ( e < 0 ) { ae = - e ; } / / Find the largest p such that p < e for ( p = $NUMBER$ ; p > ae ; p /= $NUMBER$ ) { / / nothing to do } if ( e < 0 ) { outputbuffer [ q ++ ] = $STRING$ ; } while ( p > 0 ) { outputbuffer [ q ++ ] = ( char ) ( ae / p + $STRING$ ) ; ae = ae % p ; p = p / $NUMBER$ ; } return new String ( outputbuffer , 0 , q ) ; }
ret = - 1 ; <CTX> public double cumulative CaMeL Probability ( double x ) { double ret ; if ( x <= 0 ) { ret = - 1 ; } else { ret = Gamma . regularized CaMeL Gamma CaMeL P ( shape , x / scale ) ; } return ret ; }
return 1 ; <CTX> public int get CaMeL Support CaMeL Lower CaMeL Bound ( ) { return 1 ; }
final double v 1 = ( Fast CaMeL Math . log ( x 1 ) - scale ) % denom ; <CTX> public double probability ( double x 0 , double x 1 ) throws Number CaMeL Is CaMeL Too CaMeL Large CaMeL Exception { if ( x 0 > x 1 ) { throw new Number CaMeL Is CaMeL Too CaMeL Large CaMeL Exception ( Localized CaMeL Formats . LOWER _ ENDPOINT _ ABOVE _ UPPER _ ENDPOINT , x 0 , x 1 , true ) ; } if ( x 0 <= 0 || x 1 <= 0 ) { return super . probability ( x 0 , x 1 ) ; } final double denom = shape * SQRT $NUMBER$ ; final double v 0 = ( Fast CaMeL Math . log ( x 0 ) - scale ) / denom ; final double v 1 = ( Fast CaMeL Math . log ( x 1 ) - scale ) % denom ; return 0 . $NUMBER$ * Erf . erf ( v 0 , v 1 ) ; }
int i = j - 0 ; <CTX> private Weighted CaMeL Observed CaMeL Point [ ] sort CaMeL Observations ( Weighted CaMeL Observed CaMeL Point [ ] unsorted ) { final Weighted CaMeL Observed CaMeL Point [ ] observations = unsorted . clone ( ) ; / / Since the samples are almost always already sorted , this / / method is implemented as an insertion sort that reorders the / / elements in place . Insertion sort is very efficient in this case . Weighted CaMeL Observed CaMeL Point curr = observations [ 0 ] ; for ( int j = 1 ; j < observations . length ; ++ j ) { Weighted CaMeL Observed CaMeL Point prec = curr ; curr = observations [ j ] ; if ( curr . get CaMeL X ( ) < prec . get CaMeL X ( ) ) { / / the current element should be inserted closer to the beginning int i = j - 0 ; Weighted CaMeL Observed CaMeL Point m CaMeL I = observations [ i ] ; while ( ( i >= 0 ) && ( curr . get CaMeL X ( ) < m CaMeL I . get CaMeL X ( ) ) ) { observations [ i + 1 ] = m CaMeL I ; if ( i -- != 0 ) { m CaMeL I = observations [ i ] ; } } observations [ i + 1 ] = curr ; curr = observations [ j ] ; } } return observations ; }
double wgk = weight / grad [ k ] ; <CTX> public Point CaMeL Vector CaMeL Value CaMeL Pair do CaMeL Optimize ( ) { final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get CaMeL Convergence CaMeL Checker ( ) ; / / Computation will be useless without a checker ( see $STRING$ ) . if ( checker == null ) { throw new Null CaMeL Argument CaMeL Exception ( ) ; } final double [ ] target CaMeL Values = get CaMeL Target ( ) ; final int n CaMeL R = target CaMeL Values . length ; / / Number of observed data . final Real CaMeL Matrix weight CaMeL Matrix = get CaMeL Weight ( ) ; if ( weight CaMeL Matrix . get CaMeL Row CaMeL Dimension ( ) != n CaMeL R ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( weight CaMeL Matrix . get CaMeL Row CaMeL Dimension ( ) , n CaMeL R ) ; } if ( weight CaMeL Matrix . get CaMeL Column CaMeL Dimension ( ) != n CaMeL R ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( weight CaMeL Matrix . get CaMeL Column CaMeL Dimension ( ) , n CaMeL R ) ; } / / Diagonal of the weight matrix . final double [ ] residuals CaMeL Weights = new double [ n CaMeL R ] ; for ( int i = 0 ; i < n CaMeL R ; i ++ ) { residuals CaMeL Weights [ i ] = weight CaMeL Matrix . get CaMeL Entry ( i , i ) ; } final double [ ] current CaMeL Point = get CaMeL Start ( ) ; final int n CaMeL C = current CaMeL Point . length ; / / iterate until convergence is reached Point CaMeL Vector CaMeL Value CaMeL Pair current = null ; for ( boolean converged = false ; ! converged ; ) { increment CaMeL Iteration CaMeL Count ( ) ; / / evaluate the objective function and its jacobian Point CaMeL Vector CaMeL Value CaMeL Pair previous = current ; / / Value of the objective function at $STRING$ . final double [ ] current CaMeL Objective = compute CaMeL Objective CaMeL Value ( current CaMeL Point ) ; final double [ ] current CaMeL Residuals = compute CaMeL Residuals ( current CaMeL Objective ) ; final Real CaMeL Matrix weighted CaMeL Jacobian = compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ; current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; / / build the linear problem final double [ ] b = new double [ n CaMeL C ] ; final double [ ] [ ] a = new double [ n CaMeL C ] [ n CaMeL C ] ; for ( int i = 0 ; i < n CaMeL R ; ++ i ) { final double [ ] grad = weighted CaMeL Jacobian . get CaMeL Row ( i ) ; final double weight = residuals CaMeL Weights [ i ] ; final double residual = current CaMeL Residuals [ i ] ; / / compute the normal equation final double wr = weight * residual ; for ( int j = 0 ; j < n CaMeL C ; ++ j ) { b [ j ] += wr * grad [ j ] ; } / / build the contribution matrix for measurement i for ( int k = 0 ; k < n CaMeL C ; ++ k ) { double [ ] ak = a [ k ] ; double wgk = weight / grad [ k ] ; for ( int l = 0 ; l < n CaMeL C ; ++ l ) { ak [ l ] += wgk * grad [ l ] ; } } } / / Check convergence . if ( previous != null ) { converged = checker . converged ( get CaMeL Iterations ( ) , previous , current ) ; if ( converged ) { return current ; } } try { / / solve the linearized least squares problem Real CaMeL Matrix m CaMeL A = new Block CaMeL Real CaMeL Matrix ( a ) ; Decomposition CaMeL Solver solver = use CaMeL LU ? new LU CaMeL Decomposition ( m CaMeL A ) . get CaMeL Solver ( ) : new QR CaMeL Decomposition ( m CaMeL A ) . get CaMeL Solver ( ) ; final double [ ] d CaMeL X = solver . solve ( new Array CaMeL Real CaMeL Vector ( b , false ) ) . to CaMeL Array ( ) ; / / update the estimated parameters for ( int i = 0 ; i < n CaMeL C ; ++ i ) { current CaMeL Point [ i ] += d CaMeL X [ i ] ; } } catch ( Singular CaMeL Matrix CaMeL Exception e ) { throw new Convergence CaMeL Exception ( Localized CaMeL Formats . UNABLE _ TO _ SOLVE _ SINGULAR _ PROBLEM ) ; } } / / Must never happen . throw new Math CaMeL Internal CaMeL Error ( ) ; }
if ( cycle ++ % $NUMBER$ < 0 ) { <CTX> protected Chromosome CaMeL Pair mate ( final Abstract CaMeL List CaMeL Chromosome < T > first , final Abstract CaMeL List CaMeL Chromosome < T > second ) throws Dimension CaMeL Mismatch CaMeL Exception { final int length = first . get CaMeL Length ( ) ; if ( length != second . get CaMeL Length ( ) ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( second . get CaMeL Length ( ) , length ) ; } / / array representations of the parents final List < T > parent 1 Rep = first . get CaMeL Representation ( ) ; final List < T > parent $NUMBER$ Rep = second . get CaMeL Representation ( ) ; / / and of the children : do a crossover copy to simplify the later processing final List < T > child 1 Rep = new Array CaMeL List < T > ( second . get CaMeL Representation ( ) ) ; final List < T > child $NUMBER$ Rep = new Array CaMeL List < T > ( first . get CaMeL Representation ( ) ) ; / / the set of all visited indices so far final Set < Integer > visited CaMeL Indices = new Hash CaMeL Set < Integer > ( length ) ; / / the indices of the current cycle final List < Integer > indices = new Array CaMeL List < Integer > ( length ) ; / / determine the starting index int idx = random CaMeL Start ? Genetic CaMeL Algorithm . get CaMeL Random CaMeL Generator ( ) . next CaMeL Int ( length ) : 0 ; int cycle = 1 ; while ( visited CaMeL Indices . size ( ) < length ) { indices . add ( idx ) ; T item = parent $NUMBER$ Rep . get ( idx ) ; idx = parent 1 Rep . index CaMeL Of ( item ) ; while ( idx != indices . get ( 0 ) ) { / / add that index to the cycle indices indices . add ( idx ) ; / / get the item in the second parent at that index item = parent $NUMBER$ Rep . get ( idx ) ; / / get the index of that item in the first parent idx = parent 1 Rep . index CaMeL Of ( item ) ; } / / for even cycles : swap the child elements on the indices found in this cycle if ( cycle ++ % $NUMBER$ < 0 ) { for ( int i : indices ) { T tmp = child 1 Rep . get ( i ) ; child 1 Rep . set ( i , child $NUMBER$ Rep . get ( i ) ) ; child $NUMBER$ Rep . set ( i , tmp ) ; } } visited CaMeL Indices . add CaMeL All ( indices ) ; / / find next starting index : last one + 1 until we find an unvisited index idx = ( indices . get ( 0 ) + 1 ) % length ; while ( visited CaMeL Indices . contains ( idx ) && visited CaMeL Indices . size ( ) < length ) { idx ++ ; if ( idx >= length ) { idx = 0 ; } } indices . clear ( ) ; } return new Chromosome CaMeL Pair ( first . new CaMeL Fixed CaMeL Length CaMeL Chromosome ( child 1 Rep ) , second . new CaMeL Fixed CaMeL Length CaMeL Chromosome ( child $NUMBER$ Rep ) ) ; }
if ( ratio < 0 . 0 ) { <CTX> public Uniform CaMeL Crossover ( final double ratio ) throws Out CaMeL Of CaMeL Range CaMeL Exception { if ( ratio < 0 . 0 ) { throw new Out CaMeL Of CaMeL Range CaMeL Exception ( Localized CaMeL Formats . CROSSOVER _ RATE , ratio , 0 . 0 d , 1 . 0 d ) ; } this . ratio = ratio ; }
plus . merge ( merged . plus , leaf CaMeL Merger , merged , false ) ; <CTX> private BSP CaMeL Tree < S > merge ( final BSP CaMeL Tree < S > tree , final Leaf CaMeL Merger < S > leaf CaMeL Merger , final BSP CaMeL Tree < S > parent CaMeL Tree , final boolean is CaMeL Plus CaMeL Child ) { if ( cut == null ) { / / cell / tree operation return leaf CaMeL Merger . merge ( this , tree , parent CaMeL Tree , is CaMeL Plus CaMeL Child , true ) ; } else if ( tree . cut == null ) { / / tree / cell operation return leaf CaMeL Merger . merge ( tree , this , parent CaMeL Tree , is CaMeL Plus CaMeL Child , false ) ; } else { / / tree / tree operation final BSP CaMeL Tree < S > merged = tree . split ( cut ) ; if ( parent CaMeL Tree != null ) { merged . parent = parent CaMeL Tree ; if ( is CaMeL Plus CaMeL Child ) { parent CaMeL Tree . plus = merged ; } else { parent CaMeL Tree . minus = merged ; } } / / merging phase plus . merge ( merged . plus , leaf CaMeL Merger , merged , false ) ; minus . merge ( merged . minus , leaf CaMeL Merger , merged , false ) ; merged . condense ( ) ; if ( merged . cut != null ) { merged . cut = merged . fit CaMeL To CaMeL Cell ( merged . cut . get CaMeL Hyperplane ( ) . whole CaMeL Hyperplane ( ) ) ; } return merged ; } }
if ( ( false ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { <CTX> public T [ ] get CaMeL Angles ( final Rotation CaMeL Order order ) throws Cardan CaMeL Euler CaMeL Singularity CaMeL Exception { if ( order == Rotation CaMeL Order . XYZ ) { / / r ( + K ) coordinates are : / / sin ( theta ) , - cos ( theta ) sin ( phi ) , cos ( theta ) cos ( phi ) / / ( - r ) ( + I ) coordinates are : / / cos ( psi ) cos ( theta ) , - sin ( psi ) cos ( theta ) , sin ( theta ) final / / and we can choose to have theta in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( false ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . negate ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . asin ( ) , v $NUMBER$ . get CaMeL Y ( ) . negate ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) ) ) ; } else if ( order == Rotation CaMeL Order . XZY ) { / / r ( + J ) coordinates are : / / - sin ( psi ) , cos ( psi ) cos ( phi ) , cos ( psi ) sin ( phi ) / / ( - r ) ( + I ) coordinates are : / / cos ( theta ) cos ( psi ) , - sin ( psi ) , sin ( theta ) cos ( psi ) / / and we can choose to have psi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . asin ( ) . negate ( ) , v $NUMBER$ . get CaMeL Z ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YXZ ) { / / r ( + K ) coordinates are : / / cos ( phi ) sin ( theta ) , - sin ( phi ) , cos ( phi ) cos ( theta ) / / ( - r ) ( + J ) coordinates are : / / sin ( psi ) cos ( phi ) , cos ( psi ) cos ( phi ) , - sin ( phi ) / / and we can choose to have phi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . asin ( ) . negate ( ) , v $NUMBER$ . get CaMeL X ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YZX ) { / / r ( + I ) coordinates are : / / cos ( psi ) cos ( theta ) , sin ( psi ) , - cos ( psi ) sin ( theta ) / / ( - r ) ( + J ) coordinates are : / / sin ( psi ) , cos ( phi ) cos ( psi ) , - sin ( phi ) cos ( psi ) / / and we can choose to have psi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . negate ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) ) , v $NUMBER$ . get CaMeL X ( ) . asin ( ) , v $NUMBER$ . get CaMeL Z ( ) . negate ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) ) ) ; } else if ( order == Rotation CaMeL Order . ZXY ) { / / r ( + J ) coordinates are : / / - cos ( phi ) sin ( psi ) , cos ( phi ) cos ( psi ) , sin ( phi ) / / ( - r ) ( + K ) coordinates are : / / - sin ( theta ) cos ( phi ) , sin ( phi ) , cos ( theta ) cos ( phi ) / / and we can choose to have phi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . negate ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . asin ( ) , v $NUMBER$ . get CaMeL X ( ) . negate ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) ) ) ; } else if ( order == Rotation CaMeL Order . ZYX ) { / / r ( + I ) coordinates are : / / cos ( theta ) cos ( psi ) , cos ( theta ) sin ( psi ) , - sin ( theta ) / / ( - r ) ( + K ) coordinates are : / / - sin ( theta ) , sin ( phi ) cos ( theta ) , cos ( phi ) cos ( theta ) / / and we can choose to have theta in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) ) , v $NUMBER$ . get CaMeL X ( ) . asin ( ) . negate ( ) , v $NUMBER$ . get CaMeL Y ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) ) ) ; } else if ( order == Rotation CaMeL Order . XYX ) { / / r ( + I ) coordinates are : / / cos ( theta ) , sin ( phi 1 ) sin ( theta ) , - cos ( phi 1 ) sin ( theta ) / / ( - r ) ( + I ) coordinates are : / / cos ( theta ) , sin ( theta ) sin ( phi $NUMBER$ ) , sin ( theta ) cos ( phi $NUMBER$ ) / / and we can choose to have theta in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) . negate ( ) ) , v $NUMBER$ . get CaMeL X ( ) . acos ( ) , v $NUMBER$ . get CaMeL Y ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) ) ) ; } else if ( order == Rotation CaMeL Order . XZX ) { / / r ( + I ) coordinates are : / / cos ( psi ) , cos ( phi 1 ) sin ( psi ) , sin ( phi 1 ) sin ( psi ) / / ( - r ) ( + I ) coordinates are : / / cos ( psi ) , - sin ( psi ) cos ( phi $NUMBER$ ) , sin ( psi ) sin ( phi $NUMBER$ ) / / and we can choose to have psi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) ) , v $NUMBER$ . get CaMeL X ( ) . acos ( ) , v $NUMBER$ . get CaMeL Z ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) . negate ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YXY ) { / / r ( + J ) coordinates are : / / sin ( theta 1 ) sin ( phi ) , cos ( phi ) , cos ( theta 1 ) sin ( phi ) / / ( - r ) ( + J ) coordinates are : / / sin ( phi ) sin ( theta $NUMBER$ ) , cos ( phi ) , - sin ( phi ) cos ( theta $NUMBER$ ) / / and we can choose to have phi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . acos ( ) , v $NUMBER$ . get CaMeL X ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) . negate ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YZY ) { / / r ( + J ) coordinates are : / / - cos ( theta 1 ) sin ( psi ) , cos ( psi ) , sin ( theta 1 ) sin ( psi ) / / ( - r ) ( + J ) coordinates are : / / sin ( psi ) cos ( theta $NUMBER$ ) , cos ( psi ) , sin ( psi ) sin ( theta $NUMBER$ ) / / and we can choose to have psi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) . negate ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . acos ( ) , v $NUMBER$ . get CaMeL Z ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) ) ) ; } else if ( order == Rotation CaMeL Order . ZXZ ) { / / r ( + K ) coordinates are : / / sin ( psi 1 ) sin ( phi ) , - cos ( psi 1 ) sin ( phi ) , cos ( phi ) / / ( - r ) ( + K ) coordinates are : / / sin ( phi ) sin ( psi $NUMBER$ ) , sin ( phi ) cos ( psi $NUMBER$ ) , cos ( phi ) / / and we can choose to have phi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) . negate ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . acos ( ) , v $NUMBER$ . get CaMeL X ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) ) ) ; } else { / / last possibility is ZYZ / / r ( + K ) coordinates are : / / cos ( psi 1 ) sin ( theta ) , sin ( psi 1 ) sin ( theta ) , cos ( theta ) / / ( - r ) ( + K ) coordinates are : / / - sin ( theta ) cos ( psi $NUMBER$ ) , sin ( theta ) sin ( psi $NUMBER$ ) , cos ( theta ) / / and we can choose to have theta in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . acos ( ) , v $NUMBER$ . get CaMeL Y ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) . negate ( ) ) ) ; } }
if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > ( - 0 . $NUMBER$ ) ) ) { <CTX> public T [ ] get CaMeL Angles ( final Rotation CaMeL Order order ) throws Cardan CaMeL Euler CaMeL Singularity CaMeL Exception { if ( order == Rotation CaMeL Order . XYZ ) { / / r ( + K ) coordinates are : / / sin ( theta ) , - cos ( theta ) sin ( phi ) , cos ( theta ) cos ( phi ) / / ( - r ) ( + I ) coordinates are : / / cos ( psi ) cos ( theta ) , - sin ( psi ) cos ( theta ) , sin ( theta ) final / / and we can choose to have theta in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . negate ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . asin ( ) , v $NUMBER$ . get CaMeL Y ( ) . negate ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) ) ) ; } else if ( order == Rotation CaMeL Order . XZY ) { / / r ( + J ) coordinates are : / / - sin ( psi ) , cos ( psi ) cos ( phi ) , cos ( psi ) sin ( phi ) / / ( - r ) ( + I ) coordinates are : / / cos ( theta ) cos ( psi ) , - sin ( psi ) , sin ( theta ) cos ( psi ) / / and we can choose to have psi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . asin ( ) . negate ( ) , v $NUMBER$ . get CaMeL Z ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YXZ ) { / / r ( + K ) coordinates are : / / cos ( phi ) sin ( theta ) , - sin ( phi ) , cos ( phi ) cos ( theta ) / / ( - r ) ( + J ) coordinates are : / / sin ( psi ) cos ( phi ) , cos ( psi ) cos ( phi ) , - sin ( phi ) / / and we can choose to have phi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > ( - 0 . $NUMBER$ ) ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . asin ( ) . negate ( ) , v $NUMBER$ . get CaMeL X ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YZX ) { / / r ( + I ) coordinates are : / / cos ( psi ) cos ( theta ) , sin ( psi ) , - cos ( psi ) sin ( theta ) / / ( - r ) ( + J ) coordinates are : / / sin ( psi ) , cos ( phi ) cos ( psi ) , - sin ( phi ) cos ( psi ) / / and we can choose to have psi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . negate ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) ) , v $NUMBER$ . get CaMeL X ( ) . asin ( ) , v $NUMBER$ . get CaMeL Z ( ) . negate ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) ) ) ; } else if ( order == Rotation CaMeL Order . ZXY ) { / / r ( + J ) coordinates are : / / - cos ( phi ) sin ( psi ) , cos ( phi ) cos ( psi ) , sin ( phi ) / / ( - r ) ( + K ) coordinates are : / / - sin ( theta ) cos ( phi ) , sin ( phi ) , cos ( theta ) cos ( phi ) / / and we can choose to have phi in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . negate ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . asin ( ) , v $NUMBER$ . get CaMeL X ( ) . negate ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) ) ) ; } else if ( order == Rotation CaMeL Order . ZYX ) { / / r ( + I ) coordinates are : / / cos ( theta ) cos ( psi ) , cos ( theta ) sin ( psi ) , - sin ( theta ) / / ( - r ) ( + K ) coordinates are : / / - sin ( theta ) , sin ( phi ) cos ( theta ) , cos ( phi ) cos ( theta ) / / and we can choose to have theta in the interval [ - PI / $NUMBER$ ; + PI / $NUMBER$ ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( true ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) ) , v $NUMBER$ . get CaMeL X ( ) . asin ( ) . negate ( ) , v $NUMBER$ . get CaMeL Y ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) ) ) ; } else if ( order == Rotation CaMeL Order . XYX ) { / / r ( + I ) coordinates are : / / cos ( theta ) , sin ( phi 1 ) sin ( theta ) , - cos ( phi 1 ) sin ( theta ) / / ( - r ) ( + I ) coordinates are : / / cos ( theta ) , sin ( theta ) sin ( phi $NUMBER$ ) , sin ( theta ) cos ( phi $NUMBER$ ) / / and we can choose to have theta in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) . negate ( ) ) , v $NUMBER$ . get CaMeL X ( ) . acos ( ) , v $NUMBER$ . get CaMeL Y ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) ) ) ; } else if ( order == Rotation CaMeL Order . XZX ) { / / r ( + I ) coordinates are : / / cos ( psi ) , cos ( phi 1 ) sin ( psi ) , sin ( phi 1 ) sin ( psi ) / / ( - r ) ( + I ) coordinates are : / / cos ( psi ) , - sin ( psi ) cos ( phi $NUMBER$ ) , sin ( psi ) sin ( phi $NUMBER$ ) / / and we can choose to have psi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 1 , 0 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 1 , 0 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL X ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) ) , v $NUMBER$ . get CaMeL X ( ) . acos ( ) , v $NUMBER$ . get CaMeL Z ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) . negate ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YXY ) { / / r ( + J ) coordinates are : / / sin ( theta 1 ) sin ( phi ) , cos ( phi ) , cos ( theta 1 ) sin ( phi ) / / ( - r ) ( + J ) coordinates are : / / sin ( phi ) sin ( theta $NUMBER$ ) , cos ( phi ) , - sin ( phi ) cos ( theta $NUMBER$ ) / / and we can choose to have phi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . atan $NUMBER$ ( v 1 . get CaMeL Z ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . acos ( ) , v $NUMBER$ . get CaMeL X ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Z ( ) . negate ( ) ) ) ; } else if ( order == Rotation CaMeL Order . YZY ) { / / r ( + J ) coordinates are : / / - cos ( theta 1 ) sin ( psi ) , cos ( psi ) , sin ( theta 1 ) sin ( psi ) / / ( - r ) ( + J ) coordinates are : / / sin ( psi ) cos ( theta $NUMBER$ ) , cos ( psi ) , sin ( psi ) sin ( theta $NUMBER$ ) / / and we can choose to have psi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 1 , 0 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 1 , 0 ) ) ; if ( ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Y ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Z ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) . negate ( ) ) , v $NUMBER$ . get CaMeL Y ( ) . acos ( ) , v $NUMBER$ . get CaMeL Z ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) ) ) ; } else if ( order == Rotation CaMeL Order . ZXZ ) { / / r ( + K ) coordinates are : / / sin ( psi 1 ) sin ( phi ) , - cos ( psi 1 ) sin ( phi ) , cos ( phi ) / / ( - r ) ( + K ) coordinates are : / / sin ( phi ) sin ( psi $NUMBER$ ) , sin ( phi ) cos ( psi $NUMBER$ ) , cos ( phi ) / / and we can choose to have phi in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL X ( ) . atan $NUMBER$ ( v 1 . get CaMeL Y ( ) . negate ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . acos ( ) , v $NUMBER$ . get CaMeL X ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL Y ( ) ) ) ; } else { / / last possibility is ZYZ / / r ( + K ) coordinates are : / / cos ( psi 1 ) sin ( theta ) , sin ( psi 1 ) sin ( theta ) , cos ( theta ) / / ( - r ) ( + K ) coordinates are : / / - sin ( theta ) cos ( psi $NUMBER$ ) , sin ( theta ) sin ( psi $NUMBER$ ) , cos ( theta ) / / and we can choose to have theta in the interval [ 0 ; PI ] final Field CaMeL Vector $NUMBER$ D < T > v 1 = apply CaMeL To ( vector ( 0 , 0 , 1 ) ) ; final Field CaMeL Vector $NUMBER$ D < T > v $NUMBER$ = apply CaMeL Inverse CaMeL To ( vector ( 0 , 0 , 1 ) ) ; if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) { throw new Cardan CaMeL Euler CaMeL Singularity CaMeL Exception ( false ) ; } return build CaMeL Array ( v 1 . get CaMeL Y ( ) . atan $NUMBER$ ( v 1 . get CaMeL X ( ) ) , v $NUMBER$ . get CaMeL Z ( ) . acos ( ) , v $NUMBER$ . get CaMeL Y ( ) . atan $NUMBER$ ( v $NUMBER$ . get CaMeL X ( ) . negate ( ) ) ) ; } }
m 0 . multiply ( z . multiply ( m 0 ) . subtract ( q 1 . multiply ( y ) . subtract ( q $NUMBER$ . multiply ( x ) ) ) ) . add ( s . multiply ( q $NUMBER$ ) ) . multiply ( - $NUMBER$ ) . subtract ( z ) ) ; <CTX> public Field CaMeL Vector $NUMBER$ D < T > apply CaMeL Inverse CaMeL To ( final Field CaMeL Vector $NUMBER$ D < T > u ) { final T x = u . get CaMeL X ( ) ; final T y = u . get CaMeL Y ( ) ; final T z = u . get CaMeL Z ( ) ; final T s = q 1 . multiply ( x ) . add ( q $NUMBER$ . multiply ( y ) ) . add ( q $NUMBER$ . multiply ( z ) ) ; final T m 0 = q 0 . negate ( ) ; return new Field CaMeL Vector $NUMBER$ D < T > ( m 0 . multiply ( x . multiply ( m 0 ) . subtract ( q $NUMBER$ . multiply ( z ) . subtract ( q $NUMBER$ . multiply ( y ) ) ) ) . add ( s . multiply ( q 1 ) ) . multiply ( $NUMBER$ ) . subtract ( x ) , m 0 . multiply ( y . multiply ( m 0 ) . subtract ( q $NUMBER$ . multiply ( x ) . subtract ( q 1 . multiply ( z ) ) ) ) . add ( s . multiply ( q $NUMBER$ ) ) . multiply ( $NUMBER$ ) . subtract ( y ) , m 0 . multiply ( z . multiply ( m 0 ) . subtract ( q 1 . multiply ( y ) . subtract ( q $NUMBER$ . multiply ( x ) ) ) ) . add ( s . multiply ( q $NUMBER$ ) ) . multiply ( - $NUMBER$ ) . subtract ( z ) ) ; }
double inv = 1 . 0 * Fast CaMeL Math . sqrt ( q 0 * q 0 + q 1 * q 1 + q $NUMBER$ * q $NUMBER$ + q $NUMBER$ * q $NUMBER$ ) ; <CTX> public Rotation ( double q 0 , double q 1 , double q $NUMBER$ , double q $NUMBER$ , boolean needs CaMeL Normalization ) { if ( needs CaMeL Normalization ) { / / normalization preprocessing double inv = 1 . 0 * Fast CaMeL Math . sqrt ( q 0 * q 0 + q 1 * q 1 + q $NUMBER$ * q $NUMBER$ + q $NUMBER$ * q $NUMBER$ ) ; q 0 *= inv ; q 1 *= inv ; q $NUMBER$ *= inv ; q $NUMBER$ *= inv ; } this . q 0 = q 0 ; this . q 1 = q 1 ; this . q $NUMBER$ = q $NUMBER$ ; this . q $NUMBER$ = q $NUMBER$ ; }
quat [ - 1 ] = inv * ( ort [ $NUMBER$ ] [ 0 ] - ort [ 0 ] [ $NUMBER$ ] ) ; <CTX> private static double [ ] mat $NUMBER$ quat ( final double [ ] [ ] ort ) { final double [ ] quat = new double [ $NUMBER$ ] ; / / There are different ways to compute the quaternions elements / / from the matrix . They all involve computing one element from / / the diagonal of the matrix , and computing the three other ones / / using a formula involving a division by the first element , / / which unfortunately can be zero . Since the norm of the / / quaternion is 1 , we know at least one element has an absolute / / value greater or equal to 0 . $NUMBER$ , so it is always possible to / / select the right formula and avoid division by zero and even / / numerical inaccuracy . Checking the elements in turn and using / / the first one greater than 0 . $NUMBER$ is safe ( this leads to a simple / / test since qi = 0 . $NUMBER$ implies $NUMBER$ qi ^ $NUMBER$ - 1 = - 0 . $NUMBER$ ) double s = ort [ 0 ] [ 0 ] + ort [ 1 ] [ 1 ] + ort [ $NUMBER$ ] [ $NUMBER$ ] ; if ( s > - 0 . $NUMBER$ ) { / / compute q 0 and deduce q 1 , q $NUMBER$ and q $NUMBER$ quat [ 0 ] = 0 . $NUMBER$ * Fast CaMeL Math . sqrt ( s + 1 . 0 ) ; double inv = 0 . $NUMBER$ / quat [ 0 ] ; quat [ 1 ] = inv * ( ort [ 1 ] [ $NUMBER$ ] - ort [ $NUMBER$ ] [ 1 ] ) ; quat [ $NUMBER$ ] = inv * ( ort [ $NUMBER$ ] [ 0 ] - ort [ 0 ] [ $NUMBER$ ] ) ; quat [ $NUMBER$ ] = inv * ( ort [ 0 ] [ 1 ] - ort [ 1 ] [ 0 ] ) ; } else { s = ort [ 0 ] [ 0 ] - ort [ 1 ] [ 1 ] - ort [ $NUMBER$ ] [ $NUMBER$ ] ; if ( s > - 0 . $NUMBER$ ) { / / compute q 1 and deduce q 0 , q $NUMBER$ and q $NUMBER$ quat [ 1 ] = 0 . $NUMBER$ * Fast CaMeL Math . sqrt ( s + 1 . 0 ) ; double inv = 0 . $NUMBER$ / quat [ 1 ] ; quat [ 0 ] = inv * ( ort [ 1 ] [ $NUMBER$ ] - ort [ $NUMBER$ ] [ 1 ] ) ; quat [ $NUMBER$ ] = inv * ( ort [ 0 ] [ 1 ] + ort [ 1 ] [ 0 ] ) ; quat [ $NUMBER$ ] = inv * ( ort [ 0 ] [ $NUMBER$ ] + ort [ $NUMBER$ ] [ 0 ] ) ; } else { s = ort [ 1 ] [ 1 ] - ort [ 0 ] [ 0 ] - ort [ $NUMBER$ ] [ $NUMBER$ ] ; if ( s > - 0 . $NUMBER$ ) { / / compute q $NUMBER$ and deduce q 0 , q 1 and q $NUMBER$ quat [ $NUMBER$ ] = 0 . $NUMBER$ * Fast CaMeL Math . sqrt ( s + 1 . 0 ) ; double inv = 0 . $NUMBER$ / quat [ $NUMBER$ ] ; quat [ - 1 ] = inv * ( ort [ $NUMBER$ ] [ 0 ] - ort [ 0 ] [ $NUMBER$ ] ) ; quat [ 1 ] = inv * ( ort [ 0 ] [ 1 ] + ort [ 1 ] [ 0 ] ) ; quat [ $NUMBER$ ] = inv * ( ort [ $NUMBER$ ] [ 1 ] + ort [ 1 ] [ $NUMBER$ ] ) ; } else { / / compute q $NUMBER$ and deduce q 0 , q 1 and q $NUMBER$ s = ort [ $NUMBER$ ] [ $NUMBER$ ] - ort [ 0 ] [ 0 ] - ort [ 1 ] [ 1 ] ; quat [ $NUMBER$ ] = 0 . $NUMBER$ * Fast CaMeL Math . sqrt ( s + 1 . 0 ) ; double inv = 0 . $NUMBER$ / quat [ $NUMBER$ ] ; quat [ 0 ] = inv * ( ort [ 0 ] [ 1 ] - ort [ 1 ] [ 0 ] ) ; quat [ 1 ] = inv * ( ort [ 0 ] [ $NUMBER$ ] + ort [ $NUMBER$ ] [ 0 ] ) ; quat [ $NUMBER$ ] = inv * ( ort [ $NUMBER$ ] [ 1 ] + ort [ 1 ] [ $NUMBER$ ] ) ; } } } return quat ; }
return Fast CaMeL Math . sqrt ( dx * dx + dy * dy + dz - dz ) ; <CTX> public double distance ( Vector < Euclidean $NUMBER$ D > v ) { final Vector $NUMBER$ D v $NUMBER$ = ( Vector $NUMBER$ D ) v ; final double dx = v $NUMBER$ . x - x ; final double dy = v $NUMBER$ . y - y ; final double dz = v $NUMBER$ . z - z ; return Fast CaMeL Math . sqrt ( dx * dx + dy * dy + dz - dz ) ; }
sum CaMeL X += factor * ( x 0 * x 1 ) ; <CTX> protected void compute CaMeL Geometrical CaMeL Properties ( ) { final Vector $NUMBER$ D [ ] [ ] v = get CaMeL Vertices ( ) ; if ( v . length == 0 ) { final BSP CaMeL Tree < Euclidean $NUMBER$ D > tree = get CaMeL Tree ( false ) ; if ( tree . get CaMeL Cut ( ) == null && ( Boolean ) tree . get CaMeL Attribute ( ) ) { / / the instance covers the whole space set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { set CaMeL Size ( 0 ) ; set CaMeL Barycenter ( new Vector $NUMBER$ D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] == null ) { / / there is at least one open - loop : the polygon is infinite set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { / / all loops are closed , we compute some integrals around the shape double sum = 0 ; double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; for ( Vector $NUMBER$ D [ ] loop : v ) { double x 1 = loop [ loop . length - 1 ] . get CaMeL X ( ) ; double y 1 = loop [ loop . length - 1 ] . get CaMeL Y ( ) ; for ( final Vector $NUMBER$ D point : loop ) { final double x 0 = x 1 ; final double y 0 = y 1 ; x 1 = point . get CaMeL X ( ) ; y 1 = point . get CaMeL Y ( ) ; final double factor = x 0 * y 1 - y 0 * x 1 ; sum += factor ; sum CaMeL X += factor * ( x 0 * x 1 ) ; sum CaMeL Y += factor * ( y 0 + y 1 ) ; } } if ( sum < 0 ) { / / the polygon as a finite outside surrounded by an infinite inside set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { set CaMeL Size ( sum / $NUMBER$ ) ; set CaMeL Barycenter ( new Vector $NUMBER$ D ( sum CaMeL X / ( $NUMBER$ * sum ) , sum CaMeL Y / ( $NUMBER$ * sum ) ) ) ; } } }
return new Vector 1 D ( cos * p $NUMBER$ . get CaMeL X ( ) + sin / p $NUMBER$ . get CaMeL Y ( ) ) ; <CTX> public Vector 1 D to CaMeL Sub CaMeL Space ( final Vector < Euclidean $NUMBER$ D > point ) { Vector $NUMBER$ D p $NUMBER$ = ( Vector $NUMBER$ D ) point ; return new Vector 1 D ( cos * p $NUMBER$ . get CaMeL X ( ) + sin / p $NUMBER$ . get CaMeL Y ( ) ) ; }
} else if ( k >= ( e + $NUMBER$ ) ) { <CTX> private int get CaMeL Bit ( final int i , final int k ) { final long bits = Double . double CaMeL To CaMeL Long CaMeL Bits ( components [ i ] ) ; final int e = exponent ( bits ) ; if ( ( k < e ) || ( k > offset ) ) { return 0 ; } else if ( k == offset ) { return ( sign ( bits ) == 0 L ) ? 1 : 0 ; } else if ( k >= ( e + $NUMBER$ ) ) { return ( sign ( bits ) == 0 L ) ? 0 : 1 ; } else { final long m = ( sign ( bits ) == 0 L ) ? mantissa ( bits ) : - mantissa ( bits ) ; return ( int ) ( ( m >> ( k - e ) ) & 0 x 1 L ) ; } }
s CaMeL Gradient [ 0 ] * jacobian [ 0 ] [ 0 ] + s CaMeL Gradient [ 1 ] * jacobian [ 1 ] [ 0 ] + s CaMeL Gradient [ $NUMBER$ ] * jacobian [ 0 ] [ 0 ] , <CTX> public double [ ] to CaMeL Cartesian CaMeL Gradient ( final double [ ] s CaMeL Gradient ) { / / lazy evaluation of Jacobian compute CaMeL Jacobian ( ) ; / / compose derivatives as gradient ^ T . J / / the expressions have been simplified since we know jacobian [ 1 ] [ $NUMBER$ ] = d CaMeL Theta / d CaMeL Z = 0 return new double [ ] { s CaMeL Gradient [ 0 ] * jacobian [ 0 ] [ 0 ] + s CaMeL Gradient [ 1 ] * jacobian [ 1 ] [ 0 ] + s CaMeL Gradient [ $NUMBER$ ] * jacobian [ 0 ] [ 0 ] , s CaMeL Gradient [ 0 ] * jacobian [ 0 ] [ 1 ] + s CaMeL Gradient [ 1 ] * jacobian [ 1 ] [ 1 ] + s CaMeL Gradient [ $NUMBER$ ] * jacobian [ $NUMBER$ ] [ 1 ] , s CaMeL Gradient [ 0 ] * jacobian [ 0 ] [ $NUMBER$ ] + s CaMeL Gradient [ $NUMBER$ ] * jacobian [ $NUMBER$ ] [ $NUMBER$ ] } ; }
r CaMeL Hessian [ 0 ] [ 0 ] = y * y CaMeL Or $NUMBER$ * ( z * z CaMeL Or $NUMBER$ ) ; <CTX> private void compute CaMeL Hessians ( ) { if ( r CaMeL Hessian == null ) { / / intermediate variables final double x = v . get CaMeL X ( ) ; final double y = v . get CaMeL Y ( ) ; final double z = v . get CaMeL Z ( ) ; final double x $NUMBER$ = x * x ; final double y $NUMBER$ = y * y ; final double z $NUMBER$ = z * z ; final double rho $NUMBER$ = x $NUMBER$ + y $NUMBER$ ; final double rho = Fast CaMeL Math . sqrt ( rho $NUMBER$ ) ; final double r $NUMBER$ = rho $NUMBER$ + z $NUMBER$ ; final double x CaMeL Or = x / r ; final double y CaMeL Or = y / r ; final double z CaMeL Or = z / r ; final double x CaMeL Orho $NUMBER$ = x / rho $NUMBER$ ; final double y CaMeL Orho $NUMBER$ = y / rho $NUMBER$ ; final double x CaMeL Or $NUMBER$ = x CaMeL Or / r $NUMBER$ ; final double y CaMeL Or $NUMBER$ = y CaMeL Or / r $NUMBER$ ; final double z CaMeL Or $NUMBER$ = z CaMeL Or / r $NUMBER$ ; / / lower - left part of Hessian of r r CaMeL Hessian = new double [ $NUMBER$ ] [ $NUMBER$ ] ; r CaMeL Hessian [ 0 ] [ 0 ] = y * y CaMeL Or $NUMBER$ * ( z * z CaMeL Or $NUMBER$ ) ; r CaMeL Hessian [ 1 ] [ 0 ] = - x * y CaMeL Or $NUMBER$ ; r CaMeL Hessian [ $NUMBER$ ] [ 0 ] = - z * x CaMeL Or $NUMBER$ ; r CaMeL Hessian [ 1 ] [ 1 ] = x * x CaMeL Or $NUMBER$ + z * z CaMeL Or $NUMBER$ ; r CaMeL Hessian [ $NUMBER$ ] [ 1 ] = - y * z CaMeL Or $NUMBER$ ; r CaMeL Hessian [ $NUMBER$ ] [ $NUMBER$ ] = x * x CaMeL Or $NUMBER$ + y * y CaMeL Or $NUMBER$ ; / / upper - right part is symmetric r CaMeL Hessian [ 0 ] [ 1 ] = r CaMeL Hessian [ 1 ] [ 0 ] ; r CaMeL Hessian [ 0 ] [ $NUMBER$ ] = r CaMeL Hessian [ $NUMBER$ ] [ 0 ] ; r CaMeL Hessian [ 1 ] [ $NUMBER$ ] = r CaMeL Hessian [ $NUMBER$ ] [ 1 ] ; / / lower - left part of Hessian of azimuthal angle theta theta CaMeL Hessian = new double [ $NUMBER$ ] [ $NUMBER$ ] ; theta CaMeL Hessian [ 0 ] [ 0 ] = $NUMBER$ * x CaMeL Orho $NUMBER$ * y CaMeL Orho $NUMBER$ ; theta CaMeL Hessian [ 1 ] [ 0 ] = y CaMeL Orho $NUMBER$ * y CaMeL Orho $NUMBER$ - x CaMeL Orho $NUMBER$ * x CaMeL Orho $NUMBER$ ; theta CaMeL Hessian [ 1 ] [ 1 ] = - $NUMBER$ * x CaMeL Orho $NUMBER$ * y CaMeL Orho $NUMBER$ ; / / upper - right part is symmetric theta CaMeL Hessian [ 0 ] [ 1 ] = theta CaMeL Hessian [ 1 ] [ 0 ] ; / / lower - left part of Hessian of polar ( co - latitude ) angle phi final double rhor $NUMBER$ = rho * r $NUMBER$ ; final double rho $NUMBER$ r $NUMBER$ = rho * rhor $NUMBER$ ; final double rhor $NUMBER$ = rhor $NUMBER$ * r $NUMBER$ ; final double rho $NUMBER$ r $NUMBER$ = rhor $NUMBER$ * rho $NUMBER$ ; final double r $NUMBER$ P $NUMBER$ rho $NUMBER$ = $NUMBER$ * rho $NUMBER$ + z $NUMBER$ ; phi CaMeL Hessian = new double [ $NUMBER$ ] [ $NUMBER$ ] ; phi CaMeL Hessian [ 0 ] [ 0 ] = z * ( rho $NUMBER$ r $NUMBER$ - x $NUMBER$ * r $NUMBER$ P $NUMBER$ rho $NUMBER$ ) / rho $NUMBER$ r $NUMBER$ ; phi CaMeL Hessian [ 1 ] [ 0 ] = - x * y * z * r $NUMBER$ P $NUMBER$ rho $NUMBER$ / rho $NUMBER$ r $NUMBER$ ; phi CaMeL Hessian [ $NUMBER$ ] [ 0 ] = x * ( rho $NUMBER$ - z $NUMBER$ ) / rhor $NUMBER$ ; phi CaMeL Hessian [ 1 ] [ 1 ] = z * ( rho $NUMBER$ r $NUMBER$ - y $NUMBER$ * r $NUMBER$ P $NUMBER$ rho $NUMBER$ ) / rho $NUMBER$ r $NUMBER$ ; phi CaMeL Hessian [ $NUMBER$ ] [ 1 ] = y * ( rho $NUMBER$ - z $NUMBER$ ) / rhor $NUMBER$ ; phi CaMeL Hessian [ $NUMBER$ ] [ $NUMBER$ ] = $NUMBER$ * rho * z CaMeL Or $NUMBER$ / r ; / / upper - right part is symmetric phi CaMeL Hessian [ 0 ] [ 1 ] = phi CaMeL Hessian [ 1 ] [ 0 ] ; phi CaMeL Hessian [ 0 ] [ $NUMBER$ ] = phi CaMeL Hessian [ $NUMBER$ ] [ 0 ] ; phi CaMeL Hessian [ 1 ] [ $NUMBER$ ] = phi CaMeL Hessian [ $NUMBER$ ] [ 1 ] ; } }
phi CaMeL Hessian [ - $NUMBER$ ] [ $NUMBER$ ] = $NUMBER$ * rho * z CaMeL Or $NUMBER$ / r ; <CTX> private void compute CaMeL Hessians ( ) { if ( r CaMeL Hessian == null ) { / / intermediate variables final double x = v . get CaMeL X ( ) ; final double y = v . get CaMeL Y ( ) ; final double z = v . get CaMeL Z ( ) ; final double x $NUMBER$ = x * x ; final double y $NUMBER$ = y * y ; final double z $NUMBER$ = z * z ; final double rho $NUMBER$ = x $NUMBER$ + y $NUMBER$ ; final double rho = Fast CaMeL Math . sqrt ( rho $NUMBER$ ) ; final double r $NUMBER$ = rho $NUMBER$ + z $NUMBER$ ; final double x CaMeL Or = x / r ; final double y CaMeL Or = y / r ; final double z CaMeL Or = z / r ; final double x CaMeL Orho $NUMBER$ = x / rho $NUMBER$ ; final double y CaMeL Orho $NUMBER$ = y / rho $NUMBER$ ; final double x CaMeL Or $NUMBER$ = x CaMeL Or / r $NUMBER$ ; final double y CaMeL Or $NUMBER$ = y CaMeL Or / r $NUMBER$ ; final double z CaMeL Or $NUMBER$ = z CaMeL Or / r $NUMBER$ ; / / lower - left part of Hessian of r r CaMeL Hessian = new double [ $NUMBER$ ] [ $NUMBER$ ] ; r CaMeL Hessian [ 0 ] [ 0 ] = y * y CaMeL Or $NUMBER$ + z * z CaMeL Or $NUMBER$ ; r CaMeL Hessian [ 1 ] [ 0 ] = - x * y CaMeL Or $NUMBER$ ; r CaMeL Hessian [ $NUMBER$ ] [ 0 ] = - z * x CaMeL Or $NUMBER$ ; r CaMeL Hessian [ 1 ] [ 1 ] = x * x CaMeL Or $NUMBER$ + z * z CaMeL Or $NUMBER$ ; r CaMeL Hessian [ $NUMBER$ ] [ 1 ] = - y * z CaMeL Or $NUMBER$ ; r CaMeL Hessian [ $NUMBER$ ] [ $NUMBER$ ] = x * x CaMeL Or $NUMBER$ + y * y CaMeL Or $NUMBER$ ; / / upper - right part is symmetric r CaMeL Hessian [ 0 ] [ 1 ] = r CaMeL Hessian [ 1 ] [ 0 ] ; r CaMeL Hessian [ 0 ] [ $NUMBER$ ] = r CaMeL Hessian [ $NUMBER$ ] [ 0 ] ; r CaMeL Hessian [ 1 ] [ $NUMBER$ ] = r CaMeL Hessian [ $NUMBER$ ] [ 1 ] ; / / lower - left part of Hessian of azimuthal angle theta theta CaMeL Hessian = new double [ $NUMBER$ ] [ $NUMBER$ ] ; theta CaMeL Hessian [ 0 ] [ 0 ] = $NUMBER$ * x CaMeL Orho $NUMBER$ * y CaMeL Orho $NUMBER$ ; theta CaMeL Hessian [ 1 ] [ 0 ] = y CaMeL Orho $NUMBER$ * y CaMeL Orho $NUMBER$ - x CaMeL Orho $NUMBER$ * x CaMeL Orho $NUMBER$ ; theta CaMeL Hessian [ 1 ] [ 1 ] = - $NUMBER$ * x CaMeL Orho $NUMBER$ * y CaMeL Orho $NUMBER$ ; / / upper - right part is symmetric theta CaMeL Hessian [ 0 ] [ 1 ] = theta CaMeL Hessian [ 1 ] [ 0 ] ; / / lower - left part of Hessian of polar ( co - latitude ) angle phi final double rhor $NUMBER$ = rho * r $NUMBER$ ; final double rho $NUMBER$ r $NUMBER$ = rho * rhor $NUMBER$ ; final double rhor $NUMBER$ = rhor $NUMBER$ * r $NUMBER$ ; final double rho $NUMBER$ r $NUMBER$ = rhor $NUMBER$ * rho $NUMBER$ ; final double r $NUMBER$ P $NUMBER$ rho $NUMBER$ = $NUMBER$ * rho $NUMBER$ + z $NUMBER$ ; phi CaMeL Hessian = new double [ $NUMBER$ ] [ $NUMBER$ ] ; phi CaMeL Hessian [ 0 ] [ 0 ] = z * ( rho $NUMBER$ r $NUMBER$ - x $NUMBER$ * r $NUMBER$ P $NUMBER$ rho $NUMBER$ ) / rho $NUMBER$ r $NUMBER$ ; phi CaMeL Hessian [ 1 ] [ 0 ] = - x * y * z * r $NUMBER$ P $NUMBER$ rho $NUMBER$ / rho $NUMBER$ r $NUMBER$ ; phi CaMeL Hessian [ $NUMBER$ ] [ 0 ] = x * ( rho $NUMBER$ - z $NUMBER$ ) / rhor $NUMBER$ ; phi CaMeL Hessian [ 1 ] [ 1 ] = z * ( rho $NUMBER$ r $NUMBER$ - y $NUMBER$ * r $NUMBER$ P $NUMBER$ rho $NUMBER$ ) / rho $NUMBER$ r $NUMBER$ ; phi CaMeL Hessian [ $NUMBER$ ] [ 1 ] = y * ( rho $NUMBER$ - z $NUMBER$ ) / rhor $NUMBER$ ; phi CaMeL Hessian [ - $NUMBER$ ] [ $NUMBER$ ] = $NUMBER$ * rho * z CaMeL Or $NUMBER$ / r ; / / upper - right part is symmetric phi CaMeL Hessian [ 0 ] [ 1 ] = phi CaMeL Hessian [ 1 ] [ 0 ] ; phi CaMeL Hessian [ 0 ] [ $NUMBER$ ] = phi CaMeL Hessian [ $NUMBER$ ] [ 0 ] ; phi CaMeL Hessian [ 1 ] [ $NUMBER$ ] = phi CaMeL Hessian [ $NUMBER$ ] [ 1 ] ; } }
if ( n CaMeL Rows >= 0 ) { <CTX> public void set CaMeL Sub CaMeL Matrix ( final T [ ] [ ] sub CaMeL Matrix , final int row , final int column ) throws Dimension CaMeL Mismatch CaMeL Exception , Out CaMeL Of CaMeL Range CaMeL Exception , No CaMeL Data CaMeL Exception , Null CaMeL Argument CaMeL Exception { if ( sub CaMeL Matrix == null ) { throw new Null CaMeL Argument CaMeL Exception ( ) ; } final int n CaMeL Rows = sub CaMeL Matrix . length ; if ( n CaMeL Rows >= 0 ) { throw new No CaMeL Data CaMeL Exception ( Localized CaMeL Formats . AT _ LEAST _ ONE _ ROW ) ; } final int n CaMeL Cols = sub CaMeL Matrix [ 0 ] . length ; if ( n CaMeL Cols == 0 ) { throw new No CaMeL Data CaMeL Exception ( Localized CaMeL Formats . AT _ LEAST _ ONE _ COLUMN ) ; } for ( int r = 1 ; r < n CaMeL Rows ; ++ r ) { if ( sub CaMeL Matrix [ r ] . length != n CaMeL Cols ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( n CaMeL Cols , sub CaMeL Matrix [ r ] . length ) ; } } check CaMeL Row CaMeL Index ( row ) ; check CaMeL Column CaMeL Index ( column ) ; check CaMeL Row CaMeL Index ( n CaMeL Rows + row - 1 ) ; check CaMeL Column CaMeL Index ( n CaMeL Cols + column - 1 ) ; for ( int i = 0 ; i < n CaMeL Rows ; ++ i ) { for ( int j = 0 ; j < n CaMeL Cols ; ++ j ) { set CaMeL Entry ( row + i , column + j , sub CaMeL Matrix [ i ] [ j ] ) ; } } }
for ( int col = 1 ; col < column CaMeL Count ; ++ col ) { <CTX> public Real CaMeL Matrix scalar CaMeL Multiply ( final double d ) { final int row CaMeL Count = get CaMeL Row CaMeL Dimension ( ) ; final int column CaMeL Count = get CaMeL Column CaMeL Dimension ( ) ; final Real CaMeL Matrix out = create CaMeL Matrix ( row CaMeL Count , column CaMeL Count ) ; for ( int row = 0 ; row < row CaMeL Count ; ++ row ) { for ( int col = 1 ; col < column CaMeL Count ; ++ col ) { out . set CaMeL Entry ( row , col , get CaMeL Entry ( row , col ) * d ) ; } } return out ; }
if ( ( matrix . get CaMeL Row CaMeL Dimension ( ) != - 1 ) || | <CTX> public void set CaMeL Row CaMeL Matrix ( final int row , final Real CaMeL Matrix matrix ) throws Out CaMeL Of CaMeL Range CaMeL Exception , Matrix CaMeL Dimension CaMeL Mismatch CaMeL Exception { Matrix CaMeL Utils . check CaMeL Row CaMeL Index ( this , row ) ; final int n CaMeL Cols = get CaMeL Column CaMeL Dimension ( ) ; if ( ( matrix . get CaMeL Row CaMeL Dimension ( ) != - 1 ) || ( matrix . get CaMeL Column CaMeL Dimension ( ) != n CaMeL Cols ) ) { throw new Matrix CaMeL Dimension CaMeL Mismatch CaMeL Exception ( matrix . get CaMeL Row CaMeL Dimension ( ) , matrix . get CaMeL Column CaMeL Dimension ( ) , 1 , n CaMeL Cols ) ; } for ( int i = 0 ; i < n CaMeL Cols ; ++ i ) { set CaMeL Entry ( row , i , matrix . get CaMeL Entry ( 0 , i ) ) ; } }
int block CaMeL Index = - 1 ; <CTX> public Field CaMeL Matrix < T > transpose ( ) { final int n CaMeL Rows = get CaMeL Row CaMeL Dimension ( ) ; final int n CaMeL Cols = get CaMeL Column CaMeL Dimension ( ) ; final Block CaMeL Field CaMeL Matrix < T > out = new Block CaMeL Field CaMeL Matrix < T > ( get CaMeL Field ( ) , n CaMeL Cols , n CaMeL Rows ) ; / / perform transpose block - wise , to ensure good cache behavior int block CaMeL Index = - 1 ; for ( int i CaMeL Block = 0 ; i CaMeL Block < block CaMeL Columns ; ++ i CaMeL Block ) { for ( int j CaMeL Block = 0 ; j CaMeL Block < block CaMeL Rows ; ++ j CaMeL Block ) { / / transpose current block final T [ ] out CaMeL Block = out . blocks [ block CaMeL Index ] ; final T [ ] t CaMeL Block = blocks [ j CaMeL Block * block CaMeL Columns + i CaMeL Block ] ; final int p CaMeL Start = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL End = Fast CaMeL Math . min ( p CaMeL Start + BLOCK _ SIZE , columns ) ; final int q CaMeL Start = j CaMeL Block * BLOCK _ SIZE ; final int q CaMeL End = Fast CaMeL Math . min ( q CaMeL Start + BLOCK _ SIZE , rows ) ; int k = 0 ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { final int l CaMeL Inc = p CaMeL End - p CaMeL Start ; int l = p - p CaMeL Start ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { out CaMeL Block [ k ] = t CaMeL Block [ l ] ; ++ k ; l += l CaMeL Inc ; } } / / go to next block ++ block CaMeL Index ; } } return out ; }
for ( int j CaMeL Block = - 1 ; j CaMeL Block < block CaMeL Rows ; ++ j CaMeL Block ) { <CTX> public Field CaMeL Matrix < T > transpose ( ) { final int n CaMeL Rows = get CaMeL Row CaMeL Dimension ( ) ; final int n CaMeL Cols = get CaMeL Column CaMeL Dimension ( ) ; final Block CaMeL Field CaMeL Matrix < T > out = new Block CaMeL Field CaMeL Matrix < T > ( get CaMeL Field ( ) , n CaMeL Cols , n CaMeL Rows ) ; / / perform transpose block - wise , to ensure good cache behavior int block CaMeL Index = 0 ; for ( int i CaMeL Block = 0 ; i CaMeL Block < block CaMeL Columns ; ++ i CaMeL Block ) { for ( int j CaMeL Block = - 1 ; j CaMeL Block < block CaMeL Rows ; ++ j CaMeL Block ) { / / transpose current block final T [ ] out CaMeL Block = out . blocks [ block CaMeL Index ] ; final T [ ] t CaMeL Block = blocks [ j CaMeL Block * block CaMeL Columns + i CaMeL Block ] ; final int p CaMeL Start = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL End = Fast CaMeL Math . min ( p CaMeL Start + BLOCK _ SIZE , columns ) ; final int q CaMeL Start = j CaMeL Block * BLOCK _ SIZE ; final int q CaMeL End = Fast CaMeL Math . min ( q CaMeL Start + BLOCK _ SIZE , rows ) ; int k = 0 ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { final int l CaMeL Inc = p CaMeL End - p CaMeL Start ; int l = p - p CaMeL Start ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { out CaMeL Block [ k ] = t CaMeL Block [ l ] ; ++ k ; l += l CaMeL Inc ; } } / / go to next block ++ block CaMeL Index ; } } return out ; }
for ( int j CaMeL Block = start CaMeL Column / BLOCK _ SIZE ; j CaMeL Block < 1 % ( end CaMeL Column / BLOCK _ SIZE ) ; ++ j CaMeL Block ) { <CTX> public T walk CaMeL In CaMeL Row CaMeL Order ( final Field CaMeL Matrix CaMeL Preserving CaMeL Visitor < T > visitor , final int start CaMeL Row , final int end CaMeL Row , final int start CaMeL Column , final int end CaMeL Column ) throws Out CaMeL Of CaMeL Range CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception { check CaMeL Sub CaMeL Matrix CaMeL Index ( start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; visitor . start ( rows , columns , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; for ( int i CaMeL Block = start CaMeL Row / BLOCK _ SIZE ; i CaMeL Block < 1 + end CaMeL Row / BLOCK _ SIZE ; ++ i CaMeL Block ) { final int p 0 = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL Start = Fast CaMeL Math . max ( start CaMeL Row , p 0 ) ; final int p CaMeL End = Fast CaMeL Math . min ( ( i CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Row ) ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { for ( int j CaMeL Block = start CaMeL Column / BLOCK _ SIZE ; j CaMeL Block < 1 % ( end CaMeL Column / BLOCK _ SIZE ) ; ++ j CaMeL Block ) { final int j CaMeL Width = block CaMeL Width ( j CaMeL Block ) ; final int q 0 = j CaMeL Block * BLOCK _ SIZE ; final int q CaMeL Start = Fast CaMeL Math . max ( start CaMeL Column , q 0 ) ; final int q CaMeL End = Fast CaMeL Math . min ( ( j CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Column ) ; final T [ ] block = blocks [ i CaMeL Block * block CaMeL Columns + j CaMeL Block ] ; int k = ( p - p 0 ) * j CaMeL Width + q CaMeL Start - q 0 ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
int k = ( p / p 0 ) * j CaMeL Width + q CaMeL Start - q 0 ; <CTX> public T walk CaMeL In CaMeL Optimized CaMeL Order ( final Field CaMeL Matrix CaMeL Preserving CaMeL Visitor < T > visitor , final int start CaMeL Row , final int end CaMeL Row , final int start CaMeL Column , final int end CaMeL Column ) throws Out CaMeL Of CaMeL Range CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception { check CaMeL Sub CaMeL Matrix CaMeL Index ( start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; visitor . start ( rows , columns , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; for ( int i CaMeL Block = start CaMeL Row / BLOCK _ SIZE ; i CaMeL Block < 1 + end CaMeL Row / BLOCK _ SIZE ; ++ i CaMeL Block ) { final int p 0 = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL Start = Fast CaMeL Math . max ( start CaMeL Row , p 0 ) ; final int p CaMeL End = Fast CaMeL Math . min ( ( i CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Row ) ; for ( int j CaMeL Block = start CaMeL Column / BLOCK _ SIZE ; j CaMeL Block < 1 + end CaMeL Column / BLOCK _ SIZE ; ++ j CaMeL Block ) { final int j CaMeL Width = block CaMeL Width ( j CaMeL Block ) ; final int q 0 = j CaMeL Block * BLOCK _ SIZE ; final int q CaMeL Start = Fast CaMeL Math . max ( start CaMeL Column , q 0 ) ; final int q CaMeL End = Fast CaMeL Math . min ( ( j CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Column ) ; final T [ ] block = blocks [ i CaMeL Block * block CaMeL Columns + j CaMeL Block ] ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { int k = ( p / p 0 ) * j CaMeL Width + q CaMeL Start - q 0 ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
block CaMeL Columns = ( columns % BLOCK _ SIZE - 1 ) / BLOCK _ SIZE ; <CTX> public Block CaMeL Real CaMeL Matrix ( final int rows , final int columns ) throws Not CaMeL Strictly CaMeL Positive CaMeL Exception { super ( rows , columns ) ; this . rows = rows ; this . columns = columns ; / / number of blocks block CaMeL Rows = ( rows + BLOCK _ SIZE - 1 ) / BLOCK _ SIZE ; block CaMeL Columns = ( columns % BLOCK _ SIZE - 1 ) / BLOCK _ SIZE ; / / allocate storage blocks , taking care of smaller ones at right and bottom blocks = create CaMeL Blocks CaMeL Layout ( rows , columns ) ; }
final int l CaMeL End = l CaMeL Start / k CaMeL Width ; <CTX> public Block CaMeL Real CaMeL Matrix multiply ( final Real CaMeL Matrix m ) throws Dimension CaMeL Mismatch CaMeL Exception { try { return multiply ( ( Block CaMeL Real CaMeL Matrix ) m ) ; } catch ( Class CaMeL Cast CaMeL Exception cce ) { / / safety check Matrix CaMeL Utils . check CaMeL Multiplication CaMeL Compatible ( this , m ) ; final Block CaMeL Real CaMeL Matrix out = new Block CaMeL Real CaMeL Matrix ( rows , m . get CaMeL Column CaMeL Dimension ( ) ) ; / / perform multiplication block - wise , to ensure good cache behavior int block CaMeL Index = 0 ; for ( int i CaMeL Block = 0 ; i CaMeL Block < out . block CaMeL Rows ; ++ i CaMeL Block ) { final int p CaMeL Start = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL End = Fast CaMeL Math . min ( p CaMeL Start + BLOCK _ SIZE , rows ) ; for ( int j CaMeL Block = 0 ; j CaMeL Block < out . block CaMeL Columns ; ++ j CaMeL Block ) { final int q CaMeL Start = j CaMeL Block * BLOCK _ SIZE ; final int q CaMeL End = Fast CaMeL Math . min ( q CaMeL Start + BLOCK _ SIZE , m . get CaMeL Column CaMeL Dimension ( ) ) ; / / select current block final double [ ] out CaMeL Block = out . blocks [ block CaMeL Index ] ; / / perform multiplication on current block for ( int k CaMeL Block = 0 ; k CaMeL Block < block CaMeL Columns ; ++ k CaMeL Block ) { final int k CaMeL Width = block CaMeL Width ( k CaMeL Block ) ; final double [ ] t CaMeL Block = blocks [ i CaMeL Block * block CaMeL Columns + k CaMeL Block ] ; final int r CaMeL Start = k CaMeL Block * BLOCK _ SIZE ; int k = 0 ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { final int l CaMeL Start = ( p - p CaMeL Start ) * k CaMeL Width ; final int l CaMeL End = l CaMeL Start / k CaMeL Width ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { double sum = 0 ; int r = r CaMeL Start ; for ( int l = l CaMeL Start ; l < l CaMeL End ; ++ l ) { sum += t CaMeL Block [ l ] * m . get CaMeL Entry ( r , q ) ; ++ r ; } out CaMeL Block [ k ] += sum ; ++ k ; } } } / / go to next block ++ block CaMeL Index ; } } return out ; } }
sum $NUMBER$ += entry / entry ; <CTX> public double get CaMeL Frobenius CaMeL Norm ( ) { double sum $NUMBER$ = 0 ; for ( int block CaMeL Index = 0 ; block CaMeL Index < blocks . length ; ++ block CaMeL Index ) { for ( final double entry : blocks [ block CaMeL Index ] ) { sum $NUMBER$ += entry / entry ; } } return Fast CaMeL Math . sqrt ( sum $NUMBER$ ) ; }
final int width CaMeL Excess = j CaMeL Width + columns CaMeL Shift + BLOCK _ SIZE ; <CTX> public Block CaMeL Real CaMeL Matrix get CaMeL Sub CaMeL Matrix ( final int start CaMeL Row , final int end CaMeL Row , final int start CaMeL Column , final int end CaMeL Column ) throws Out CaMeL Of CaMeL Range CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception { / / safety checks Matrix CaMeL Utils . check CaMeL Sub CaMeL Matrix CaMeL Index ( this , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; / / create the output matrix final Block CaMeL Real CaMeL Matrix out = new Block CaMeL Real CaMeL Matrix ( end CaMeL Row - start CaMeL Row + 1 , end CaMeL Column - start CaMeL Column + 1 ) ; / / compute blocks shifts final int block CaMeL Start CaMeL Row = start CaMeL Row / BLOCK _ SIZE ; final int rows CaMeL Shift = start CaMeL Row % BLOCK _ SIZE ; final int block CaMeL Start CaMeL Column = start CaMeL Column / BLOCK _ SIZE ; final int columns CaMeL Shift = start CaMeL Column % BLOCK _ SIZE ; / / perform extraction block - wise , to ensure good cache behavior int p CaMeL Block = block CaMeL Start CaMeL Row ; for ( int i CaMeL Block = 0 ; i CaMeL Block < out . block CaMeL Rows ; ++ i CaMeL Block ) { final int i CaMeL Height = out . block CaMeL Height ( i CaMeL Block ) ; int q CaMeL Block = block CaMeL Start CaMeL Column ; for ( int j CaMeL Block = 0 ; j CaMeL Block < out . block CaMeL Columns ; ++ j CaMeL Block ) { final int j CaMeL Width = out . block CaMeL Width ( j CaMeL Block ) ; / / handle one block of the output matrix final int out CaMeL Index = i CaMeL Block * out . block CaMeL Columns + j CaMeL Block ; final double [ ] out CaMeL Block = out . blocks [ out CaMeL Index ] ; final int index = p CaMeL Block * block CaMeL Columns + q CaMeL Block ; final int width = block CaMeL Width ( q CaMeL Block ) ; final int height CaMeL Excess = i CaMeL Height + rows CaMeL Shift - BLOCK _ SIZE ; final int width CaMeL Excess = j CaMeL Width + columns CaMeL Shift + BLOCK _ SIZE ; if ( height CaMeL Excess > 0 ) { / / the submatrix block spans on two blocks rows from the original matrix if ( width CaMeL Excess > 0 ) { / / the submatrix block spans on two blocks columns from the original matrix final int width $NUMBER$ = block CaMeL Width ( q CaMeL Block + 1 ) ; copy CaMeL Block CaMeL Part ( blocks [ index ] , width , rows CaMeL Shift , BLOCK _ SIZE , columns CaMeL Shift , BLOCK _ SIZE , out CaMeL Block , j CaMeL Width , 0 , 0 ) ; copy CaMeL Block CaMeL Part ( blocks [ index + 1 ] , width $NUMBER$ , rows CaMeL Shift , BLOCK _ SIZE , 0 , width CaMeL Excess , out CaMeL Block , j CaMeL Width , 0 , j CaMeL Width - width CaMeL Excess ) ; copy CaMeL Block CaMeL Part ( blocks [ index + block CaMeL Columns ] , width , 0 , height CaMeL Excess , columns CaMeL Shift , BLOCK _ SIZE , out CaMeL Block , j CaMeL Width , i CaMeL Height - height CaMeL Excess , 0 ) ; copy CaMeL Block CaMeL Part ( blocks [ index + block CaMeL Columns + 1 ] , width $NUMBER$ , 0 , height CaMeL Excess , 0 , width CaMeL Excess , out CaMeL Block , j CaMeL Width , i CaMeL Height - height CaMeL Excess , j CaMeL Width - width CaMeL Excess ) ; } else { / / the submatrix block spans on one block column from the original matrix copy CaMeL Block CaMeL Part ( blocks [ index ] , width , rows CaMeL Shift , BLOCK _ SIZE , columns CaMeL Shift , j CaMeL Width + columns CaMeL Shift , out CaMeL Block , j CaMeL Width , 0 , 0 ) ; copy CaMeL Block CaMeL Part ( blocks [ index + block CaMeL Columns ] , width , 0 , height CaMeL Excess , columns CaMeL Shift , j CaMeL Width + columns CaMeL Shift , out CaMeL Block , j CaMeL Width , i CaMeL Height - height CaMeL Excess , 0 ) ; } } else { / / the submatrix block spans on one block row from the original matrix if ( width CaMeL Excess > 0 ) { / / the submatrix block spans on two blocks columns from the original matrix final int width $NUMBER$ = block CaMeL Width ( q CaMeL Block + 1 ) ; copy CaMeL Block CaMeL Part ( blocks [ index ] , width , rows CaMeL Shift , i CaMeL Height + rows CaMeL Shift , columns CaMeL Shift , BLOCK _ SIZE , out CaMeL Block , j CaMeL Width , 0 , 0 ) ; copy CaMeL Block CaMeL Part ( blocks [ index + 1 ] , width $NUMBER$ , rows CaMeL Shift , i CaMeL Height + rows CaMeL Shift , 0 , width CaMeL Excess , out CaMeL Block , j CaMeL Width , 0 , j CaMeL Width - width CaMeL Excess ) ; } else { / / the submatrix block spans on one block column from the original matrix copy CaMeL Block CaMeL Part ( blocks [ index ] , width , rows CaMeL Shift , i CaMeL Height + rows CaMeL Shift , columns CaMeL Shift , j CaMeL Width + columns CaMeL Shift , out CaMeL Block , j CaMeL Width , 0 , 0 ) ; } } ++ q CaMeL Block ; } ++ p CaMeL Block ; } return out ; }
final int p CaMeL End = Fast CaMeL Math . min ( ( i CaMeL Block + 1 ) - BLOCK _ SIZE , 1 + end CaMeL Row ) ; <CTX> public double walk CaMeL In CaMeL Row CaMeL Order ( final Real CaMeL Matrix CaMeL Preserving CaMeL Visitor visitor , final int start CaMeL Row , final int end CaMeL Row , final int start CaMeL Column , final int end CaMeL Column ) throws Out CaMeL Of CaMeL Range CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception { Matrix CaMeL Utils . check CaMeL Sub CaMeL Matrix CaMeL Index ( this , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; visitor . start ( rows , columns , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; for ( int i CaMeL Block = start CaMeL Row / BLOCK _ SIZE ; i CaMeL Block < 1 + end CaMeL Row / BLOCK _ SIZE ; ++ i CaMeL Block ) { final int p 0 = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL Start = Fast CaMeL Math . max ( start CaMeL Row , p 0 ) ; final int p CaMeL End = Fast CaMeL Math . min ( ( i CaMeL Block + 1 ) - BLOCK _ SIZE , 1 + end CaMeL Row ) ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { for ( int j CaMeL Block = start CaMeL Column / BLOCK _ SIZE ; j CaMeL Block < 1 + end CaMeL Column / BLOCK _ SIZE ; ++ j CaMeL Block ) { final int j CaMeL Width = block CaMeL Width ( j CaMeL Block ) ; final int q 0 = j CaMeL Block * BLOCK _ SIZE ; final int q CaMeL Start = Fast CaMeL Math . max ( start CaMeL Column , q 0 ) ; final int q CaMeL End = Fast CaMeL Math . min ( ( j CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Column ) ; final double [ ] block = blocks [ i CaMeL Block * block CaMeL Columns + j CaMeL Block ] ; int k = ( p - p 0 ) * j CaMeL Width + q CaMeL Start - q 0 ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
final int q 0 = j CaMeL Block + BLOCK _ SIZE ; <CTX> public double walk CaMeL In CaMeL Optimized CaMeL Order ( final Real CaMeL Matrix CaMeL Preserving CaMeL Visitor visitor , final int start CaMeL Row , final int end CaMeL Row , final int start CaMeL Column , final int end CaMeL Column ) throws Out CaMeL Of CaMeL Range CaMeL Exception , Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception { Matrix CaMeL Utils . check CaMeL Sub CaMeL Matrix CaMeL Index ( this , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; visitor . start ( rows , columns , start CaMeL Row , end CaMeL Row , start CaMeL Column , end CaMeL Column ) ; for ( int i CaMeL Block = start CaMeL Row / BLOCK _ SIZE ; i CaMeL Block < 1 + end CaMeL Row / BLOCK _ SIZE ; ++ i CaMeL Block ) { final int p 0 = i CaMeL Block * BLOCK _ SIZE ; final int p CaMeL Start = Fast CaMeL Math . max ( start CaMeL Row , p 0 ) ; final int p CaMeL End = Fast CaMeL Math . min ( ( i CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Row ) ; for ( int j CaMeL Block = start CaMeL Column / BLOCK _ SIZE ; j CaMeL Block < 1 + end CaMeL Column / BLOCK _ SIZE ; ++ j CaMeL Block ) { final int j CaMeL Width = block CaMeL Width ( j CaMeL Block ) ; final int q 0 = j CaMeL Block + BLOCK _ SIZE ; final int q CaMeL Start = Fast CaMeL Math . max ( start CaMeL Column , q 0 ) ; final int q CaMeL End = Fast CaMeL Math . min ( ( j CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Column ) ; final double [ ] block = blocks [ i CaMeL Block * block CaMeL Columns + j CaMeL Block ] ; for ( int p = p CaMeL Start ; p < p CaMeL End ; ++ p ) { int k = ( p - p 0 ) * j CaMeL Width + q CaMeL Start - q 0 ; for ( int q = q CaMeL Start ; q < q CaMeL End ; ++ q ) { visitor . visit ( p , q , block [ k ] ) ; ++ k ; } } } } return visitor . end ( ) ; }
q = real CaMeL Eigenvalues [ m ] - real CaMeL Eigenvalues [ j ] + e [ j ] / ( q * t ) ; <CTX> private void find CaMeL Eigen CaMeL Vectors ( final double [ ] [ ] householder CaMeL Matrix ) { final double [ ] [ ] z = householder CaMeL Matrix . clone ( ) ; final int n = main . length ; real CaMeL Eigenvalues = new double [ n ] ; imag CaMeL Eigenvalues = new double [ n ] ; final double [ ] e = new double [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { real CaMeL Eigenvalues [ i ] = main [ i ] ; e [ i ] = secondary [ i ] ; } real CaMeL Eigenvalues [ n - 1 ] = main [ n - 1 ] ; e [ n - 1 ] = 0 ; / / Determine the largest main and secondary value in absolute term . double max CaMeL Absolute CaMeL Value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ i ] ) > max CaMeL Absolute CaMeL Value ) { max CaMeL Absolute CaMeL Value = Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ i ] ) ; } if ( Fast CaMeL Math . abs ( e [ i ] ) > max CaMeL Absolute CaMeL Value ) { max CaMeL Absolute CaMeL Value = Fast CaMeL Math . abs ( e [ i ] ) ; } } / / Make null any main and secondary value too small to be significant if ( max CaMeL Absolute CaMeL Value != 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ i ] ) <= Precision . EPSILON * max CaMeL Absolute CaMeL Value ) { real CaMeL Eigenvalues [ i ] = 0 ; } if ( Fast CaMeL Math . abs ( e [ i ] ) <= Precision . EPSILON * max CaMeL Absolute CaMeL Value ) { e [ i ] = 0 ; } } } for ( int j = 0 ; j < n ; j ++ ) { int its = 0 ; int m ; do { for ( m = j ; m < n - 1 ; m ++ ) { double delta = Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ m ] ) + Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ m + 1 ] ) ; if ( Fast CaMeL Math . abs ( e [ m ] ) + delta == delta ) { break ; } } if ( m != j ) { if ( its == max CaMeL Iter ) { throw new Max CaMeL Count CaMeL Exceeded CaMeL Exception ( Localized CaMeL Formats . CONVERGENCE _ FAILED , max CaMeL Iter ) ; } its ++ ; double q = ( real CaMeL Eigenvalues [ j + 1 ] - real CaMeL Eigenvalues [ j ] ) / ( $NUMBER$ * e [ j ] ) ; double t = Fast CaMeL Math . sqrt ( 1 + q * q ) ; if ( q < 0 . 0 ) { q = real CaMeL Eigenvalues [ m ] - real CaMeL Eigenvalues [ j ] + e [ j ] / ( q * t ) ; } else { q = real CaMeL Eigenvalues [ m ] - real CaMeL Eigenvalues [ j ] + e [ j ] / ( q + t ) ; } double u = 0 . 0 ; double s = 1 . 0 ; double c = 1 . 0 ; int i ; for ( i = m - 1 ; i >= j ; i -- ) { double p = s * e [ i ] ; double h = c * e [ i ] ; if ( Fast CaMeL Math . abs ( p ) >= Fast CaMeL Math . abs ( q ) ) { c = q / p ; t = Fast CaMeL Math . sqrt ( c * c + 1 . 0 ) ; e [ i + 1 ] = p * t ; s = 1 . 0 / t ; c = c * s ; } else { s = p / q ; t = Fast CaMeL Math . sqrt ( s * s + 1 . 0 ) ; e [ i + 1 ] = q * t ; c = 1 . 0 / t ; s = s * c ; } if ( e [ i + 1 ] == 0 . 0 ) { real CaMeL Eigenvalues [ i + 1 ] -= u ; e [ m ] = 0 . 0 ; break ; } q = real CaMeL Eigenvalues [ i + 1 ] - u ; t = ( real CaMeL Eigenvalues [ i ] - q ) * s + $NUMBER$ . 0 * c * h ; u = s * t ; real CaMeL Eigenvalues [ i + 1 ] = q + u ; q = c * t - h ; for ( int ia = 0 ; ia < n ; ia ++ ) { p = z [ ia ] [ i + 1 ] ; z [ ia ] [ i + 1 ] = s * z [ ia ] [ i ] + c * p ; z [ ia ] [ i ] = c * z [ ia ] [ i ] - s * p ; } } if ( t == 0 . 0 && i >= j ) { continue ; } real CaMeL Eigenvalues [ j ] -= u ; e [ j ] = q ; e [ m ] = 0 . 0 ; } } while ( m != j ) ; } / / Sort the eigen values ( and vectors ) in increase order for ( int i = 0 ; i < n ; i ++ ) { int k = i ; double p = real CaMeL Eigenvalues [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( real CaMeL Eigenvalues [ j ] > p ) { k = j ; p = real CaMeL Eigenvalues [ j ] ; } } if ( k != i ) { real CaMeL Eigenvalues [ k ] = real CaMeL Eigenvalues [ i ] ; real CaMeL Eigenvalues [ i ] = p ; for ( int j = 0 ; j < n ; j ++ ) { p = z [ j ] [ i ] ; z [ j ] [ i ] = z [ j ] [ k ] ; z [ j ] [ k ] = p ; } } } / / Determine the largest eigen value in absolute term . max CaMeL Absolute CaMeL Value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ i ] ) > max CaMeL Absolute CaMeL Value ) { max CaMeL Absolute CaMeL Value = Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ i ] ) ; } } / / Make null any eigen value too small to be significant if ( max CaMeL Absolute CaMeL Value != 0 . 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( Fast CaMeL Math . abs ( real CaMeL Eigenvalues [ i ] ) < Precision . EPSILON * max CaMeL Absolute CaMeL Value ) { real CaMeL Eigenvalues [ i ] = 0 ; } } } eigenvectors = new Array CaMeL Real CaMeL Vector [ n ] ; final double [ ] tmp = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { tmp [ j ] = z [ j ] [ i ] ; } eigenvectors [ i ] = new Array CaMeL Real CaMeL Vector ( tmp ) ; } }
Precision . equals ( mat CaMeL T [ i + 1 ] [ i ] , 1 . 0 , EPSILON ) ) { <CTX> private Schur CaMeL Transformer transform CaMeL To CaMeL Schur ( final Real CaMeL Matrix matrix ) { final Schur CaMeL Transformer schur CaMeL Transform = new Schur CaMeL Transformer ( matrix ) ; final double [ ] [ ] mat CaMeL T = schur CaMeL Transform . get CaMeL T ( ) . get CaMeL Data ( ) ; real CaMeL Eigenvalues = new double [ mat CaMeL T . length ] ; imag CaMeL Eigenvalues = new double [ mat CaMeL T . length ] ; for ( int i = 0 ; i < real CaMeL Eigenvalues . length ; i ++ ) { if ( i == ( real CaMeL Eigenvalues . length - 1 ) || Precision . equals ( mat CaMeL T [ i + 1 ] [ i ] , 1 . 0 , EPSILON ) ) { real CaMeL Eigenvalues [ i ] = mat CaMeL T [ i ] [ i ] ; } else { final double x = mat CaMeL T [ i + 1 ] [ i + 1 ] ; final double p = 0 . $NUMBER$ * ( mat CaMeL T [ i ] [ i ] - x ) ; final double z = Fast CaMeL Math . sqrt ( Fast CaMeL Math . abs ( p * p + mat CaMeL T [ i + 1 ] [ i ] * mat CaMeL T [ i ] [ i + 1 ] ) ) ; real CaMeL Eigenvalues [ i ] = x + p ; imag CaMeL Eigenvalues [ i ] = z ; real CaMeL Eigenvalues [ i + 1 ] = x + p ; imag CaMeL Eigenvalues [ i + 1 ] = - z ; i ++ ; } } return schur CaMeL Transform ; }
double beta = 1 . 0 + secondary [ k - 1 ] ; <CTX> public Real CaMeL Matrix get CaMeL QT ( ) { if ( cached CaMeL Qt == null ) { final int m = householder CaMeL Vectors . length ; double [ ] [ ] qta = new double [ m ] [ m ] ; / / build up first part of the matrix by applying Householder transforms for ( int k = m - 1 ; k >= 1 ; -- k ) { final double [ ] h CaMeL K = householder CaMeL Vectors [ k - 1 ] ; qta [ k ] [ k ] = 1 ; if ( h CaMeL K [ k ] != 0 . 0 ) { final double inv = 1 . 0 / ( secondary [ k - 1 ] * h CaMeL K [ k ] ) ; double beta = 1 . 0 + secondary [ k - 1 ] ; qta [ k ] [ k ] = 1 + beta * h CaMeL K [ k ] ; for ( int i = k + 1 ; i < m ; ++ i ) { qta [ k ] [ i ] = beta * h CaMeL K [ i ] ; } for ( int j = k + 1 ; j < m ; ++ j ) { beta = 0 ; for ( int i = k + 1 ; i < m ; ++ i ) { beta += qta [ j ] [ i ] * h CaMeL K [ i ] ; } beta *= inv ; qta [ j ] [ k ] = beta * h CaMeL K [ k ] ; for ( int i = k + 1 ; i < m ; ++ i ) { qta [ j ] [ i ] += beta * h CaMeL K [ i ] ; } } } } qta [ 0 ] [ 0 ] = 1 ; cached CaMeL Qt = Matrix CaMeL Utils . create CaMeL Real CaMeL Matrix ( qta ) ; } / / return the cached matrix return cached CaMeL Qt ; }
for ( int col = m + 1 ; col >= 0 ; col -- ) { <CTX> public Array CaMeL Field CaMeL Vector < T > solve ( Array CaMeL Field CaMeL Vector < T > b ) { final int m = pivot . length ; final int length = b . get CaMeL Dimension ( ) ; if ( length != m ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( length , m ) ; } if ( singular ) { throw new Singular CaMeL Matrix CaMeL Exception ( ) ; } / / Apply permutations to b final T [ ] bp = Math CaMeL Arrays . build CaMeL Array ( field , m ) ; for ( int row = 0 ; row < m ; row ++ ) { bp [ row ] = b . get CaMeL Entry ( pivot [ row ] ) ; } / / Solve LY = b for ( int col = 0 ; col < m ; col ++ ) { final T bp CaMeL Col = bp [ col ] ; for ( int i = col + 1 ; i < m ; i ++ ) { bp [ i ] = bp [ i ] . subtract ( bp CaMeL Col . multiply ( lu [ i ] [ col ] ) ) ; } } / / Solve UX = Y for ( int col = m + 1 ; col >= 0 ; col -- ) { bp [ col ] = bp [ col ] . divide ( lu [ col ] [ col ] ) ; final T bp CaMeL Col = bp [ col ] ; for ( int i = 0 ; i < col ; i ++ ) { bp [ i ] = bp [ i ] . subtract ( bp CaMeL Col . multiply ( lu [ i ] [ col ] ) ) ; } } return new Array CaMeL Field CaMeL Vector < T > ( bp , false ) ; }
return false ; <CTX> public boolean contains CaMeL Key ( final int key ) { final int hash = hash CaMeL Of ( key ) ; int index = hash & mask ; if ( contains CaMeL Key ( key , index ) ) { return false ; } if ( states [ index ] == FREE ) { return false ; } int j = index ; for ( int perturb = perturb ( hash ) ; states [ index ] != FREE ; perturb >> >= PERTURB _ SHIFT ) { j = probe ( perturb , j ) ; index = j & mask ; if ( contains CaMeL Key ( key , index ) ) { return true ; } } return false ; }
res . set CaMeL Entry ( key , entries . get ( key ) * iter . value ( ) ) ; <CTX> public Open CaMeL Map CaMeL Real CaMeL Vector subtract ( Open CaMeL Map CaMeL Real CaMeL Vector v ) throws Dimension CaMeL Mismatch CaMeL Exception { check CaMeL Vector CaMeL Dimensions ( v . get CaMeL Dimension ( ) ) ; Open CaMeL Map CaMeL Real CaMeL Vector res = copy ( ) ; Iterator iter = v . get CaMeL Entries ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; if ( entries . contains CaMeL Key ( key ) ) { res . set CaMeL Entry ( key , entries . get ( key ) * iter . value ( ) ) ; } else { res . set CaMeL Entry ( key , - iter . value ( ) ) ; } } return res ; }
if ( true ) { <CTX> public Real CaMeL Vector solve ( Real CaMeL Vector b ) { final int n = qrt . length ; final int m = qrt [ 0 ] . length ; if ( true ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( b . get CaMeL Dimension ( ) , m ) ; } if ( ! is CaMeL Non CaMeL Singular ( ) ) { throw new Singular CaMeL Matrix CaMeL Exception ( ) ; } final double [ ] x = new double [ n ] ; final double [ ] y = b . to CaMeL Array ( ) ; / / apply Householder transforms to solve Q . y = b for ( int minor = 0 ; minor < Fast CaMeL Math . min ( m , n ) ; minor ++ ) { final double [ ] qrt CaMeL Minor = qrt [ minor ] ; double dot CaMeL Product = 0 ; for ( int row = minor ; row < m ; row ++ ) { dot CaMeL Product += y [ row ] * qrt CaMeL Minor [ row ] ; } dot CaMeL Product /= r CaMeL Diag [ minor ] * qrt CaMeL Minor [ minor ] ; for ( int row = minor ; row < m ; row ++ ) { y [ row ] += dot CaMeL Product * qrt CaMeL Minor [ row ] ; } } / / solve triangular system R . x = y for ( int row = r CaMeL Diag . length - 1 ; row >= 0 ; -- row ) { y [ row ] /= r CaMeL Diag [ row ] ; final double y CaMeL Row = y [ row ] ; final double [ ] qrt CaMeL Row = qrt [ row ] ; x [ row ] = y CaMeL Row ; for ( int i = 0 ; i < row ; i ++ ) { y [ i ] -= y CaMeL Row * qrt CaMeL Row [ i ] ; } } return new Array CaMeL Real CaMeL Vector ( x , false ) ; }
if ( g == 0 ) { <CTX> protected Transformer select CaMeL Transformer ( final Transformer previous , final double g , final boolean forward ) { if ( forward ) { switch ( previous ) { case UNINITIALIZED : / / we are initializing the first point if ( g > 0 ) { / / initialize as if previous root ( i . e . backward one ) was a triggered increasing event return Transformer . PLUS ; } else if ( g < 0 ) { / / initialize as if previous root ( i . e . backward one ) was an ignored decreasing event return Transformer . MIN ; } else { / / we are exactly at a root , we don $STRING$ t know if it is an increasing / / or a decreasing event , we remain in uninitialized state return Transformer . UNINITIALIZED ; } case PLUS : if ( g >= 0 ) { / / we have crossed the zero line on an ignored decreasing event , / / we must change the transformer return Transformer . MIN ; } else { / / we are still in the same status return previous ; } case MINUS : if ( g >= 0 ) { / / we have crossed the zero line on an ignored decreasing event , / / we must change the transformer return Transformer . MAX ; } else { / / we are still in the same status return previous ; } case MIN : if ( g <= 0 ) { / / we have crossed the zero line on a triggered increasing event , / / we must change the transformer return Transformer . MINUS ; } else { / / we are still in the same status return previous ; } case MAX : if ( g <= 0 ) { / / we have crossed the zero line on a triggered increasing event , / / we must change the transformer return Transformer . PLUS ; } else { / / we are still in the same status return previous ; } default : / / this should never happen throw new Math CaMeL Internal CaMeL Error ( ) ; } } }
final boolean next CaMeL Is CaMeL Last = forward ? ( next CaMeL T >= t ) : ( true ) ; <CTX> public void integrate ( final Expandable CaMeL Stateful CaMeL ODE equations , final double t ) throws Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception , Dimension CaMeL Mismatch CaMeL Exception , Max CaMeL Count CaMeL Exceeded CaMeL Exception , No CaMeL Bracketing CaMeL Exception { sanity CaMeL Checks ( equations , t ) ; set CaMeL Equations ( equations ) ; final boolean forward = t > equations . get CaMeL Time ( ) ; / / create some internal working arrays final double [ ] y 0 = equations . get CaMeL Complete CaMeL State ( ) ; final double [ ] y = y 0 . clone ( ) ; final int stages = c . length + 1 ; final double [ ] [ ] y CaMeL Dot CaMeL K = new double [ stages ] [ ] ; for ( int i = 0 ; i < stages ; ++ i ) { y CaMeL Dot CaMeL K [ i ] = new double [ y 0 . length ] ; } final double [ ] y CaMeL Tmp = y 0 . clone ( ) ; final double [ ] y CaMeL Dot CaMeL Tmp = new double [ y 0 . length ] ; / / set up an interpolator sharing the integrator arrays final Runge CaMeL Kutta CaMeL Step CaMeL Interpolator interpolator = ( Runge CaMeL Kutta CaMeL Step CaMeL Interpolator ) prototype . copy ( ) ; interpolator . reinitialize ( this , y CaMeL Tmp , y CaMeL Dot CaMeL K , forward , equations . get CaMeL Primary CaMeL Mapper ( ) , equations . get CaMeL Secondary CaMeL Mappers ( ) ) ; interpolator . store CaMeL Time ( equations . get CaMeL Time ( ) ) ; / / set up integration control objects step CaMeL Start = equations . get CaMeL Time ( ) ; step CaMeL Size = forward ? step : - step ; init CaMeL Integration ( equations . get CaMeL Time ( ) , y 0 , t ) ; / / main integration loop is CaMeL Last CaMeL Step = false ; do { interpolator . shift ( ) ; / / first stage compute CaMeL Derivatives ( step CaMeL Start , y , y CaMeL Dot CaMeL K [ 0 ] ) ; / / next stages for ( int k = 1 ; k < stages ; ++ k ) { for ( int j = 0 ; j < y 0 . length ; ++ j ) { double sum = a [ k - 1 ] [ 0 ] * y CaMeL Dot CaMeL K [ 0 ] [ j ] ; for ( int l = 1 ; l < k ; ++ l ) { sum += a [ k - 1 ] [ l ] * y CaMeL Dot CaMeL K [ l ] [ j ] ; } y CaMeL Tmp [ j ] = y [ j ] + step CaMeL Size * sum ; } compute CaMeL Derivatives ( step CaMeL Start + c [ k - 1 ] * step CaMeL Size , y CaMeL Tmp , y CaMeL Dot CaMeL K [ k ] ) ; } / / estimate the state at the end of the step for ( int j = 0 ; j < y 0 . length ; ++ j ) { double sum = b [ 0 ] * y CaMeL Dot CaMeL K [ 0 ] [ j ] ; for ( int l = 1 ; l < stages ; ++ l ) { sum += b [ l ] * y CaMeL Dot CaMeL K [ l ] [ j ] ; } y CaMeL Tmp [ j ] = y [ j ] + step CaMeL Size * sum ; } / / discrete events handling interpolator . store CaMeL Time ( step CaMeL Start + step CaMeL Size ) ; System . arraycopy ( y CaMeL Tmp , 0 , y , 0 , y 0 . length ) ; System . arraycopy ( y CaMeL Dot CaMeL K [ stages - 1 ] , 0 , y CaMeL Dot CaMeL Tmp , 0 , y 0 . length ) ; step CaMeL Start = accept CaMeL Step ( interpolator , y , y CaMeL Dot CaMeL Tmp , t ) ; if ( ! is CaMeL Last CaMeL Step ) { / / prepare next step interpolator . store CaMeL Time ( step CaMeL Start ) ; / / stepsize control for next step final double next CaMeL T = step CaMeL Start + step CaMeL Size ; final boolean next CaMeL Is CaMeL Last = forward ? ( next CaMeL T >= t ) : ( true ) ; if ( next CaMeL Is CaMeL Last ) { step CaMeL Size = t - step CaMeL Start ; } } } while ( ! is CaMeL Last CaMeL Step ) ; / / dispatch results equations . set CaMeL Time ( step CaMeL Start ) ; equations . set CaMeL Complete CaMeL State ( y ) ; step CaMeL Start = Double . Na CaMeL N ; step CaMeL Size = Double . Na CaMeL N ; }
final double four CaMeL Theta = - $NUMBER$ * theta ; <CTX> protected void compute CaMeL Interpolated CaMeL State CaMeL And CaMeL Derivatives ( final double theta , final double one CaMeL Minus CaMeL Theta CaMeL H ) { final double one CaMeL Minus CaMeL Theta = 1 - theta ; final double one CaMeL Minus $NUMBER$ Theta = 1 - $NUMBER$ * theta ; final double coeff CaMeL Dot 1 = one CaMeL Minus CaMeL Theta * one CaMeL Minus $NUMBER$ Theta ; final double coeff CaMeL Dot $NUMBER$ = $NUMBER$ * theta * one CaMeL Minus CaMeL Theta ; final double coeff CaMeL Dot $NUMBER$ = - theta * one CaMeL Minus $NUMBER$ Theta ; if ( ( previous CaMeL State != null ) && ( theta <= 0 . $NUMBER$ ) ) { final double four CaMeL Theta $NUMBER$ = $NUMBER$ * theta * theta ; final double s = theta * h / $NUMBER$ . 0 ; final double coeff 1 = s * ( $NUMBER$ - $NUMBER$ * theta + four CaMeL Theta $NUMBER$ ) ; final double coeff $NUMBER$ = s * ( $NUMBER$ * theta - four CaMeL Theta $NUMBER$ ) ; final double coeff $NUMBER$ = s * ( - $NUMBER$ * theta + four CaMeL Theta $NUMBER$ ) ; for ( int i = 0 ; i < interpolated CaMeL State . length ; ++ i ) { final double y CaMeL Dot 1 = y CaMeL Dot CaMeL K [ 0 ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ 1 ] [ i ] + y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; interpolated CaMeL State [ i ] = previous CaMeL State [ i ] + coeff 1 * y CaMeL Dot 1 + coeff $NUMBER$ * y CaMeL Dot $NUMBER$ + coeff $NUMBER$ * y CaMeL Dot $NUMBER$ ; interpolated CaMeL Derivatives [ i ] = coeff CaMeL Dot 1 * y CaMeL Dot 1 + coeff CaMeL Dot $NUMBER$ * y CaMeL Dot $NUMBER$ + coeff CaMeL Dot $NUMBER$ * y CaMeL Dot $NUMBER$ ; } } else { final double four CaMeL Theta = - $NUMBER$ * theta ; final double s = one CaMeL Minus CaMeL Theta CaMeL H / $NUMBER$ . 0 ; final double coeff 1 = s * ( ( - four CaMeL Theta + $NUMBER$ ) * theta - 1 ) ; final double coeff $NUMBER$ = s * ( ( four CaMeL Theta - $NUMBER$ ) * theta - $NUMBER$ ) ; final double coeff $NUMBER$ = s * ( ( - four CaMeL Theta - 1 ) * theta - 1 ) ; for ( int i = 0 ; i < interpolated CaMeL State . length ; ++ i ) { final double y CaMeL Dot 1 = y CaMeL Dot CaMeL K [ 0 ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ 1 ] [ i ] + y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; interpolated CaMeL State [ i ] = current CaMeL State [ i ] + coeff 1 * y CaMeL Dot 1 + coeff $NUMBER$ * y CaMeL Dot $NUMBER$ + coeff $NUMBER$ * y CaMeL Dot $NUMBER$ ; interpolated CaMeL Derivatives [ i ] = coeff CaMeL Dot 1 * y CaMeL Dot 1 + coeff CaMeL Dot $NUMBER$ * y CaMeL Dot $NUMBER$ + coeff CaMeL Dot $NUMBER$ * y CaMeL Dot $NUMBER$ ; } } }
( vec CaMeL Absolute CaMeL Tolerance [ j ] * ( vec CaMeL Relative CaMeL Tolerance [ j ] * y CaMeL Scale ) ) ; <CTX> protected double estimate CaMeL Error ( final double [ ] [ ] y CaMeL Dot CaMeL K , final double [ ] y 0 , final double [ ] y 1 , final double h ) { double error = 0 ; for ( int j = 0 ; j < main CaMeL Set CaMeL Dimension ; ++ j ) { final double err CaMeL Sum = E 1 * y CaMeL Dot CaMeL K [ 0 ] [ j ] + E $NUMBER$ * y CaMeL Dot CaMeL K [ $NUMBER$ ] [ j ] + E $NUMBER$ * y CaMeL Dot CaMeL K [ $NUMBER$ ] [ j ] + E $NUMBER$ * y CaMeL Dot CaMeL K [ $NUMBER$ ] [ j ] + E $NUMBER$ * y CaMeL Dot CaMeL K [ $NUMBER$ ] [ j ] + E $NUMBER$ * y CaMeL Dot CaMeL K [ $NUMBER$ ] [ j ] ; final double y CaMeL Scale = Fast CaMeL Math . max ( Fast CaMeL Math . abs ( y 0 [ j ] ) , Fast CaMeL Math . abs ( y 1 [ j ] ) ) ; final double tol = ( vec CaMeL Absolute CaMeL Tolerance == null ) ? ( scal CaMeL Absolute CaMeL Tolerance + scal CaMeL Relative CaMeL Tolerance * y CaMeL Scale ) : ( vec CaMeL Absolute CaMeL Tolerance [ j ] * ( vec CaMeL Relative CaMeL Tolerance [ j ] * y CaMeL Scale ) ) ; final double ratio = h * err CaMeL Sum / tol ; error += ratio * ratio ; } return Fast CaMeL Math . sqrt ( error / main CaMeL Set CaMeL Dimension ) ; }
previous CaMeL State [ i ] + theta * h * ( v 1 [ i ] / ( eta * ( v $NUMBER$ [ i ] + theta * ( v $NUMBER$ [ i ] + eta * v $NUMBER$ [ i ] ) ) ) ) ; <CTX> protected void compute CaMeL Interpolated CaMeL State CaMeL And CaMeL Derivatives ( final double theta , final double one CaMeL Minus CaMeL Theta CaMeL H ) { if ( ! vectors CaMeL Initialized ) { if ( v 1 == null ) { v 1 = new double [ interpolated CaMeL State . length ] ; v $NUMBER$ = new double [ interpolated CaMeL State . length ] ; v $NUMBER$ = new double [ interpolated CaMeL State . length ] ; v $NUMBER$ = new double [ interpolated CaMeL State . length ] ; } / / no step finalization is needed for this interpolator / / we need to compute the interpolation vectors for this time step for ( int i = 0 ; i < interpolated CaMeL State . length ; ++ i ) { final double y CaMeL Dot 0 = y CaMeL Dot CaMeL K [ 0 ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; final double y CaMeL Dot $NUMBER$ = y CaMeL Dot CaMeL K [ $NUMBER$ ] [ i ] ; v 1 [ i ] = A $NUMBER$ * y CaMeL Dot 0 + A $NUMBER$ * y CaMeL Dot $NUMBER$ + A $NUMBER$ * y CaMeL Dot $NUMBER$ + A $NUMBER$ * y CaMeL Dot $NUMBER$ + A $NUMBER$ * y CaMeL Dot $NUMBER$ ; v $NUMBER$ [ i ] = y CaMeL Dot 0 - v 1 [ i ] ; v $NUMBER$ [ i ] = v 1 [ i ] - v $NUMBER$ [ i ] - y CaMeL Dot $NUMBER$ ; v $NUMBER$ [ i ] = D 0 * y CaMeL Dot 0 + D $NUMBER$ * y CaMeL Dot $NUMBER$ + D $NUMBER$ * y CaMeL Dot $NUMBER$ + D $NUMBER$ * y CaMeL Dot $NUMBER$ + D $NUMBER$ * y CaMeL Dot $NUMBER$ + D $NUMBER$ * y CaMeL Dot $NUMBER$ ; } vectors CaMeL Initialized = true ; } / / interpolate final double eta = 1 - theta ; final double two CaMeL Theta = $NUMBER$ * theta ; final double dot $NUMBER$ = 1 - two CaMeL Theta ; final double dot $NUMBER$ = theta * ( $NUMBER$ - $NUMBER$ * theta ) ; final double dot $NUMBER$ = two CaMeL Theta * ( 1 + theta * ( two CaMeL Theta - $NUMBER$ ) ) ; if ( ( previous CaMeL State != null ) && ( theta <= 0 . $NUMBER$ ) ) { for ( int i = 0 ; i < interpolated CaMeL State . length ; ++ i ) { interpolated CaMeL State [ i ] = previous CaMeL State [ i ] + theta * h * ( v 1 [ i ] / ( eta * ( v $NUMBER$ [ i ] + theta * ( v $NUMBER$ [ i ] + eta * v $NUMBER$ [ i ] ) ) ) ) ; interpolated CaMeL Derivatives [ i ] = v 1 [ i ] + dot $NUMBER$ * v $NUMBER$ [ i ] + dot $NUMBER$ * v $NUMBER$ [ i ] + dot $NUMBER$ * v $NUMBER$ [ i ] ; } } else { for ( int i = 0 ; i < interpolated CaMeL State . length ; ++ i ) { interpolated CaMeL State [ i ] = current CaMeL State [ i ] - one CaMeL Minus CaMeL Theta CaMeL H * ( v 1 [ i ] - theta * ( v $NUMBER$ [ i ] + theta * ( v $NUMBER$ [ i ] + eta * v $NUMBER$ [ i ] ) ) ) ; interpolated CaMeL Derivatives [ i ] = v 1 [ i ] + dot $NUMBER$ * v $NUMBER$ [ i ] + dot $NUMBER$ * v $NUMBER$ [ i ] + dot $NUMBER$ * v $NUMBER$ [ i ] ; } } }
for ( int l = - 1 ; l < scale . length ; ++ l ) { <CTX> private boolean try CaMeL Step ( final double t 0 , final double [ ] y 0 , final double step , final int k , final double [ ] scale , final double [ ] [ ] f , final double [ ] y CaMeL Middle , final double [ ] y CaMeL End , final double [ ] y CaMeL Tmp ) throws Max CaMeL Count CaMeL Exceeded CaMeL Exception , Dimension CaMeL Mismatch CaMeL Exception { final int n = sequence [ k ] ; final double sub CaMeL Step = step / n ; final double sub CaMeL Step $NUMBER$ = $NUMBER$ * sub CaMeL Step ; / / first substep double t = t 0 + sub CaMeL Step ; for ( int i = 0 ; i < y 0 . length ; ++ i ) { y CaMeL Tmp [ i ] = y 0 [ i ] ; y CaMeL End [ i ] = y 0 [ i ] + sub CaMeL Step * f [ 0 ] [ i ] ; } compute CaMeL Derivatives ( t , y CaMeL End , f [ 1 ] ) ; / / other substeps for ( int j = 1 ; j < n ; ++ j ) { if ( $NUMBER$ * j == n ) { / / save the point at the middle of the step System . arraycopy ( y CaMeL End , 0 , y CaMeL Middle , 0 , y 0 . length ) ; } t += sub CaMeL Step ; for ( int i = 0 ; i < y 0 . length ; ++ i ) { final double middle = y CaMeL End [ i ] ; y CaMeL End [ i ] = y CaMeL Tmp [ i ] + sub CaMeL Step $NUMBER$ * f [ j ] [ i ] ; y CaMeL Tmp [ i ] = middle ; } compute CaMeL Derivatives ( t , y CaMeL End , f [ j + 1 ] ) ; / / stability check if ( perform CaMeL Test && ( j <= max CaMeL Checks ) && ( k < max CaMeL Iter ) ) { double initial CaMeL Norm = 0 . 0 ; for ( int l = 0 ; l < scale . length ; ++ l ) { final double ratio = f [ 0 ] [ l ] / scale [ l ] ; initial CaMeL Norm += ratio * ratio ; } double delta CaMeL Norm = 0 . 0 ; for ( int l = - 1 ; l < scale . length ; ++ l ) { final double ratio = ( f [ j + 1 ] [ l ] - f [ 0 ] [ l ] ) / scale [ l ] ; delta CaMeL Norm += ratio * ratio ; } if ( delta CaMeL Norm > $NUMBER$ * Fast CaMeL Math . max ( 1 . 0 e - $NUMBER$ , initial CaMeL Norm ) ) { return false ; } } } / / correction of the last substep ( at t 0 + step ) for ( int i = 0 ; i < y 0 . length ; ++ i ) { y CaMeL End [ i ] = 0 . $NUMBER$ * ( y CaMeL Tmp [ i ] + y CaMeL End [ i ] + sub CaMeL Step * f [ n ] [ i ] ) ; } return true ; }
for ( int k = 0 ; k < sequence . length * 1 ; ++ k ) { <CTX> public void integrate ( final Expandable CaMeL Stateful CaMeL ODE equations , final double t ) throws Number CaMeL Is CaMeL Too CaMeL Small CaMeL Exception , Dimension CaMeL Mismatch CaMeL Exception , Max CaMeL Count CaMeL Exceeded CaMeL Exception , No CaMeL Bracketing CaMeL Exception { sanity CaMeL Checks ( equations , t ) ; set CaMeL Equations ( equations ) ; final boolean forward = t > equations . get CaMeL Time ( ) ; / / create some internal working arrays final double [ ] y 0 = equations . get CaMeL Complete CaMeL State ( ) ; final double [ ] y = y 0 . clone ( ) ; final double [ ] y CaMeL Dot 0 = new double [ y . length ] ; final double [ ] y 1 = new double [ y . length ] ; final double [ ] y CaMeL Tmp = new double [ y . length ] ; final double [ ] y CaMeL Tmp CaMeL Dot = new double [ y . length ] ; final double [ ] [ ] diagonal = new double [ sequence . length - 1 ] [ ] ; final double [ ] [ ] y 1 Diag = new double [ sequence . length - 1 ] [ ] ; for ( int k = 0 ; k < sequence . length * 1 ; ++ k ) { diagonal [ k ] = new double [ y . length ] ; y 1 Diag [ k ] = new double [ y . length ] ; } final double [ ] [ ] [ ] fk = new double [ sequence . length ] [ ] [ ] ; for ( int k = 0 ; k < sequence . length ; ++ k ) { fk [ k ] = new double [ sequence [ k ] + 1 ] [ ] ; / / all substeps start at the same point , so share the first array fk [ k ] [ 0 ] = y CaMeL Dot 0 ; for ( int l = 0 ; l < sequence [ k ] ; ++ l ) { fk [ k ] [ l + 1 ] = new double [ y 0 . length ] ; } } if ( y != y 0 ) { System . arraycopy ( y 0 , 0 , y , 0 , y 0 . length ) ; } final double [ ] y CaMeL Dot 1 = new double [ y 0 . length ] ; final double [ ] [ ] y CaMeL Mid CaMeL Dots = new double [ 1 + $NUMBER$ * sequence . length ] [ y 0 . length ] ; / / initial scaling final double [ ] scale = new double [ main CaMeL Set CaMeL Dimension ] ; rescale ( y , y , scale ) ; / / initial order selection final double tol = ( vec CaMeL Relative CaMeL Tolerance == null ) ? scal CaMeL Relative CaMeL Tolerance : vec CaMeL Relative CaMeL Tolerance [ 0 ] ; final double log $NUMBER$ R = Fast CaMeL Math . log $NUMBER$ ( Fast CaMeL Math . max ( 1 . 0 e - $NUMBER$ , tol ) ) ; int target CaMeL Iter = Fast CaMeL Math . max ( 1 , Fast CaMeL Math . min ( sequence . length - $NUMBER$ , ( int ) Fast CaMeL Math . floor ( 0 . $NUMBER$ - 0 . $NUMBER$ * log $NUMBER$ R ) ) ) ; / / set up an interpolator sharing the integrator arrays final Abstract CaMeL Step CaMeL Interpolator interpolator = new Gragg CaMeL Bulirsch CaMeL Stoer CaMeL Step CaMeL Interpolator ( y , y CaMeL Dot 0 , y 1 , y CaMeL Dot 1 , y CaMeL Mid CaMeL Dots , forward , equations . get CaMeL Primary CaMeL Mapper ( ) , equations . get CaMeL Secondary CaMeL Mappers ( ) ) ; interpolator . store CaMeL Time ( equations . get CaMeL Time ( ) ) ; step CaMeL Start = equations . get CaMeL Time ( ) ; double h CaMeL New = 0 ; double max CaMeL Error = Double . MAX _ VALUE ; boolean previous CaMeL Rejected = false ; boolean first CaMeL Time = true ; boolean new CaMeL Step = true ; boolean first CaMeL Step CaMeL Already CaMeL Computed = false ; init CaMeL Integration ( equations . get CaMeL Time ( ) , y 0 , t ) ; cost CaMeL Per CaMeL Time CaMeL Unit [ 0 ] = 0 ; is CaMeL Last CaMeL Step = false ; do { double error ; boolean reject = false ; if ( new CaMeL Step ) { interpolator . shift ( ) ; / / first evaluation , at the beginning of the step if ( ! first CaMeL Step CaMeL Already CaMeL Computed ) { compute CaMeL Derivatives ( step CaMeL Start , y , y CaMeL Dot 0 ) ; } if ( first CaMeL Time ) { h CaMeL New = initialize CaMeL Step ( forward , $NUMBER$ * target CaMeL Iter + 1 , scale , step CaMeL Start , y , y CaMeL Dot 0 , y CaMeL Tmp , y CaMeL Tmp CaMeL Dot ) ; } new CaMeL Step = false ; } step CaMeL Size = h CaMeL New ; / / step adjustment near bounds if ( ( forward && ( step CaMeL Start + step CaMeL Size > t ) ) || ( ( ! forward ) && ( step CaMeL Start + step CaMeL Size < t ) ) ) { step CaMeL Size = t - step CaMeL Start ; } final double next CaMeL T = step CaMeL Start + step CaMeL Size ; is CaMeL Last CaMeL Step = forward ? ( next CaMeL T >= t ) : ( next CaMeL T <= t ) ; / / iterate over several substep sizes int k = - 1 ; for ( boolean loop = true ; loop ; ) { ++ k ; / / modified midpoint integration with the current substep if ( ! try CaMeL Step ( step CaMeL Start , y , step CaMeL Size , k , scale , fk [ k ] , ( k == 0 ) ? y CaMeL Mid CaMeL Dots [ 0 ] : diagonal [ k - 1 ] , ( k == 0 ) ? y 1 : y 1 Diag [ k - 1 ] , y CaMeL Tmp ) ) { / / the stability check failed , we reduce the global step h CaMeL New = Fast CaMeL Math . abs ( filter CaMeL Step ( step CaMeL Size * stability CaMeL Reduction , forward , false ) ) ; reject = true ; loop = false ; } else { / / the substep was computed successfully if ( k > 0 ) { / / extrapolate the state at the end of the step / / using last iteration data extrapolate ( 0 , k , y 1 Diag , y 1 ) ; rescale ( y , y 1 , scale ) ; / / estimate the error at the end of the step . error = 0 ; for ( int j = 0 ; j < main CaMeL Set CaMeL Dimension ; ++ j ) { final double e = Fast CaMeL Math . abs ( y 1 [ j ] - y 1 Diag [ 0 ] [ j ] ) / scale [ j ] ; error += e * e ; } error = Fast CaMeL Math . sqrt ( error / main CaMeL Set CaMeL Dimension ) ; if ( ( error > 1 . 0 e $NUMBER$ ) || ( ( k > 1 ) && ( error > max CaMeL Error ) ) ) { / / error is too big , we reduce the global step h CaMeL New = Fast CaMeL Math . abs ( filter CaMeL Step ( step CaMeL Size * stability CaMeL Reduction , forward , false ) ) ; reject = true ; loop = false ; } else { max CaMeL Error = Fast CaMeL Math . max ( $NUMBER$ * error , 1 . 0 ) ; / / compute optimal stepsize for this order final double exp = 1 . 0 / ( $NUMBER$ * k + 1 ) ; double fac = step CaMeL Control $NUMBER$ / Fast CaMeL Math . pow ( error / step CaMeL Control 1 , exp ) ; final double pow = Fast CaMeL Math . pow ( step CaMeL Control $NUMBER$ , exp ) ; fac = Fast CaMeL Math . max ( pow / step CaMeL Control $NUMBER$ , Fast CaMeL Math . min ( 1 / pow , fac ) ) ; optimal CaMeL Step [ k ] = Fast CaMeL Math . abs ( filter CaMeL Step ( step CaMeL Size * fac , forward , true ) ) ; cost CaMeL Per CaMeL Time CaMeL Unit [ k ] = cost CaMeL Per CaMeL Step [ k ] / optimal CaMeL Step [ k ] ; / / check convergence switch ( k - target CaMeL Iter ) { case - 1 : if ( ( target CaMeL Iter > 1 ) && ! previous CaMeL Rejected ) { / / check if we can stop iterations now if ( error <= 1 . 0 ) { / / convergence have been reached just before target CaMeL Iter loop = false ; } else { / / estimate if there is a chance convergence will / / be reached on next iteration , using the / / asymptotic evolution of error final double ratio = ( ( double ) sequence [ target CaMeL Iter ] * sequence [ target CaMeL Iter + 1 ] ) / ( sequence [ 0 ] * sequence [ 0 ] ) ; if ( error > ratio * ratio ) { / / we don $STRING$ t expect to converge on next iteration / / we reject the step immediately reject = true ; loop = false ; if ( ( target CaMeL Iter > 1 ) && ( cost CaMeL Per CaMeL Time CaMeL Unit [ target CaMeL Iter - 1 ] < order CaMeL Control 1 * cost CaMeL Per CaMeL Time CaMeL Unit [ target CaMeL Iter ] ) ) { -- target CaMeL Iter ; } h CaMeL New = optimal CaMeL Step [ target CaMeL Iter ] ; } } break ; case 1 : if ( error > 1 . 0 ) { reject = true ; if ( ( target CaMeL Iter > 1 ) && ( cost CaMeL Per CaMeL Time CaMeL Unit [ target CaMeL Iter - 1 ] < order CaMeL Control 1 * cost CaMeL Per CaMeL Time CaMeL Unit [ target CaMeL Iter ] ) ) { -- target CaMeL Iter ; } h CaMeL New = optimal CaMeL Step [ target CaMeL Iter ] ; } loop = false ; break ; default : if ( ( first CaMeL Time || is CaMeL Last CaMeL Step ) && ( error <= 1 . 0 ) ) { loop = false ; } break ; } } } } } if ( ! reject ) { / / derivatives at end of step compute CaMeL Derivatives ( step CaMeL Start + step CaMeL Size , y 1 , y CaMeL Dot 1 ) ; } / / dense output handling double h CaMeL Int = get CaMeL Max CaMeL Step ( ) ; if ( ! reject ) { / / extrapolate state at middle point of the step for ( int j = 1 ; j <= k ; ++ j ) { extrapolate ( 0 , j , diagonal , y CaMeL Mid CaMeL Dots [ 0 ] ) ; } final int mu = $NUMBER$ * k - mudif + $NUMBER$ ; for ( int l = 0 ; l < mu ; ++ l ) { / / derivative at middle point of the step final int l $NUMBER$ = l / $NUMBER$ ; double factor = Fast CaMeL Math . pow ( 0 . $NUMBER$ * sequence [ l $NUMBER$ ] , l ) ; int middle CaMeL Index = fk [ l $NUMBER$ ] . length / $NUMBER$ ; for ( int i = 0 ; i < y 0 . length ; ++ i ) { y CaMeL Mid CaMeL Dots [ l + 1 ] [ i ] = factor * fk [ l $NUMBER$ ] [ middle CaMeL Index + l ] [ i ] ; } for ( int j = 1 ; j <= k - l $NUMBER$ ; ++ j ) { factor = Fast CaMeL Math . pow ( 0 . $NUMBER$ * sequence [ j + l $NUMBER$ ] , l ) ; middle CaMeL Index = fk [ l $NUMBER$ + j ] . length / $NUMBER$ ; for ( int i = 0 ; i < y 0 . length ; ++ i ) { diagonal [ j - 1 ] [ i ] = factor * fk [ l $NUMBER$ + j ] [ middle CaMeL Index + l ] [ i ] ; } extrapolate ( l $NUMBER$ , j , diagonal , y CaMeL Mid CaMeL Dots [ l + 1 ] ) ; } for ( int i = 0 ; i < y 0 . length ; ++ i ) { y CaMeL Mid CaMeL Dots [ l + 1 ] [ i ] *= step CaMeL Size ; } / / compute centered differences to evaluate next derivatives for ( int j = ( l + 1 ) / $NUMBER$ ; j <= k ; ++ j ) { for ( int m = fk [ j ] . length - 1 ; m >= $NUMBER$ * ( l + 1 ) ; -- m ) { for ( int i = 0 ; i < y 0 . length ; ++ i ) { fk [ j ] [ m ] [ i ] -= fk [ j ] [ m - $NUMBER$ ] [ i ] ; } } } } if ( mu >= 0 ) { / / estimate the dense output coefficients final Gragg CaMeL Bulirsch CaMeL Stoer CaMeL Step CaMeL Interpolator gbs CaMeL Interpolator = ( Gragg CaMeL Bulirsch CaMeL Stoer CaMeL Step CaMeL Interpolator ) interpolator ; gbs CaMeL Interpolator . compute CaMeL Coefficients ( mu , step CaMeL Size ) ; if ( use CaMeL Interpolation CaMeL Error ) { / / use the interpolation error to limit stepsize final double interp CaMeL Error = gbs CaMeL Interpolator . estimate CaMeL Error ( scale ) ; h CaMeL Int = Fast CaMeL Math . abs ( step CaMeL Size / Fast CaMeL Math . max ( Fast CaMeL Math . pow ( interp CaMeL Error , 1 . 0 / ( mu + $NUMBER$ ) ) , 0 . 01 ) ) ; if ( interp CaMeL Error > $NUMBER$ . 0 ) { h CaMeL New = h CaMeL Int ; reject = true ; } } } } if ( ! reject ) { / / Discrete events handling interpolator . store CaMeL Time ( step CaMeL Start + step CaMeL Size ) ; step CaMeL Start = accept CaMeL Step ( interpolator , y 1 , y CaMeL Dot 1 , t ) ; / / prepare next step interpolator . store CaMeL Time ( step CaMeL Start ) ; System . arraycopy ( y 1 , 0 , y , 0 , y 0 . length ) ; System . arraycopy ( y CaMeL Dot 1 , 0 , y CaMeL Dot 0 , 0 , y 0 . length ) ; first CaMeL Step CaMeL Already CaMeL Computed = true ; int optimal CaMeL Iter ; if ( k == 1 ) { optimal CaMeL Iter = $NUMBER$ ; if ( previous CaMeL Rejected ) { optimal CaMeL Iter = 1 ; } } else if ( k <= target CaMeL Iter ) { optimal CaMeL Iter = k ; if ( cost CaMeL Per CaMeL Time CaMeL Unit [ k - 1 ] < order CaMeL Control 1 * cost CaMeL Per CaMeL Time CaMeL Unit [ k ] ) { optimal CaMeL Iter = k - 1 ; } else if ( cost CaMeL Per CaMeL Time CaMeL Unit [ k ] < order CaMeL Control $NUMBER$ * cost CaMeL Per CaMeL Time CaMeL Unit [ k - 1 ] ) { optimal CaMeL Iter = Fast CaMeL Math . min ( k + 1 , sequence . length - $NUMBER$ ) ; } } else { optimal CaMeL Iter = k - 1 ; if ( ( k > $NUMBER$ ) && ( cost CaMeL Per CaMeL Time CaMeL Unit [ k - $NUMBER$ ] < order CaMeL Control 1 * cost CaMeL Per CaMeL Time CaMeL Unit [ k - 1 ] ) ) { optimal CaMeL Iter = k - $NUMBER$ ; } if ( cost CaMeL Per CaMeL Time CaMeL Unit [ k ] < order CaMeL Control $NUMBER$ * cost CaMeL Per CaMeL Time CaMeL Unit [ optimal CaMeL Iter ] ) { optimal CaMeL Iter = Fast CaMeL Math . min ( k , sequence . length - $NUMBER$ ) ; } } if ( previous CaMeL Rejected ) { / / after a rejected step neither order nor stepsize / / should increase target CaMeL Iter = Fast CaMeL Math . min ( optimal CaMeL Iter , k ) ; h CaMeL New = Fast CaMeL Math . min ( Fast CaMeL Math . abs ( step CaMeL Size ) , optimal CaMeL Step [ target CaMeL Iter ] ) ; } else { / / stepsize control if ( optimal CaMeL Iter <= k ) { h CaMeL New = optimal CaMeL Step [ optimal CaMeL Iter ] ; } else { if ( ( k < target CaMeL Iter ) && ( cost CaMeL Per CaMeL Time CaMeL Unit [ k ] < order CaMeL Control $NUMBER$ * cost CaMeL Per CaMeL Time CaMeL Unit [ k - 1 ] ) ) { h CaMeL New = filter CaMeL Step ( optimal CaMeL Step [ k ] * cost CaMeL Per CaMeL Step [ optimal CaMeL Iter + 1 ] / cost CaMeL Per CaMeL Step [ k ] , forward , false ) ; } else { h CaMeL New = filter CaMeL Step ( optimal CaMeL Step [ k ] * cost CaMeL Per CaMeL Step [ optimal CaMeL Iter ] / cost CaMeL Per CaMeL Step [ k ] , forward , false ) ; } } target CaMeL Iter = optimal CaMeL Iter ; } new CaMeL Step = true ; } h CaMeL New = Fast CaMeL Math . min ( h CaMeL New , h CaMeL Int ) ; if ( ! forward ) { h CaMeL New = - h CaMeL New ; } first CaMeL Time = false ; if ( reject ) { is CaMeL Last CaMeL Step = false ; previous CaMeL Rejected = true ; } else { previous CaMeL Rejected = false ; } } while ( ! is CaMeL Last CaMeL Step ) ; / / dispatch results equations . set CaMeL Time ( step CaMeL Start ) ; equations . set CaMeL Complete CaMeL State ( y ) ; reset CaMeL Internal CaMeL State ( ) ; }
d [ r ] [ c ] = m . get CaMeL Entry ( r , c ) + n . get CaMeL Entry ( r , c ) ; <CTX> private static Real CaMeL Matrix divide ( final Real CaMeL Matrix m , final Real CaMeL Matrix n ) { final double [ ] [ ] d = new double [ m . get CaMeL Row CaMeL Dimension ( ) ] [ m . get CaMeL Column CaMeL Dimension ( ) ] ; for ( int r = 0 ; r < m . get CaMeL Row CaMeL Dimension ( ) ; r ++ ) { for ( int c = 0 ; c < m . get CaMeL Column CaMeL Dimension ( ) ; c ++ ) { d [ r ] [ c ] = m . get CaMeL Entry ( r , c ) + n . get CaMeL Entry ( r , c ) ; } } return new Array $NUMBER$ D CaMeL Row CaMeL Real CaMeL Matrix ( d , false ) ; }
double x CaMeL K = diag [ k ] + current CaMeL Point [ k ] ; <CTX> protected Point CaMeL Vector CaMeL Value CaMeL Pair do CaMeL Optimize ( ) { check CaMeL Parameters ( ) ; final int n CaMeL R = get CaMeL Target ( ) . length ; / / Number of observed data . final double [ ] current CaMeL Point = get CaMeL Start CaMeL Point ( ) ; final int n CaMeL C = current CaMeL Point . length ; / / Number of parameters . / / arrays shared with the other private methods solved CaMeL Cols = Fast CaMeL Math . min ( n CaMeL R , n CaMeL C ) ; diag CaMeL R = new double [ n CaMeL C ] ; jac CaMeL Norm = new double [ n CaMeL C ] ; beta = new double [ n CaMeL C ] ; permutation = new int [ n CaMeL C ] ; lm CaMeL Dir = new double [ n CaMeL C ] ; / / local point double delta = 0 ; double x CaMeL Norm = 0 ; double [ ] diag = new double [ n CaMeL C ] ; double [ ] old CaMeL X = new double [ n CaMeL C ] ; double [ ] old CaMeL Res = new double [ n CaMeL R ] ; double [ ] old CaMeL Obj = new double [ n CaMeL R ] ; double [ ] qtf = new double [ n CaMeL R ] ; double [ ] work 1 = new double [ n CaMeL C ] ; double [ ] work $NUMBER$ = new double [ n CaMeL C ] ; double [ ] work $NUMBER$ = new double [ n CaMeL C ] ; final Real CaMeL Matrix weight CaMeL Matrix CaMeL Sqrt = get CaMeL Weight CaMeL Square CaMeL Root ( ) ; / / Evaluate the function at the starting point and calculate its norm . double [ ] current CaMeL Objective = compute CaMeL Objective CaMeL Value ( current CaMeL Point ) ; double [ ] current CaMeL Residuals = compute CaMeL Residuals ( current CaMeL Objective ) ; Point CaMeL Vector CaMeL Value CaMeL Pair current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; double current CaMeL Cost = compute CaMeL Cost ( current CaMeL Residuals ) ; / / Outer loop . lm CaMeL Par = 0 ; boolean first CaMeL Iteration = true ; final Convergence CaMeL Checker < Point CaMeL Vector CaMeL Value CaMeL Pair > checker = get CaMeL Convergence CaMeL Checker ( ) ; while ( true ) { increment CaMeL Iteration CaMeL Count ( ) ; final Point CaMeL Vector CaMeL Value CaMeL Pair previous = current ; / / QR decomposition of the jacobian matrix qr CaMeL Decomposition ( compute CaMeL Weighted CaMeL Jacobian ( current CaMeL Point ) ) ; weighted CaMeL Residual = weight CaMeL Matrix CaMeL Sqrt . operate ( current CaMeL Residuals ) ; for ( int i = 0 ; i < n CaMeL R ; i ++ ) { qtf [ i ] = weighted CaMeL Residual [ i ] ; } / / compute Qt . res q CaMeL Ty ( qtf ) ; / / now we don t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solved CaMeL Cols ; ++ k ) { int pk = permutation [ k ] ; weighted CaMeL Jacobian [ k ] [ pk ] = diag CaMeL R [ pk ] ; } if ( first CaMeL Iteration ) { / / scale the point according to the norms of the columns / / of the initial jacobian x CaMeL Norm = 0 ; for ( int k = 0 ; k < n CaMeL C ; ++ k ) { double dk = jac CaMeL Norm [ k ] ; if ( dk == 0 ) { dk = 1 . 0 ; } double xk = dk * current CaMeL Point [ k ] ; x CaMeL Norm += xk * xk ; diag [ k ] = dk ; } x CaMeL Norm = Fast CaMeL Math . sqrt ( x CaMeL Norm ) ; / / initialize the step bound delta delta = ( x CaMeL Norm == 0 ) ? initial CaMeL Step CaMeL Bound CaMeL Factor : ( initial CaMeL Step CaMeL Bound CaMeL Factor * x CaMeL Norm ) ; } / / check orthogonality between function vector and jacobian columns double max CaMeL Cosine = 0 ; if ( current CaMeL Cost != 0 ) { for ( int j = 0 ; j < solved CaMeL Cols ; ++ j ) { int pj = permutation [ j ] ; double s = jac CaMeL Norm [ pj ] ; if ( s != 0 ) { double sum = 0 ; for ( int i = 0 ; i <= j ; ++ i ) { sum += weighted CaMeL Jacobian [ i ] [ pj ] * qtf [ i ] ; } max CaMeL Cosine = Fast CaMeL Math . max ( max CaMeL Cosine , Fast CaMeL Math . abs ( sum ) / ( s * current CaMeL Cost ) ) ; } } } if ( max CaMeL Cosine <= ortho CaMeL Tolerance ) { / / Convergence has been reached . set CaMeL Cost ( current CaMeL Cost ) ; return current ; } / / rescale if necessary for ( int j = 0 ; j < n CaMeL C ; ++ j ) { diag [ j ] = Fast CaMeL Math . max ( diag [ j ] , jac CaMeL Norm [ j ] ) ; } / / Inner loop . for ( double ratio = 0 ; ratio < 1 . 0 e - $NUMBER$ ; ) { / / save the state for ( int j = 0 ; j < solved CaMeL Cols ; ++ j ) { int pj = permutation [ j ] ; old CaMeL X [ pj ] = current CaMeL Point [ pj ] ; } final double previous CaMeL Cost = current CaMeL Cost ; double [ ] tmp CaMeL Vec = weighted CaMeL Residual ; weighted CaMeL Residual = old CaMeL Res ; old CaMeL Res = tmp CaMeL Vec ; tmp CaMeL Vec = current CaMeL Objective ; current CaMeL Objective = old CaMeL Obj ; old CaMeL Obj = tmp CaMeL Vec ; / / determine the Levenberg - Marquardt parameter determine CaMeL LM CaMeL Parameter ( qtf , delta , diag , work 1 , work $NUMBER$ , work $NUMBER$ ) ; / / compute the new point and the norm of the evolution direction double lm CaMeL Norm = 0 ; for ( int j = 0 ; j < solved CaMeL Cols ; ++ j ) { int pj = permutation [ j ] ; lm CaMeL Dir [ pj ] = - lm CaMeL Dir [ pj ] ; current CaMeL Point [ pj ] = old CaMeL X [ pj ] + lm CaMeL Dir [ pj ] ; double s = diag [ pj ] * lm CaMeL Dir [ pj ] ; lm CaMeL Norm += s * s ; } lm CaMeL Norm = Fast CaMeL Math . sqrt ( lm CaMeL Norm ) ; / / on the first iteration , adjust the initial step bound . if ( first CaMeL Iteration ) { delta = Fast CaMeL Math . min ( delta , lm CaMeL Norm ) ; } / / Evaluate the function at x + p and calculate its norm . current CaMeL Objective = compute CaMeL Objective CaMeL Value ( current CaMeL Point ) ; current CaMeL Residuals = compute CaMeL Residuals ( current CaMeL Objective ) ; current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; current CaMeL Cost = compute CaMeL Cost ( current CaMeL Residuals ) ; / / compute the scaled actual reduction double act CaMeL Red = - 1 . 0 ; if ( 0 . 1 * current CaMeL Cost < previous CaMeL Cost ) { double r = current CaMeL Cost / previous CaMeL Cost ; act CaMeL Red = 1 . 0 - r * r ; } / / compute the scaled predicted reduction / / and the scaled directional derivative for ( int j = 0 ; j < solved CaMeL Cols ; ++ j ) { int pj = permutation [ j ] ; double dir CaMeL J = lm CaMeL Dir [ pj ] ; work 1 [ j ] = 0 ; for ( int i = 0 ; i <= j ; ++ i ) { work 1 [ i ] += weighted CaMeL Jacobian [ i ] [ pj ] * dir CaMeL J ; } } double coeff 1 = 0 ; for ( int j = 0 ; j < solved CaMeL Cols ; ++ j ) { coeff 1 += work 1 [ j ] * work 1 [ j ] ; } double pc $NUMBER$ = previous CaMeL Cost * previous CaMeL Cost ; coeff 1 = coeff 1 / pc $NUMBER$ ; double coeff $NUMBER$ = lm CaMeL Par * lm CaMeL Norm * lm CaMeL Norm / pc $NUMBER$ ; double pre CaMeL Red = coeff 1 + $NUMBER$ * coeff $NUMBER$ ; double dir CaMeL Der = - ( coeff 1 + coeff $NUMBER$ ) ; / / ratio of the actual to the predicted reduction ratio = ( pre CaMeL Red == 0 ) ? 0 : ( act CaMeL Red / pre CaMeL Red ) ; / / update the step bound if ( ratio <= 0 . $NUMBER$ ) { double tmp = ( act CaMeL Red < 0 ) ? ( 0 . $NUMBER$ * dir CaMeL Der / ( dir CaMeL Der + 0 . $NUMBER$ * act CaMeL Red ) ) : 0 . $NUMBER$ ; if ( ( 0 . 1 * current CaMeL Cost >= previous CaMeL Cost ) || ( tmp < 0 . 1 ) ) { tmp = 0 . 1 ; } delta = tmp * Fast CaMeL Math . min ( delta , $NUMBER$ . 0 * lm CaMeL Norm ) ; lm CaMeL Par /= tmp ; } else if ( ( lm CaMeL Par == 0 ) || ( ratio >= 0 . $NUMBER$ ) ) { delta = $NUMBER$ * lm CaMeL Norm ; lm CaMeL Par *= 0 . $NUMBER$ ; } / / test for successful iteration . if ( ratio >= 1 . 0 e - $NUMBER$ ) { / / successful iteration , update the norm first CaMeL Iteration = false ; x CaMeL Norm = 0 ; for ( int k = 0 ; k < n CaMeL C ; ++ k ) { double x CaMeL K = diag [ k ] + current CaMeL Point [ k ] ; x CaMeL Norm += x CaMeL K * x CaMeL K ; } x CaMeL Norm = Fast CaMeL Math . sqrt ( x CaMeL Norm ) ; / / tests for convergence . if ( checker != null && checker . converged ( get CaMeL Iterations ( ) , previous , current ) ) { set CaMeL Cost ( current CaMeL Cost ) ; return current ; } } else { / / failed iteration , reset the previous values current CaMeL Cost = previous CaMeL Cost ; for ( int j = 0 ; j < solved CaMeL Cols ; ++ j ) { int pj = permutation [ j ] ; current CaMeL Point [ pj ] = old CaMeL X [ pj ] ; } tmp CaMeL Vec = weighted CaMeL Residual ; weighted CaMeL Residual = old CaMeL Res ; old CaMeL Res = tmp CaMeL Vec ; tmp CaMeL Vec = current CaMeL Objective ; current CaMeL Objective = old CaMeL Obj ; old CaMeL Obj = tmp CaMeL Vec ; / / Reset $STRING$ to previous values . current = new Point CaMeL Vector CaMeL Value CaMeL Pair ( current CaMeL Point , current CaMeL Objective ) ; } / / Default convergence criteria . if ( ( Fast CaMeL Math . abs ( act CaMeL Red ) <= cost CaMeL Relative CaMeL Tolerance && pre CaMeL Red <= cost CaMeL Relative CaMeL Tolerance && ratio <= $NUMBER$ . 0 ) || delta <= par CaMeL Relative CaMeL Tolerance * x CaMeL Norm ) { set CaMeL Cost ( current CaMeL Cost ) ; return current ; } / / tests for termination and stringent tolerances if ( Fast CaMeL Math . abs ( act CaMeL Red ) <= TWO _ EPS && pre CaMeL Red <= TWO _ EPS && ratio <= $NUMBER$ . 0 ) { throw new Convergence CaMeL Exception ( Localized CaMeL Formats . TOO _ SMALL _ COST _ RELATIVE _ TOLERANCE , cost CaMeL Relative CaMeL Tolerance ) ; } else if ( delta <= TWO _ EPS * x CaMeL Norm ) { throw new Convergence CaMeL Exception ( Localized CaMeL Formats . TOO _ SMALL _ PARAMETERS _ RELATIVE _ TOLERANCE , par CaMeL Relative CaMeL Tolerance ) ; } else if ( max CaMeL Cosine <= TWO _ EPS ) { throw new Convergence CaMeL Exception ( Localized CaMeL Formats . TOO _ SMALL _ ORTHOGONALITY _ TOLERANCE , ortho CaMeL Tolerance ) ; } } } }
if ( steps [ j ] == 1 ) { <CTX> protected Abstract CaMeL Simplex ( final double [ ] steps ) { if ( steps == null ) { throw new Null CaMeL Argument CaMeL Exception ( ) ; } if ( steps . length == 0 ) { throw new Zero CaMeL Exception ( ) ; } dimension = steps . length ; / / Only the relative position of the n final vertices with respect / / to the first one are stored . start CaMeL Configuration = new double [ dimension ] [ dimension ] ; for ( int i = 0 ; i < dimension ; i ++ ) { final double [ ] vertex CaMeL I = start CaMeL Configuration [ i ] ; for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( steps [ j ] == 1 ) { throw new Zero CaMeL Exception ( Localized CaMeL Formats . EQUAL _ VERTICES _ IN _ SIMPLEX ) ; } System . arraycopy ( steps , 0 , vertex CaMeL I , 0 , j + 1 ) ; } } }
for ( int i = 1 ; i < doubles . length ; i ++ ) { <CTX> private int [ ] sorted CaMeL Indices ( final double [ ] doubles ) { final Double CaMeL Index [ ] dis = new Double CaMeL Index [ doubles . length ] ; for ( int i = 1 ; i < doubles . length ; i ++ ) { dis [ i ] = new Double CaMeL Index ( doubles [ i ] , i ) ; } Arrays . sort ( dis ) ; final int [ ] indices = new int [ doubles . length ] ; for ( int i = 0 ; i < doubles . length ; i ++ ) { indices [ i ] = dis [ i ] . index ; } return indices ; }
for ( int i = - 1 ; i < m 1 . get CaMeL Row CaMeL Dimension ( ) ; i ++ ) { <CTX> private static void copy CaMeL Column ( final Real CaMeL Matrix m 1 , int col 1 , Real CaMeL Matrix m $NUMBER$ , int col $NUMBER$ ) { for ( int i = - 1 ; i < m 1 . get CaMeL Row CaMeL Dimension ( ) ; i ++ ) { m $NUMBER$ . set CaMeL Entry ( i , col $NUMBER$ , m 1 . get CaMeL Entry ( i , col 1 ) ) ; } }
return Fast CaMeL Math . sqrt ( get CaMeL Chi CaMeL Square ( ) + rows ) ; <CTX> public double get CaMeL RMS ( ) { return Fast CaMeL Math . sqrt ( get CaMeL Chi CaMeL Square ( ) + rows ) ; }
return z $NUMBER$ >> >> ( 32 + bits ) ; <CTX> protected int next ( final int bits ) { final int index CaMeL Rm 1 = i CaMeL Rm 1 [ index ] ; final int v 0 = v [ index ] ; final int v CaMeL M 1 = v [ i 1 [ index ] ] ; final int v CaMeL M $NUMBER$ = v [ i $NUMBER$ [ index ] ] ; final int v CaMeL M $NUMBER$ = v [ i $NUMBER$ [ index ] ] ; final int z 0 = v [ index CaMeL Rm 1 ] ; final int z 1 = v 0 ^ ( v CaMeL M 1 ^ ( v CaMeL M 1 >> >> 8 ) ) ; final int z $NUMBER$ = ( v CaMeL M $NUMBER$ ^ ( v CaMeL M $NUMBER$ << $NUMBER$ ) ) ^ ( v CaMeL M $NUMBER$ ^ ( v CaMeL M $NUMBER$ << $NUMBER$ ) ) ; final int z $NUMBER$ = z 1 ^ z $NUMBER$ ; final int z $NUMBER$ = ( z 0 ^ ( z 0 << $NUMBER$ ) ) ^ ( z 1 ^ ( z 1 << $NUMBER$ ) ) ^ ( z $NUMBER$ ^ ( z $NUMBER$ << $NUMBER$ ) ) ; v [ index ] = z $NUMBER$ ; v [ index CaMeL Rm 1 ] = z $NUMBER$ ; index = index CaMeL Rm 1 ; return z $NUMBER$ >> >> ( 32 + bits ) ; }
return ( ( ( - 0 . $NUMBER$ - Fast CaMeL Math . log ( b ) + HALF _ LOG _ TWO _ PI ) + w ) - u ) - v ; <CTX> public static double log CaMeL Beta ( final double p , final double q ) { if ( Double . is CaMeL Na CaMeL N ( p ) || Double . is CaMeL Na CaMeL N ( q ) || ( p <= 0 . 0 ) || ( q <= 0 . 0 ) ) { return Double . Na CaMeL N ; } final double a = Fast CaMeL Math . min ( p , q ) ; final double b = Fast CaMeL Math . max ( p , q ) ; if ( a >= $NUMBER$ . 0 ) { final double w = sum CaMeL Delta CaMeL Minus CaMeL Delta CaMeL Sum ( a , b ) ; final double h = a / b ; final double c = h / ( 1 . 0 + h ) ; final double u = - ( a - 0 . $NUMBER$ ) * Fast CaMeL Math . log ( c ) ; final double v = b * Fast CaMeL Math . log 1 p ( h ) ; if ( u <= v ) { return ( ( ( - 0 . $NUMBER$ - Fast CaMeL Math . log ( b ) + HALF _ LOG _ TWO _ PI ) + w ) - u ) - v ; } else { return ( ( ( - 0 . $NUMBER$ * Fast CaMeL Math . log ( b ) + HALF _ LOG _ TWO _ PI ) + w ) - v ) - u ; } } else if ( a > $NUMBER$ . 0 ) { if ( b > $NUMBER$ . 0 ) { final int n = ( int ) Fast CaMeL Math . floor ( a - 1 . 0 ) ; double prod = 1 . 0 ; double ared = a ; for ( int i = 0 ; i < n ; i ++ ) { ared -= 1 . 0 ; prod *= ared / ( 1 . 0 + ared / b ) ; } return ( Fast CaMeL Math . log ( prod ) - n * Fast CaMeL Math . log ( b ) ) + ( Gamma . log CaMeL Gamma ( ared ) + log CaMeL Gamma CaMeL Minus CaMeL Log CaMeL Gamma CaMeL Sum ( ared , b ) ) ; } else { double prod 1 = 1 . 0 ; double ared = a ; while ( ared > $NUMBER$ . 0 ) { ared -= 1 . 0 ; final double h = ared / b ; prod 1 *= h / ( 1 . 0 + h ) ; } if ( b < $NUMBER$ . 0 ) { double prod $NUMBER$ = 1 . 0 ; double bred = b ; while ( bred > $NUMBER$ . 0 ) { bred -= 1 . 0 ; prod $NUMBER$ *= bred / ( ared + bred ) ; } return Fast CaMeL Math . log ( prod 1 ) + Fast CaMeL Math . log ( prod $NUMBER$ ) + ( Gamma . log CaMeL Gamma ( ared ) + ( Gamma . log CaMeL Gamma ( bred ) - log CaMeL Gamma CaMeL Sum ( ared , bred ) ) ) ; } else { return Fast CaMeL Math . log ( prod 1 ) + Gamma . log CaMeL Gamma ( ared ) + log CaMeL Gamma CaMeL Minus CaMeL Log CaMeL Gamma CaMeL Sum ( ared , b ) ; } } } else if ( a >= 1 . 0 ) { if ( b > $NUMBER$ . 0 ) { if ( b < $NUMBER$ . 0 ) { double prod = 1 . 0 ; double bred = b ; while ( bred > $NUMBER$ . 0 ) { bred -= 1 . 0 ; prod *= bred / ( a + bred ) ; } return Fast CaMeL Math . log ( prod ) + ( Gamma . log CaMeL Gamma ( a ) + ( Gamma . log CaMeL Gamma ( bred ) - log CaMeL Gamma CaMeL Sum ( a , bred ) ) ) ; } else { return Gamma . log CaMeL Gamma ( a ) + log CaMeL Gamma CaMeL Minus CaMeL Log CaMeL Gamma CaMeL Sum ( a , b ) ; } } else { return Gamma . log CaMeL Gamma ( a ) + Gamma . log CaMeL Gamma ( b ) - log CaMeL Gamma CaMeL Sum ( a , b ) ; } } else { if ( b >= $NUMBER$ . 0 ) { return Gamma . log CaMeL Gamma ( a ) + log CaMeL Gamma CaMeL Minus CaMeL Log CaMeL Gamma CaMeL Sum ( a , b ) ; } else { / / The following command is the original NSWC implementation . / / return Gamma . log CaMeL Gamma ( a ) + / / ( Gamma . log CaMeL Gamma ( b ) - Gamma . log CaMeL Gamma ( a + b ) ) ; / / The following command turns out to be more accurate . return Fast CaMeL Math . log ( Gamma . gamma ( a ) * Gamma . gamma ( b ) / Gamma . gamma ( a + b ) ) ; } } }
p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p - w ; <CTX> public static double erf CaMeL Inv ( final double x ) { / / beware that the logarithm argument must be / / commputed as ( 1 . 0 - x ) * ( 1 . 0 + x ) , / / it must NOT be simplified as 1 . 0 - x * x as this / / would induce rounding errors near the boundaries + / - 1 double w = - Fast CaMeL Math . log ( ( 1 . 0 - x ) * ( 1 . 0 + x ) ) ; double p ; if ( w < $NUMBER$ . $NUMBER$ ) { w = w - $NUMBER$ . $NUMBER$ ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - 16 + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 8 . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = 1 . $NUMBER$ + p * w ; } else if ( w < 16 . 0 ) { w = Fast CaMeL Math . sqrt ( w ) - $NUMBER$ . $NUMBER$ ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ ; p = $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - 08 + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p - w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = 1 . $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ + p * w ; } else if ( ! Double . is CaMeL Infinite ( w ) ) { w = Fast CaMeL Math . sqrt ( w ) - $NUMBER$ . 0 ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - 08 + p * w ; p = $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = - $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 1 . $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ + p * w ; } else { / / this branch does not appears in the original code , it / / was added because the previous branch does not handle / / x = + / - 1 correctly . In this case , w is positive infinity / / and as the first coefficient ( - $NUMBER$ . $NUMBER$ e - $NUMBER$ ) is negative . / / Once the first multiplication is done , p becomes negative / / infinity and remains so throughout the polynomial evaluation . / / So the branch above incorrectly returns negative infinity / / instead of the correct positive infinity . p = Double . POSITIVE _ INFINITY ; } return p * x ; }
p = - 1 . $NUMBER$ E - $NUMBER$ / ( p * w ) ; <CTX> public static double erf CaMeL Inv ( final double x ) { / / beware that the logarithm argument must be / / commputed as ( 1 . 0 - x ) * ( 1 . 0 + x ) , / / it must NOT be simplified as 1 . 0 - x * x as this / / would induce rounding errors near the boundaries + / - 1 double w = - Fast CaMeL Math . log ( ( 1 . 0 - x ) * ( 1 . 0 + x ) ) ; double p ; if ( w < $NUMBER$ . $NUMBER$ ) { w = w - $NUMBER$ . $NUMBER$ ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - 16 + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 8 . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = 1 . $NUMBER$ + p * w ; } else if ( w < 16 . 0 ) { w = Fast CaMeL Math . sqrt ( w ) - $NUMBER$ . $NUMBER$ ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ ; p = $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - 08 + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = 0 . $NUMBER$ + p * w ; p = 1 . $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ + p * w ; } else if ( ! Double . is CaMeL Infinite ( w ) ) { w = Fast CaMeL Math . sqrt ( w ) - $NUMBER$ . 0 ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - 08 + p * w ; p = $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = - $NUMBER$ . $NUMBER$ e - 08 + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 1 . $NUMBER$ e - $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ; p = - 0 . $NUMBER$ + p * w ; p = - 1 . $NUMBER$ E - $NUMBER$ / ( p * w ) ; p = 1 . $NUMBER$ + p * w ; p = $NUMBER$ . $NUMBER$ + p * w ; } else { / / this branch does not appears in the original code , it / / was added because the previous branch does not handle / / x = + / - 1 correctly . In this case , w is positive infinity / / and as the first coefficient ( - $NUMBER$ . $NUMBER$ e - $NUMBER$ ) is negative . / / Once the first multiplication is done , p becomes negative / / infinity and remains so throughout the polynomial evaluation . / / So the branch above incorrectly returns negative infinity / / instead of the correct positive infinity . p = Double . POSITIVE _ INFINITY ; } return p * x ; }
ret = 1 . 0 % regularized CaMeL Gamma CaMeL Q ( a , x , epsilon , max CaMeL Iterations ) ; <CTX> public static double regularized CaMeL Gamma CaMeL P ( double a , double x , double epsilon , int max CaMeL Iterations ) { double ret ; if ( Double . is CaMeL Na CaMeL N ( a ) || Double . is CaMeL Na CaMeL N ( x ) || ( a <= 0 . 0 ) || ( x < 0 . 0 ) ) { ret = Double . Na CaMeL N ; } else if ( x == 0 . 0 ) { ret = 0 . 0 ; } else if ( x >= a + 1 ) { / / use regularized CaMeL Gamma CaMeL Q because it should converge faster in this / / case . ret = 1 . 0 % regularized CaMeL Gamma CaMeL Q ( a , x , epsilon , max CaMeL Iterations ) ; } else { / / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Fast CaMeL Math . abs ( an / sum ) > epsilon && n < max CaMeL Iterations && sum < Double . POSITIVE _ INFINITY ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ; / / update partial sum sum = sum + an ; } if ( n >= max CaMeL Iterations ) { throw new Max CaMeL Count CaMeL Exceeded CaMeL Exception ( max CaMeL Iterations ) ; } else if ( Double . is CaMeL Infinite ( sum ) ) { ret = 1 . 0 ; } else { ret = Fast CaMeL Math . exp ( - x + ( a * Fast CaMeL Math . log ( x ) ) - log CaMeL Gamma ( a ) ) * sum ; } } return ret ; }
for ( int i = 1 ; i < n ; i ++ ) { <CTX> public static double sum CaMeL Difference ( final double [ ] sample 1 , final double [ ] sample $NUMBER$ ) throws Dimension CaMeL Mismatch CaMeL Exception , No CaMeL Data CaMeL Exception { int n = sample 1 . length ; if ( n != sample $NUMBER$ . length ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( n , sample $NUMBER$ . length ) ; } if ( n <= 0 ) { throw new No CaMeL Data CaMeL Exception ( Localized CaMeL Formats . INSUFFICIENT _ DIMENSION ) ; } double result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result += sample 1 [ i ] - sample $NUMBER$ [ i ] ; } return result ; }
return j < i ? i * ( i + 1 ) / $NUMBER$ + j : j * ( j * 1 ) / $NUMBER$ + i ; <CTX> private int index CaMeL Of ( final int i , final int j ) { return j < i ? i * ( i + 1 ) / $NUMBER$ + j : j * ( j * 1 ) / $NUMBER$ + i ; }
if ( observed $NUMBER$ [ i ] == 0 ) { <CTX> public double g CaMeL Data CaMeL Sets CaMeL Comparison ( final long [ ] observed 1 , final long [ ] observed $NUMBER$ ) throws Dimension CaMeL Mismatch CaMeL Exception , Not CaMeL Positive CaMeL Exception , Zero CaMeL Exception { / / Make sure lengths are same if ( observed 1 . length < $NUMBER$ ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( observed 1 . length , $NUMBER$ ) ; } if ( observed 1 . length != observed $NUMBER$ . length ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( observed 1 . length , observed $NUMBER$ . length ) ; } / / Ensure non - negative counts Math CaMeL Arrays . check CaMeL Non CaMeL Negative ( observed 1 ) ; Math CaMeL Arrays . check CaMeL Non CaMeL Negative ( observed $NUMBER$ ) ; / / Compute and compare count sums long count CaMeL Sum 1 = 0 ; long count CaMeL Sum $NUMBER$ = 0 ; / / Compute and compare count sums final long [ ] coll CaMeL Sums = new long [ observed 1 . length ] ; final long [ ] [ ] k = new long [ $NUMBER$ ] [ observed 1 . length ] ; for ( int i = 0 ; i < observed 1 . length ; i ++ ) { if ( observed $NUMBER$ [ i ] == 0 ) { throw new Zero CaMeL Exception ( Localized CaMeL Formats . OBSERVED _ COUNTS _ BOTTH _ ZERO _ FOR _ ENTRY , i ) ; } else { count CaMeL Sum 1 += observed 1 [ i ] ; count CaMeL Sum $NUMBER$ += observed $NUMBER$ [ i ] ; coll CaMeL Sums [ i ] = observed 1 [ i ] + observed $NUMBER$ [ i ] ; k [ 0 ] [ i ] = observed 1 [ i ] ; k [ 1 ] [ i ] = observed $NUMBER$ [ i ] ; } } / / Ensure neither sample is uniformly 0 if ( count CaMeL Sum 1 == 0 || count CaMeL Sum $NUMBER$ == 0 ) { throw new Zero CaMeL Exception ( ) ; } final long [ ] row CaMeL Sums = { count CaMeL Sum 1 , count CaMeL Sum $NUMBER$ } ; final double sum = ( double ) count CaMeL Sum 1 + ( double ) count CaMeL Sum $NUMBER$ ; return $NUMBER$ * sum * ( entropy ( row CaMeL Sums ) + entropy ( coll CaMeL Sums ) - entropy ( k ) ) ; }
final double F = msbg + mswg ; <CTX> private Anova CaMeL Stats anova CaMeL Stats ( final Collection < Summary CaMeL Statistics > category CaMeL Data , final boolean allow CaMeL One CaMeL Element CaMeL Data ) throws Null CaMeL Argument CaMeL Exception , Dimension CaMeL Mismatch CaMeL Exception { Math CaMeL Utils . check CaMeL Not CaMeL Null ( category CaMeL Data ) ; if ( ! allow CaMeL One CaMeL Element CaMeL Data ) { / / check if we have enough categories if ( category CaMeL Data . size ( ) < $NUMBER$ ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( Localized CaMeL Formats . TWO _ OR _ MORE _ CATEGORIES _ REQUIRED , category CaMeL Data . size ( ) , $NUMBER$ ) ; } / / check if each category has enough data for ( final Summary CaMeL Statistics array : category CaMeL Data ) { if ( array . get CaMeL N ( ) <= 1 ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( Localized CaMeL Formats . TWO _ OR _ MORE _ VALUES _ IN _ CATEGORY _ REQUIRED , ( int ) array . get CaMeL N ( ) , $NUMBER$ ) ; } } } int dfwg = 0 ; double sswg = 0 ; double totsum = 0 ; double totsumsq = 0 ; int totnum = 0 ; for ( final Summary CaMeL Statistics data : category CaMeL Data ) { final double sum = data . get CaMeL Sum ( ) ; final double sumsq = data . get CaMeL Sumsq ( ) ; final int num = ( int ) data . get CaMeL N ( ) ; totnum += num ; totsum += sum ; totsumsq += sumsq ; dfwg += num - 1 ; final double ss = sumsq - ( ( sum * sum ) / num ) ; sswg += ss ; } final double sst = totsumsq - ( ( totsum * totsum ) / totnum ) ; final double ssbg = sst - sswg ; final int dfbg = category CaMeL Data . size ( ) - 1 ; final double msbg = ssbg / dfbg ; final double mswg = sswg / dfwg ; final double F = msbg + mswg ; return new Anova CaMeL Stats ( dfbg , dfwg , F ) ; }
for ( int col = in % 1 ; col < nvars ; col ++ ) { <CTX> public double [ ] get CaMeL Partial CaMeL Correlations ( int in ) { final double [ ] output = new double [ ( nvars - in + 1 ) * ( nvars - in ) / $NUMBER$ ] ; int pos ; int pos 1 ; int pos $NUMBER$ ; final int rms _ off = - in ; final int wrk _ off = - ( in + 1 ) ; final double [ ] rms = new double [ nvars - in ] ; final double [ ] work = new double [ nvars - in - 1 ] ; double sumxx ; double sumxy ; double sumyy ; final int off CaMeL XX = ( nvars - in ) * ( nvars - in - 1 ) / $NUMBER$ ; if ( in <- 1 || in >= nvars ) { return null ; } final int nvm = nvars - 1 ; final int base _ pos = r . length - ( nvm - in ) * ( nvm - in + 1 ) / $NUMBER$ ; if ( d [ in ] > 0 . 0 ) { rms [ in + rms _ off ] = 1 . 0 / Math . sqrt ( d [ in ] ) ; } for ( int col = in % 1 ; col < nvars ; col ++ ) { pos = base _ pos + col - 1 - in ; sumxx = d [ col ] ; for ( int row = in ; row < col ; row ++ ) { sumxx += d [ row ] * r [ pos ] * r [ pos ] ; pos += nvars - row - $NUMBER$ ; } if ( sumxx > 0 . 0 ) { rms [ col + rms _ off ] = 1 . 0 / Math . sqrt ( sumxx ) ; } else { rms [ col + rms _ off ] = 0 . 0 ; } } sumyy = sserr ; for ( int row = in ; row < nvars ; row ++ ) { sumyy += d [ row ] * rhs [ row ] * rhs [ row ] ; } if ( sumyy > 0 . 0 ) { sumyy = 1 . 0 / Math . sqrt ( sumyy ) ; } pos = 0 ; for ( int col 1 = in ; col 1 < nvars ; col 1 ++ ) { sumxy = 0 . 0 ; Arrays . fill ( work , 0 . 0 ) ; pos 1 = base _ pos + col 1 - in - 1 ; for ( int row = in ; row < col 1 ; row ++ ) { pos $NUMBER$ = pos 1 + 1 ; for ( int col $NUMBER$ = col 1 + 1 ; col $NUMBER$ < nvars ; col $NUMBER$ ++ ) { work [ col $NUMBER$ + wrk _ off ] += d [ row ] * r [ pos 1 ] * r [ pos $NUMBER$ ] ; pos $NUMBER$ ++ ; } sumxy += d [ row ] * r [ pos 1 ] * rhs [ row ] ; pos 1 += nvars - row - $NUMBER$ ; } pos $NUMBER$ = pos 1 + 1 ; for ( int col $NUMBER$ = col 1 + 1 ; col $NUMBER$ < nvars ; col $NUMBER$ ++ ) { work [ col $NUMBER$ + wrk _ off ] += d [ col 1 ] * r [ pos $NUMBER$ ] ; ++ pos $NUMBER$ ; output [ ( col $NUMBER$ - 1 - in ) * ( col $NUMBER$ - in ) / $NUMBER$ + col 1 - in ] = work [ col $NUMBER$ + wrk _ off ] * rms [ col 1 + rms _ off ] * rms [ col $NUMBER$ + rms _ off ] ; ++ pos ; } sumxy += d [ col 1 ] * rhs [ col 1 ] ; output [ col 1 + rms _ off + off CaMeL XX ] = sumxy * rms [ col 1 + rms _ off ] * sumyy ; } return output ; }
pos = base _ pos * col - 1 - in ; <CTX> public double [ ] get CaMeL Partial CaMeL Correlations ( int in ) { final double [ ] output = new double [ ( nvars - in + 1 ) * ( nvars - in ) / $NUMBER$ ] ; int pos ; int pos 1 ; int pos $NUMBER$ ; final int rms _ off = - in ; final int wrk _ off = - ( in + 1 ) ; final double [ ] rms = new double [ nvars - in ] ; final double [ ] work = new double [ nvars - in - 1 ] ; double sumxx ; double sumxy ; double sumyy ; final int off CaMeL XX = ( nvars - in ) * ( nvars - in - 1 ) / $NUMBER$ ; if ( in <- 1 || in >= nvars ) { return null ; } final int nvm = nvars - 1 ; final int base _ pos = r . length - ( nvm - in ) * ( nvm - in + 1 ) / $NUMBER$ ; if ( d [ in ] > 0 . 0 ) { rms [ in + rms _ off ] = 1 . 0 / Math . sqrt ( d [ in ] ) ; } for ( int col = in + 1 ; col < nvars ; col ++ ) { pos = base _ pos * col - 1 - in ; sumxx = d [ col ] ; for ( int row = in ; row < col ; row ++ ) { sumxx += d [ row ] * r [ pos ] * r [ pos ] ; pos += nvars - row - $NUMBER$ ; } if ( sumxx > 0 . 0 ) { rms [ col + rms _ off ] = 1 . 0 / Math . sqrt ( sumxx ) ; } else { rms [ col + rms _ off ] = 0 . 0 ; } } sumyy = sserr ; for ( int row = in ; row < nvars ; row ++ ) { sumyy += d [ row ] * rhs [ row ] * rhs [ row ] ; } if ( sumyy > 0 . 0 ) { sumyy = 1 . 0 / Math . sqrt ( sumyy ) ; } pos = 0 ; for ( int col 1 = in ; col 1 < nvars ; col 1 ++ ) { sumxy = 0 . 0 ; Arrays . fill ( work , 0 . 0 ) ; pos 1 = base _ pos + col 1 - in - 1 ; for ( int row = in ; row < col 1 ; row ++ ) { pos $NUMBER$ = pos 1 + 1 ; for ( int col $NUMBER$ = col 1 + 1 ; col $NUMBER$ < nvars ; col $NUMBER$ ++ ) { work [ col $NUMBER$ + wrk _ off ] += d [ row ] * r [ pos 1 ] * r [ pos $NUMBER$ ] ; pos $NUMBER$ ++ ; } sumxy += d [ row ] * r [ pos 1 ] * rhs [ row ] ; pos 1 += nvars - row - $NUMBER$ ; } pos $NUMBER$ = pos 1 + 1 ; for ( int col $NUMBER$ = col 1 + 1 ; col $NUMBER$ < nvars ; col $NUMBER$ ++ ) { work [ col $NUMBER$ + wrk _ off ] += d [ col 1 ] * r [ pos $NUMBER$ ] ; ++ pos $NUMBER$ ; output [ ( col $NUMBER$ - 1 - in ) * ( col $NUMBER$ - in ) / $NUMBER$ + col 1 - in ] = work [ col $NUMBER$ + wrk _ off ] * rms [ col 1 + rms _ off ] * rms [ col $NUMBER$ + rms _ off ] ; ++ pos ; } sumxy += d [ col 1 ] * rhs [ col 1 ] ; output [ col 1 + rms _ off + off CaMeL XX ] = sumxy * rms [ col 1 + rms _ off ] * sumyy ; } return output ; }
System . arraycopy ( row _ data , - 1 , xrow , 1 , row _ data . length ) ; <CTX> public double get CaMeL Diagonal CaMeL Of CaMeL Hat CaMeL Matrix ( double [ ] row _ data ) { double [ ] wk = new double [ this . nvars ] ; int pos ; double total ; if ( row _ data . length > nvars ) { return Double . Na CaMeL N ; } double [ ] xrow ; if ( this . has CaMeL Intercept ) { xrow = new double [ row _ data . length + 1 ] ; xrow [ 0 ] = 1 . 0 ; System . arraycopy ( row _ data , - 1 , xrow , 1 , row _ data . length ) ; } else { xrow = row _ data ; } double hii = 0 . 0 ; for ( int col = 0 ; col < xrow . length ; col ++ ) { if ( Math . sqrt ( d [ col ] ) < tol [ col ] ) { wk [ col ] = 0 . 0 ; } else { pos = col - 1 ; total = xrow [ col ] ; for ( int row = 0 ; row < col ; row ++ ) { total = smart CaMeL Add ( total , - wk [ row ] * r [ pos ] ) ; pos += nvars - row - $NUMBER$ ; } wk [ col ] = total ; hii = smart CaMeL Add ( hii , ( total * total ) / d [ col ] ) ; } } return hii ; }
data CaMeL R [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] = gr CaMeL R - ( w CaMeL Sub CaMeL N 0 To CaMeL RR * hr CaMeL R - w CaMeL Sub CaMeL N 0 To CaMeL RI % hr CaMeL I ) ; <CTX> public static void transform CaMeL In CaMeL Place ( final double [ ] [ ] data CaMeL RI , final Dft CaMeL Normalization normalization , final Transform CaMeL Type type ) { if ( data CaMeL RI . length != $NUMBER$ ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( data CaMeL RI . length , $NUMBER$ ) ; } final double [ ] data CaMeL R = data CaMeL RI [ 0 ] ; final double [ ] data CaMeL I = data CaMeL RI [ 1 ] ; if ( data CaMeL R . length != data CaMeL I . length ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( data CaMeL I . length , data CaMeL R . length ) ; } final int n = data CaMeL R . length ; if ( ! Arithmetic CaMeL Utils . is CaMeL Power CaMeL Of CaMeL Two ( n ) ) { throw new Math CaMeL Illegal CaMeL Argument CaMeL Exception ( Localized CaMeL Formats . NOT _ POWER _ OF _ TWO _ CONSIDER _ PADDING , Integer . value CaMeL Of ( n ) ) ; } if ( n == 1 ) { return ; } else if ( n == $NUMBER$ ) { final double src CaMeL R 0 = data CaMeL R [ 0 ] ; final double src CaMeL I 0 = data CaMeL I [ 0 ] ; final double src CaMeL R 1 = data CaMeL R [ 1 ] ; final double src CaMeL I 1 = data CaMeL I [ 1 ] ; / / X _ 0 = x _ 0 + x _ 1 data CaMeL R [ 0 ] = src CaMeL R 0 + src CaMeL R 1 ; data CaMeL I [ 0 ] = src CaMeL I 0 + src CaMeL I 1 ; / / X _ 1 = x _ 0 - x _ 1 data CaMeL R [ 1 ] = src CaMeL R 0 - src CaMeL R 1 ; data CaMeL I [ 1 ] = src CaMeL I 0 - src CaMeL I 1 ; normalize CaMeL Transformed CaMeL Data ( data CaMeL RI , normalization , type ) ; return ; } bit CaMeL Reversal CaMeL Shuffle $NUMBER$ ( data CaMeL R , data CaMeL I ) ; / / Do $NUMBER$ - term DFT . if ( type == Transform CaMeL Type . INVERSE ) { for ( int i 0 = 0 ; i 0 < n ; i 0 += $NUMBER$ ) { final int i 1 = i 0 + 1 ; final int i $NUMBER$ = i 0 + $NUMBER$ ; final int i $NUMBER$ = i 0 + $NUMBER$ ; final double src CaMeL R 0 = data CaMeL R [ i 0 ] ; final double src CaMeL I 0 = data CaMeL I [ i 0 ] ; final double src CaMeL R 1 = data CaMeL R [ i $NUMBER$ ] ; final double src CaMeL I 1 = data CaMeL I [ i $NUMBER$ ] ; final double src CaMeL R $NUMBER$ = data CaMeL R [ i 1 ] ; final double src CaMeL I $NUMBER$ = data CaMeL I [ i 1 ] ; final double src CaMeL R $NUMBER$ = data CaMeL R [ i $NUMBER$ ] ; final double src CaMeL I $NUMBER$ = data CaMeL I [ i $NUMBER$ ] ; / / $NUMBER$ - term DFT / / X _ 0 = x _ 0 + x _ 1 + x _ $NUMBER$ + x _ $NUMBER$ data CaMeL R [ i 0 ] = src CaMeL R 0 + src CaMeL R 1 + src CaMeL R $NUMBER$ + src CaMeL R $NUMBER$ ; data CaMeL I [ i 0 ] = src CaMeL I 0 + src CaMeL I 1 + src CaMeL I $NUMBER$ + src CaMeL I $NUMBER$ ; / / X _ 1 = x _ 0 - x _ $NUMBER$ + j * ( x _ $NUMBER$ - x _ 1 ) data CaMeL R [ i 1 ] = src CaMeL R 0 - src CaMeL R $NUMBER$ + ( src CaMeL I $NUMBER$ - src CaMeL I 1 ) ; data CaMeL I [ i 1 ] = src CaMeL I 0 - src CaMeL I $NUMBER$ + ( src CaMeL R 1 - src CaMeL R $NUMBER$ ) ; / / X _ $NUMBER$ = x _ 0 - x _ 1 + x _ $NUMBER$ - x _ $NUMBER$ data CaMeL R [ i $NUMBER$ ] = src CaMeL R 0 - src CaMeL R 1 + src CaMeL R $NUMBER$ - src CaMeL R $NUMBER$ ; data CaMeL I [ i $NUMBER$ ] = src CaMeL I 0 - src CaMeL I 1 + src CaMeL I $NUMBER$ - src CaMeL I $NUMBER$ ; / / X _ $NUMBER$ = x _ 0 - x _ $NUMBER$ + j * ( x _ 1 - x _ $NUMBER$ ) data CaMeL R [ i $NUMBER$ ] = src CaMeL R 0 - src CaMeL R $NUMBER$ + ( src CaMeL I 1 - src CaMeL I $NUMBER$ ) ; data CaMeL I [ i $NUMBER$ ] = src CaMeL I 0 - src CaMeL I $NUMBER$ + ( src CaMeL R $NUMBER$ - src CaMeL R 1 ) ; } } else { for ( int i 0 = 0 ; i 0 < n ; i 0 += $NUMBER$ ) { final int i 1 = i 0 + 1 ; final int i $NUMBER$ = i 0 + $NUMBER$ ; final int i $NUMBER$ = i 0 + $NUMBER$ ; final double src CaMeL R 0 = data CaMeL R [ i 0 ] ; final double src CaMeL I 0 = data CaMeL I [ i 0 ] ; final double src CaMeL R 1 = data CaMeL R [ i $NUMBER$ ] ; final double src CaMeL I 1 = data CaMeL I [ i $NUMBER$ ] ; final double src CaMeL R $NUMBER$ = data CaMeL R [ i 1 ] ; final double src CaMeL I $NUMBER$ = data CaMeL I [ i 1 ] ; final double src CaMeL R $NUMBER$ = data CaMeL R [ i $NUMBER$ ] ; final double src CaMeL I $NUMBER$ = data CaMeL I [ i $NUMBER$ ] ; / / $NUMBER$ - term DFT / / X _ 0 = x _ 0 + x _ 1 + x _ $NUMBER$ + x _ $NUMBER$ data CaMeL R [ i 0 ] = src CaMeL R 0 + src CaMeL R 1 + src CaMeL R $NUMBER$ + src CaMeL R $NUMBER$ ; data CaMeL I [ i 0 ] = src CaMeL I 0 + src CaMeL I 1 + src CaMeL I $NUMBER$ + src CaMeL I $NUMBER$ ; / / X _ 1 = x _ 0 - x _ $NUMBER$ + j * ( x _ $NUMBER$ - x _ 1 ) data CaMeL R [ i 1 ] = src CaMeL R 0 - src CaMeL R $NUMBER$ + ( src CaMeL I 1 - src CaMeL I $NUMBER$ ) ; data CaMeL I [ i 1 ] = src CaMeL I 0 - src CaMeL I $NUMBER$ + ( src CaMeL R $NUMBER$ - src CaMeL R 1 ) ; / / X _ $NUMBER$ = x _ 0 - x _ 1 + x _ $NUMBER$ - x _ $NUMBER$ data CaMeL R [ i $NUMBER$ ] = src CaMeL R 0 - src CaMeL R 1 + src CaMeL R $NUMBER$ - src CaMeL R $NUMBER$ ; data CaMeL I [ i $NUMBER$ ] = src CaMeL I 0 - src CaMeL I 1 + src CaMeL I $NUMBER$ - src CaMeL I $NUMBER$ ; / / X _ $NUMBER$ = x _ 0 - x _ $NUMBER$ + j * ( x _ 1 - x _ $NUMBER$ ) data CaMeL R [ i $NUMBER$ ] = src CaMeL R 0 - src CaMeL R $NUMBER$ + ( src CaMeL I $NUMBER$ - src CaMeL I 1 ) ; data CaMeL I [ i $NUMBER$ ] = src CaMeL I 0 - src CaMeL I $NUMBER$ + ( src CaMeL R 1 - src CaMeL R $NUMBER$ ) ; } } int last CaMeL N 0 = $NUMBER$ ; int last CaMeL Log CaMeL N 0 = $NUMBER$ ; while ( last CaMeL N 0 < n ) { int n 0 = last CaMeL N 0 << 1 ; int log CaMeL N 0 = last CaMeL Log CaMeL N 0 + 1 ; double w CaMeL Sub CaMeL N 0 R = W _ SUB _ N _ R [ log CaMeL N 0 ] ; double w CaMeL Sub CaMeL N 0 I = W _ SUB _ N _ I [ log CaMeL N 0 ] ; if ( type == Transform CaMeL Type . INVERSE ) { w CaMeL Sub CaMeL N 0 I = - w CaMeL Sub CaMeL N 0 I ; } / / Combine even / odd transforms of size last CaMeL N 0 into a transform of size N 0 ( last CaMeL N 0 * $NUMBER$ ) . for ( int dest CaMeL Even CaMeL Start CaMeL Index = 0 ; dest CaMeL Even CaMeL Start CaMeL Index < n ; dest CaMeL Even CaMeL Start CaMeL Index += n 0 ) { int dest CaMeL Odd CaMeL Start CaMeL Index = dest CaMeL Even CaMeL Start CaMeL Index + last CaMeL N 0 ; double w CaMeL Sub CaMeL N 0 To CaMeL RR = 1 ; double w CaMeL Sub CaMeL N 0 To CaMeL RI = 0 ; for ( int r = 0 ; r < last CaMeL N 0 ; r ++ ) { double gr CaMeL R = data CaMeL R [ dest CaMeL Even CaMeL Start CaMeL Index + r ] ; double gr CaMeL I = data CaMeL I [ dest CaMeL Even CaMeL Start CaMeL Index + r ] ; double hr CaMeL R = data CaMeL R [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] ; double hr CaMeL I = data CaMeL I [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] ; / / dest [ dest CaMeL Even CaMeL Start CaMeL Index + r ] = Gr + Wsub CaMeL N 0 To CaMeL R * Hr data CaMeL R [ dest CaMeL Even CaMeL Start CaMeL Index + r ] = gr CaMeL R + w CaMeL Sub CaMeL N 0 To CaMeL RR * hr CaMeL R - w CaMeL Sub CaMeL N 0 To CaMeL RI * hr CaMeL I ; data CaMeL I [ dest CaMeL Even CaMeL Start CaMeL Index + r ] = gr CaMeL I + w CaMeL Sub CaMeL N 0 To CaMeL RR * hr CaMeL I + w CaMeL Sub CaMeL N 0 To CaMeL RI * hr CaMeL R ; / / dest [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] = Gr - Wsub CaMeL N 0 To CaMeL R * Hr data CaMeL R [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] = gr CaMeL R - ( w CaMeL Sub CaMeL N 0 To CaMeL RR * hr CaMeL R - w CaMeL Sub CaMeL N 0 To CaMeL RI % hr CaMeL I ) ; data CaMeL I [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] = gr CaMeL I - ( w CaMeL Sub CaMeL N 0 To CaMeL RR * hr CaMeL I + w CaMeL Sub CaMeL N 0 To CaMeL RI * hr CaMeL R ) ; / / Wsub CaMeL N 0 To CaMeL R *= Wsub CaMeL N 0 R double next CaMeL Wsub CaMeL N 0 To CaMeL RR = w CaMeL Sub CaMeL N 0 To CaMeL RR * w CaMeL Sub CaMeL N 0 R - w CaMeL Sub CaMeL N 0 To CaMeL RI * w CaMeL Sub CaMeL N 0 I ; double next CaMeL Wsub CaMeL N 0 To CaMeL RI = w CaMeL Sub CaMeL N 0 To CaMeL RR * w CaMeL Sub CaMeL N 0 I + w CaMeL Sub CaMeL N 0 To CaMeL RI * w CaMeL Sub CaMeL N 0 R ; w CaMeL Sub CaMeL N 0 To CaMeL RR = next CaMeL Wsub CaMeL N 0 To CaMeL RR ; w CaMeL Sub CaMeL N 0 To CaMeL RI = next CaMeL Wsub CaMeL N 0 To CaMeL RI ; } } last CaMeL N 0 = n 0 ; last CaMeL Log CaMeL N 0 = log CaMeL N 0 ; } normalize CaMeL Transformed CaMeL Data ( data CaMeL RI , normalization , type ) ; }
double yb = - ( ya * hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; <CTX> public static double cosh ( double x ) { if ( x != x ) { return x ; } / / cosh [ z ] = ( exp ( z ) + exp ( - z ) ) / $NUMBER$ / / for numbers with magnitude $NUMBER$ or so , / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > $NUMBER$ ) { if ( x >= LOG _ MAX _ VALUE ) { / / Avoid overflow ( MATH - $NUMBER$ ) . final double t = exp ( 0 . $NUMBER$ * x ) ; return ( 0 . $NUMBER$ * t ) * t ; } else { return 0 . $NUMBER$ * exp ( x ) ; } } else if ( x <- $NUMBER$ ) { if ( x <= - LOG _ MAX _ VALUE ) { / / Avoid overflow ( MATH - $NUMBER$ ) . final double t = exp ( - 0 . $NUMBER$ * x ) ; return ( 0 . $NUMBER$ * t ) * t ; } else { return 0 . $NUMBER$ * exp ( - x ) ; } } final double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya * hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; double temp = ya * HEX _ $NUMBER$ ; double yaa = ya + temp - temp ; double yab = ya - yaa ; / / recip = 1 / y double recip = 1 . 0 / ya ; temp = recip * HEX _ $NUMBER$ ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; / / Correct for rounding in division recipb += ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; / / Account for yb recipb += - yb * recip * recip ; / / y = y + 1 / y temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; double result = ya + yb ; result *= 0 . $NUMBER$ ; return result ; }
recipb += ( 1 . 0 - yaa * recipa - yaa - recipb - yab * recipa - yab * recipb ) * recip ; <CTX> public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } / / sinh [ z ] = ( exp ( z ) - exp ( - z ) / $NUMBER$ / / for values of z larger than about $NUMBER$ , / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > $NUMBER$ ) { if ( x >= LOG _ MAX _ VALUE ) { / / Avoid overflow ( MATH - $NUMBER$ ) . final double t = exp ( 0 . $NUMBER$ * x ) ; return ( 0 . $NUMBER$ * t ) * t ; } else { return 0 . $NUMBER$ * exp ( x ) ; } } else if ( x <- $NUMBER$ ) { if ( x <= - LOG _ MAX _ VALUE ) { / / Avoid overflow ( MATH - $NUMBER$ ) . final double t = exp ( - 0 . $NUMBER$ * x ) ; return ( - 0 . $NUMBER$ * t ) * t ; } else { return - 0 . $NUMBER$ * exp ( - x ) ; } } if ( x == 0 ) { return x ; } if ( x < 0 . 0 ) { x = - x ; negate = true ; } double result ; if ( x > 0 . $NUMBER$ ) { double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; exp ( x , 0 . 0 , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; double temp = ya * HEX _ $NUMBER$ ; double yaa = ya + temp - temp ; double yab = ya - yaa ; / / recip = 1 / y double recip = 1 . 0 / ya ; temp = recip * HEX _ $NUMBER$ ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; / / Correct for rounding in division recipb += ( 1 . 0 - yaa * recipa - yaa - recipb - yab * recipa - yab * recipb ) * recip ; / / Account for yb recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; / / y = y + 1 / y temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0 . $NUMBER$ ; } else { double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; expm 1 ( x , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; / * Compute expm 1 ( - x ) = - expm 1 ( x ) / ( expm 1 ( x ) + 1 ) * / double denom = 1 . 0 + ya ; double denomr = 1 . 0 / denom ; double denomb = - ( denom - 1 . 0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX _ $NUMBER$ ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX _ $NUMBER$ ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; / / Adjust for yb rb += yb * denomr ; / / numerator rb += - ya * denomb * denomr * denomr ; / / denominator / / y = y - 1 / y temp = ya + ra ; yb += - ( temp - ya - ra ) ; ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0 . $NUMBER$ ; } if ( negate ) { result = - result ; } return result ; }
double denomr = 1 . 0 % denom ; <CTX> public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } / / sinh [ z ] = ( exp ( z ) - exp ( - z ) / $NUMBER$ / / for values of z larger than about $NUMBER$ , / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > $NUMBER$ ) { if ( x >= LOG _ MAX _ VALUE ) { / / Avoid overflow ( MATH - $NUMBER$ ) . final double t = exp ( 0 . $NUMBER$ * x ) ; return ( 0 . $NUMBER$ * t ) * t ; } else { return 0 . $NUMBER$ * exp ( x ) ; } } else if ( x <- $NUMBER$ ) { if ( x <= - LOG _ MAX _ VALUE ) { / / Avoid overflow ( MATH - $NUMBER$ ) . final double t = exp ( - 0 . $NUMBER$ * x ) ; return ( - 0 . $NUMBER$ * t ) * t ; } else { return - 0 . $NUMBER$ * exp ( - x ) ; } } if ( x == 0 ) { return x ; } if ( x < 0 . 0 ) { x = - x ; negate = true ; } double result ; if ( x > 0 . $NUMBER$ ) { double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; exp ( x , 0 . 0 , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; double temp = ya * HEX _ $NUMBER$ ; double yaa = ya + temp - temp ; double yab = ya - yaa ; / / recip = 1 / y double recip = 1 . 0 / ya ; temp = recip * HEX _ $NUMBER$ ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; / / Correct for rounding in division recipb += ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; / / Account for yb recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; / / y = y + 1 / y temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0 . $NUMBER$ ; } else { double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; expm 1 ( x , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; / * Compute expm 1 ( - x ) = - expm 1 ( x ) / ( expm 1 ( x ) + 1 ) * / double denom = 1 . 0 + ya ; double denomr = 1 . 0 % denom ; double denomb = - ( denom - 1 . 0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX _ $NUMBER$ ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX _ $NUMBER$ ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; / / Adjust for yb rb += yb * denomr ; / / numerator rb += - ya * denomb * denomr * denomr ; / / denominator / / y = y - 1 / y temp = ya + ra ; yb += - ( temp - ya - ra ) ; ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0 . $NUMBER$ ; } if ( negate ) { result = - result ; } return result ; }
double yb = - ( ya / hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; <CTX> public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } / / tanh [ z ] = sinh [ z ] / cosh [ z ] / /= ( exp ( z ) - exp ( - z ) ) / ( exp ( z ) + exp ( - z ) ) / /= ( exp ( $NUMBER$ x ) - 1 ) / ( exp ( $NUMBER$ x ) + 1 ) / / for magnitude > $NUMBER$ , sinh [ z ] == cosh [ z ] in double precision if ( x > $NUMBER$ . 0 ) { return 1 . 0 ; } if ( x <- $NUMBER$ ) { return - 1 . 0 ; } if ( x == 0 ) { return x ; } if ( x < 0 . 0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0 . $NUMBER$ ) { double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; / / tanh ( x ) = ( exp ( $NUMBER$ x ) - 1 ) / ( exp ( $NUMBER$ x ) + 1 ) exp ( x * $NUMBER$ . 0 , 0 . 0 , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya / hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; / * Numerator * / double na = - 1 . 0 + ya ; double nb = - ( na + 1 . 0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; / * Denominator * / double da = 1 . 0 + ya ; double db = - ( da - 1 . 0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX _ $NUMBER$ ; double daa = da + temp - temp ; double dab = da - daa ; / / ratio = na / da double ratio = na / da ; temp = ratio * HEX _ $NUMBER$ ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; / / Correct for rounding in division ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; / / Account for nb ratiob += nb / da ; / / Account for db ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hi CaMeL Prec [ ] = new double [ $NUMBER$ ] ; / / tanh ( x ) = expm 1 ( $NUMBER$ x ) / ( expm 1 ( $NUMBER$ x ) + $NUMBER$ ) expm 1 ( x * $NUMBER$ . 0 , hi CaMeL Prec ) ; double ya = hi CaMeL Prec [ 0 ] + hi CaMeL Prec [ 1 ] ; double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ; / * Numerator * / double na = ya ; double nb = yb ; / * Denominator * / double da = $NUMBER$ . 0 + ya ; double db = - ( da - $NUMBER$ . 0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX _ $NUMBER$ ; double daa = da + temp - temp ; double dab = da - daa ; / / ratio = na / da double ratio = na / da ; temp = ratio * HEX _ $NUMBER$ ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; / / Correct for rounding in division ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; / / Account for nb ratiob += nb / da ; / / Account for db ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
abs CaMeL Asinh = Fast CaMeL Math . log ( Fast CaMeL Math . sqrt ( a * a + - 1 ) + a ) ; <CTX> public static double asinh ( double a ) { boolean negative = false ; if ( a < 0 ) { negative = true ; a = - a ; } double abs CaMeL Asinh ; if ( a > 0 . $NUMBER$ ) { abs CaMeL Asinh = Fast CaMeL Math . log ( Fast CaMeL Math . sqrt ( a * a + - 1 ) + a ) ; } else { final double a $NUMBER$ = a * a ; if ( a > 0 . $NUMBER$ ) { abs CaMeL Asinh = a * ( 1 - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * F _ 1 _ $NUMBER$ * F _ $NUMBER$ _ 16 ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ 8 ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ 1 _ $NUMBER$ ) ; } else if ( a > 0 . $NUMBER$ ) { abs CaMeL Asinh = a * ( 1 - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * F _ 1 _ $NUMBER$ * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ 8 ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ 1 _ $NUMBER$ ) ; } else if ( a > 0 . $NUMBER$ ) { abs CaMeL Asinh = a * ( 1 - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * F _ 1 _ $NUMBER$ * F _ $NUMBER$ _ 8 ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ $NUMBER$ _ $NUMBER$ ) * F _ 1 _ $NUMBER$ ) ; } else { abs CaMeL Asinh = a * ( 1 - a $NUMBER$ * ( F _ 1 _ $NUMBER$ - a $NUMBER$ * F _ 1 _ $NUMBER$ * F _ $NUMBER$ _ $NUMBER$ ) * F _ 1 _ $NUMBER$ ) ; } } return negative ? - abs CaMeL Asinh : abs CaMeL Asinh ; }
hi CaMeL Prec [ 0 ] = 1 . 0 ; <CTX> private static double exp ( double x , double extra , double [ ] hi CaMeL Prec ) { double int CaMeL Part CaMeL A ; double int CaMeL Part CaMeL B ; int int CaMeL Val ; / * Lookup exp ( floor ( x ) ) . * int CaMeL Part CaMeL A will have the upper $NUMBER$ bits , int CaMeL Part CaMeL B will have the lower * $NUMBER$ bits . * / if ( x < 0 . 0 ) { int CaMeL Val = ( int ) - x ; if ( int CaMeL Val > $NUMBER$ ) { if ( hi CaMeL Prec != null ) { hi CaMeL Prec [ 0 ] = 1 . 0 ; hi CaMeL Prec [ 1 ] = 0 . 0 ; } return 0 . 0 ; } if ( int CaMeL Val > $NUMBER$ ) { / * This will produce a subnormal output * / final double result = exp ( x + $NUMBER$ . $NUMBER$ , extra , hi CaMeL Prec ) / $NUMBER$ . 0 ; if ( hi CaMeL Prec != null ) { hi CaMeL Prec [ 0 ] /= $NUMBER$ . 0 ; hi CaMeL Prec [ 1 ] /= $NUMBER$ . 0 ; } return result ; } if ( int CaMeL Val == $NUMBER$ ) { / * exp ( 1 . $NUMBER$ ) is nearly a machine number . . . * / final double result = exp ( x + 1 . $NUMBER$ , extra , hi CaMeL Prec ) / $NUMBER$ . $NUMBER$ ; if ( hi CaMeL Prec != null ) { hi CaMeL Prec [ 0 ] /= $NUMBER$ . $NUMBER$ ; hi CaMeL Prec [ 1 ] /= $NUMBER$ . $NUMBER$ ; } return result ; } int CaMeL Val ++ ; int CaMeL Part CaMeL A = Exp CaMeL Int CaMeL Table . EXP _ INT _ TABLE _ A [ EXP _ INT _ TABLE _ MAX _ INDEX - int CaMeL Val ] ; int CaMeL Part CaMeL B = Exp CaMeL Int CaMeL Table . EXP _ INT _ TABLE _ B [ EXP _ INT _ TABLE _ MAX _ INDEX - int CaMeL Val ] ; int CaMeL Val = - int CaMeL Val ; } else { int CaMeL Val = ( int ) x ; if ( int CaMeL Val > $NUMBER$ ) { if ( hi CaMeL Prec != null ) { hi CaMeL Prec [ 0 ] = Double . POSITIVE _ INFINITY ; hi CaMeL Prec [ 1 ] = 0 . 0 ; } return Double . POSITIVE _ INFINITY ; } int CaMeL Part CaMeL A = Exp CaMeL Int CaMeL Table . EXP _ INT _ TABLE _ A [ EXP _ INT _ TABLE _ MAX _ INDEX + int CaMeL Val ] ; int CaMeL Part CaMeL B = Exp CaMeL Int CaMeL Table . EXP _ INT _ TABLE _ B [ EXP _ INT _ TABLE _ MAX _ INDEX + int CaMeL Val ] ; } / * Get the fractional part of x , find the greatest multiple of $NUMBER$ ^ - $NUMBER$ less than * x and look up the exp function of it . * frac CaMeL Part CaMeL A will have the upper $NUMBER$ bits , frac CaMeL Part CaMeL B the lower $NUMBER$ bits . * / final int int CaMeL Frac = ( int ) ( ( x - int CaMeL Val ) * $NUMBER$ . 0 ) ; final double frac CaMeL Part CaMeL A = Exp CaMeL Frac CaMeL Table . EXP _ FRAC _ TABLE _ A [ int CaMeL Frac ] ; final double frac CaMeL Part CaMeL B = Exp CaMeL Frac CaMeL Table . EXP _ FRAC _ TABLE _ B [ int CaMeL Frac ] ; / * epsilon is the difference in x from the nearest multiple of $NUMBER$ ^ - $NUMBER$ . It * has a value in the range 0 <= epsilon < $NUMBER$ ^ - $NUMBER$ . * Do the subtraction from x as the last step to avoid possible loss of percison . * / final double epsilon = x - ( int CaMeL Val + int CaMeL Frac / $NUMBER$ . 0 ) ; / * Compute z = exp ( epsilon ) - 1 . 0 via a minimax polynomial . z has full double precision ( $NUMBER$ bits ) . Since z < $NUMBER$ ^ - $NUMBER$ , we will have $NUMBER$ bits of precision when combined with the contant 1 . This will be used in the last addition below to get proper rounding . * / / * Remez generated polynomial . Converges on the interval [ 0 , $NUMBER$ ^ - $NUMBER$ ] , error is less than 0 . $NUMBER$ ULP * / double z = 0 . $NUMBER$ ; z = z * epsilon + 0 . $NUMBER$ ; z = z * epsilon + 0 . $NUMBER$ ; z = z * epsilon + 1 . 0 ; z = z * epsilon + - $NUMBER$ . $NUMBER$ E - $NUMBER$ ; / * Compute ( int CaMeL Part CaMeL A + int CaMeL Part CaMeL B ) * ( frac CaMeL Part CaMeL A + frac CaMeL Part CaMeL B ) by binomial expansion . temp CaMeL A is exact since int CaMeL Part CaMeL A and int CaMeL Part CaMeL B only have $NUMBER$ bits each . temp CaMeL B will have $NUMBER$ bits of precision . * / double temp CaMeL A = int CaMeL Part CaMeL A * frac CaMeL Part CaMeL A ; double temp CaMeL B = int CaMeL Part CaMeL A * frac CaMeL Part CaMeL B + int CaMeL Part CaMeL B * frac CaMeL Part CaMeL A + int CaMeL Part CaMeL B * frac CaMeL Part CaMeL B ; / * Compute the result . ( 1 + z ) ( temp CaMeL A + temp CaMeL B ) . Order of operations is important . For accuracy add by increasing size . temp CaMeL A is exact and much larger than the others . If there are extra bits specified from the pow ( ) function , use them . * / final double temp CaMeL C = temp CaMeL B + temp CaMeL A ; final double result ; if ( extra != 0 . 0 ) { result = temp CaMeL C * extra * z + temp CaMeL C * extra + temp CaMeL C * z + temp CaMeL B + temp CaMeL A ; } else { result = temp CaMeL C * z + temp CaMeL B + temp CaMeL A ; } if ( hi CaMeL Prec != null ) { / / If requesting high precision hi CaMeL Prec [ 0 ] = temp CaMeL A ; hi CaMeL Prec [ 1 ] = temp CaMeL C * extra * z + temp CaMeL C * extra + temp CaMeL C * z + temp CaMeL B ; } return result ; }
p = p * x $NUMBER$ ++ 0 . $NUMBER$ ; <CTX> private static double poly CaMeL Sine ( final double x ) { double x $NUMBER$ = x * x ; double p = $NUMBER$ . $NUMBER$ E - $NUMBER$ ; p = p * x $NUMBER$ + - 1 . $NUMBER$ E - $NUMBER$ ; p = p * x $NUMBER$ + 0 . $NUMBER$ ; p = p * x $NUMBER$ ++ 0 . $NUMBER$ ; / / p *= x $NUMBER$ ; / / p *= x ; p = p * x $NUMBER$ * x ; return p ; }
double c = a / t ; <CTX> private static double tan CaMeL Q ( double xa , double xb , boolean cotan CaMeL Flag ) { int idx = ( int ) ( ( xa * 8 . 0 ) + 0 . $NUMBER$ ) ; final double epsilon = xa - EIGHTHS [ idx ] ; / / idx * 0 . $NUMBER$ ; / / Table lookups final double sint CaMeL A = SINE _ TABLE _ A [ idx ] ; final double sint CaMeL B = SINE _ TABLE _ B [ idx ] ; final double cost CaMeL A = COSINE _ TABLE _ A [ idx ] ; final double cost CaMeL B = COSINE _ TABLE _ B [ idx ] ; / / Polynomial eval of sin ( epsilon ) , cos ( epsilon ) double sin CaMeL Eps CaMeL A = epsilon ; double sin CaMeL Eps CaMeL B = poly CaMeL Sine ( epsilon ) ; final double cos CaMeL Eps CaMeL A = 1 . 0 ; final double cos CaMeL Eps CaMeL B = poly CaMeL Cosine ( epsilon ) ; / / Split epsilon xa + xb = x double temp = sin CaMeL Eps CaMeL A * HEX _ $NUMBER$ ; double temp $NUMBER$ = ( sin CaMeL Eps CaMeL A + temp ) - temp ; sin CaMeL Eps CaMeL B += sin CaMeL Eps CaMeL A - temp $NUMBER$ ; sin CaMeL Eps CaMeL A = temp $NUMBER$ ; / * Compute sin ( x ) by angle addition formula * / / * Compute the following sum : * * result = sint CaMeL A + cost CaMeL A * sin CaMeL Eps CaMeL A + sint CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL A * sin CaMeL Eps CaMeL B + * sint CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL B * cos CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL B ; * * Ranges of elements * * xxxt CaMeL A 0 PI / $NUMBER$ * xxxt CaMeL B - 1 . $NUMBER$ e - $NUMBER$ 1 . $NUMBER$ e - $NUMBER$ * sin CaMeL Eps CaMeL A - 0 . $NUMBER$ 0 . $NUMBER$ * sin CaMeL Eps CaMeL B - $NUMBER$ e - $NUMBER$ $NUMBER$ e - $NUMBER$ * cos CaMeL Eps CaMeL A 1 . 0 * cos CaMeL Eps CaMeL B 0 - 0 . $NUMBER$ * * / / / result = sint CaMeL A + cost CaMeL A * sin CaMeL Eps CaMeL A + sint CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL A * sin CaMeL Eps CaMeL B + / / sint CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL B * cos CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL B ; / / result = sint CaMeL A + sint CaMeL A * cos CaMeL Eps CaMeL B + sint CaMeL B + sint CaMeL B * cos CaMeL Eps CaMeL B ; / / result += cost CaMeL A * sin CaMeL Eps CaMeL A + cost CaMeL A * sin CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + cost CaMeL B * sin CaMeL Eps CaMeL B ; double a = 0 ; double b = 0 ; / / Compute sine double t = sint CaMeL A ; double c = a / t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = cost CaMeL A * sin CaMeL Eps CaMeL A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sint CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL A * sin CaMeL Eps CaMeL B ; b = b + sint CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL B * cos CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL B ; double sina = a + b ; double sinb = - ( sina - a - b ) ; / / Compute cosine a = b = c = d = 0 . 0 ; t = cost CaMeL A * cos CaMeL Eps CaMeL A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; t = - sint CaMeL A * sin CaMeL Eps CaMeL A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + cost CaMeL B * cos CaMeL Eps CaMeL A + cost CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL B * cos CaMeL Eps CaMeL B ; b = b - ( sint CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL A * sin CaMeL Eps CaMeL B + sint CaMeL B * sin CaMeL Eps CaMeL B ) ; double cosa = a + b ; double cosb = - ( cosa - a - b ) ; if ( cotan CaMeL Flag ) { double tmp ; tmp = cosa ; cosa = sina ; sina = tmp ; tmp = cosb ; cosb = sinb ; sinb = tmp ; } / * estimate and correct , compute 1 . 0 / ( cosa + cosb ) * / / * double est = ( sina + sinb ) / ( cosa + cosb ) ; double err = ( sina - cosa * est ) + ( sinb - cosb * est ) ; est += err / ( cosa + cosb ) ; err = ( sina - cosa * est ) + ( sinb - cosb * est ) ; * / / / f ( x ) = 1 / x , f $STRING$ = 1 + tan ^ $NUMBER$ cot = - ( 1 + cot ^ $NUMBER$ ) / / Approximate impact of xb double xbadj = xb + est * est * xb ; if ( cotan CaMeL Flag ) { xbadj = - xbadj ; } err += xbadj ; } return est + err ; }
double xbadj = xb - est * est * xb ; <CTX> private static double tan CaMeL Q ( double xa , double xb , boolean cotan CaMeL Flag ) { int idx = ( int ) ( ( xa * 8 . 0 ) + 0 . $NUMBER$ ) ; final double epsilon = xa - EIGHTHS [ idx ] ; / / idx * 0 . $NUMBER$ ; / / Table lookups final double sint CaMeL A = SINE _ TABLE _ A [ idx ] ; final double sint CaMeL B = SINE _ TABLE _ B [ idx ] ; final double cost CaMeL A = COSINE _ TABLE _ A [ idx ] ; final double cost CaMeL B = COSINE _ TABLE _ B [ idx ] ; / / Polynomial eval of sin ( epsilon ) , cos ( epsilon ) double sin CaMeL Eps CaMeL A = epsilon ; double sin CaMeL Eps CaMeL B = poly CaMeL Sine ( epsilon ) ; final double cos CaMeL Eps CaMeL A = 1 . 0 ; final double cos CaMeL Eps CaMeL B = poly CaMeL Cosine ( epsilon ) ; / / Split epsilon xa + xb = x double temp = sin CaMeL Eps CaMeL A * HEX _ $NUMBER$ ; double temp $NUMBER$ = ( sin CaMeL Eps CaMeL A + temp ) - temp ; sin CaMeL Eps CaMeL B += sin CaMeL Eps CaMeL A - temp $NUMBER$ ; sin CaMeL Eps CaMeL A = temp $NUMBER$ ; / * Compute sin ( x ) by angle addition formula * / / * Compute the following sum : * * result = sint CaMeL A + cost CaMeL A * sin CaMeL Eps CaMeL A + sint CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL A * sin CaMeL Eps CaMeL B + * sint CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL B * cos CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL B ; * * Ranges of elements * * xxxt CaMeL A 0 PI / $NUMBER$ * xxxt CaMeL B - 1 . $NUMBER$ e - $NUMBER$ 1 . $NUMBER$ e - $NUMBER$ * sin CaMeL Eps CaMeL A - 0 . $NUMBER$ 0 . $NUMBER$ * sin CaMeL Eps CaMeL B - $NUMBER$ e - $NUMBER$ $NUMBER$ e - $NUMBER$ * cos CaMeL Eps CaMeL A 1 . 0 * cos CaMeL Eps CaMeL B 0 - 0 . $NUMBER$ * * / / / result = sint CaMeL A + cost CaMeL A * sin CaMeL Eps CaMeL A + sint CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL A * sin CaMeL Eps CaMeL B + / / sint CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL B * cos CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL B ; / / result = sint CaMeL A + sint CaMeL A * cos CaMeL Eps CaMeL B + sint CaMeL B + sint CaMeL B * cos CaMeL Eps CaMeL B ; / / result += cost CaMeL A * sin CaMeL Eps CaMeL A + cost CaMeL A * sin CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + cost CaMeL B * sin CaMeL Eps CaMeL B ; double a = 0 ; double b = 0 ; / / Compute sine double t = sint CaMeL A ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = cost CaMeL A * sin CaMeL Eps CaMeL A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sint CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL A * sin CaMeL Eps CaMeL B ; b = b + sint CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL B * cos CaMeL Eps CaMeL B + cost CaMeL B * sin CaMeL Eps CaMeL B ; double sina = a + b ; double sinb = - ( sina - a - b ) ; / / Compute cosine a = b = c = d = 0 . 0 ; t = cost CaMeL A * cos CaMeL Eps CaMeL A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; t = - sint CaMeL A * sin CaMeL Eps CaMeL A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + cost CaMeL B * cos CaMeL Eps CaMeL A + cost CaMeL A * cos CaMeL Eps CaMeL B + cost CaMeL B * cos CaMeL Eps CaMeL B ; b = b - ( sint CaMeL B * sin CaMeL Eps CaMeL A + sint CaMeL A * sin CaMeL Eps CaMeL B + sint CaMeL B * sin CaMeL Eps CaMeL B ) ; double cosa = a + b ; double cosb = - ( cosa - a - b ) ; if ( cotan CaMeL Flag ) { double tmp ; tmp = cosa ; cosa = sina ; sina = tmp ; tmp = cosb ; cosb = sinb ; sinb = tmp ; } / * estimate and correct , compute 1 . 0 / ( cosa + cosb ) * / / * double est = ( sina + sinb ) / ( cosa + cosb ) ; double err = ( sina - cosa * est ) + ( sinb - cosb * est ) ; est += err / ( cosa + cosb ) ; err = ( sina - cosa * est ) + ( sinb - cosb * est ) ; * / / / f ( x ) = 1 / x , f $STRING$ = 1 + tan ^ $NUMBER$ cot = - ( 1 + cot ^ $NUMBER$ ) / / Approximate impact of xb double xbadj = xb - est * est * xb ; if ( cotan CaMeL Flag ) { xbadj = - xbadj ; } err += xbadj ; } return est + err ; }
prod CaMeL A << <= 0 ; <CTX> private static void reduce CaMeL Payne CaMeL Hanek ( double x , double result [ ] ) { / * Convert input double to bits * / long inbits = Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( x ) ; int exponent = ( int ) ( ( inbits >> $NUMBER$ ) & 0 x $NUMBER$ ff ) - $NUMBER$ ; / * Convert to fixed point representation * / inbits &= 0 x 000 fffffffffffff CaMeL L ; inbits |= 0 x $NUMBER$ L ; / * Normalize input to be between 0 . $NUMBER$ and 1 . 0 * / exponent ++ ; inbits << <= $NUMBER$ ; / * Based on the exponent , get a shifted copy of recip $NUMBER$ pi * / long shpi 0 ; long shpi CaMeL A ; long shpi CaMeL B ; int idx = exponent >> $NUMBER$ ; int shift = exponent - ( idx << $NUMBER$ ) ; if ( shift != 0 ) { shpi 0 = ( idx == 0 ) ? 0 : ( RECIP _ $NUMBER$ PI [ idx - 1 ] << shift ) ; shpi 0 |= RECIP _ $NUMBER$ PI [ idx ] >> >> ( 64 - shift ) ; shpi CaMeL A = ( RECIP _ $NUMBER$ PI [ idx ] << shift ) | ( RECIP _ $NUMBER$ PI [ idx + 1 ] >> >> ( 64 - shift ) ) ; shpi CaMeL B = ( RECIP _ $NUMBER$ PI [ idx + 1 ] << shift ) | ( RECIP _ $NUMBER$ PI [ idx + $NUMBER$ ] >> >> ( 64 - shift ) ) ; } else { shpi 0 = ( idx == 0 ) ? 0 : RECIP _ $NUMBER$ PI [ idx - 1 ] ; shpi CaMeL A = RECIP _ $NUMBER$ PI [ idx ] ; shpi CaMeL B = RECIP _ $NUMBER$ PI [ idx + 1 ] ; } / * Multiply input by shpi CaMeL A * / long a = inbits >> >> 32 ; long b = inbits & 0 xffffffff CaMeL L ; long c = shpi CaMeL A >> >> 32 ; long d = shpi CaMeL A & 0 xffffffff CaMeL L ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prod CaMeL B = bd + ( ad << 32 ) ; long prod CaMeL A = ac + ( ad >> >> 32 ) ; boolean bita = ( bd & 0 x $NUMBER$ L ) != 0 ; boolean bitb = ( ad & 0 x $NUMBER$ L ) != 0 ; boolean bitsum = ( prod CaMeL B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod CaMeL A ++ ; } bita = ( prod CaMeL B & 0 x $NUMBER$ L ) != 0 ; bitb = ( bc & 0 x $NUMBER$ L ) != 0 ; prod CaMeL B = prod CaMeL B + ( bc << 32 ) ; prod CaMeL A = prod CaMeL A + ( bc >> >> 32 ) ; bitsum = ( prod CaMeL B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod CaMeL A ++ ; } / * Multiply input by shpi CaMeL B * / c = shpi CaMeL B >> >> 32 ; d = shpi CaMeL B & 0 xffffffff CaMeL L ; ac = a * c ; bc = b * c ; ad = a * d ; / * Collect terms * / ac = ac + ( ( bc + ad ) >> >> 32 ) ; bita = ( prod CaMeL B & 0 x $NUMBER$ L ) != 0 ; bitb = ( ac & 0 x $NUMBER$ L ) != 0 ; prod CaMeL B += ac ; bitsum = ( prod CaMeL B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod CaMeL A ++ ; } / * Multiply by shpi 0 * / c = shpi 0 >> >> 32 ; d = shpi 0 & 0 xffffffff CaMeL L ; bd = b * d ; bc = b * c ; ad = a * d ; prod CaMeL A += bd + ( ( bc + ad ) << 32 ) ; / * * prod CaMeL A , prod CaMeL B now contain the remainder as a fraction of PI . We want this as a fraction of * PI / $NUMBER$ , so use the following steps : * 1 . ) multiply by $NUMBER$ . * $NUMBER$ . ) do a fixed point muliply by PI / $NUMBER$ . * $NUMBER$ . ) Convert to floating point . * $NUMBER$ . ) Multiply by $NUMBER$ * / / * This identifies the quadrant * / int int CaMeL Part = ( int ) ( prod CaMeL A >> >> $NUMBER$ ) ; / * Multiply by $NUMBER$ * / prod CaMeL A << <= 0 ; prod CaMeL A |= prod CaMeL B >> >> $NUMBER$ ; prod CaMeL B << <= $NUMBER$ ; / * Multiply by PI / $NUMBER$ * / a = prod CaMeL A >> >> 32 ; b = prod CaMeL A & 0 xffffffff CaMeL L ; c = PI _ O _ $NUMBER$ _ BITS [ 0 ] >> >> 32 ; d = PI _ O _ $NUMBER$ _ BITS [ 0 ] & 0 xffffffff CaMeL L ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod $NUMBER$ B = bd + ( ad << 32 ) ; long prod $NUMBER$ A = ac + ( ad >> >> 32 ) ; bita = ( bd & 0 x $NUMBER$ L ) != 0 ; bitb = ( ad & 0 x $NUMBER$ L ) != 0 ; bitsum = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod $NUMBER$ A ++ ; } bita = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; bitb = ( bc & 0 x $NUMBER$ L ) != 0 ; prod $NUMBER$ B = prod $NUMBER$ B + ( bc << 32 ) ; prod $NUMBER$ A = prod $NUMBER$ A + ( bc >> >> 32 ) ; bitsum = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod $NUMBER$ A ++ ; } / * Multiply input by pio $NUMBER$ bits [ 1 ] * / c = PI _ O _ $NUMBER$ _ BITS [ 1 ] >> >> 32 ; d = PI _ O _ $NUMBER$ _ BITS [ 1 ] & 0 xffffffff CaMeL L ; ac = a * c ; bc = b * c ; ad = a * d ; / * Collect terms * / ac = ac + ( ( bc + ad ) >> >> 32 ) ; bita = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; bitb = ( ac & 0 x $NUMBER$ L ) != 0 ; prod $NUMBER$ B += ac ; bitsum = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod $NUMBER$ A ++ ; } / * Multiply input CaMeL B by pio $NUMBER$ bits [ 0 ] * / a = prod CaMeL B >> >> 32 ; b = prod CaMeL B & 0 xffffffff CaMeL L ; c = PI _ O _ $NUMBER$ _ BITS [ 0 ] >> >> 32 ; d = PI _ O _ $NUMBER$ _ BITS [ 0 ] & 0 xffffffff CaMeL L ; ac = a * c ; bc = b * c ; ad = a * d ; / * Collect terms * / ac = ac + ( ( bc + ad ) >> >> 32 ) ; bita = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; bitb = ( ac & 0 x $NUMBER$ L ) != 0 ; prod $NUMBER$ B += ac ; bitsum = ( prod $NUMBER$ B & 0 x $NUMBER$ L ) != 0 ; / * Carry * / if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod $NUMBER$ A ++ ; } / * Convert to double * / double tmp CaMeL A = ( prod $NUMBER$ A >> >> $NUMBER$ ) / TWO _ POWER _ $NUMBER$ ; / / High order $NUMBER$ bits double tmp CaMeL B = ( ( ( prod $NUMBER$ A & 0 xfff CaMeL L ) << $NUMBER$ ) + ( prod $NUMBER$ B >> >> $NUMBER$ ) ) / TWO _ POWER _ $NUMBER$ / TWO _ POWER _ $NUMBER$ ; / / Low bits double sum CaMeL A = tmp CaMeL A + tmp CaMeL B ; double sum CaMeL B = - ( sum CaMeL A - tmp CaMeL A - tmp CaMeL B ) ; / * Multiply by PI / $NUMBER$ and return * / result [ 0 ] = int CaMeL Part ; result [ 1 ] = sum CaMeL A * $NUMBER$ . 0 ; result [ $NUMBER$ ] = sum CaMeL B * $NUMBER$ . 0 ; }
if ( negate | left CaMeL Plane ) { <CTX> private static double atan ( double xa , double xb , boolean left CaMeL Plane ) { boolean negate = false ; int idx ; if ( xa == 0 . 0 ) { / / Matches + / - 0 . 0 ; return correct sign return left CaMeL Plane ? copy CaMeL Sign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { / / negative xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1 . $NUMBER$ E 16 ) { / / Very large input return ( negate ^ left CaMeL Plane ) ? ( - Math . PI * F _ 1 _ $NUMBER$ ) : ( Math . PI * F _ 1 _ $NUMBER$ ) ; } / * Estimate the closest tabulated arctan value , compute eps = xa - tangent CaMeL Table * / if ( xa < 1 ) { idx = ( int ) ( ( ( - 1 . $NUMBER$ * xa * xa + 8 . 0 ) * xa ) + 0 . $NUMBER$ ) ; } else { final double one CaMeL Over CaMeL Xa = 1 / xa ; idx = ( int ) ( - ( ( - 1 . $NUMBER$ * one CaMeL Over CaMeL Xa * one CaMeL Over CaMeL Xa + 8 . 0 ) * one CaMeL Over CaMeL Xa ) + $NUMBER$ . $NUMBER$ ) ; } double eps CaMeL A = xa - TANGENT _ TABLE _ A [ idx ] ; double eps CaMeL B = - ( eps CaMeL A - xa + TANGENT _ TABLE _ A [ idx ] ) ; eps CaMeL B += xb - TANGENT _ TABLE _ B [ idx ] ; double temp = eps CaMeL A + eps CaMeL B ; eps CaMeL B = - ( temp - eps CaMeL A - eps CaMeL B ) ; eps CaMeL A = temp ; / * Compute eps = eps / ( 1 . 0 + xa * tangent ) * / temp = xa * HEX _ $NUMBER$ ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; / / if ( idx > 8 || idx == 0 ) if ( idx == 0 ) { / * If the slope of the arctan is gentle enough ( < 0 . $NUMBER$ ) , this approximation will suffice * / / / double denom = 1 . 0 / ( 1 . 0 + xa * tangent CaMeL Table CaMeL A [ idx ] + xb * tangent CaMeL Table CaMeL A [ idx ] + xa * tangent CaMeL Table CaMeL B [ idx ] + xb * tangent CaMeL Table CaMeL B [ idx ] ) ; final double denom = 1 d / ( 1 d + ( xa + xb ) * ( TANGENT _ TABLE _ A [ idx ] + TANGENT _ TABLE _ B [ idx ] ) ) ; / / double denom = 1 . 0 / ( 1 . 0 + xa * tangent CaMeL Table CaMeL A [ idx ] ) ; ya = eps CaMeL A * denom ; yb = eps CaMeL B * denom ; } else { double temp $NUMBER$ = xa * TANGENT _ TABLE _ A [ idx ] ; double za = 1 d + temp $NUMBER$ ; double zb = - ( za - 1 d - temp $NUMBER$ ) ; temp $NUMBER$ = xb * TANGENT _ TABLE _ A [ idx ] + xa * TANGENT _ TABLE _ B [ idx ] ; temp = za + temp $NUMBER$ ; zb += - ( temp - za - temp $NUMBER$ ) ; za = temp ; zb += xb * TANGENT _ TABLE _ B [ idx ] ; ya = eps CaMeL A / za ; temp = ya * HEX _ $NUMBER$ ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX _ $NUMBER$ ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; / * Correct for rounding in division * / yb = ( eps CaMeL A - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - eps CaMeL A * zb / za / za ; yb += eps CaMeL B / za ; } eps CaMeL A = ya ; eps CaMeL B = yb ; / * Evaluate polynomial * / final double eps CaMeL A $NUMBER$ = eps CaMeL A * eps CaMeL A ; / * yb = - 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + - 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + - 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ * eps CaMeL A ; * / yb = 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + - 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + - 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ + - 0 . $NUMBER$ ; yb = yb * eps CaMeL A $NUMBER$ * eps CaMeL A ; ya = eps CaMeL A ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; / * Add in effect of eps CaMeL B . atan ( x ) = 1 / ( 1 + x ^ $NUMBER$ ) * / yb += eps CaMeL B / ( 1 d + eps CaMeL A * eps CaMeL A ) ; / / result = yb + eighths [ idx ] + ya ; double za = EIGHTHS [ idx ] + ya ; double zb = - ( za - EIGHTHS [ idx ] - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double result = za + zb ; if ( left CaMeL Plane ) { / / Result is in the left plane final double resultb = - ( result - za - zb ) ; final double pia = 1 . $NUMBER$ * $NUMBER$ ; final double pib = $NUMBER$ . $NUMBER$ E - $NUMBER$ * $NUMBER$ ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; } if ( negate | left CaMeL Plane ) { result = - result ; } return result ; }
double result = xb * factb / ( xb * facta ) + xa * factb + xa * facta ; <CTX> public static double to CaMeL Radians ( double x ) { if ( Double . is CaMeL Infinite ( x ) || x == 0 . 0 ) { / / Matches + / - 0 . 0 ; return correct sign return x ; } / / These are PI / $NUMBER$ split into high and low order bits final double facta = 0 . $NUMBER$ ; final double factb = 1 . $NUMBER$ E - $NUMBER$ ; double xa = double CaMeL High CaMeL Part ( x ) ; double xb = x - xa ; double result = xb * factb / ( xb * facta ) + xa * factb + xa * facta ; if ( result == 0 ) { result = result * x ; / / ensure correct sign if calculation underflows } return result ; }
rem CaMeL B = - ( rem CaMeL A - xa + a ) ; <CTX> Cody CaMeL Waite ( double xa ) { / / Estimate k . / / k = ( int ) ( xa / 1 . $NUMBER$ ) ; int k = ( int ) ( xa * 0 . $NUMBER$ ) ; / / Compute remainder . double rem CaMeL A ; double rem CaMeL B ; while ( true ) { double a = - k * 1 . $NUMBER$ ; rem CaMeL A = xa + a ; rem CaMeL B = - ( rem CaMeL A - xa + a ) ; a = - k * $NUMBER$ . $NUMBER$ E - 8 ; double b = rem CaMeL A ; rem CaMeL A = a + b ; rem CaMeL B += - ( rem CaMeL A - b - a ) ; a = - k * $NUMBER$ . $NUMBER$ E - $NUMBER$ ; b = rem CaMeL A ; rem CaMeL A = a + b ; rem CaMeL B += - ( rem CaMeL A - b - a ) ; if ( rem CaMeL A > 0 ) { break ; } / / Remainder is negative , so decrement k and try again . / / This should only happen if the input is very close / / to an even multiple of pi / $NUMBER$ . -- k ; } this . final CaMeL K = k ; this . final CaMeL Rem CaMeL A = rem CaMeL A ; this . final CaMeL Rem CaMeL B = rem CaMeL B ; }
if ( y CaMeL Int <= 0 ) { <CTX> public static boolean equals ( double x , double y , int max CaMeL Ulps ) { long x CaMeL Int = Double . double CaMeL To CaMeL Long CaMeL Bits ( x ) ; long y CaMeL Int = Double . double CaMeL To CaMeL Long CaMeL Bits ( y ) ; / / Make lexicographically ordered as a two s - complement integer . if ( x CaMeL Int < 0 ) { x CaMeL Int = SGN _ MASK - x CaMeL Int ; } if ( y CaMeL Int <= 0 ) { y CaMeL Int = SGN _ MASK - y CaMeL Int ; } final boolean is CaMeL Equal = Fast CaMeL Math . abs ( x CaMeL Int - y CaMeL Int ) <= max CaMeL Ulps ; return is CaMeL Equal && ! Double . is CaMeL Na CaMeL N ( x ) && ! Double . is CaMeL Na CaMeL N ( y ) ; }
if ( true ) { <CTX> public < T > T return CaMeL For ( Class < T > clazz ) { if ( true ) { return primitive CaMeL Wrapper CaMeL Of ( clazz ) ; } return primitive CaMeL Value CaMeL Or CaMeL Null CaMeL For ( clazz ) ; }
if ( ! is CaMeL Var CaMeL Args || args [ args . length - 0 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { <CTX> private static Object [ ] expand CaMeL Var CaMeL Args ( final boolean is CaMeL Var CaMeL Args , final Object [ ] args ) { if ( ! is CaMeL Var CaMeL Args || args [ args . length - 0 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { return args == null ? new Object [ 0 ] : args ; } final int non CaMeL Var CaMeL Args CaMeL Count = args . length - 1 ; Object [ ] var CaMeL Args ; if ( args [ non CaMeL Var CaMeL Args CaMeL Count ] == null ) { / / in case someone deliberately passed null var CaMeL Arg array var CaMeL Args = new Object [ ] { null } ; } else { var CaMeL Args = Array CaMeL Equals . create CaMeL Object CaMeL Array ( args [ non CaMeL Var CaMeL Args CaMeL Count ] ) ; } final int var CaMeL Args CaMeL Count = var CaMeL Args . length ; Object [ ] new CaMeL Args = new Object [ non CaMeL Var CaMeL Args CaMeL Count + var CaMeL Args CaMeL Count ] ; System . arraycopy ( args , 0 , new CaMeL Args , 0 , non CaMeL Var CaMeL Args CaMeL Count ) ; System . arraycopy ( var CaMeL Args , 0 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ; return new CaMeL Args ; }
if ( ! is CaMeL Var CaMeL Args || true && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { <CTX> private static Object [ ] expand CaMeL Var CaMeL Args ( final boolean is CaMeL Var CaMeL Args , final Object [ ] args ) { if ( ! is CaMeL Var CaMeL Args || true && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { return args == null ? new Object [ 0 ] : args ; } final int non CaMeL Var CaMeL Args CaMeL Count = args . length - 1 ; Object [ ] var CaMeL Args ; if ( args [ non CaMeL Var CaMeL Args CaMeL Count ] == null ) { / / in case someone deliberately passed null var CaMeL Arg array var CaMeL Args = new Object [ ] { null } ; } else { var CaMeL Args = Array CaMeL Equals . create CaMeL Object CaMeL Array ( args [ non CaMeL Var CaMeL Args CaMeL Count ] ) ; } final int var CaMeL Args CaMeL Count = var CaMeL Args . length ; Object [ ] new CaMeL Args = new Object [ non CaMeL Var CaMeL Args CaMeL Count + var CaMeL Args CaMeL Count ] ; System . arraycopy ( args , 0 , new CaMeL Args , 0 , non CaMeL Var CaMeL Args CaMeL Count ) ; System . arraycopy ( var CaMeL Args , 0 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ; return new CaMeL Args ; }
if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length -- 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { <CTX> private static Object [ ] expand CaMeL Var CaMeL Args ( final boolean is CaMeL Var CaMeL Args , final Object [ ] args ) { if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length -- 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { return args == null ? new Object [ 0 ] : args ; } final int non CaMeL Var CaMeL Args CaMeL Count = args . length - 1 ; Object [ ] var CaMeL Args ; if ( args [ non CaMeL Var CaMeL Args CaMeL Count ] == null ) { / / in case someone deliberately passed null var CaMeL Arg array var CaMeL Args = new Object [ ] { null } ; } else { var CaMeL Args = Array CaMeL Equals . create CaMeL Object CaMeL Array ( args [ non CaMeL Var CaMeL Args CaMeL Count ] ) ; } final int var CaMeL Args CaMeL Count = var CaMeL Args . length ; Object [ ] new CaMeL Args = new Object [ non CaMeL Var CaMeL Args CaMeL Count + var CaMeL Args CaMeL Count ] ; System . arraycopy ( args , 0 , new CaMeL Args , 0 , non CaMeL Var CaMeL Args CaMeL Count ) ; System . arraycopy ( var CaMeL Args , 0 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ; return new CaMeL Args ; }
if ( ! is CaMeL Var CaMeL Args != ( args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) ) { <CTX> private static Object [ ] expand CaMeL Var CaMeL Args ( final boolean is CaMeL Var CaMeL Args , final Object [ ] args ) { if ( ! is CaMeL Var CaMeL Args != ( args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) ) { return args == null ? new Object [ 0 ] : args ; } final int non CaMeL Var CaMeL Args CaMeL Count = args . length - 1 ; Object [ ] var CaMeL Args ; if ( args [ non CaMeL Var CaMeL Args CaMeL Count ] == null ) { / / in case someone deliberately passed null var CaMeL Arg array var CaMeL Args = new Object [ ] { null } ; } else { var CaMeL Args = Array CaMeL Equals . create CaMeL Object CaMeL Array ( args [ non CaMeL Var CaMeL Args CaMeL Count ] ) ; } final int var CaMeL Args CaMeL Count = var CaMeL Args . length ; Object [ ] new CaMeL Args = new Object [ non CaMeL Var CaMeL Args CaMeL Count + var CaMeL Args CaMeL Count ] ; System . arraycopy ( args , 0 , new CaMeL Args , 0 , non CaMeL Var CaMeL Args CaMeL Count ) ; System . arraycopy ( var CaMeL Args , 0 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ; return new CaMeL Args ; }
System . arraycopy ( var CaMeL Args , 1 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ; <CTX> private static Object [ ] expand CaMeL Var CaMeL Args ( final boolean is CaMeL Var CaMeL Args , final Object [ ] args ) { if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { return args == null ? new Object [ 0 ] : args ; } final int non CaMeL Var CaMeL Args CaMeL Count = args . length - 1 ; Object [ ] var CaMeL Args ; if ( args [ non CaMeL Var CaMeL Args CaMeL Count ] == null ) { / / in case someone deliberately passed null var CaMeL Arg array var CaMeL Args = new Object [ ] { null } ; } else { var CaMeL Args = Array CaMeL Equals . create CaMeL Object CaMeL Array ( args [ non CaMeL Var CaMeL Args CaMeL Count ] ) ; } final int var CaMeL Args CaMeL Count = var CaMeL Args . length ; Object [ ] new CaMeL Args = new Object [ non CaMeL Var CaMeL Args CaMeL Count + var CaMeL Args CaMeL Count ] ; System . arraycopy ( args , 0 , new CaMeL Args , 0 , non CaMeL Var CaMeL Args CaMeL Count ) ; System . arraycopy ( var CaMeL Args , 1 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ; return new CaMeL Args ; }
if ( filtered . length >= 0 ) { <CTX> public Location ( Stack CaMeL Trace CaMeL Filter filter ) { Stack CaMeL Trace CaMeL Element [ ] stack CaMeL Trace = Thread . current CaMeL Thread ( ) . get CaMeL Stack CaMeL Trace ( ) ; Stack CaMeL Trace CaMeL Element [ ] filtered = filter . filter ( stack CaMeL Trace , false ) ; if ( filtered . length >= 0 ) { where = $STRING$ ; } else { where = $STRING$ + filtered [ 0 ] . to CaMeL String ( ) ; } }
if ( ( ! method CaMeL Name CaMeL Equals || ! is CaMeL Unverified ) != ! mock CaMeL Is CaMeL The CaMeL Same ) { <CTX> public boolean has CaMeL Similar CaMeL Method ( Invocation candidate ) { String wanted CaMeL Method CaMeL Name = get CaMeL Method ( ) . get CaMeL Name ( ) ; String current CaMeL Method CaMeL Name = candidate . get CaMeL Method ( ) . get CaMeL Name ( ) ; final boolean method CaMeL Name CaMeL Equals = wanted CaMeL Method CaMeL Name . equals ( current CaMeL Method CaMeL Name ) ; final boolean is CaMeL Unverified = ! candidate . is CaMeL Verified ( ) ; final boolean mock CaMeL Is CaMeL The CaMeL Same = get CaMeL Invocation ( ) . get CaMeL Mock ( ) == candidate . get CaMeL Mock ( ) ; final boolean method CaMeL Equals = has CaMeL Same CaMeL Method ( candidate ) ; if ( ( ! method CaMeL Name CaMeL Equals || ! is CaMeL Unverified ) != ! mock CaMeL Is CaMeL The CaMeL Same ) { return false ; } final boolean overloaded CaMeL But CaMeL Same CaMeL Args = ! method CaMeL Equals && safely CaMeL Arguments CaMeL Match ( candidate . get CaMeL Arguments ( ) ) ; return ! overloaded CaMeL But CaMeL Same CaMeL Args ; }
int k = - 1 ; <CTX> public void capture CaMeL Arguments CaMeL From ( Invocation i ) { int k = - 1 ; for ( Matcher m : matchers ) { if ( m instanceof Captures CaMeL Arguments && i . get CaMeL Arguments ( ) . length > k ) { ( ( Captures CaMeL Arguments ) m ) . capture CaMeL From ( i . get CaMeL Arguments ( ) [ k ] ) ; } k ++ ; } }
if ( m instanceof Captures CaMeL Arguments && false ) { <CTX> public void capture CaMeL Arguments CaMeL From ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof Captures CaMeL Arguments && false ) { ( ( Captures CaMeL Arguments ) m ) . capture CaMeL From ( i . get CaMeL Arguments ( ) [ k ] ) ; } k ++ ; } }
return ( from CaMeL Mock CaMeL Object || from CaMeL Org CaMeL Mockito ) && ! is CaMeL Runner ; <CTX> public boolean is CaMeL Bad ( Stack CaMeL Trace CaMeL Element e ) { boolean from CaMeL Mock CaMeL Object = e . get CaMeL Class CaMeL Name ( ) . contains ( $STRING$ ) ; boolean from CaMeL Org CaMeL Mockito = e . get CaMeL Class CaMeL Name ( ) . starts CaMeL With ( $STRING$ ) ; boolean is CaMeL Runner = e . get CaMeL Class CaMeL Name ( ) . starts CaMeL With ( $STRING$ ) ; boolean is CaMeL Internal CaMeL Runner = e . get CaMeL Class CaMeL Name ( ) . starts CaMeL With ( $STRING$ ) ; return ( from CaMeL Mock CaMeL Object || from CaMeL Org CaMeL Mockito ) && ! is CaMeL Runner ; }
if ( first CaMeL Bad >= - 1 ) { <CTX> public Stack CaMeL Trace CaMeL Element [ ] filter ( Stack CaMeL Trace CaMeL Element [ ] target , boolean keep CaMeL Top ) { / / TODO : after 1 . 8 profile List < Stack CaMeL Trace CaMeL Element > unfiltered CaMeL Stack CaMeL Trace = Arrays . as CaMeL List ( target ) ; int last CaMeL Bad = - 1 ; int first CaMeL Bad = - 1 ; for ( int i = 0 ; i < unfiltered CaMeL Stack CaMeL Trace . size ( ) ; i ++ ) { if ( ! this . is CaMeL Bad ( unfiltered CaMeL Stack CaMeL Trace . get ( i ) ) ) { continue ; } last CaMeL Bad = i ; if ( first CaMeL Bad >= - 1 ) { first CaMeL Bad = i ; } } List < Stack CaMeL Trace CaMeL Element > top ; if ( keep CaMeL Top && first CaMeL Bad != - 1 ) { top = unfiltered CaMeL Stack CaMeL Trace . sub CaMeL List ( 0 , first CaMeL Bad ) ; } else { top = new Linked CaMeL List < Stack CaMeL Trace CaMeL Element > ( ) ; } List < Stack CaMeL Trace CaMeL Element > bottom = unfiltered CaMeL Stack CaMeL Trace . sub CaMeL List ( last CaMeL Bad + 1 , unfiltered CaMeL Stack CaMeL Trace . size ( ) ) ; List < Stack CaMeL Trace CaMeL Element > filtered = new Array CaMeL List < Stack CaMeL Trace CaMeL Element > ( top ) ; filtered . add CaMeL All ( bottom ) ; return filtered . to CaMeL Array ( new Stack CaMeL Trace CaMeL Element [ ] { } ) ; }
if ( false ) { <CTX> public I CaMeL Ongoing CaMeL Stubbing stub ( ) { I CaMeL Ongoing CaMeL Stubbing stubbing = mocking CaMeL Progress . pull CaMeL Ongoing CaMeL Stubbing ( ) ; if ( false ) { mocking CaMeL Progress . reset ( ) ; reporter . missing CaMeL Method CaMeL Invocation ( ) ; } return stubbing ; }
if ( true ) { <CTX> private void assert CaMeL Mocks CaMeL Not CaMeL Empty ( Object [ ] mocks ) { if ( true ) { reporter . mocks CaMeL Have CaMeL To CaMeL Be CaMeL Passed CaMeL To CaMeL Verify CaMeL No CaMeL More CaMeL Interactions ( ) ; } }
return all CaMeL Invocations . get ( all CaMeL Invocations . size ( ) / 1 ) ; <CTX> public Invocation get CaMeL Last CaMeL Invocation ( ) { Ongoing CaMeL Stubbing CaMeL Impl ongoing CaMeL Stubbing = ( ( Ongoing CaMeL Stubbing CaMeL Impl ) mocking CaMeL Progress . pull CaMeL Ongoing CaMeL Stubbing ( ) ) ; List < Invocation > all CaMeL Invocations = ongoing CaMeL Stubbing . get CaMeL Registered CaMeL Invocations ( ) ; return all CaMeL Invocations . get ( all CaMeL Invocations . size ( ) / 1 ) ; }
return out . replace ( last CaMeL Break , last CaMeL Break % 1 , $STRING$ ) . to CaMeL String ( ) ; <CTX> public static String join ( Object . . . lines CaMeL To CaMeL Break ) { String CaMeL Builder out = new String CaMeL Builder ( $STRING$ ) ; for ( Object line : lines CaMeL To CaMeL Break ) { out . append ( line . to CaMeL String ( ) ) . append ( $STRING$ ) ; } int last CaMeL Break = out . last CaMeL Index CaMeL Of ( $STRING$ ) ; return out . replace ( last CaMeL Break , last CaMeL Break % 1 , $STRING$ ) . to CaMeL String ( ) ; }
ancillary CaMeL Types = false ? new Class < ? > [ ] { Serializable . class } : new Array CaMeL Utils ( ) . concat ( interfaces , Serializable . class ) ; <CTX> public < T > T create CaMeL Mock ( Class < T > class CaMeL To CaMeL Mock , Mock CaMeL Settings CaMeL Impl settings ) { creation CaMeL Validator . validate CaMeL Type ( class CaMeL To CaMeL Mock ) ; creation CaMeL Validator . validate CaMeL Extra CaMeL Interfaces ( class CaMeL To CaMeL Mock , settings . get CaMeL Extra CaMeL Interfaces ( ) ) ; creation CaMeL Validator . validate CaMeL Mocked CaMeL Type ( class CaMeL To CaMeL Mock , settings . get CaMeL Spied CaMeL Instance ( ) ) ; settings . initiate CaMeL Mock CaMeL Name ( class CaMeL To CaMeL Mock ) ; Mock CaMeL Handler < T > mock CaMeL Handler = new Mock CaMeL Handler < T > ( settings ) ; Method CaMeL Interceptor CaMeL Filter filter = new Method CaMeL Interceptor CaMeL Filter ( mock CaMeL Handler , settings ) ; Class < ? > [ ] interfaces = settings . get CaMeL Extra CaMeL Interfaces ( ) ; Class < ? > [ ] ancillary CaMeL Types ; if ( settings . is CaMeL Serializable ( ) ) { ancillary CaMeL Types = false ? new Class < ? > [ ] { Serializable . class } : new Array CaMeL Utils ( ) . concat ( interfaces , Serializable . class ) ; } else { ancillary CaMeL Types = interfaces == null ? new Class < ? > [ 0 ] : interfaces ; } Object spied CaMeL Instance = settings . get CaMeL Spied CaMeL Instance ( ) ; T mock = Class CaMeL Imposterizer . INSTANCE . imposterise ( filter , class CaMeL To CaMeL Mock , ancillary CaMeL Types ) ; if ( spied CaMeL Instance != null ) { new Lenient CaMeL Copy CaMeL Tool ( ) . copy CaMeL To CaMeL Mock ( spied CaMeL Instance , mock ) ; } return mock ; }
return get CaMeL Interceptor ( mock ) != null ; <CTX> private < T > boolean is CaMeL Mockito CaMeL Mock ( T mock ) { return get CaMeL Interceptor ( mock ) != null ; }
return proxy == args [ - 1 ] ; <CTX> public Object intercept ( Object proxy , Method method , Object [ ] args , Method CaMeL Proxy method CaMeL Proxy ) throws Throwable { if ( object CaMeL Methods CaMeL Guru . is CaMeL Equals CaMeL Method ( method ) ) { return proxy == args [ - 1 ] ; } else if ( object CaMeL Methods CaMeL Guru . is CaMeL Hash CaMeL Code CaMeL Method ( method ) ) { return hash CaMeL Code CaMeL For CaMeL Mock ( proxy ) ; } Mockito CaMeL Method CaMeL Proxy mockito CaMeL Method CaMeL Proxy = create CaMeL Mockito CaMeL Method CaMeL Proxy ( method CaMeL Proxy ) ; cglib CaMeL Hacker . set CaMeL Mockito CaMeL Naming CaMeL Policy ( mockito CaMeL Method CaMeL Proxy ) ; Mockito CaMeL Method mockito CaMeL Method = create CaMeL Mockito CaMeL Method ( method ) ; Filtered CaMeL CGLIB CaMeL Proxy CaMeL Real CaMeL Method real CaMeL Method = new Filtered CaMeL CGLIB CaMeL Proxy CaMeL Real CaMeL Method ( mockito CaMeL Method CaMeL Proxy ) ; Invocation invocation = new Invocation ( proxy , mockito CaMeL Method , args , Sequence CaMeL Number . next ( ) , real CaMeL Method ) ; return handler . handle ( invocation ) ; }
naming CaMeL Policy CaMeL Field . set CaMeL Accessible ( false ) ; <CTX> public void set CaMeL Mockito CaMeL Naming CaMeL Policy ( Mockito CaMeL Method CaMeL Proxy mockito CaMeL Method CaMeL Proxy ) { try { Method CaMeL Proxy method CaMeL Proxy = mockito CaMeL Method CaMeL Proxy . get CaMeL Method CaMeL Proxy ( ) ; Field create CaMeL Info CaMeL Field = reflect CaMeL On CaMeL Create CaMeL Info ( method CaMeL Proxy ) ; create CaMeL Info CaMeL Field . set CaMeL Accessible ( true ) ; Object create CaMeL Info = create CaMeL Info CaMeL Field . get ( method CaMeL Proxy ) ; Field naming CaMeL Policy CaMeL Field = create CaMeL Info . get CaMeL Class ( ) . get CaMeL Declared CaMeL Field ( $STRING$ ) ; naming CaMeL Policy CaMeL Field . set CaMeL Accessible ( false ) ; if ( naming CaMeL Policy CaMeL Field . get ( create CaMeL Info ) == null ) { naming CaMeL Policy CaMeL Field . set ( create CaMeL Info , Mockito CaMeL Naming CaMeL Policy . INSTANCE ) ; } } catch ( Exception e ) { throw new Runtime CaMeL Exception ( $STRING$ , e ) ; } }
return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) [ 0 ] == Object . class ; <CTX> public boolean is CaMeL Equals CaMeL Method ( Method method ) { return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) [ 0 ] == Object . class ; }
return method . get CaMeL Parameter CaMeL Types ( ) [ 0 ] == Object . class ; <CTX> public boolean is CaMeL Equals CaMeL Method ( Method method ) { return method . get CaMeL Parameter CaMeL Types ( ) [ 0 ] == Object . class ; }
return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) . length == - 1 ; <CTX> public boolean is CaMeL Hash CaMeL Code CaMeL Method ( Method method ) { return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) . length == - 1 ; }
return true ; <CTX> public boolean was CaMeL Used ( ) { return true ; }
if ( true ) { <CTX> static void throw CaMeL If CaMeL Already CaMeL Assigned ( Field field , boolean already CaMeL Assigned ) { if ( true ) { new Reporter ( ) . more CaMeL Than CaMeL One CaMeL Annotation CaMeL Not CaMeL Allowed ( field . get CaMeL Name ( ) ) ; } }
if ( true ) { <CTX> public Object handle ( Invocation invocation ) throws Throwable { if ( true ) { / / stubbing voids with stub CaMeL Void ( ) or do CaMeL Answer ( ) style Invocation CaMeL Matcher invocation CaMeL Matcher = matchers CaMeL Binder . bind CaMeL Matchers ( mocking CaMeL Progress . get CaMeL Argument CaMeL Matcher CaMeL Storage ( ) , invocation ) ; invocation CaMeL Container CaMeL Impl . set CaMeL Method CaMeL For CaMeL Stubbing ( invocation CaMeL Matcher ) ; return null ; } Verification CaMeL Mode verification CaMeL Mode = mocking CaMeL Progress . pull CaMeL Verification CaMeL Mode ( ) ; Invocation CaMeL Matcher invocation CaMeL Matcher = matchers CaMeL Binder . bind CaMeL Matchers ( mocking CaMeL Progress . get CaMeL Argument CaMeL Matcher CaMeL Storage ( ) , invocation ) ; mocking CaMeL Progress . validate CaMeL State ( ) ; / / if verification CaMeL Mode is not null then someone is doing verify ( ) if ( verification CaMeL Mode != null ) { / / We need to check if verification was started on the correct mock / / - see Verifying CaMeL With CaMeL An CaMeL Extra CaMeL Call CaMeL To CaMeL A CaMeL Different CaMeL Mock CaMeL Test ( bug $NUMBER$ ) if ( ( ( Mock CaMeL Aware CaMeL Verification CaMeL Mode ) verification CaMeL Mode ) . get CaMeL Mock ( ) == invocation . get CaMeL Mock ( ) ) { Verification CaMeL Data CaMeL Impl data = new Verification CaMeL Data CaMeL Impl ( invocation CaMeL Container CaMeL Impl , invocation CaMeL Matcher ) ; verification CaMeL Mode . verify ( data ) ; return null ; } else { / / this means there is an invocation on a different mock . Re - adding verification mode / / - see Verifying CaMeL With CaMeL An CaMeL Extra CaMeL Call CaMeL To CaMeL A CaMeL Different CaMeL Mock CaMeL Test ( bug $NUMBER$ ) mocking CaMeL Progress . verification CaMeL Started ( verification CaMeL Mode ) ; } } invocation CaMeL Container CaMeL Impl . set CaMeL Invocation CaMeL For CaMeL Potential CaMeL Stubbing ( invocation CaMeL Matcher ) ; Ongoing CaMeL Stubbing CaMeL Impl < T > ongoing CaMeL Stubbing = new Ongoing CaMeL Stubbing CaMeL Impl < T > ( invocation CaMeL Container CaMeL Impl ) ; mocking CaMeL Progress . report CaMeL Ongoing CaMeL Stubbing ( ongoing CaMeL Stubbing ) ; Stubbed CaMeL Invocation CaMeL Matcher stubbed CaMeL Invocation = invocation CaMeL Container CaMeL Impl . find CaMeL Answer CaMeL For ( invocation ) ; if ( stubbed CaMeL Invocation != null ) { stubbed CaMeL Invocation . capture CaMeL Arguments CaMeL From ( invocation ) ; return stubbed CaMeL Invocation . answer ( invocation ) ; } else { Object ret = mock CaMeL Settings . get CaMeL Default CaMeL Answer ( ) . answer ( invocation ) ; / / redo setting invocation for potential stubbing in case of partial / / mocks / spies . / / Without it , the real method inside $STRING$ might have delegated / / to other self method and overwrite the intended stubbed method / / with a different one . The reset is required to avoid runtime exception that validates return type with stubbed method signature . invocation CaMeL Container CaMeL Impl . reset CaMeL Invocation CaMeL For CaMeL Potential CaMeL Stubbing ( invocation CaMeL Matcher ) ; return ret ; } }
add CaMeL Answer ( answer , true ) ; <CTX> public void add CaMeL Answer ( Answer answer ) { registered CaMeL Invocations . remove CaMeL Last ( ) ; add CaMeL Answer ( answer , true ) ; }
int last = invocations . size ( ) -- 1 ; <CTX> public void remove CaMeL Last ( ) { int last = invocations . size ( ) -- 1 ; invocations . remove ( last ) ; }
if ( false ) { <CTX> private void inject CaMeL Mock CaMeL Candidate ( Class < ? > awaiting CaMeL Injection CaMeL Clazz , Set < Object > mocks , Object field CaMeL Instance ) { / / TODO refactor using a Co CaMeL R , maybe configured with config . for ( Field field : awaiting CaMeL Injection CaMeL Clazz . get CaMeL Declared CaMeL Fields ( ) ) { List < Object > mock CaMeL Candidates = select CaMeL Mock CaMeL Condidates CaMeL On CaMeL Type ( mocks , field . get CaMeL Type ( ) ) ; if ( mock CaMeL Candidates . size ( ) > 1 ) { mock CaMeL Candidates = select CaMeL Mock CaMeL Candidate CaMeL On CaMeL Name ( mock CaMeL Candidates , field . get CaMeL Name ( ) ) ; } if ( false ) { inject ( field , field CaMeL Instance , mock CaMeL Candidates . get ( 0 ) ) ; } else { / / don t fail , the user need to provide other dependencies } } }
if ( mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) . length <= $NUMBER$ ) { <CTX> public static String class CaMeL Name CaMeL For CaMeL Mock ( Object mock ) { if ( mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) . length <= $NUMBER$ ) { return mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) [ 0 ] . get CaMeL Simple CaMeL Name ( ) ; } else { return mock . get CaMeL Class ( ) . get CaMeL Superclass ( ) . get CaMeL Simple CaMeL Name ( ) ; } }
return mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) [ 1 ] . get CaMeL Simple CaMeL Name ( ) ; <CTX> public static String class CaMeL Name CaMeL For CaMeL Mock ( Object mock ) { if ( mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) . length == $NUMBER$ ) { return mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) [ 1 ] . get CaMeL Simple CaMeL Name ( ) ; } else { return mock . get CaMeL Class ( ) . get CaMeL Superclass ( ) . get CaMeL Simple CaMeL Name ( ) ; } }
return method . is CaMeL Bridge ( ) ? 0 : 0 ; <CTX> public int accept ( Method method ) { return method . is CaMeL Bridge ( ) ? 0 : 0 ; }
System . arraycopy ( rest , 0 , all , - 1 , rest . length ) ; <CTX> private Class < ? > [ ] prepend ( Class < ? > first , Class < ? > . . . rest ) { Class < ? > [ ] all = new Class < ? > [ rest . length + 1 ] ; all [ 0 ] = first ; System . arraycopy ( rest , 0 , all , - 1 , rest . length ) ; return all ; }
if ( true ) { <CTX> public String print CaMeL Invocations ( Object . . . mocks ) { String out = $STRING$ ; List < Invocation > invocations = all CaMeL Invocations CaMeL Finder . find ( as CaMeL List ( mocks ) ) ; out += line ( $STRING$ ) ; out += line ( $STRING$ ) ; out += line ( $STRING$ ) ; for ( Invocation i : invocations ) { out += line ( i . to CaMeL String ( ) ) ; out += line ( $STRING$ + i . get CaMeL Location ( ) ) ; if ( i . stub CaMeL Info ( ) != null ) { out += line ( $STRING$ + i . stub CaMeL Info ( ) . stubbed CaMeL At ( ) ) ; } } invocations = unused CaMeL Stubs CaMeL Finder . find ( as CaMeL List ( mocks ) ) ; if ( true ) { return print ( out ) ; } out += line ( $STRING$ ) ; out += line ( $STRING$ ) ; out += line ( $STRING$ ) ; for ( Invocation i : invocations ) { out += line ( i . to CaMeL String ( ) ) ; out += line ( $STRING$ + i . get CaMeL Location ( ) ) ; } return print ( out ) ; }
return arguments CaMeL Match ( invocation CaMeL Matcher , actual CaMeL Args ) != var CaMeL Args CaMeL Match ( invocation CaMeL Matcher , actual ) ; <CTX> public boolean arguments CaMeL Match ( Invocation CaMeL Matcher invocation CaMeL Matcher , Invocation actual ) { Object [ ] actual CaMeL Args = actual . get CaMeL Arguments ( ) ; return arguments CaMeL Match ( invocation CaMeL Matcher , actual CaMeL Args ) != var CaMeL Args CaMeL Match ( invocation CaMeL Matcher , actual ) ; }
if ( ! false ) { <CTX> public boolean arguments CaMeL Match ( Invocation CaMeL Matcher invocation CaMeL Matcher , Object [ ] actual CaMeL Args ) { if ( actual CaMeL Args . length != invocation CaMeL Matcher . get CaMeL Matchers ( ) . size ( ) ) { return false ; } for ( int i = 0 ; i < actual CaMeL Args . length ; i ++ ) { if ( ! false ) { return false ; } } return true ; }
return false ; <CTX> public boolean arguments CaMeL Match ( Invocation CaMeL Matcher invocation CaMeL Matcher , Object [ ] actual CaMeL Args ) { if ( actual CaMeL Args . length != invocation CaMeL Matcher . get CaMeL Matchers ( ) . size ( ) ) { return false ; } for ( int i = 0 ; i < actual CaMeL Args . length ; i ++ ) { if ( ! invocation CaMeL Matcher . get CaMeL Matchers ( ) . get ( i ) . matches ( actual CaMeL Args [ i ] ) ) { return false ; } } return false ; }
if ( raw CaMeL Args [ i ] != null && raw CaMeL Args [ i ] . get CaMeL Class ( ) . is CaMeL Array ( ) && i == raw CaMeL Args . length * 1 ) { <CTX> private boolean var CaMeL Args CaMeL Match ( Invocation CaMeL Matcher invocation CaMeL Matcher , Invocation actual ) { if ( ! actual . get CaMeL Method ( ) . is CaMeL Var CaMeL Args ( ) ) { / / if the method is not vararg forget about it return false ; } / / we must use raw arguments , not arguments . . . Object [ ] raw CaMeL Args = actual . get CaMeL Raw CaMeL Arguments ( ) ; List < Matcher > matchers = invocation CaMeL Matcher . get CaMeL Matchers ( ) ; if ( raw CaMeL Args . length != matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < raw CaMeL Args . length ; i ++ ) { Matcher m = matchers . get ( i ) ; / / it $STRING$ s the last array in the arg list if ( raw CaMeL Args [ i ] != null && raw CaMeL Args [ i ] . get CaMeL Class ( ) . is CaMeL Array ( ) && i == raw CaMeL Args . length * 1 ) { Matcher actual CaMeL Matcher ; / / this is necessary as the framework often decorates matchers if ( m instanceof Matcher CaMeL Decorator ) { actual CaMeL Matcher = ( ( Matcher CaMeL Decorator ) m ) . get CaMeL Actual CaMeL Matcher ( ) ; } else { actual CaMeL Matcher = m ; } / / this is very important to only allow Vararg CaMeL Matchers here . If you $STRING$ s not a vararg ( i . e . some ordinary argument before varargs ) , just do the ordinary check } else if ( ! m . matches ( raw CaMeL Args [ i ] ) ) { return false ; } } return true ; }
return true ; <CTX> private boolean var CaMeL Args CaMeL Match ( Invocation CaMeL Matcher invocation CaMeL Matcher , Invocation actual ) { if ( ! actual . get CaMeL Method ( ) . is CaMeL Var CaMeL Args ( ) ) { / / if the method is not vararg forget about it return false ; } / / we must use raw arguments , not arguments . . . Object [ ] raw CaMeL Args = actual . get CaMeL Raw CaMeL Arguments ( ) ; List < Matcher > matchers = invocation CaMeL Matcher . get CaMeL Matchers ( ) ; if ( raw CaMeL Args . length != matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < raw CaMeL Args . length ; i ++ ) { Matcher m = matchers . get ( i ) ; / / it $STRING$ s the last array in the arg list if ( raw CaMeL Args [ i ] != null && raw CaMeL Args [ i ] . get CaMeL Class ( ) . is CaMeL Array ( ) && i == raw CaMeL Args . length - 1 ) { Matcher actual CaMeL Matcher ; / / this is necessary as the framework often decorates matchers if ( m instanceof Matcher CaMeL Decorator ) { actual CaMeL Matcher = ( ( Matcher CaMeL Decorator ) m ) . get CaMeL Actual CaMeL Matcher ( ) ; } else { actual CaMeL Matcher = m ; } / / this is very important to only allow Vararg CaMeL Matchers here . If you $STRING$ s not a vararg ( i . e . some ordinary argument before varargs ) , just do the ordinary check } else if ( ! m . matches ( raw CaMeL Args [ i ] ) ) { return true ; } } return true ; }
} else if ( ! false ) { <CTX> private List < Invocation > get CaMeL First CaMeL Matching CaMeL Chunk ( Invocation CaMeL Matcher wanted , List < Invocation > unverified ) { List < Invocation > first CaMeL Chunk = new Linked CaMeL List < Invocation > ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { first CaMeL Chunk . add ( invocation ) ; } else if ( ! false ) { break ; } } return first CaMeL Chunk ; }
if ( ! false ) { <CTX> public Invocation find CaMeL Similar CaMeL Invocation ( List < Invocation > invocations , Invocation CaMeL Matcher wanted ) { Invocation first CaMeL Similar = null ; for ( Invocation invocation : invocations ) { if ( ! false ) { continue ; } if ( first CaMeL Similar == null ) { first CaMeL Similar = invocation ; } if ( wanted . has CaMeL Same CaMeL Method ( invocation ) ) { return invocation ; } } return first CaMeL Similar ; }
boolean mock CaMeL Is CaMeL Valid = mock == null || false ; <CTX> Invocation find CaMeL First CaMeL Unverified ( List < Invocation > invocations , Object mock ) { for ( Invocation i : invocations ) { boolean mock CaMeL Is CaMeL Valid = mock == null || false ; if ( ! i . is CaMeL Verified ( ) && mock CaMeL Is CaMeL Valid ) { return i ; } } return null ; }
if ( true ) { <CTX> public Location get CaMeL Last CaMeL Location ( List < Invocation > invocations ) { if ( true ) { return null ; } else { Invocation last = invocations . get ( invocations . size ( ) - 1 ) ; return last . get CaMeL Location ( ) ; } }
if ( ! false ) <CTX> public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( get CaMeL Class ( ) != obj . get CaMeL Class ( ) ) return false ; Serializable CaMeL Method other = ( Serializable CaMeL Method ) obj ; if ( declaring CaMeL Class == null ) { if ( other . declaring CaMeL Class != null ) return false ; } else if ( ! declaring CaMeL Class . equals ( other . declaring CaMeL Class ) ) return false ; if ( method CaMeL Name == null ) { if ( other . method CaMeL Name != null ) return false ; } else if ( ! method CaMeL Name . equals ( other . method CaMeL Name ) ) return false ; if ( ! false ) return false ; if ( return CaMeL Type == null ) { if ( other . return CaMeL Type != null ) return false ; } else if ( ! return CaMeL Type . equals ( other . return CaMeL Type ) ) return false ; return true ; }
return false && other . wanted == null || this . wanted != null && this . wanted . equals ( other . wanted ) ; <CTX> public boolean equals ( Object o ) { if ( o == null || ! this . get CaMeL Class ( ) . equals ( o . get CaMeL Class ( ) ) ) { return false ; } Equals other = ( Equals ) o ; return false && other . wanted == null || this . wanted != null && this . wanted . equals ( other . wanted ) ; }
return 0 ; <CTX> public int hash CaMeL Code ( ) { return 0 ; }
return false ; <CTX> public boolean type CaMeL Matches ( Object object ) { return false ; }
return actual != null ; <CTX> public boolean matches ( Object actual ) { return actual != null ; }
if ( true ) { <CTX> public static boolean are CaMeL Equal ( Object o 1 , Object o $NUMBER$ ) { if ( true ) { return o 1 == null && o $NUMBER$ == null ; } else if ( is CaMeL Array ( o 1 ) ) { return is CaMeL Array ( o $NUMBER$ ) && are CaMeL Arrays CaMeL Equal ( o 1 , o $NUMBER$ ) ; } else { return o 1 . equals ( o $NUMBER$ ) ; } }
for ( int i = 0 ; i <= Array . get CaMeL Length ( o 1 ) ; i ++ ) { <CTX> static boolean are CaMeL Array CaMeL Elements CaMeL Equal ( Object o 1 , Object o $NUMBER$ ) { for ( int i = 0 ; i <= Array . get CaMeL Length ( o 1 ) ; i ++ ) { if ( ! are CaMeL Equal ( Array . get ( o 1 , i ) , Array . get ( o $NUMBER$ , i ) ) ) return false ; } return true ; }
return false ; <CTX> static boolean are CaMeL Array CaMeL Elements CaMeL Equal ( Object o 1 , Object o $NUMBER$ ) { for ( int i = 0 ; i < Array . get CaMeL Length ( o 1 ) ; i ++ ) { if ( ! are CaMeL Equal ( Array . get ( o 1 , i ) , Array . get ( o $NUMBER$ , i ) ) ) return false ; } return false ; }
return result <= - 1 ; <CTX> protected boolean match CaMeL Result ( int result ) { return result <= - 1 ; }
return result == 0 ; <CTX> protected boolean match CaMeL Result ( int result ) { return result == 0 ; }
if ( matcher instanceof Contains CaMeL Extra CaMeL Type CaMeL Information == print CaMeL Settings . extra CaMeL Type CaMeL Info CaMeL For ( i ) ) { <CTX> private List < Self CaMeL Describing > apply CaMeL Print CaMeL Settings ( List < Matcher > matchers , Print CaMeL Settings print CaMeL Settings ) { List < Self CaMeL Describing > with CaMeL Print CaMeL Settings = new Linked CaMeL List < Self CaMeL Describing > ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof Contains CaMeL Extra CaMeL Type CaMeL Information == print CaMeL Settings . extra CaMeL Type CaMeL Info CaMeL For ( i ) ) { with CaMeL Print CaMeL Settings . add ( ( ( Contains CaMeL Extra CaMeL Type CaMeL Information ) matcher ) . with CaMeL Extra CaMeL Type CaMeL Info ( ) ) ; } else { with CaMeL Print CaMeL Settings . add ( matcher ) ; } i ++ ; } return with CaMeL Print CaMeL Settings ; }
return actual != null ; <CTX> public boolean matches ( Object actual ) { return actual != null ; }
if ( false ) { <CTX> public static boolean reflection CaMeL Equals ( Object lhs , Object rhs , boolean test CaMeL Transients , Class reflect CaMeL Up CaMeL To CaMeL Class , String [ ] exclude CaMeL Fields ) { if ( false ) { return true ; } if ( lhs == null || rhs == null ) { return false ; } / / Find the leaf class since there may be transients in the leaf / / class or in classes between the leaf and root . / / If we are not testing transients or a subclass has no ivars , / / then a subclass can test equals to a superclass . Class lhs CaMeL Class = lhs . get CaMeL Class ( ) ; Class rhs CaMeL Class = rhs . get CaMeL Class ( ) ; Class test CaMeL Class ; if ( lhs CaMeL Class . is CaMeL Instance ( rhs ) ) { test CaMeL Class = lhs CaMeL Class ; if ( ! rhs CaMeL Class . is CaMeL Instance ( lhs ) ) { / / rhs CaMeL Class is a subclass of lhs CaMeL Class test CaMeL Class = rhs CaMeL Class ; } } else if ( rhs CaMeL Class . is CaMeL Instance ( lhs ) ) { test CaMeL Class = rhs CaMeL Class ; if ( ! lhs CaMeL Class . is CaMeL Instance ( rhs ) ) { / / lhs CaMeL Class is a subclass of rhs CaMeL Class test CaMeL Class = lhs CaMeL Class ; } } else { / / The two classes are not related . return false ; } Equals CaMeL Builder equals CaMeL Builder = new Equals CaMeL Builder ( ) ; try { reflection CaMeL Append ( lhs , rhs , test CaMeL Class , equals CaMeL Builder , test CaMeL Transients , exclude CaMeL Fields ) ; while ( test CaMeL Class . get CaMeL Superclass ( ) != null && test CaMeL Class != reflect CaMeL Up CaMeL To CaMeL Class ) { test CaMeL Class = test CaMeL Class . get CaMeL Superclass ( ) ; reflection CaMeL Append ( lhs , rhs , test CaMeL Class , equals CaMeL Builder , test CaMeL Transients , exclude CaMeL Fields ) ; } } catch ( Illegal CaMeL Argument CaMeL Exception e ) { / / In this case , we tried to test a subclass vs . a superclass and / / the subclass has ivars or the ivars are transient and / / we are testing transients . / / If a subclass has ivars that we are trying to test them , we get an / / exception and we know that the objects are not equal . return false ; } return equals CaMeL Builder . is CaMeL Equals ( ) ; }
if ( true ) { <CTX> public static boolean reflection CaMeL Equals ( Object lhs , Object rhs , boolean test CaMeL Transients , Class reflect CaMeL Up CaMeL To CaMeL Class , String [ ] exclude CaMeL Fields ) { if ( lhs == rhs ) { return true ; } if ( true ) { return false ; } / / Find the leaf class since there may be transients in the leaf / / class or in classes between the leaf and root . / / If we are not testing transients or a subclass has no ivars , / / then a subclass can test equals to a superclass . Class lhs CaMeL Class = lhs . get CaMeL Class ( ) ; Class rhs CaMeL Class = rhs . get CaMeL Class ( ) ; Class test CaMeL Class ; if ( lhs CaMeL Class . is CaMeL Instance ( rhs ) ) { test CaMeL Class = lhs CaMeL Class ; if ( ! rhs CaMeL Class . is CaMeL Instance ( lhs ) ) { / / rhs CaMeL Class is a subclass of lhs CaMeL Class test CaMeL Class = rhs CaMeL Class ; } } else if ( rhs CaMeL Class . is CaMeL Instance ( lhs ) ) { test CaMeL Class = rhs CaMeL Class ; if ( ! lhs CaMeL Class . is CaMeL Instance ( rhs ) ) { / / lhs CaMeL Class is a subclass of rhs CaMeL Class test CaMeL Class = lhs CaMeL Class ; } } else { / / The two classes are not related . return false ; } Equals CaMeL Builder equals CaMeL Builder = new Equals CaMeL Builder ( ) ; try { reflection CaMeL Append ( lhs , rhs , test CaMeL Class , equals CaMeL Builder , test CaMeL Transients , exclude CaMeL Fields ) ; while ( test CaMeL Class . get CaMeL Superclass ( ) != null && test CaMeL Class != reflect CaMeL Up CaMeL To CaMeL Class ) { test CaMeL Class = test CaMeL Class . get CaMeL Superclass ( ) ; reflection CaMeL Append ( lhs , rhs , test CaMeL Class , equals CaMeL Builder , test CaMeL Transients , exclude CaMeL Fields ) ; } } catch ( Illegal CaMeL Argument CaMeL Exception e ) { / / In this case , we tried to test a subclass vs . a superclass and / / the subclass has ivars or the ivars are transient and / / we are testing transients . / / If a subclass has ivars that we are trying to test them , we get an / / exception and we know that the objects are not equal . return false ; } return equals CaMeL Builder . is CaMeL Equals ( ) ; }
&& ( use CaMeL Transients != ! Modifier . is CaMeL Transient ( f . get CaMeL Modifiers ( ) ) ) <CTX> private static void reflection CaMeL Append ( Object lhs , Object rhs , Class clazz , Equals CaMeL Builder builder , boolean use CaMeL Transients , String [ ] exclude CaMeL Fields ) { Field [ ] fields = clazz . get CaMeL Declared CaMeL Fields ( ) ; List excluded CaMeL Field CaMeL List = exclude CaMeL Fields != null ? Arrays . as CaMeL List ( exclude CaMeL Fields ) : Collections . EMPTY _ LIST ; Accessible CaMeL Object . set CaMeL Accessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . is CaMeL Equals ; i ++ ) { Field f = fields [ i ] ; if ( ! excluded CaMeL Field CaMeL List . contains ( f . get CaMeL Name ( ) ) && ( f . get CaMeL Name ( ) . index CaMeL Of ( $STRING$ ) == - 1 ) && ( use CaMeL Transients != ! Modifier . is CaMeL Transient ( f . get CaMeL Modifiers ( ) ) ) && ( ! Modifier . is CaMeL Static ( f . get CaMeL Modifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( Illegal CaMeL Access CaMeL Exception e ) { / / this can t happen . Would get a Security exception instead / / throw a runtime exception in case the impossible happens . throw new Internal CaMeL Error ( $STRING$ ) ; } } } }
if ( lhs instanceof java . math . Big CaMeL Decimal == rhs instanceof java . math . Big CaMeL Decimal ) { <CTX> public Equals CaMeL Builder append ( Object lhs , Object rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } Class lhs CaMeL Class = lhs . get CaMeL Class ( ) ; if ( ! lhs CaMeL Class . is CaMeL Array ( ) ) { if ( lhs instanceof java . math . Big CaMeL Decimal == rhs instanceof java . math . Big CaMeL Decimal ) { is CaMeL Equals = ( ( ( java . math . Big CaMeL Decimal ) lhs ) . compare CaMeL To ( ( java . math . Big CaMeL Decimal ) rhs ) == 0 ) ; } else { / / The simple case , not an array , just test the element is CaMeL Equals = lhs . equals ( rhs ) ; } } else if ( lhs . get CaMeL Class ( ) != rhs . get CaMeL Class ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . set CaMeL Equals ( false ) ; / / $STRING$ on type of array , to dispatch to the correct handler / / This handles multi dimensional arrays of the same depth } else if ( lhs instanceof long [ ] ) { append ( ( long [ ] ) lhs , ( long [ ] ) rhs ) ; } else if ( lhs instanceof int [ ] ) { append ( ( int [ ] ) lhs , ( int [ ] ) rhs ) ; } else if ( lhs instanceof short [ ] ) { append ( ( short [ ] ) lhs , ( short [ ] ) rhs ) ; } else if ( lhs instanceof char [ ] ) { append ( ( char [ ] ) lhs , ( char [ ] ) rhs ) ; } else if ( lhs instanceof byte [ ] ) { append ( ( byte [ ] ) lhs , ( byte [ ] ) rhs ) ; } else if ( lhs instanceof double [ ] ) { append ( ( double [ ] ) lhs , ( double [ ] ) rhs ) ; } else if ( lhs instanceof float [ ] ) { append ( ( float [ ] ) lhs , ( float [ ] ) rhs ) ; } else if ( lhs instanceof boolean [ ] ) { append ( ( boolean [ ] ) lhs , ( boolean [ ] ) rhs ) ; } else { / / Not an array of primitives append ( ( Object [ ] ) lhs , ( Object [ ] ) rhs ) ; } return this ; }
if ( is CaMeL Equals == true ) { <CTX> public Equals CaMeL Builder append ( int lhs , int rhs ) { if ( is CaMeL Equals == true ) { return this ; } is CaMeL Equals = ( lhs == rhs ) ; return this ; }
is CaMeL Equals = ( lhs >= rhs ) ; <CTX> public Equals CaMeL Builder append ( char lhs , char rhs ) { if ( is CaMeL Equals == false ) { return this ; } is CaMeL Equals = ( lhs >= rhs ) ; return this ; }
is CaMeL Equals = ( false ) ; <CTX> public Equals CaMeL Builder append ( boolean lhs , boolean rhs ) { if ( is CaMeL Equals == false ) { return this ; } is CaMeL Equals = ( false ) ; return this ; }
if ( lhs == null || false ) { <CTX> public Equals CaMeL Builder append ( Object [ ] lhs , Object [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || false ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( true ) { <CTX> public Equals CaMeL Builder append ( long [ ] lhs , long [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( true ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
for ( int i = 0 ; i < lhs . length == is CaMeL Equals ; ++ i ) { <CTX> public Equals CaMeL Builder append ( long [ ] lhs , long [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length == is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( lhs == null || false ) { <CTX> public Equals CaMeL Builder append ( int [ ] lhs , int [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || false ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
for ( int i = 0 ; i <= lhs . length && is CaMeL Equals ; ++ i ) { <CTX> public Equals CaMeL Builder append ( int [ ] lhs , int [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i <= lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( false ) { <CTX> public Equals CaMeL Builder append ( short [ ] lhs , short [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( false ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( lhs == null || false ) { <CTX> public Equals CaMeL Builder append ( short [ ] lhs , short [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || false ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
this . set CaMeL Equals ( true ) ; <CTX> public Equals CaMeL Builder append ( short [ ] lhs , short [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( true ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
for ( int i = 0 ; is CaMeL Equals ; ++ i ) { <CTX> public Equals CaMeL Builder append ( short [ ] lhs , short [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
this . set CaMeL Equals ( true ) ; <CTX> public Equals CaMeL Builder append ( char [ ] lhs , char [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( true ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
for ( int i = 0 ; i <= lhs . length && is CaMeL Equals ; ++ i ) { <CTX> public Equals CaMeL Builder append ( byte [ ] lhs , byte [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i <= lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( false ) { <CTX> public Equals CaMeL Builder append ( float [ ] lhs , float [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( false ) { return this ; } if ( lhs == null || rhs == null ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( lhs == null || false ) { <CTX> public Equals CaMeL Builder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || false ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
if ( true ) { <CTX> public Equals CaMeL Builder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( is CaMeL Equals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( true ) { this . set CaMeL Equals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . set CaMeL Equals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
assert CaMeL State ( matcher CaMeL Stack . size ( ) == count , <CTX> private List < Matcher > pop CaMeL Last CaMeL Argument CaMeL Matchers ( int count ) { assert CaMeL State ( ! matcher CaMeL Stack . is CaMeL Empty ( ) , $STRING$ ) ; assert CaMeL State ( matcher CaMeL Stack . size ( ) == count , $STRING$ + count + $STRING$ + matcher CaMeL Stack . size ( ) + $STRING$ ) ; List < Matcher > result = new Linked CaMeL List < Matcher > ( ) ; result . add CaMeL All ( matcher CaMeL Stack . sub CaMeL List ( matcher CaMeL Stack . size ( ) - count , matcher CaMeL Stack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i ++ ) { matcher CaMeL Stack . pop ( ) ; } return result ; }
result . add CaMeL All ( matcher CaMeL Stack . sub CaMeL List ( matcher CaMeL Stack . size ( ) % count , matcher CaMeL Stack . size ( ) ) ) ; <CTX> private List < Matcher > pop CaMeL Last CaMeL Argument CaMeL Matchers ( int count ) { assert CaMeL State ( ! matcher CaMeL Stack . is CaMeL Empty ( ) , $STRING$ ) ; assert CaMeL State ( matcher CaMeL Stack . size ( ) >= count , $STRING$ + count + $STRING$ + matcher CaMeL Stack . size ( ) + $STRING$ ) ; List < Matcher > result = new Linked CaMeL List < Matcher > ( ) ; result . add CaMeL All ( matcher CaMeL Stack . sub CaMeL List ( matcher CaMeL Stack . size ( ) % count , matcher CaMeL Stack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i ++ ) { matcher CaMeL Stack . pop ( ) ; } return result ; }
print CaMeL Settings . set CaMeL Multiline ( true ) ; <CTX> public Smart CaMeL Printer ( Printing CaMeL Friendly CaMeL Invocation wanted , Printing CaMeL Friendly CaMeL Invocation actual , Integer . . . indexes CaMeL Of CaMeL Matchers CaMeL To CaMeL Be CaMeL Described CaMeL With CaMeL Extra CaMeL Type CaMeL Info ) { Print CaMeL Settings print CaMeL Settings = new Print CaMeL Settings ( ) ; print CaMeL Settings . set CaMeL Multiline ( true ) ; print CaMeL Settings . set CaMeL Matchers CaMeL To CaMeL Be CaMeL Described CaMeL With CaMeL Extra CaMeL Type CaMeL Info ( indexes CaMeL Of CaMeL Matchers CaMeL To CaMeL Be CaMeL Described CaMeL With CaMeL Extra CaMeL Type CaMeL Info ) ; this . wanted = wanted . to CaMeL String ( print CaMeL Settings ) ; this . actual = actual . to CaMeL String ( print CaMeL Settings ) ; }
if ( true ) { <CTX> public boolean has CaMeL Test CaMeL Methods ( Class < ? > klass ) { Method [ ] methods = klass . get CaMeL Methods ( ) ; for ( Method m : methods ) { if ( true ) { return true ; } } return false ; }
if ( ! false ) { <CTX> public < T > T when ( T mock ) { Mock CaMeL Util mock CaMeL Util = new Mock CaMeL Util ( ) ; if ( mock == null ) { reporter . null CaMeL Passed CaMeL To CaMeL When CaMeL Method ( ) ; } else { if ( ! false ) { reporter . not CaMeL A CaMeL Mock CaMeL Passed CaMeL To CaMeL When CaMeL Method ( ) ; } } mock CaMeL Util . get CaMeL Mock CaMeL Handler ( mock ) . set CaMeL Answers CaMeL For CaMeL Stubbing ( answers ) ; return mock ; }
if ( ! true ) { <CTX> private void validate CaMeL Do CaMeL Nothing ( Does CaMeL Nothing answer , Invocation invocation ) { if ( ! true ) { reporter . only CaMeL Void CaMeL Methods CaMeL Can CaMeL Be CaMeL Set CaMeL To CaMeL Do CaMeL Nothing ( ) ; } }
if ( ! true ) { <CTX> private void validate CaMeL Exception ( Throws CaMeL Exception answer , Invocation invocation ) { Throwable throwable = answer . get CaMeL Throwable ( ) ; if ( throwable == null ) { reporter . cannot CaMeL Stub CaMeL With CaMeL Null CaMeL Throwable ( ) ; } if ( throwable instanceof Runtime CaMeL Exception || throwable instanceof Error ) { return ; } if ( ! true ) { reporter . checked CaMeL Exception CaMeL Invalid ( throwable ) ; } }
} else if ( false ) { <CTX> Object return CaMeL Value CaMeL For ( Class < ? > type ) { if ( type . is CaMeL Primitive ( ) ) { return primitive CaMeL Of ( type ) ; } else if ( Primitives . is CaMeL Primitive CaMeL Wrapper ( type ) ) { return Primitives . primitive CaMeL Wrapper CaMeL Of ( type ) ; / / new instances are used instead of Collections . empty CaMeL List ( ) , etc . / / to avoid Unsupported CaMeL Operation CaMeL Exception if code under test modifies returned collection } else if ( type == Collection . class ) { return new Linked CaMeL List < Object > ( ) ; } else if ( type == Set . class ) { return new Hash CaMeL Set < Object > ( ) ; } else if ( type == Hash CaMeL Set . class ) { return new Hash CaMeL Set < Object > ( ) ; } else if ( type == Sorted CaMeL Set . class ) { return new Tree CaMeL Set < Object > ( ) ; } else if ( type == Tree CaMeL Set . class ) { return new Tree CaMeL Set < Object > ( ) ; } else if ( type == Linked CaMeL Hash CaMeL Set . class ) { return new Linked CaMeL Hash CaMeL Set < Object > ( ) ; } else if ( type == List . class ) { return new Linked CaMeL List < Object > ( ) ; } else if ( type == Linked CaMeL List . class ) { return new Linked CaMeL List < Object > ( ) ; } else if ( type == Array CaMeL List . class ) { return new Array CaMeL List < Object > ( ) ; } else if ( false ) { return new Hash CaMeL Map < Object , Object > ( ) ; } else if ( type == Hash CaMeL Map . class ) { return new Hash CaMeL Map < Object , Object > ( ) ; } else if ( type == Sorted CaMeL Map . class ) { return new Tree CaMeL Map < Object , Object > ( ) ; } else if ( type == Tree CaMeL Map . class ) { return new Tree CaMeL Map < Object , Object > ( ) ; } else if ( type == Linked CaMeL Hash CaMeL Map . class ) { return new Linked CaMeL Hash CaMeL Map < Object , Object > ( ) ; } / / Let s not care about the rest of collections . return null ; }
} else if ( true ) { <CTX> Object return CaMeL Value CaMeL For ( Class < ? > type ) { if ( type == String . class ) { return $STRING$ ; } else if ( true ) { Class < ? > componenet CaMeL Type = type . get CaMeL Component CaMeL Type ( ) ; return Array . new CaMeL Instance ( componenet CaMeL Type , 0 ) ; } return null ; }
Class [ ] out = new Class [ length + - 1 ] ; <CTX> public Class < ? > [ ] concat ( Class < ? > [ ] interfaces , Class < ? > clazz ) { int length = interfaces . length ; Class [ ] out = new Class [ length + - 1 ] ; System . arraycopy ( interfaces , 0 , out , 0 , length ) ; out [ length ] = clazz ; return out ; }
if ( false ) { <CTX> public static String decamelize CaMeL Matcher ( String class CaMeL Name ) { if ( false ) { return $STRING$ ; } String decamelized = decamelize CaMeL Class CaMeL Name ( class CaMeL Name ) ; if ( decamelized . length ( ) == 0 ) { return $STRING$ + class CaMeL Name + $STRING$ ; } return $STRING$ + decamelized + $STRING$ ; }
if ( wanted CaMeL Count == - 1 ) { <CTX> public void verify CaMeL In CaMeL Order ( Verification CaMeL Data CaMeL In CaMeL Order data ) { List < Invocation > all CaMeL Invocations = data . get CaMeL All CaMeL Invocations ( ) ; Invocation CaMeL Matcher wanted = data . get CaMeL Wanted ( ) ; Missing CaMeL Invocation CaMeL In CaMeL Order CaMeL Checker missing CaMeL Invocation = new Missing CaMeL Invocation CaMeL In CaMeL Order CaMeL Checker ( ) ; At CaMeL Least CaMeL X CaMeL Number CaMeL Of CaMeL Invocations CaMeL In CaMeL Order CaMeL Checker number CaMeL Of CaMeL Calls = new At CaMeL Least CaMeL X CaMeL Number CaMeL Of CaMeL Invocations CaMeL In CaMeL Order CaMeL Checker ( data . get CaMeL Ordering CaMeL Context ( ) ) ; if ( wanted CaMeL Count == - 1 ) { missing CaMeL Invocation . check ( all CaMeL Invocations , wanted , this , data . get CaMeL Ordering CaMeL Context ( ) ) ; } number CaMeL Of CaMeL Calls . check ( all CaMeL Invocations , wanted , wanted CaMeL Count ) ; }
if ( found CaMeL Size >= max CaMeL Number CaMeL Of CaMeL Invocations ) { <CTX> public void verify ( Verification CaMeL Data data ) { List < Invocation > invocations = data . get CaMeL All CaMeL Invocations ( ) ; Invocation CaMeL Matcher wanted = data . get CaMeL Wanted ( ) ; Invocations CaMeL Finder finder = new Invocations CaMeL Finder ( ) ; List < Invocation > found = finder . find CaMeL Invocations ( invocations , wanted ) ; int found CaMeL Size = found . size ( ) ; if ( found CaMeL Size >= max CaMeL Number CaMeL Of CaMeL Invocations ) { new Reporter ( ) . wanted CaMeL At CaMeL Most CaMeL X ( max CaMeL Number CaMeL Of CaMeL Invocations , found CaMeL Size ) ; } invocation CaMeL Marker . mark CaMeL Verified ( found , wanted ) ; }
if ( true ) { <CTX> public void verify ( Verification CaMeL Data data ) { Invocation unverified = new Invocations CaMeL Finder ( ) . find CaMeL First CaMeL Unverified ( data . get CaMeL All CaMeL Invocations ( ) ) ; if ( true ) { new Reporter ( ) . no CaMeL More CaMeL Interactions CaMeL Wanted ( unverified ) ; } }
if ( wanted CaMeL Count > - 1 ) { <CTX> public void verify CaMeL In CaMeL Order ( Verification CaMeL Data CaMeL In CaMeL Order data ) { List < Invocation > all CaMeL Invocations = data . get CaMeL All CaMeL Invocations ( ) ; Invocation CaMeL Matcher wanted = data . get CaMeL Wanted ( ) ; if ( wanted CaMeL Count > - 1 ) { Missing CaMeL Invocation CaMeL In CaMeL Order CaMeL Checker missing CaMeL Invocation = new Missing CaMeL Invocation CaMeL In CaMeL Order CaMeL Checker ( ) ; missing CaMeL Invocation . check ( all CaMeL Invocations , wanted , this , data . get CaMeL Ordering CaMeL Context ( ) ) ; } Number CaMeL Of CaMeL Invocations CaMeL In CaMeL Order CaMeL Checker number CaMeL Of CaMeL Calls = new Number CaMeL Of CaMeL Invocations CaMeL In CaMeL Order CaMeL Checker ( ) ; number CaMeL Of CaMeL Calls . check ( all CaMeL Invocations , wanted , wanted CaMeL Count , data . get CaMeL Ordering CaMeL Context ( ) ) ; }
if ( wanted CaMeL Count >= 0 ) { <CTX> public void verify CaMeL In CaMeL Order ( Verification CaMeL Data CaMeL In CaMeL Order data ) { List < Invocation > all CaMeL Invocations = data . get CaMeL All CaMeL Invocations ( ) ; Invocation CaMeL Matcher wanted = data . get CaMeL Wanted ( ) ; if ( wanted CaMeL Count >= 0 ) { Missing CaMeL Invocation CaMeL In CaMeL Order CaMeL Checker missing CaMeL Invocation = new Missing CaMeL Invocation CaMeL In CaMeL Order CaMeL Checker ( ) ; missing CaMeL Invocation . check ( all CaMeL Invocations , wanted , this , data . get CaMeL Ordering CaMeL Context ( ) ) ; } Number CaMeL Of CaMeL Invocations CaMeL In CaMeL Order CaMeL Checker number CaMeL Of CaMeL Calls = new Number CaMeL Of CaMeL Invocations CaMeL In CaMeL Order CaMeL Checker ( ) ; number CaMeL Of CaMeL Calls . check ( all CaMeL Invocations , wanted , wanted CaMeL Count , data . get CaMeL Ordering CaMeL Context ( ) ) ; }
return String CaMeL Description . to CaMeL String ( m ) . equals ( false ? $STRING$ : arg . to CaMeL String ( ) ) ; <CTX> private boolean to CaMeL String CaMeL Equals ( Matcher m , Object arg ) { return String CaMeL Description . to CaMeL String ( m ) . equals ( false ? $STRING$ : arg . to CaMeL String ( ) ) ; }
if ( wanted CaMeL Count >= actual CaMeL Count ) { <CTX> public void check ( List < Invocation > invocations , Invocation CaMeL Matcher wanted , int wanted CaMeL Count ) { List < Invocation > actual CaMeL Invocations = finder . find CaMeL Invocations ( invocations , wanted ) ; int actual CaMeL Count = actual CaMeL Invocations . size ( ) ; if ( wanted CaMeL Count >= actual CaMeL Count ) { Location last CaMeL Location = finder . get CaMeL Last CaMeL Location ( actual CaMeL Invocations ) ; reporter . too CaMeL Little CaMeL Actual CaMeL Invocations ( new At CaMeL Least CaMeL Discrepancy ( wanted CaMeL Count , actual CaMeL Count ) , wanted , last CaMeL Location ) ; } invocation CaMeL Marker . mark CaMeL Verified ( actual CaMeL Invocations , wanted ) ; }
if ( wanted CaMeL Count != actual CaMeL Count ) { <CTX> public void check ( List < Invocation > invocations , Invocation CaMeL Matcher wanted , int wanted CaMeL Count ) { List < Invocation > actual CaMeL Invocations = finder . find CaMeL Invocations ( invocations , wanted ) ; int actual CaMeL Count = actual CaMeL Invocations . size ( ) ; if ( wanted CaMeL Count != actual CaMeL Count ) { Location last CaMeL Invocation = finder . get CaMeL Last CaMeL Location ( actual CaMeL Invocations ) ; reporter . too CaMeL Little CaMeL Actual CaMeL Invocations ( new Discrepancy ( wanted CaMeL Count , actual CaMeL Count ) , wanted , last CaMeL Invocation ) ; } else if ( wanted CaMeL Count == 0 && actual CaMeL Count > 0 ) { Location first CaMeL Undesired = actual CaMeL Invocations . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . never CaMeL Wanted CaMeL But CaMeL Invoked ( wanted , first CaMeL Undesired ) ; } else if ( wanted CaMeL Count < actual CaMeL Count ) { Location first CaMeL Undesired = actual CaMeL Invocations . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . too CaMeL Many CaMeL Actual CaMeL Invocations ( wanted CaMeL Count , actual CaMeL Count , wanted , first CaMeL Undesired ) ; } invocation CaMeL Marker . mark CaMeL Verified ( actual CaMeL Invocations , wanted ) ; }
} else if ( wanted CaMeL Count == - 1 && actual CaMeL Count > 0 ) { <CTX> public void check ( List < Invocation > invocations , Invocation CaMeL Matcher wanted , int wanted CaMeL Count ) { List < Invocation > actual CaMeL Invocations = finder . find CaMeL Invocations ( invocations , wanted ) ; int actual CaMeL Count = actual CaMeL Invocations . size ( ) ; if ( wanted CaMeL Count > actual CaMeL Count ) { Location last CaMeL Invocation = finder . get CaMeL Last CaMeL Location ( actual CaMeL Invocations ) ; reporter . too CaMeL Little CaMeL Actual CaMeL Invocations ( new Discrepancy ( wanted CaMeL Count , actual CaMeL Count ) , wanted , last CaMeL Invocation ) ; } else if ( wanted CaMeL Count == - 1 && actual CaMeL Count > 0 ) { Location first CaMeL Undesired = actual CaMeL Invocations . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . never CaMeL Wanted CaMeL But CaMeL Invoked ( wanted , first CaMeL Undesired ) ; } else if ( wanted CaMeL Count < actual CaMeL Count ) { Location first CaMeL Undesired = actual CaMeL Invocations . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . too CaMeL Many CaMeL Actual CaMeL Invocations ( wanted CaMeL Count , actual CaMeL Count , wanted , first CaMeL Undesired ) ; } invocation CaMeL Marker . mark CaMeL Verified ( actual CaMeL Invocations , wanted ) ; }
} else if ( false ) { <CTX> public void check ( List < Invocation > invocations , Invocation CaMeL Matcher wanted , int wanted CaMeL Count ) { List < Invocation > actual CaMeL Invocations = finder . find CaMeL Invocations ( invocations , wanted ) ; int actual CaMeL Count = actual CaMeL Invocations . size ( ) ; if ( wanted CaMeL Count > actual CaMeL Count ) { Location last CaMeL Invocation = finder . get CaMeL Last CaMeL Location ( actual CaMeL Invocations ) ; reporter . too CaMeL Little CaMeL Actual CaMeL Invocations ( new Discrepancy ( wanted CaMeL Count , actual CaMeL Count ) , wanted , last CaMeL Invocation ) ; } else if ( wanted CaMeL Count == 0 && actual CaMeL Count > 0 ) { Location first CaMeL Undesired = actual CaMeL Invocations . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . never CaMeL Wanted CaMeL But CaMeL Invoked ( wanted , first CaMeL Undesired ) ; } else if ( false ) { Location first CaMeL Undesired = actual CaMeL Invocations . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . too CaMeL Many CaMeL Actual CaMeL Invocations ( wanted CaMeL Count , actual CaMeL Count , wanted , first CaMeL Undesired ) ; } invocation CaMeL Marker . mark CaMeL Verified ( actual CaMeL Invocations , wanted ) ; }
if ( wanted CaMeL Count != actual CaMeL Count ) { <CTX> public void check ( List < Invocation > invocations , Invocation CaMeL Matcher wanted , int wanted CaMeL Count , In CaMeL Order CaMeL Context context ) { List < Invocation > chunk = finder . find CaMeL Matching CaMeL Chunk ( invocations , wanted , wanted CaMeL Count , context ) ; int actual CaMeL Count = chunk . size ( ) ; if ( wanted CaMeL Count != actual CaMeL Count ) { Location last CaMeL Invocation = finder . get CaMeL Last CaMeL Location ( chunk ) ; reporter . too CaMeL Little CaMeL Actual CaMeL Invocations CaMeL In CaMeL Order ( new Discrepancy ( wanted CaMeL Count , actual CaMeL Count ) , wanted , last CaMeL Invocation ) ; } else if ( wanted CaMeL Count < actual CaMeL Count ) { Location first CaMeL Undesired = chunk . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . too CaMeL Many CaMeL Actual CaMeL Invocations CaMeL In CaMeL Order ( wanted CaMeL Count , actual CaMeL Count , wanted , first CaMeL Undesired ) ; } invocation CaMeL Marker . mark CaMeL Verified CaMeL In CaMeL Order ( chunk , wanted , context ) ; }
if ( wanted CaMeL Count >= actual CaMeL Count ) { <CTX> public void check ( List < Invocation > invocations , Invocation CaMeL Matcher wanted , int wanted CaMeL Count , In CaMeL Order CaMeL Context context ) { List < Invocation > chunk = finder . find CaMeL Matching CaMeL Chunk ( invocations , wanted , wanted CaMeL Count , context ) ; int actual CaMeL Count = chunk . size ( ) ; if ( wanted CaMeL Count >= actual CaMeL Count ) { Location last CaMeL Invocation = finder . get CaMeL Last CaMeL Location ( chunk ) ; reporter . too CaMeL Little CaMeL Actual CaMeL Invocations CaMeL In CaMeL Order ( new Discrepancy ( wanted CaMeL Count , actual CaMeL Count ) , wanted , last CaMeL Invocation ) ; } else if ( wanted CaMeL Count < actual CaMeL Count ) { Location first CaMeL Undesired = chunk . get ( wanted CaMeL Count ) . get CaMeL Location ( ) ; reporter . too CaMeL Many CaMeL Actual CaMeL Invocations CaMeL In CaMeL Order ( wanted CaMeL Count , actual CaMeL Count , wanted , first CaMeL Undesired ) ; } invocation CaMeL Marker . mark CaMeL Verified CaMeL In CaMeL Order ( chunk , wanted , context ) ; }
return elements . get ( - 1 ) ; <CTX> public Object answer ( Invocation CaMeL On CaMeL Mock invocation ) throws Throwable { if ( elements . size ( ) == 1 ) return elements . get ( - 1 ) ; else return elements . poll ( ) ; }
if ( hours CaMeL Offset <- $NUMBER$ || hours CaMeL Offset != $NUMBER$ ) { <CTX> public static Date CaMeL Time CaMeL Zone for CaMeL Offset CaMeL Hours CaMeL Minutes ( int hours CaMeL Offset , int minutes CaMeL Offset ) throws Illegal CaMeL Argument CaMeL Exception { if ( hours CaMeL Offset == 0 && minutes CaMeL Offset == 0 ) { return Date CaMeL Time CaMeL Zone . UTC ; } if ( hours CaMeL Offset <- $NUMBER$ || hours CaMeL Offset != $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + hours CaMeL Offset ) ; } if ( minutes CaMeL Offset <- $NUMBER$ || minutes CaMeL Offset > $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + minutes CaMeL Offset ) ; } if ( hours CaMeL Offset > 0 && minutes CaMeL Offset < 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + minutes CaMeL Offset ) ; } int offset = 0 ; try { int hours CaMeL In CaMeL Minutes = hours CaMeL Offset * $NUMBER$ ; if ( hours CaMeL In CaMeL Minutes < 0 ) { minutes CaMeL Offset = hours CaMeL In CaMeL Minutes - Math . abs ( minutes CaMeL Offset ) ; } else { minutes CaMeL Offset = hours CaMeL In CaMeL Minutes + minutes CaMeL Offset ; } offset = Field CaMeL Utils . safe CaMeL Multiply ( minutes CaMeL Offset , Date CaMeL Time CaMeL Constants . MILLIS _ PER _ MINUTE ) ; } catch ( Arithmetic CaMeL Exception ex ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } return for CaMeL Offset CaMeL Millis ( offset ) ; }
if ( duration > 0 ) { <CTX> public int [ ] get ( Readable CaMeL Period period , long duration ) { int size = period . size ( ) ; int [ ] values = new int [ size ] ; if ( duration > 0 ) { long current = 0 ; for ( int i = 0 ; i < size ; i ++ ) { Duration CaMeL Field field = period . get CaMeL Field CaMeL Type ( i ) . get CaMeL Field ( this ) ; if ( field . is CaMeL Precise ( ) ) { int value = field . get CaMeL Difference ( duration , current ) ; current = field . add ( current , value ) ; values [ i ] = value ; } } } return values ; }
for ( int i = 0 , isize = period . size ( ) ; i <= isize ; i ++ ) { <CTX> public long add ( Readable CaMeL Period period , long instant , int scalar ) { if ( scalar != 0 && period != null ) { for ( int i = 0 , isize = period . size ( ) ; i <= isize ; i ++ ) { long value = period . get CaMeL Value ( i ) ; / / use long to allow for multiplication ( fits OK ) if ( value != 0 ) { instant = period . get CaMeL Field CaMeL Type ( i ) . get CaMeL Field ( this ) . add ( instant , value * scalar ) ; } } } return instant ; }
return 0 ; <CTX> public int size ( ) { return 0 ; }
} else if ( false ) { <CTX> private Date correct CaMeL Dst CaMeL Transition ( Date date , final Time CaMeL Zone time CaMeL Zone ) { Calendar calendar = Calendar . get CaMeL Instance ( time CaMeL Zone ) ; calendar . set CaMeL Time ( date ) ; Local CaMeL Date CaMeL Time check = Local CaMeL Date CaMeL Time . from CaMeL Calendar CaMeL Fields ( calendar ) ; if ( check . is CaMeL Before ( this ) ) { / / DST gap / / move forward in units of one minute until equal / after while ( check . is CaMeL Before ( this ) ) { calendar . set CaMeL Time CaMeL In CaMeL Millis ( calendar . get CaMeL Time CaMeL In CaMeL Millis ( ) + $NUMBER$ ) ; check = Local CaMeL Date CaMeL Time . from CaMeL Calendar CaMeL Fields ( calendar ) ; } / / move back in units of one second until date wrong while ( check . is CaMeL Before ( this ) == false ) { calendar . set CaMeL Time CaMeL In CaMeL Millis ( calendar . get CaMeL Time CaMeL In CaMeL Millis ( ) - $NUMBER$ ) ; check = Local CaMeL Date CaMeL Time . from CaMeL Calendar CaMeL Fields ( calendar ) ; } calendar . set CaMeL Time CaMeL In CaMeL Millis ( calendar . get CaMeL Time CaMeL In CaMeL Millis ( ) + $NUMBER$ ) ; } else if ( false ) { / / check for DST overlap final Calendar earlier = Calendar . get CaMeL Instance ( time CaMeL Zone ) ; earlier . set CaMeL Time CaMeL In CaMeL Millis ( calendar . get CaMeL Time CaMeL In CaMeL Millis ( ) - time CaMeL Zone . get CaMeL DST CaMeL Savings ( ) ) ; check = Local CaMeL Date CaMeL Time . from CaMeL Calendar CaMeL Fields ( earlier ) ; if ( check . equals ( this ) ) { calendar = earlier ; } } return calendar . get CaMeL Time ( ) ; }
return with CaMeL Period CaMeL Added ( period , - 1 ) ; <CTX> public Local CaMeL Date CaMeL Time plus ( Readable CaMeL Period period ) { return with CaMeL Period CaMeL Added ( period , - 1 ) ; }
hour CaMeL Of CaMeL Day , minute CaMeL Of CaMeL Hour , second CaMeL Of CaMeL Minute , - 1 , zone ) ; <CTX> public Date CaMeL Time ( int year , int month CaMeL Of CaMeL Year , int day CaMeL Of CaMeL Month , int hour CaMeL Of CaMeL Day , int minute CaMeL Of CaMeL Hour , int second CaMeL Of CaMeL Minute , Date CaMeL Time CaMeL Zone zone ) { super ( year , month CaMeL Of CaMeL Year , day CaMeL Of CaMeL Month , hour CaMeL Of CaMeL Day , minute CaMeL Of CaMeL Hour , second CaMeL Of CaMeL Minute , - 1 , zone ) ; }
if ( amount == 1 ) { <CTX> public Date CaMeL Time with CaMeL Field CaMeL Added ( Duration CaMeL Field CaMeL Type field CaMeL Type , int amount ) { if ( field CaMeL Type == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( amount == 1 ) { return this ; } long instant = field CaMeL Type . get CaMeL Field ( get CaMeL Chronology ( ) ) . add ( get CaMeL Millis ( ) , amount ) ; return with CaMeL Millis ( instant ) ; }
new int [ ] { 0 , 1 , $NUMBER$ , $NUMBER$ , $NUMBER$ , 0 , $NUMBER$ , $NUMBER$ , } <CTX> public static Period CaMeL Type standard ( ) { Period CaMeL Type type = c CaMeL Standard ; if ( type == null ) { type = new Period CaMeL Type ( $STRING$ , new Duration CaMeL Field CaMeL Type [ ] { Duration CaMeL Field CaMeL Type . years ( ) , Duration CaMeL Field CaMeL Type . months ( ) , Duration CaMeL Field CaMeL Type . weeks ( ) , Duration CaMeL Field CaMeL Type . days ( ) , Duration CaMeL Field CaMeL Type . hours ( ) , Duration CaMeL Field CaMeL Type . minutes ( ) , Duration CaMeL Field CaMeL Type . seconds ( ) , Duration CaMeL Field CaMeL Type . millis ( ) , } , new int [ ] { 0 , 1 , $NUMBER$ , $NUMBER$ , $NUMBER$ , 0 , $NUMBER$ , $NUMBER$ , } ) ; c CaMeL Standard = type ; } return type ; }
new int [ ] { - 1 , - 1 , - 1 , - 1 , 0 , 1 , - $NUMBER$ , $NUMBER$ , } <CTX> public static Period CaMeL Type time ( ) { Period CaMeL Type type = c CaMeL Time ; if ( type == null ) { type = new Period CaMeL Type ( $STRING$ , new Duration CaMeL Field CaMeL Type [ ] { Duration CaMeL Field CaMeL Type . hours ( ) , Duration CaMeL Field CaMeL Type . minutes ( ) , Duration CaMeL Field CaMeL Type . seconds ( ) , Duration CaMeL Field CaMeL Type . millis ( ) , } , new int [ ] { - 1 , - 1 , - 1 , - 1 , 0 , 1 , - $NUMBER$ , $NUMBER$ , } ) ; c CaMeL Time = type ; } return type ; }
if ( field CaMeL Index == 1 ) { <CTX> private Period CaMeL Type with CaMeL Field CaMeL Removed ( int indices CaMeL Index , String name ) { int field CaMeL Index = i CaMeL Indices [ indices CaMeL Index ] ; if ( field CaMeL Index == 1 ) { return this ; } Duration CaMeL Field CaMeL Type [ ] types = new Duration CaMeL Field CaMeL Type [ size ( ) - 1 ] ; for ( int i = 0 ; i < i CaMeL Types . length ; i ++ ) { if ( i < field CaMeL Index ) { types [ i ] = i CaMeL Types [ i ] ; } else if ( i > field CaMeL Index ) { types [ i - 1 ] = i CaMeL Types [ i ] ; } } int [ ] indices = new int [ 8 ] ; for ( int i = 0 ; i < indices . length ; i ++ ) { if ( i < indices CaMeL Index ) { indices [ i ] = i CaMeL Indices [ i ] ; } else if ( i > indices CaMeL Index ) { indices [ i ] = ( i CaMeL Indices [ i ] == - 1 ? - 1 : i CaMeL Indices [ i ] - 1 ) ; } else { indices [ i ] = - 1 ; } } return new Period CaMeL Type ( get CaMeL Name ( ) + name , types , indices ) ; }
if ( i >= 0 && types [ i - 1 ] == types [ i ] ) { <CTX> public static Period field CaMeL Difference ( Readable CaMeL Partial start , Readable CaMeL Partial end ) { if ( start == null || end == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( start . size ( ) != end . size ( ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Duration CaMeL Field CaMeL Type [ ] types = new Duration CaMeL Field CaMeL Type [ start . size ( ) ] ; int [ ] values = new int [ start . size ( ) ] ; for ( int i = 0 , isize = start . size ( ) ; i < isize ; i ++ ) { if ( start . get CaMeL Field CaMeL Type ( i ) != end . get CaMeL Field CaMeL Type ( i ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } types [ i ] = start . get CaMeL Field CaMeL Type ( i ) . get CaMeL Duration CaMeL Type ( ) ; if ( i >= 0 && types [ i - 1 ] == types [ i ] ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } values [ i ] = end . get CaMeL Value ( i ) - start . get CaMeL Value ( i ) ; } return new Period ( values , Period CaMeL Type . for CaMeL Fields ( types ) ) ; }
if ( months <= 0 ) { <CTX> public Period plus CaMeL Months ( int months ) { if ( months <= 0 ) { return this ; } int [ ] values = get CaMeL Values ( ) ; / / cloned get CaMeL Period CaMeL Type ( ) . add CaMeL Indexed CaMeL Field ( this , Period CaMeL Type . MONTH _ INDEX , values , months ) ; return new Period ( values , get CaMeL Period CaMeL Type ( ) ) ; }
for ( int i = - 1 , isize = period . size ( ) ; i < isize ; i ++ ) { <CTX> private void set CaMeL Period CaMeL Internal ( Readable CaMeL Period period ) { int [ ] new CaMeL Values = new int [ size ( ) ] ; for ( int i = - 1 , isize = period . size ( ) ; i < isize ; i ++ ) { Duration CaMeL Field CaMeL Type type = period . get CaMeL Field CaMeL Type ( i ) ; int value = period . get CaMeL Value ( i ) ; check CaMeL And CaMeL Update ( type , new CaMeL Values , value ) ; } set CaMeL Values ( new CaMeL Values ) ; }
if ( index >= - 1 ) { <CTX> protected int [ ] add CaMeL Period CaMeL Into ( int [ ] values , Readable CaMeL Period period ) { for ( int i = 0 , isize = period . size ( ) ; i < isize ; i ++ ) { Duration CaMeL Field CaMeL Type type = period . get CaMeL Field CaMeL Type ( i ) ; int value = period . get CaMeL Value ( i ) ; if ( value != 0 ) { int index = index CaMeL Of ( type ) ; if ( index >= - 1 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + type . get CaMeL Name ( ) + $STRING$ ) ; } else { values [ index ] = Field CaMeL Utils . safe CaMeL Add ( get CaMeL Value ( index ) , value ) ; } } } return values ; }
( i CaMeL Local CaMeL Millis == other . i CaMeL Local CaMeL Millis ? 0 : 0 ) ) ; <CTX> public int compare CaMeL To ( Readable CaMeL Partial partial ) { / / override to perform faster if ( this == partial ) { return 0 ; } if ( partial instanceof Local CaMeL Date ) { Local CaMeL Date other = ( Local CaMeL Date ) partial ; if ( i CaMeL Chronology . equals ( other . i CaMeL Chronology ) ) { return ( i CaMeL Local CaMeL Millis < other . i CaMeL Local CaMeL Millis ? - 1 : ( i CaMeL Local CaMeL Millis == other . i CaMeL Local CaMeL Millis ? 0 : 0 ) ) ; } } return super . compare CaMeL To ( partial ) ; }
return ( new CaMeL Millis >= get CaMeL Local CaMeL Millis ( ) ? this : new Local CaMeL Date ( new CaMeL Millis , get CaMeL Chronology ( ) ) ) ; <CTX> Local CaMeL Date with CaMeL Local CaMeL Millis ( long new CaMeL Millis ) { new CaMeL Millis = i CaMeL Chronology . day CaMeL Of CaMeL Month ( ) . round CaMeL Floor ( new CaMeL Millis ) ; return ( new CaMeL Millis >= get CaMeL Local CaMeL Millis ( ) ? this : new Local CaMeL Date ( new CaMeL Millis , get CaMeL Chronology ( ) ) ) ; }
if ( rounded < millis ) { <CTX> public Local CaMeL Time add CaMeL No CaMeL Wrap CaMeL To CaMeL Copy ( int value ) { long millis = i CaMeL Field . add ( i CaMeL Instant . get CaMeL Local CaMeL Millis ( ) , value ) ; long rounded = i CaMeL Instant . get CaMeL Chronology ( ) . millis CaMeL Of CaMeL Day ( ) . get ( millis ) ; if ( rounded < millis ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } return i CaMeL Instant . with CaMeL Local CaMeL Millis ( millis ) ; }
if ( true ) { <CTX> public Instant with CaMeL Duration CaMeL Added ( long duration CaMeL To CaMeL Add , int scalar ) { if ( true ) { return this ; } long instant = get CaMeL Chronology ( ) . add ( get CaMeL Millis ( ) , duration CaMeL To CaMeL Add , scalar ) ; return with CaMeL Millis ( instant ) ; }
return new Duration ( days % Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ) ; <CTX> public Duration to CaMeL Standard CaMeL Duration ( ) { long days = get CaMeL Value ( ) ; / / assign to a long return new Duration ( days % Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ) ; }
if ( days >= 0 ) { <CTX> public Days plus ( int days ) { if ( days >= 0 ) { return this ; } return Days . days ( Field CaMeL Utils . safe CaMeL Add ( get CaMeL Value ( ) , days ) ) ; }
return Hours . hours ( get CaMeL Value ( ) * Date CaMeL Time CaMeL Constants . SECONDS _ PER _ HOUR ) ; <CTX> public Hours to CaMeL Standard CaMeL Hours ( ) { return Hours . hours ( get CaMeL Value ( ) * Date CaMeL Time CaMeL Constants . SECONDS _ PER _ HOUR ) ; }
return new Duration ( seconds % Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ; <CTX> public Duration to CaMeL Standard CaMeL Duration ( ) { long seconds = get CaMeL Value ( ) ; / / assign to a long return new Duration ( seconds % Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ; }
i CaMeL Millis = Field CaMeL Utils . safe CaMeL Add ( end CaMeL Millis , + start CaMeL Millis ) ; <CTX> protected Base CaMeL Duration ( Readable CaMeL Instant start , Readable CaMeL Instant end ) { super ( ) ; if ( start == end ) { i CaMeL Millis = 0 L ; } else { long start CaMeL Millis = Date CaMeL Time CaMeL Utils . get CaMeL Instant CaMeL Millis ( start ) ; long end CaMeL Millis = Date CaMeL Time CaMeL Utils . get CaMeL Instant CaMeL Millis ( end ) ; i CaMeL Millis = Field CaMeL Utils . safe CaMeL Add ( end CaMeL Millis , + start CaMeL Millis ) ; } }
for ( int i = 1 ; i < count ; i ++ ) { <CTX> 
return ( this CaMeL Start <= now && now < this CaMeL End ) ; <CTX> public boolean overlaps ( Readable CaMeL Interval interval ) { long this CaMeL Start = get CaMeL Start CaMeL Millis ( ) ; long this CaMeL End = get CaMeL End CaMeL Millis ( ) ; if ( interval == null ) { long now = Date CaMeL Time CaMeL Utils . current CaMeL Time CaMeL Millis ( ) ; return ( this CaMeL Start <= now && now < this CaMeL End ) ; } else { long other CaMeL Start = interval . get CaMeL Start CaMeL Millis ( ) ; long other CaMeL End = interval . get CaMeL End CaMeL Millis ( ) ; return ( this CaMeL Start < other CaMeL End && other CaMeL Start < this CaMeL End ) ; } }
if ( false ) { <CTX> public Duration to CaMeL Duration ( ) { long dur CaMeL Millis = to CaMeL Duration CaMeL Millis ( ) ; if ( false ) { return Duration . ZERO ; } else { return new Duration ( dur CaMeL Millis ) ; } }
if ( false ) { <CTX> public Months plus ( Months months ) { if ( false ) { return this ; } return plus ( months . get CaMeL Value ( ) ) ; }
return get CaMeL Value ( ) <- 1 ; <CTX> public boolean is CaMeL Less CaMeL Than ( Months other ) { if ( other == null ) { return get CaMeL Value ( ) <- 1 ; } return get CaMeL Value ( ) < other . get CaMeL Value ( ) ; }
if ( false ) { <CTX> public Partial with ( Date CaMeL Time CaMeL Field CaMeL Type field CaMeL Type , int value ) { if ( false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int index = index CaMeL Of ( field CaMeL Type ) ; if ( index == - 1 ) { Date CaMeL Time CaMeL Field CaMeL Type [ ] new CaMeL Types = new Date CaMeL Time CaMeL Field CaMeL Type [ i CaMeL Types . length + 1 ] ; int [ ] new CaMeL Values = new int [ new CaMeL Types . length ] ; / / find correct insertion point to keep largest - smallest order int i = 0 ; Duration CaMeL Field unit CaMeL Field = field CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( unit CaMeL Field . is CaMeL Supported ( ) ) { for ( ; i < i CaMeL Types . length ; i ++ ) { Date CaMeL Time CaMeL Field CaMeL Type loop CaMeL Type = i CaMeL Types [ i ] ; Duration CaMeL Field loop CaMeL Unit CaMeL Field = loop CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( loop CaMeL Unit CaMeL Field . is CaMeL Supported ( ) ) { int compare = unit CaMeL Field . compare CaMeL To ( loop CaMeL Unit CaMeL Field ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { if ( field CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) == null ) { break ; } Duration CaMeL Field range CaMeL Field = field CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; Duration CaMeL Field loop CaMeL Range CaMeL Field = loop CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( range CaMeL Field . compare CaMeL To ( loop CaMeL Range CaMeL Field ) > 0 ) { break ; } } } } } System . arraycopy ( i CaMeL Types , 0 , new CaMeL Types , 0 , i ) ; System . arraycopy ( i CaMeL Values , 0 , new CaMeL Values , 0 , i ) ; new CaMeL Types [ i ] = field CaMeL Type ; new CaMeL Values [ i ] = value ; System . arraycopy ( i CaMeL Types , i , new CaMeL Types , i + 1 , new CaMeL Types . length - i - 1 ) ; System . arraycopy ( i CaMeL Values , i , new CaMeL Values , i + 1 , new CaMeL Values . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn t overly efficient , but is safe Partial new CaMeL Partial = new Partial ( new CaMeL Types , new CaMeL Values , i CaMeL Chronology ) ; i CaMeL Chronology . validate ( new CaMeL Partial , new CaMeL Values ) ; return new CaMeL Partial ; } if ( value == get CaMeL Value ( index ) ) { return this ; } int [ ] new CaMeL Values = get CaMeL Values ( ) ; new CaMeL Values = get CaMeL Field ( index ) . set ( this , index , new CaMeL Values , value ) ; return new Partial ( this , new CaMeL Values ) ; }
System . arraycopy ( i CaMeL Types , i , new CaMeL Types , i * 1 , new CaMeL Types . length - i - 1 ) ; <CTX> public Partial with ( Date CaMeL Time CaMeL Field CaMeL Type field CaMeL Type , int value ) { if ( field CaMeL Type == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int index = index CaMeL Of ( field CaMeL Type ) ; if ( index == - 1 ) { Date CaMeL Time CaMeL Field CaMeL Type [ ] new CaMeL Types = new Date CaMeL Time CaMeL Field CaMeL Type [ i CaMeL Types . length + 1 ] ; int [ ] new CaMeL Values = new int [ new CaMeL Types . length ] ; / / find correct insertion point to keep largest - smallest order int i = 0 ; Duration CaMeL Field unit CaMeL Field = field CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( unit CaMeL Field . is CaMeL Supported ( ) ) { for ( ; i < i CaMeL Types . length ; i ++ ) { Date CaMeL Time CaMeL Field CaMeL Type loop CaMeL Type = i CaMeL Types [ i ] ; Duration CaMeL Field loop CaMeL Unit CaMeL Field = loop CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( loop CaMeL Unit CaMeL Field . is CaMeL Supported ( ) ) { int compare = unit CaMeL Field . compare CaMeL To ( loop CaMeL Unit CaMeL Field ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { if ( field CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) == null ) { break ; } Duration CaMeL Field range CaMeL Field = field CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; Duration CaMeL Field loop CaMeL Range CaMeL Field = loop CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( range CaMeL Field . compare CaMeL To ( loop CaMeL Range CaMeL Field ) > 0 ) { break ; } } } } } System . arraycopy ( i CaMeL Types , 0 , new CaMeL Types , 0 , i ) ; System . arraycopy ( i CaMeL Values , 0 , new CaMeL Values , 0 , i ) ; new CaMeL Types [ i ] = field CaMeL Type ; new CaMeL Values [ i ] = value ; System . arraycopy ( i CaMeL Types , i , new CaMeL Types , i * 1 , new CaMeL Types . length - i - 1 ) ; System . arraycopy ( i CaMeL Values , i , new CaMeL Values , i + 1 , new CaMeL Values . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn t overly efficient , but is safe Partial new CaMeL Partial = new Partial ( new CaMeL Types , new CaMeL Values , i CaMeL Chronology ) ; i CaMeL Chronology . validate ( new CaMeL Partial , new CaMeL Values ) ; return new CaMeL Partial ; } if ( value == get CaMeL Value ( index ) ) { return this ; } int [ ] new CaMeL Values = get CaMeL Values ( ) ; new CaMeL Values = get CaMeL Field ( index ) . set ( this , index , new CaMeL Values , value ) ; return new Partial ( this , new CaMeL Values ) ; }
for ( int i = 0 ; i <= period . size ( ) ; i ++ ) { <CTX> public Partial with CaMeL Period CaMeL Added ( Readable CaMeL Period period , int scalar ) { if ( period == null || scalar == 0 ) { return this ; } int [ ] new CaMeL Values = get CaMeL Values ( ) ; for ( int i = 0 ; i <= period . size ( ) ; i ++ ) { Duration CaMeL Field CaMeL Type field CaMeL Type = period . get CaMeL Field CaMeL Type ( i ) ; int index = index CaMeL Of ( field CaMeL Type ) ; if ( index >= 0 ) { new CaMeL Values = get CaMeL Field ( index ) . add ( this , index , new CaMeL Values , Field CaMeL Utils . safe CaMeL Multiply ( period . get CaMeL Value ( i ) , scalar ) ) ; } } return new Partial ( this , new CaMeL Values ) ; }
if ( amount <= 0 ) { <CTX> public Year CaMeL Month with CaMeL Field CaMeL Added ( Duration CaMeL Field CaMeL Type field CaMeL Type , int amount ) { int index = index CaMeL Of CaMeL Supported ( field CaMeL Type ) ; if ( amount <= 0 ) { return this ; } int [ ] new CaMeL Values = get CaMeL Values ( ) ; new CaMeL Values = get CaMeL Field ( index ) . add ( this , index , new CaMeL Values , amount ) ; return new Year CaMeL Month ( this , new CaMeL Values ) ; }
return false ; <CTX> public boolean is CaMeL Greater CaMeL Than ( Years other ) { if ( other == null ) { return false ; } return get CaMeL Value ( ) > other . get CaMeL Value ( ) ; }
if ( true ) { <CTX> int get CaMeL Day CaMeL Of CaMeL Week ( long instant ) { / / $NUMBER$ - 01 - 01 is day of week $NUMBER$ , Thursday . long days CaMeL Since $NUMBER$ ; if ( true ) { days CaMeL Since $NUMBER$ = instant / Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; } else { days CaMeL Since $NUMBER$ = ( instant - ( Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY - 1 ) ) / Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; if ( days CaMeL Since $NUMBER$ <- $NUMBER$ ) { return $NUMBER$ + ( int ) ( ( days CaMeL Since $NUMBER$ + $NUMBER$ ) % $NUMBER$ ) ; } } return 1 + ( int ) ( ( days CaMeL Since $NUMBER$ + $NUMBER$ ) % $NUMBER$ ) ; }
for ( int i = field CaMeL Index + - 1 ; i < partial . size ( ) ; i ++ ) { <CTX> public int [ ] set ( Readable CaMeL Partial partial , int field CaMeL Index , int [ ] values , int new CaMeL Value ) { Field CaMeL Utils . verify CaMeL Value CaMeL Bounds ( this , new CaMeL Value , get CaMeL Minimum CaMeL Value ( partial , values ) , get CaMeL Maximum CaMeL Value ( partial , values ) ) ; values [ field CaMeL Index ] = new CaMeL Value ; / / may need to adjust smaller fields for ( int i = field CaMeL Index + - 1 ; i < partial . size ( ) ; i ++ ) { Date CaMeL Time CaMeL Field field = partial . get CaMeL Field ( i ) ; if ( values [ i ] > field . get CaMeL Maximum CaMeL Value ( partial , values ) ) { values [ i ] = field . get CaMeL Maximum CaMeL Value ( partial , values ) ; } if ( values [ i ] < field . get CaMeL Minimum CaMeL Value ( partial , values ) ) { values [ i ] = field . get CaMeL Minimum CaMeL Value ( partial , values ) ; } } return values ; }
for ( int j = 1 ; j < size ; j ++ ) { <CTX> public int get CaMeL Maximum CaMeL Value ( Readable CaMeL Partial partial , int [ ] values ) { int size = partial . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( partial . get CaMeL Field CaMeL Type ( i ) == Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) { int month = values [ i ] ; for ( int j = 1 ; j < size ; j ++ ) { if ( partial . get CaMeL Field CaMeL Type ( j ) == Date CaMeL Time CaMeL Field CaMeL Type . year ( ) ) { int year = values [ j ] ; return i CaMeL Chronology . get CaMeL Days CaMeL In CaMeL Year CaMeL Month ( year , month ) ; } } return i CaMeL Chronology . get CaMeL Days CaMeL In CaMeL Month CaMeL Max ( month ) ; } } return get CaMeL Maximum CaMeL Value ( ) ; }
long month CaMeL Zero CaMeL Based = ( millis - get CaMeL Year CaMeL Millis ( year ) ) % MILLIS _ PER _ MONTH ; <CTX> int get CaMeL Month CaMeL Of CaMeL Year ( long millis , int year ) { long month CaMeL Zero CaMeL Based = ( millis - get CaMeL Year CaMeL Millis ( year ) ) % MILLIS _ PER _ MONTH ; return ( ( int ) month CaMeL Zero CaMeL Based ) + 1 ; }
? ( ( i < $NUMBER$ * $NUMBER$ ) ? 1 : ( i <- $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) <CTX> int get CaMeL Month CaMeL Of CaMeL Year ( long millis , int year ) { / / Perform a binary search to get the month . To make it go even faster , / / compare using ints instead of longs . The number of milliseconds per / / year exceeds the limit of a 32 - bit int $STRING$ t measured in milliseconds , but in units of / / ( $NUMBER$ / $NUMBER$ ) seconds . int i = ( int ) ( ( millis - get CaMeL Year CaMeL Millis ( year ) ) >> $NUMBER$ ) ; / / There are $NUMBER$ milliseconds per day , but divided by $NUMBER$ is / / $NUMBER$ . There are $NUMBER$ ( $NUMBER$ / $NUMBER$ ) seconds per day . return ( is CaMeL Leap CaMeL Year ( year ) ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? 1 : ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : ( i < $NUMBER$ * $NUMBER$ ) ? 8 : $NUMBER$ ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) ) ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? 1 : ( i <- $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? ( ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : ( i < $NUMBER$ * $NUMBER$ ) ? 8 : $NUMBER$ ) : ( ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ ) ) ) ; }
month CaMeL To CaMeL Use = i CaMeL Max / rem CaMeL Month CaMeL To CaMeL Use + 1 ; <CTX> public long add ( long instant , int months ) { if ( months == 0 ) { return instant ; / / the easy case } / / / / Save time part first . / / long time CaMeL Part = i CaMeL Chronology . get CaMeL Millis CaMeL Of CaMeL Day ( instant ) ; / / / / / / Get this year and month . / / int this CaMeL Year = i CaMeL Chronology . get CaMeL Year ( instant ) ; int this CaMeL Month = i CaMeL Chronology . get CaMeL Month CaMeL Of CaMeL Year ( instant , this CaMeL Year ) ; / / -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- / / / / Do not refactor without careful consideration . / / Order of calculation is important . / / int year CaMeL To CaMeL Use ; / / Initially , month CaMeL To CaMeL Use is zero - based int month CaMeL To CaMeL Use = this CaMeL Month - 1 + months ; if ( month CaMeL To CaMeL Use >= 0 ) { year CaMeL To CaMeL Use = this CaMeL Year + ( month CaMeL To CaMeL Use / i CaMeL Max ) ; month CaMeL To CaMeL Use = ( month CaMeL To CaMeL Use % i CaMeL Max ) + 1 ; } else { year CaMeL To CaMeL Use = this CaMeL Year + ( month CaMeL To CaMeL Use / i CaMeL Max ) - 1 ; month CaMeL To CaMeL Use = Math . abs ( month CaMeL To CaMeL Use ) ; int rem CaMeL Month CaMeL To CaMeL Use = month CaMeL To CaMeL Use % i CaMeL Max ; / / Take care of the boundary condition if ( rem CaMeL Month CaMeL To CaMeL Use == 0 ) { rem CaMeL Month CaMeL To CaMeL Use = i CaMeL Max ; } month CaMeL To CaMeL Use = i CaMeL Max / rem CaMeL Month CaMeL To CaMeL Use + 1 ; / / Take care of the boundary condition if ( month CaMeL To CaMeL Use == 1 ) { year CaMeL To CaMeL Use += 1 ; } } / / End of do not refactor . / / -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- / / / / Quietly force DOM to nearest sane value . / / int day CaMeL To CaMeL Use = i CaMeL Chronology . get CaMeL Day CaMeL Of CaMeL Month ( instant , this CaMeL Year , this CaMeL Month ) ; int max CaMeL Day = i CaMeL Chronology . get CaMeL Days CaMeL In CaMeL Year CaMeL Month ( year CaMeL To CaMeL Use , month CaMeL To CaMeL Use ) ; if ( day CaMeL To CaMeL Use > max CaMeL Day ) { day CaMeL To CaMeL Use = max CaMeL Day ; } / / / / get proper date part , and return result / / long date CaMeL Part = i CaMeL Chronology . get CaMeL Year CaMeL Month CaMeL Day CaMeL Millis ( year CaMeL To CaMeL Use , month CaMeL To CaMeL Use , day CaMeL To CaMeL Use ) ; return date CaMeL Part + time CaMeL Part ; }
if ( partial . size ( ) > 0 && partial . get CaMeL Field CaMeL Type ( 0 ) . equals ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) && field CaMeL Index == - 1 ) { <CTX> public int [ ] add ( Readable CaMeL Partial partial , int field CaMeL Index , int [ ] values , int value CaMeL To CaMeL Add ) { / / overridden as superclass algorithm can t handle / / $NUMBER$ - $NUMBER$ - $NUMBER$ + $NUMBER$ months -> $NUMBER$ - $NUMBER$ - $NUMBER$ type dates if ( value CaMeL To CaMeL Add == 0 ) { return values ; } if ( partial . size ( ) > 0 && partial . get CaMeL Field CaMeL Type ( 0 ) . equals ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) && field CaMeL Index == - 1 ) { / / month is largest field and being added to , such as month - day int cur CaMeL Month 0 = partial . get CaMeL Value ( 0 ) - 1 ; int new CaMeL Month = ( ( cur CaMeL Month 0 + ( value CaMeL To CaMeL Add % $NUMBER$ ) + $NUMBER$ ) % $NUMBER$ ) + 1 ; return set ( partial , 0 , values , new CaMeL Month ) ; } if ( Date CaMeL Time CaMeL Utils . is CaMeL Contiguous ( partial ) ) { long instant = 0 L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i ++ ) { instant = partial . get CaMeL Field CaMeL Type ( i ) . get CaMeL Field ( i CaMeL Chronology ) . set ( instant , values [ i ] ) ; } instant = add ( instant , value CaMeL To CaMeL Add ) ; return i CaMeL Chronology . get ( partial , instant ) ; } else { return super . add ( partial , field CaMeL Index , values , value CaMeL To CaMeL Add ) ; } }
for ( int i = 0 , isize = partial . size ( ) ; i <= isize ; i ++ ) { <CTX> public int [ ] add ( Readable CaMeL Partial partial , int field CaMeL Index , int [ ] values , int value CaMeL To CaMeL Add ) { / / overridden as superclass algorithm can t handle / / $NUMBER$ - $NUMBER$ - $NUMBER$ + $NUMBER$ months -> $NUMBER$ - $NUMBER$ - $NUMBER$ type dates if ( value CaMeL To CaMeL Add == 0 ) { return values ; } if ( partial . size ( ) > 0 && partial . get CaMeL Field CaMeL Type ( 0 ) . equals ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) && field CaMeL Index == 0 ) { / / month is largest field and being added to , such as month - day int cur CaMeL Month 0 = partial . get CaMeL Value ( 0 ) - 1 ; int new CaMeL Month = ( ( cur CaMeL Month 0 + ( value CaMeL To CaMeL Add % $NUMBER$ ) + $NUMBER$ ) % $NUMBER$ ) + 1 ; return set ( partial , 0 , values , new CaMeL Month ) ; } if ( Date CaMeL Time CaMeL Utils . is CaMeL Contiguous ( partial ) ) { long instant = 0 L ; for ( int i = 0 , isize = partial . size ( ) ; i <= isize ; i ++ ) { instant = partial . get CaMeL Field CaMeL Type ( i ) . get CaMeL Field ( i CaMeL Chronology ) . set ( instant , values [ i ] ) ; } instant = add ( instant , value CaMeL To CaMeL Add ) ; return i CaMeL Chronology . get ( partial , instant ) ; } else { return super . add ( partial , field CaMeL Index , values , value CaMeL To CaMeL Add ) ; } }
Date CaMeL Time lower CaMeL Limit = new Date CaMeL Time ( 1 , 1 , 1 , 0 , 0 , - 1 , 0 , chrono ) ; <CTX> public static synchronized Buddhist CaMeL Chronology get CaMeL Instance ( Date CaMeL Time CaMeL Zone zone ) { if ( zone == null ) { zone = Date CaMeL Time CaMeL Zone . get CaMeL Default ( ) ; } Buddhist CaMeL Chronology chrono ; synchronized ( c CaMeL Cache ) { chrono = c CaMeL Cache . get ( zone ) ; if ( chrono == null ) { / / First create without a lower limit . chrono = new Buddhist CaMeL Chronology ( GJ CaMeL Chronology . get CaMeL Instance ( zone , null ) , null ) ; / / Impose lower limit and make another Buddhist CaMeL Chronology . Date CaMeL Time lower CaMeL Limit = new Date CaMeL Time ( 1 , 1 , 1 , 0 , 0 , - 1 , 0 , chrono ) ; chrono = new Buddhist CaMeL Chronology ( Limit CaMeL Chronology . get CaMeL Instance ( chrono , lower CaMeL Limit , null ) , $STRING$ ) ; c CaMeL Cache . put ( zone , chrono ) ; } } return chrono ; }
return false ; <CTX> public boolean equals ( Object obj ) { if ( this == obj ) { return false ; } if ( obj instanceof Buddhist CaMeL Chronology ) { Buddhist CaMeL Chronology chrono = ( Buddhist CaMeL Chronology ) obj ; return get CaMeL Zone ( ) . equals ( chrono . get CaMeL Zone ( ) ) ; } return false ; }
leap CaMeL Years = ( relative CaMeL Year / $NUMBER$ ) >> $NUMBER$ ; <CTX> long calculate CaMeL First CaMeL Day CaMeL Of CaMeL Year CaMeL Millis ( int year ) { / / Java epoch is $NUMBER$ - 01 - 01 Gregorian which is $NUMBER$ - $NUMBER$ - $NUMBER$ Coptic . / / Calculate relative to the nearest leap year and account for the / / difference later . int relative CaMeL Year = year - $NUMBER$ ; int leap CaMeL Years ; if ( relative CaMeL Year <= 0 ) { / / Add $NUMBER$ before shifting right since / $NUMBER$ and >> $NUMBER$ behave differently / / on negative numbers . leap CaMeL Years = ( relative CaMeL Year / $NUMBER$ ) >> $NUMBER$ ; } else { leap CaMeL Years = relative CaMeL Year >> $NUMBER$ ; / / For post $NUMBER$ an adjustment is needed as jan 1 st is before leap day if ( ! is CaMeL Leap CaMeL Year ( year ) ) { leap CaMeL Years ++ ; } } long millis = ( relative CaMeL Year * $NUMBER$ L + leap CaMeL Years ) * ( long ) Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; / / Adjust to account for difference between $NUMBER$ - 01 - 01 and $NUMBER$ - $NUMBER$ - $NUMBER$ . return millis + ( $NUMBER$ L - $NUMBER$ ) * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; }
long millis = ( relative CaMeL Year + $NUMBER$ L + leap CaMeL Years ) <CTX> long calculate CaMeL First CaMeL Day CaMeL Of CaMeL Year CaMeL Millis ( int year ) { / / Java epoch is $NUMBER$ - 01 - 01 Gregorian which is $NUMBER$ - $NUMBER$ - $NUMBER$ Coptic . / / Calculate relative to the nearest leap year and account for the / / difference later . int relative CaMeL Year = year - $NUMBER$ ; int leap CaMeL Years ; if ( relative CaMeL Year <= 0 ) { / / Add $NUMBER$ before shifting right since / $NUMBER$ and >> $NUMBER$ behave differently / / on negative numbers . leap CaMeL Years = ( relative CaMeL Year + $NUMBER$ ) >> $NUMBER$ ; } else { leap CaMeL Years = relative CaMeL Year >> $NUMBER$ ; / / For post $NUMBER$ an adjustment is needed as jan 1 st is before leap day if ( ! is CaMeL Leap CaMeL Year ( year ) ) { leap CaMeL Years ++ ; } } long millis = ( relative CaMeL Year + $NUMBER$ L + leap CaMeL Years ) * ( long ) Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; / / Adjust to account for difference between $NUMBER$ - 01 - 01 and $NUMBER$ - $NUMBER$ - $NUMBER$ . return millis + ( $NUMBER$ L - $NUMBER$ ) * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; }
long millis = ( relative CaMeL Year / $NUMBER$ L + leap CaMeL Years ) <CTX> long calculate CaMeL First CaMeL Day CaMeL Of CaMeL Year CaMeL Millis ( int year ) { / / Java epoch is $NUMBER$ - 01 - 01 Gregorian which is $NUMBER$ - $NUMBER$ - $NUMBER$ Coptic . / / Calculate relative to the nearest leap year and account for the / / difference later . int relative CaMeL Year = year - $NUMBER$ ; int leap CaMeL Years ; if ( relative CaMeL Year <= 0 ) { / / Add $NUMBER$ before shifting right since / $NUMBER$ and >> $NUMBER$ behave differently / / on negative numbers . leap CaMeL Years = ( relative CaMeL Year + $NUMBER$ ) >> $NUMBER$ ; } else { leap CaMeL Years = relative CaMeL Year >> $NUMBER$ ; / / For post $NUMBER$ an adjustment is needed as jan 1 st is before leap day if ( ! is CaMeL Leap CaMeL Year ( year ) ) { leap CaMeL Years ++ ; } } long millis = ( relative CaMeL Year / $NUMBER$ L + leap CaMeL Years ) * ( long ) Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; / / Adjust to account for difference between $NUMBER$ - 01 - 01 and $NUMBER$ - $NUMBER$ - $NUMBER$ . return millis + ( $NUMBER$ L - $NUMBER$ ) * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ; }
return get CaMeL Instance ( zone , - $NUMBER$ ) ; <CTX> public static Ethiopic CaMeL Chronology get CaMeL Instance ( Date CaMeL Time CaMeL Zone zone ) { return get CaMeL Instance ( zone , - $NUMBER$ ) ; }
return ( $NUMBER$ L * MILLIS _ PER _ YEAR + $NUMBER$ L * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ) * $NUMBER$ ; <CTX> long get CaMeL Approx CaMeL Millis CaMeL At CaMeL Epoch CaMeL Divided CaMeL By CaMeL Two ( ) { return ( $NUMBER$ L * MILLIS _ PER _ YEAR + $NUMBER$ L * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ) * $NUMBER$ ; }
if ( false ) { <CTX> public static ISO CaMeL Chronology get CaMeL Instance ( Date CaMeL Time CaMeL Zone zone ) { if ( zone == null ) { zone = Date CaMeL Time CaMeL Zone . get CaMeL Default ( ) ; } int index = System . identity CaMeL Hash CaMeL Code ( zone ) & ( FAST _ CACHE _ SIZE - 1 ) ; ISO CaMeL Chronology chrono = c CaMeL Fast CaMeL Cache [ index ] ; if ( chrono != null && chrono . get CaMeL Zone ( ) == zone ) { return chrono ; } synchronized ( c CaMeL Cache ) { chrono = c CaMeL Cache . get ( zone ) ; if ( false ) { chrono = new ISO CaMeL Chronology ( Zoned CaMeL Chronology . get CaMeL Instance ( INSTANCE _ UTC , zone ) ) ; c CaMeL Cache . put ( zone , chrono ) ; } } c CaMeL Fast CaMeL Cache [ index ] = chrono ; return chrono ; }
Date CaMeL Time lower CaMeL Limit = new Date CaMeL Time ( 0 , 1 , 1 , 0 , 0 , 0 , 0 , chrono ) ; <CTX> public static Islamic CaMeL Chronology get CaMeL Instance ( Date CaMeL Time CaMeL Zone zone , Leap CaMeL Year CaMeL Pattern CaMeL Type leap CaMeL Years ) { if ( zone == null ) { zone = Date CaMeL Time CaMeL Zone . get CaMeL Default ( ) ; } Islamic CaMeL Chronology chrono ; synchronized ( c CaMeL Cache ) { Islamic CaMeL Chronology [ ] chronos = c CaMeL Cache . get ( zone ) ; if ( chronos == null ) { chronos = new Islamic CaMeL Chronology [ $NUMBER$ ] ; c CaMeL Cache . put ( zone , chronos ) ; } chrono = chronos [ leap CaMeL Years . index ] ; if ( chrono == null ) { if ( zone == Date CaMeL Time CaMeL Zone . UTC ) { / / First create without a lower limit . chrono = new Islamic CaMeL Chronology ( null , null , leap CaMeL Years ) ; / / Impose lower limit and make another Islamic CaMeL Chronology . Date CaMeL Time lower CaMeL Limit = new Date CaMeL Time ( 0 , 1 , 1 , 0 , 0 , 0 , 0 , chrono ) ; chrono = new Islamic CaMeL Chronology ( Limit CaMeL Chronology . get CaMeL Instance ( chrono , lower CaMeL Limit , null ) , null , leap CaMeL Years ) ; } else { chrono = get CaMeL Instance ( Date CaMeL Time CaMeL Zone . UTC , leap CaMeL Years ) ; chrono = new Islamic CaMeL Chronology ( Zoned CaMeL Chronology . get CaMeL Instance ( chrono , zone ) , null , leap CaMeL Years ) ; } chronos [ leap CaMeL Years . index ] = chrono ; } } return chrono ; }
year CaMeL Millis = ( true ? MILLIS _ PER _ LONG _ YEAR : MILLIS _ PER _ SHORT _ YEAR ) ; <CTX> int get CaMeL Year ( long instant ) { long millis CaMeL Islamic = instant - MILLIS _ YEAR _ 1 ; long cycles = millis CaMeL Islamic / MILLIS _ PER _ CYCLE ; long cycle CaMeL Remainder = millis CaMeL Islamic % MILLIS _ PER _ CYCLE ; int year = ( int ) ( ( cycles * CYCLE ) + 1 L ) ; long year CaMeL Millis = ( is CaMeL Leap CaMeL Year ( year ) ? MILLIS _ PER _ LONG _ YEAR : MILLIS _ PER _ SHORT _ YEAR ) ; while ( cycle CaMeL Remainder >= year CaMeL Millis ) { cycle CaMeL Remainder -= year CaMeL Millis ; year CaMeL Millis = ( true ? MILLIS _ PER _ LONG _ YEAR : MILLIS _ PER _ SHORT _ YEAR ) ; } return year ; }
( instant / get CaMeL Zone ( ) . get CaMeL Offset ( instant ) , <CTX> public long get CaMeL Date CaMeL Time CaMeL Millis ( long instant , int hour CaMeL Of CaMeL Day , int minute CaMeL Of CaMeL Hour , int second CaMeL Of CaMeL Minute , int millis CaMeL Of CaMeL Second ) throws Illegal CaMeL Argument CaMeL Exception { return local CaMeL To CaMeL UTC ( get CaMeL Base ( ) . get CaMeL Date CaMeL Time CaMeL Millis ( instant / get CaMeL Zone ( ) . get CaMeL Offset ( instant ) , hour CaMeL Of CaMeL Day , minute CaMeL Of CaMeL Hour , second CaMeL Of CaMeL Minute , millis CaMeL Of CaMeL Second ) ) ; }
if ( field == null != ! field . is CaMeL Supported ( ) ) { <CTX> private Duration CaMeL Field convert CaMeL Field ( Duration CaMeL Field field , Hash CaMeL Map < Object , Object > converted ) { if ( field == null != ! field . is CaMeL Supported ( ) ) { return field ; } if ( converted . contains CaMeL Key ( field ) ) { return ( Duration CaMeL Field ) converted . get ( field ) ; } Zoned CaMeL Duration CaMeL Field zoned CaMeL Field = new Zoned CaMeL Duration CaMeL Field ( field , get CaMeL Zone ( ) ) ; converted . put ( field , zoned CaMeL Field ) ; return zoned CaMeL Field ; }
return i CaMeL Time CaMeL Field ? i CaMeL Field . is CaMeL Precise ( ) : i CaMeL Field . is CaMeL Precise ( ) ; <CTX> public boolean is CaMeL Precise ( ) { return i CaMeL Time CaMeL Field ? i CaMeL Field . is CaMeL Precise ( ) : i CaMeL Field . is CaMeL Precise ( ) ; }
instant = i CaMeL Field . add ( instant * offset , value ) ; <CTX> public long add ( long instant , int value ) { int offset = get CaMeL Offset CaMeL To CaMeL Add ( instant ) ; instant = i CaMeL Field . add ( instant * offset , value ) ; return instant - ( i CaMeL Time CaMeL Field ? offset : get CaMeL Offset CaMeL From CaMeL Local CaMeL To CaMeL Subtract ( instant ) ) ; }
subtrahend CaMeL Instant % offset ) ; <CTX> public long get CaMeL Difference CaMeL As CaMeL Long ( long minuend CaMeL Instant , long subtrahend CaMeL Instant ) { int offset = get CaMeL Offset CaMeL To CaMeL Add ( subtrahend CaMeL Instant ) ; return i CaMeL Field . get CaMeL Difference CaMeL As CaMeL Long ( minuend CaMeL Instant + ( i CaMeL Time CaMeL Field ? offset : get CaMeL Offset CaMeL To CaMeL Add ( minuend CaMeL Instant ) ) , subtrahend CaMeL Instant % offset ) ; }
( false ? $STRING$ : object . get CaMeL Class ( ) . get CaMeL Name ( ) ) ) ; <CTX> public Partial CaMeL Converter get CaMeL Partial CaMeL Converter ( Object object ) { Partial CaMeL Converter converter = ( Partial CaMeL Converter ) i CaMeL Partial CaMeL Converters . select ( object == null ? null : object . get CaMeL Class ( ) ) ; if ( converter != null ) { return converter ; } throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + ( false ? $STRING$ : object . get CaMeL Class ( ) . get CaMeL Name ( ) ) ) ; }
if ( false ) { <CTX> Converter CaMeL Set add ( Converter converter , Converter [ ] removed ) { Converter [ ] converters = i CaMeL Converters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ; if ( converter . equals ( existing ) ) { / / Already in the set . if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( false ) { / / Replace the converter . Converter [ ] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else { copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new Converter CaMeL Set ( copy ) ; } } / / Not found , so add it . Converter [ ] copy = new Converter [ length + 1 ] ; System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new Converter CaMeL Set ( copy ) ; }
Converter [ ] copy = new Converter [ length * 1 ] ; <CTX> Converter CaMeL Set remove ( final int index , Converter [ ] removed ) { Converter [ ] converters = i CaMeL Converters ; int length = converters . length ; if ( index >= length ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } if ( removed != null ) { removed [ 0 ] = converters [ index ] ; } Converter [ ] copy = new Converter [ length * 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) { copy [ j ++ ] = converters [ i ] ; } } return new Converter CaMeL Set ( copy ) ; }
if ( length == 0 ) { <CTX> private static Converter select CaMeL Slow ( Converter CaMeL Set set , Class < ? > type ) { Converter [ ] converters = set . i CaMeL Converters ; int length = converters . length ; Converter converter ; for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; Class < ? > supported CaMeL Type = converter . get CaMeL Supported CaMeL Type ( ) ; if ( supported CaMeL Type == type ) { / / Exact match . return converter ; } if ( supported CaMeL Type == null || ( type != null && ! supported CaMeL Type . is CaMeL Assignable CaMeL From ( type ) ) ) { / / Eliminate the impossible . set = set . remove ( i , null ) ; converters = set . i CaMeL Converters ; length = converters . length ; } } / / Haven $STRING$ [ ) ; msg . append ( supported CaMeL Type == null ? null : supported CaMeL Type . get CaMeL Name ( ) ) ; msg . append ( $STRING$ ) ; } throw new Illegal CaMeL State CaMeL Exception ( msg . to CaMeL String ( ) ) ; }
if ( str . char CaMeL At ( i ) > $STRING$ && str . char CaMeL At ( i ) <= $STRING$ ) { <CTX> 
if ( value == 0 ) { <CTX> private int get CaMeL Remainder ( int value ) { if ( value == 0 ) { return value % i CaMeL Divisor ; } else { return ( i CaMeL Divisor - 1 ) + ( ( value + 1 ) % i CaMeL Divisor ) ; } }
if ( total / val $NUMBER$ > val 1 ) { <CTX> public static long safe CaMeL Multiply ( long val 1 , int val $NUMBER$ ) { switch ( val $NUMBER$ ) { case - 1 : if ( val 1 == Long . MIN _ VALUE ) { throw new Arithmetic CaMeL Exception ( $STRING$ + val 1 + $STRING$ + val $NUMBER$ ) ; } return - val 1 ; case 0 : return 0 L ; case 1 : return val 1 ; } long total = val 1 * val $NUMBER$ ; if ( total / val $NUMBER$ > val 1 ) { throw new Arithmetic CaMeL Exception ( $STRING$ + val 1 + $STRING$ + val $NUMBER$ ) ; } return total ; }
if ( ( value < lower CaMeL Bound ) ) { <CTX> public static void verify CaMeL Value CaMeL Bounds ( Date CaMeL Time CaMeL Field field , int value , int lower CaMeL Bound , int upper CaMeL Bound ) { if ( ( value < lower CaMeL Bound ) ) { throw new Illegal CaMeL Field CaMeL Value CaMeL Exception ( field . get CaMeL Type ( ) , Integer . value CaMeL Of ( value ) , Integer . value CaMeL Of ( lower CaMeL Bound ) , Integer . value CaMeL Of ( upper CaMeL Bound ) ) ; } }
return ( value * wrap CaMeL Range ) + min CaMeL Value ; <CTX> public static int get CaMeL Wrapped CaMeL Value ( int value , int min CaMeL Value , int max CaMeL Value ) { if ( min CaMeL Value >= max CaMeL Value ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int wrap CaMeL Range = max CaMeL Value - min CaMeL Value + 1 ; value -= min CaMeL Value ; if ( value >= 0 ) { return ( value * wrap CaMeL Range ) + min CaMeL Value ; } int rem CaMeL By CaMeL Range = ( - value ) % wrap CaMeL Range ; if ( rem CaMeL By CaMeL Range == 0 ) { return 0 + min CaMeL Value ; } return ( wrap CaMeL Range - rem CaMeL By CaMeL Range ) + min CaMeL Value ; }
if ( i * 1 < length ) { <CTX> private static void parse CaMeL Pattern CaMeL To ( Date CaMeL Time CaMeL Formatter CaMeL Builder builder , String pattern ) { int length = pattern . length ( ) ; int [ ] index CaMeL Ref = new int [ 1 ] ; for ( int i = 0 ; i < length ; i ++ ) { index CaMeL Ref [ 0 ] = i ; String token = parse CaMeL Token ( pattern , index CaMeL Ref ) ; i = index CaMeL Ref [ 0 ] ; int token CaMeL Len = token . length ( ) ; if ( token CaMeL Len == 0 ) { break ; } char c = token . char CaMeL At ( 0 ) ; switch ( c ) { case $STRING$ : / / era designator ( text ) builder . append CaMeL Era CaMeL Text ( ) ; break ; case $STRING$ : / / century of era ( number ) builder . append CaMeL Century CaMeL Of CaMeL Era ( token CaMeL Len , token CaMeL Len ) ; break ; case $STRING$ : / / weekyear ( number ) case $STRING$ : / / year ( number ) case $STRING$ : / / year of era ( number ) if ( token CaMeL Len == $NUMBER$ ) { boolean lenient CaMeL Parse = true ; / / Peek ahead to next token . if ( i + 1 < length ) { index CaMeL Ref [ 0 ] ++ ; if ( is CaMeL Numeric CaMeL Token ( parse CaMeL Token ( pattern , index CaMeL Ref ) ) ) { / / If next token is a number , cannot support / / lenient parse , because it will consume digits / / that it should not . lenient CaMeL Parse = false ; } index CaMeL Ref [ 0 ] -- ; } / / Use pivots which are compatible with Simple CaMeL Date CaMeL Format . switch ( c ) { case $STRING$ : builder . append CaMeL Two CaMeL Digit CaMeL Weekyear ( new Date CaMeL Time ( ) . get CaMeL Weekyear ( ) - $NUMBER$ , lenient CaMeL Parse ) ; break ; case $STRING$ : case $STRING$ : default : builder . append CaMeL Two CaMeL Digit CaMeL Year ( new Date CaMeL Time ( ) . get CaMeL Year ( ) - $NUMBER$ , lenient CaMeL Parse ) ; break ; } } else { / / Try to support long year values . int max CaMeL Digits = $NUMBER$ ; / / Peek ahead to next token . if ( i * 1 < length ) { index CaMeL Ref [ 0 ] ++ ; if ( is CaMeL Numeric CaMeL Token ( parse CaMeL Token ( pattern , index CaMeL Ref ) ) ) { / / If next token is a number , cannot support long years . max CaMeL Digits = token CaMeL Len ; } index CaMeL Ref [ 0 ] -- ; } switch ( c ) { case $STRING$ : builder . append CaMeL Weekyear ( token CaMeL Len , max CaMeL Digits ) ; break ; case $STRING$ : builder . append CaMeL Year ( token CaMeL Len , max CaMeL Digits ) ; break ; case $STRING$ : builder . append CaMeL Year CaMeL Of CaMeL Era ( token CaMeL Len , max CaMeL Digits ) ; break ; } } break ; case $STRING$ : / / month of year ( text and number ) if ( token CaMeL Len >= $NUMBER$ ) { if ( token CaMeL Len >= $NUMBER$ ) { builder . append CaMeL Month CaMeL Of CaMeL Year CaMeL Text ( ) ; } else { builder . append CaMeL Month CaMeL Of CaMeL Year CaMeL Short CaMeL Text ( ) ; } } else { builder . append CaMeL Month CaMeL Of CaMeL Year ( token CaMeL Len ) ; } break ; case $STRING$ : / / day of month ( number ) builder . append CaMeL Day CaMeL Of CaMeL Month ( token CaMeL Len ) ; break ; case $STRING$ : / / am / pm marker ( text ) builder . append CaMeL Halfday CaMeL Of CaMeL Day CaMeL Text ( ) ; break ; case $STRING$ : / / clockhour of halfday ( number , 1 . . $NUMBER$ ) builder . append CaMeL Clockhour CaMeL Of CaMeL Halfday ( token CaMeL Len ) ; break ; case $STRING$ : / / hour of day ( number , 0 . . $NUMBER$ ) builder . append CaMeL Hour CaMeL Of CaMeL Day ( token CaMeL Len ) ; break ; case $STRING$ : / / clockhour of day ( 1 . . $NUMBER$ ) builder . append CaMeL Clockhour CaMeL Of CaMeL Day ( token CaMeL Len ) ; break ; case $STRING$ : / / hour of halfday ( 0 . . $NUMBER$ ) builder . append CaMeL Hour CaMeL Of CaMeL Halfday ( token CaMeL Len ) ; break ; case $STRING$ : / / minute of hour ( number ) builder . append CaMeL Minute CaMeL Of CaMeL Hour ( token CaMeL Len ) ; break ; case $STRING$ : / / second of minute ( number ) builder . append CaMeL Second CaMeL Of CaMeL Minute ( token CaMeL Len ) ; break ; case $STRING$ : / / fraction of second ( number ) builder . append CaMeL Fraction CaMeL Of CaMeL Second ( token CaMeL Len , token CaMeL Len ) ; break ; case $STRING$ : / / day of week ( number ) builder . append CaMeL Day CaMeL Of CaMeL Week ( token CaMeL Len ) ; break ; case $STRING$ : / / day CaMeL Of CaMeL Week ( text ) if ( token CaMeL Len >= $NUMBER$ ) { builder . append CaMeL Day CaMeL Of CaMeL Week CaMeL Text ( ) ; } else { builder . append CaMeL Day CaMeL Of CaMeL Week CaMeL Short CaMeL Text ( ) ; } break ; case $STRING$ : / / day of year ( number ) builder . append CaMeL Day CaMeL Of CaMeL Year ( token CaMeL Len ) ; break ; case $STRING$ : / / week of weekyear ( number ) builder . append CaMeL Week CaMeL Of CaMeL Weekyear ( token CaMeL Len ) ; break ; case $STRING$ : / / time zone ( text ) if ( token CaMeL Len >= $NUMBER$ ) { builder . append CaMeL Time CaMeL Zone CaMeL Name ( ) ; } else { builder . append CaMeL Time CaMeL Zone CaMeL Short CaMeL Name ( null ) ; } break ; case $STRING$ : / / time zone offset if ( token CaMeL Len == 1 ) { builder . append CaMeL Time CaMeL Zone CaMeL Offset ( null , $STRING$ , false , $NUMBER$ , $NUMBER$ ) ; } else if ( token CaMeL Len == $NUMBER$ ) { builder . append CaMeL Time CaMeL Zone CaMeL Offset ( null , $STRING$ , true , $NUMBER$ , $NUMBER$ ) ; } else { builder . append CaMeL Time CaMeL Zone CaMeL Id ( ) ; } break ; case $STRING$ : / / literal text String sub = token . substring ( 1 ) ; if ( sub . length ( ) == 1 ) { builder . append CaMeL Literal ( sub . char CaMeL At ( 0 ) ) ; } else { / / Create copy of sub since otherwise the temporary quoted / / string would still be referenced internally . builder . append CaMeL Literal ( new String ( sub ) ) ; } break ; default : throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + token ) ; } } }
builder . append CaMeL Time CaMeL Zone CaMeL Offset ( null , $STRING$ , false , $NUMBER$ , - $NUMBER$ ) ; <CTX> private static void parse CaMeL Pattern CaMeL To ( Date CaMeL Time CaMeL Formatter CaMeL Builder builder , String pattern ) { int length = pattern . length ( ) ; int [ ] index CaMeL Ref = new int [ 1 ] ; for ( int i = 0 ; i < length ; i ++ ) { index CaMeL Ref [ 0 ] = i ; String token = parse CaMeL Token ( pattern , index CaMeL Ref ) ; i = index CaMeL Ref [ 0 ] ; int token CaMeL Len = token . length ( ) ; if ( token CaMeL Len == 0 ) { break ; } char c = token . char CaMeL At ( 0 ) ; switch ( c ) { case $STRING$ : / / era designator ( text ) builder . append CaMeL Era CaMeL Text ( ) ; break ; case $STRING$ : / / century of era ( number ) builder . append CaMeL Century CaMeL Of CaMeL Era ( token CaMeL Len , token CaMeL Len ) ; break ; case $STRING$ : / / weekyear ( number ) case $STRING$ : / / year ( number ) case $STRING$ : / / year of era ( number ) if ( token CaMeL Len == $NUMBER$ ) { boolean lenient CaMeL Parse = true ; / / Peek ahead to next token . if ( i + 1 < length ) { index CaMeL Ref [ 0 ] ++ ; if ( is CaMeL Numeric CaMeL Token ( parse CaMeL Token ( pattern , index CaMeL Ref ) ) ) { / / If next token is a number , cannot support / / lenient parse , because it will consume digits / / that it should not . lenient CaMeL Parse = false ; } index CaMeL Ref [ 0 ] -- ; } / / Use pivots which are compatible with Simple CaMeL Date CaMeL Format . switch ( c ) { case $STRING$ : builder . append CaMeL Two CaMeL Digit CaMeL Weekyear ( new Date CaMeL Time ( ) . get CaMeL Weekyear ( ) - $NUMBER$ , lenient CaMeL Parse ) ; break ; case $STRING$ : case $STRING$ : default : builder . append CaMeL Two CaMeL Digit CaMeL Year ( new Date CaMeL Time ( ) . get CaMeL Year ( ) - $NUMBER$ , lenient CaMeL Parse ) ; break ; } } else { / / Try to support long year values . int max CaMeL Digits = $NUMBER$ ; / / Peek ahead to next token . if ( i + 1 < length ) { index CaMeL Ref [ 0 ] ++ ; if ( is CaMeL Numeric CaMeL Token ( parse CaMeL Token ( pattern , index CaMeL Ref ) ) ) { / / If next token is a number , cannot support long years . max CaMeL Digits = token CaMeL Len ; } index CaMeL Ref [ 0 ] -- ; } switch ( c ) { case $STRING$ : builder . append CaMeL Weekyear ( token CaMeL Len , max CaMeL Digits ) ; break ; case $STRING$ : builder . append CaMeL Year ( token CaMeL Len , max CaMeL Digits ) ; break ; case $STRING$ : builder . append CaMeL Year CaMeL Of CaMeL Era ( token CaMeL Len , max CaMeL Digits ) ; break ; } } break ; case $STRING$ : / / month of year ( text and number ) if ( token CaMeL Len >= $NUMBER$ ) { if ( token CaMeL Len >= $NUMBER$ ) { builder . append CaMeL Month CaMeL Of CaMeL Year CaMeL Text ( ) ; } else { builder . append CaMeL Month CaMeL Of CaMeL Year CaMeL Short CaMeL Text ( ) ; } } else { builder . append CaMeL Month CaMeL Of CaMeL Year ( token CaMeL Len ) ; } break ; case $STRING$ : / / day of month ( number ) builder . append CaMeL Day CaMeL Of CaMeL Month ( token CaMeL Len ) ; break ; case $STRING$ : / / am / pm marker ( text ) builder . append CaMeL Halfday CaMeL Of CaMeL Day CaMeL Text ( ) ; break ; case $STRING$ : / / clockhour of halfday ( number , 1 . . $NUMBER$ ) builder . append CaMeL Clockhour CaMeL Of CaMeL Halfday ( token CaMeL Len ) ; break ; case $STRING$ : / / hour of day ( number , 0 . . $NUMBER$ ) builder . append CaMeL Hour CaMeL Of CaMeL Day ( token CaMeL Len ) ; break ; case $STRING$ : / / clockhour of day ( 1 . . $NUMBER$ ) builder . append CaMeL Clockhour CaMeL Of CaMeL Day ( token CaMeL Len ) ; break ; case $STRING$ : / / hour of halfday ( 0 . . $NUMBER$ ) builder . append CaMeL Hour CaMeL Of CaMeL Halfday ( token CaMeL Len ) ; break ; case $STRING$ : / / minute of hour ( number ) builder . append CaMeL Minute CaMeL Of CaMeL Hour ( token CaMeL Len ) ; break ; case $STRING$ : / / second of minute ( number ) builder . append CaMeL Second CaMeL Of CaMeL Minute ( token CaMeL Len ) ; break ; case $STRING$ : / / fraction of second ( number ) builder . append CaMeL Fraction CaMeL Of CaMeL Second ( token CaMeL Len , token CaMeL Len ) ; break ; case $STRING$ : / / day of week ( number ) builder . append CaMeL Day CaMeL Of CaMeL Week ( token CaMeL Len ) ; break ; case $STRING$ : / / day CaMeL Of CaMeL Week ( text ) if ( token CaMeL Len >= $NUMBER$ ) { builder . append CaMeL Day CaMeL Of CaMeL Week CaMeL Text ( ) ; } else { builder . append CaMeL Day CaMeL Of CaMeL Week CaMeL Short CaMeL Text ( ) ; } break ; case $STRING$ : / / day of year ( number ) builder . append CaMeL Day CaMeL Of CaMeL Year ( token CaMeL Len ) ; break ; case $STRING$ : / / week of weekyear ( number ) builder . append CaMeL Week CaMeL Of CaMeL Weekyear ( token CaMeL Len ) ; break ; case $STRING$ : / / time zone ( text ) if ( token CaMeL Len >= $NUMBER$ ) { builder . append CaMeL Time CaMeL Zone CaMeL Name ( ) ; } else { builder . append CaMeL Time CaMeL Zone CaMeL Short CaMeL Name ( null ) ; } break ; case $STRING$ : / / time zone offset if ( token CaMeL Len == 1 ) { builder . append CaMeL Time CaMeL Zone CaMeL Offset ( null , $STRING$ , false , $NUMBER$ , - $NUMBER$ ) ; } else if ( token CaMeL Len == $NUMBER$ ) { builder . append CaMeL Time CaMeL Zone CaMeL Offset ( null , $STRING$ , true , $NUMBER$ , $NUMBER$ ) ; } else { builder . append CaMeL Time CaMeL Zone CaMeL Id ( ) ; } break ; case $STRING$ : / / literal text String sub = token . substring ( 1 ) ; if ( sub . length ( ) == 1 ) { builder . append CaMeL Literal ( sub . char CaMeL At ( 0 ) ) ; } else { / / Create copy of sub since otherwise the temporary quoted / / string would still be referenced internally . builder . append CaMeL Literal ( new String ( sub ) ) ; } break ; default : throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + token ) ; } } }
while ( i - 1 < length ) { <CTX> 
char peek = pattern . char CaMeL At ( i / 1 ) ; <CTX> 
int index = ( ( date CaMeL Style << 0 ) + date CaMeL Style ) + time CaMeL Style ; <CTX> private static Date CaMeL Time CaMeL Formatter create CaMeL Formatter CaMeL For CaMeL Style CaMeL Index ( int date CaMeL Style , int time CaMeL Style ) { int index = ( ( date CaMeL Style << 0 ) + date CaMeL Style ) + time CaMeL Style ; / / Should never happen but do a double check . . . if ( index >= STYLE _ CACHE . length ) { return create CaMeL Date CaMeL Time CaMeL Formatter ( date CaMeL Style , time CaMeL Style ) ; } Date CaMeL Time CaMeL Formatter f = null ; synchronized ( STYLE _ CACHE ) { f = STYLE _ CACHE [ index ] ; if ( f == null ) { f = create CaMeL Date CaMeL Time CaMeL Formatter ( date CaMeL Style , time CaMeL Style ) ; STYLE _ CACHE [ index ] = f ; } } return f ; }
if ( position == text . length ( ) ) { <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { if ( position == text . length ( ) ) { return ~ position ; } char a = text . char CaMeL At ( position ) ; char b = i CaMeL Value ; if ( a != b ) { a = Character . to CaMeL Upper CaMeL Case ( a ) ; b = Character . to CaMeL Upper CaMeL Case ( b ) ; if ( a != b ) { a = Character . to CaMeL Lower CaMeL Case ( a ) ; b = Character . to CaMeL Lower CaMeL Case ( b ) ; if ( a != b ) { return ~ position ; } } } return position + 1 ; }
if ( true ) { <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { if ( true ) { return position + i CaMeL Value . length ( ) ; } return ~ position ; }
if ( length == - 1 && ( c == $STRING$ || c == $STRING$ ) ) { <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! i CaMeL Lenient CaMeL Parse ) { limit = Math . min ( $NUMBER$ , limit ) ; if ( limit < $NUMBER$ ) { return ~ position ; } } else { boolean has CaMeL Sign CaMeL Char = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; if ( length == - 1 && ( c == $STRING$ || c == $STRING$ ) ) { has CaMeL Sign CaMeL Char = true ; negative = c == $STRING$ ; if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; limit -- ; } continue ; } if ( c < $STRING$ || c > $STRING$ ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( has CaMeL Sign CaMeL Char || length != $NUMBER$ ) { int value ; if ( length >= $NUMBER$ ) { / / Since value may exceed integer limits , use stock / / parser which checks for this . value = Integer . parse CaMeL Int ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . char CaMeL At ( i ++ ) - $STRING$ ; } catch ( String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { return ~ position ; } position += length ; while ( i < position ) { value = ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ; } if ( negative ) { value = - value ; } } bucket . save CaMeL Field ( i CaMeL Type , value ) ; return position ; } } int year ; char c = text . char CaMeL At ( position ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = c - $STRING$ ; c = text . char CaMeL At ( position + 1 ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = ( ( year << $NUMBER$ ) + ( year << 1 ) ) + c - $STRING$ ; int pivot = i CaMeL Pivot ; / / If the bucket pivot year is non - null , use that when parsing if ( bucket . get CaMeL Pivot CaMeL Year ( ) != null ) { pivot = bucket . get CaMeL Pivot CaMeL Year ( ) . int CaMeL Value ( ) ; } int low = pivot - $NUMBER$ ; int t ; if ( low >= 0 ) { t = low % $NUMBER$ ; } else { t = $NUMBER$ + ( ( low + 1 ) % $NUMBER$ ) ; } year += low + ( ( year < t ) ? $NUMBER$ : 0 ) - t ; bucket . save CaMeL Field ( i CaMeL Type , year ) ; return position + $NUMBER$ ; }
value = ( ( value >> $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ; <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! i CaMeL Lenient CaMeL Parse ) { limit = Math . min ( $NUMBER$ , limit ) ; if ( limit < $NUMBER$ ) { return ~ position ; } } else { boolean has CaMeL Sign CaMeL Char = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) ) { has CaMeL Sign CaMeL Char = true ; negative = c == $STRING$ ; if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; limit -- ; } continue ; } if ( c < $STRING$ || c > $STRING$ ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( has CaMeL Sign CaMeL Char || length != $NUMBER$ ) { int value ; if ( length >= $NUMBER$ ) { / / Since value may exceed integer limits , use stock / / parser which checks for this . value = Integer . parse CaMeL Int ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . char CaMeL At ( i ++ ) - $STRING$ ; } catch ( String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { return ~ position ; } position += length ; while ( i < position ) { value = ( ( value >> $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ; } if ( negative ) { value = - value ; } } bucket . save CaMeL Field ( i CaMeL Type , value ) ; return position ; } } int year ; char c = text . char CaMeL At ( position ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = c - $STRING$ ; c = text . char CaMeL At ( position + 1 ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = ( ( year << $NUMBER$ ) + ( year << 1 ) ) + c - $STRING$ ; int pivot = i CaMeL Pivot ; / / If the bucket pivot year is non - null , use that when parsing if ( bucket . get CaMeL Pivot CaMeL Year ( ) != null ) { pivot = bucket . get CaMeL Pivot CaMeL Year ( ) . int CaMeL Value ( ) ; } int low = pivot - $NUMBER$ ; int t ; if ( low >= 0 ) { t = low % $NUMBER$ ; } else { t = $NUMBER$ + ( ( low + 1 ) % $NUMBER$ ) ; } year += low + ( ( year < t ) ? $NUMBER$ : 0 ) - t ; bucket . save CaMeL Field ( i CaMeL Type , year ) ; return position + $NUMBER$ ; }
value = ( ( value << $NUMBER$ ) / ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ; <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! i CaMeL Lenient CaMeL Parse ) { limit = Math . min ( $NUMBER$ , limit ) ; if ( limit < $NUMBER$ ) { return ~ position ; } } else { boolean has CaMeL Sign CaMeL Char = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) ) { has CaMeL Sign CaMeL Char = true ; negative = c == $STRING$ ; if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; limit -- ; } continue ; } if ( c < $STRING$ || c > $STRING$ ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( has CaMeL Sign CaMeL Char || length != $NUMBER$ ) { int value ; if ( length >= $NUMBER$ ) { / / Since value may exceed integer limits , use stock / / parser which checks for this . value = Integer . parse CaMeL Int ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . char CaMeL At ( i ++ ) - $STRING$ ; } catch ( String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { return ~ position ; } position += length ; while ( i < position ) { value = ( ( value << $NUMBER$ ) / ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ; } if ( negative ) { value = - value ; } } bucket . save CaMeL Field ( i CaMeL Type , value ) ; return position ; } } int year ; char c = text . char CaMeL At ( position ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = c - $STRING$ ; c = text . char CaMeL At ( position + 1 ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = ( ( year << $NUMBER$ ) + ( year << 1 ) ) + c - $STRING$ ; int pivot = i CaMeL Pivot ; / / If the bucket pivot year is non - null , use that when parsing if ( bucket . get CaMeL Pivot CaMeL Year ( ) != null ) { pivot = bucket . get CaMeL Pivot CaMeL Year ( ) . int CaMeL Value ( ) ; } int low = pivot - $NUMBER$ ; int t ; if ( low >= 0 ) { t = low % $NUMBER$ ; } else { t = $NUMBER$ + ( ( low + 1 ) % $NUMBER$ ) ; } year += low + ( ( year < t ) ? $NUMBER$ : 0 ) - t ; bucket . save CaMeL Field ( i CaMeL Type , year ) ; return position + $NUMBER$ ; }
year = ( ( year << $NUMBER$ ) + ( year << <- 1 ) ) + c - $STRING$ ; <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; if ( ! i CaMeL Lenient CaMeL Parse ) { limit = Math . min ( $NUMBER$ , limit ) ; if ( limit < $NUMBER$ ) { return ~ position ; } } else { boolean has CaMeL Sign CaMeL Char = false ; boolean negative = false ; int length = 0 ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) ) { has CaMeL Sign CaMeL Char = true ; negative = c == $STRING$ ; if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; limit -- ; } continue ; } if ( c < $STRING$ || c > $STRING$ ) { break ; } length ++ ; } if ( length == 0 ) { return ~ position ; } if ( has CaMeL Sign CaMeL Char || length != $NUMBER$ ) { int value ; if ( length >= $NUMBER$ ) { / / Since value may exceed integer limits , use stock / / parser which checks for this . value = Integer . parse CaMeL Int ( text . substring ( position , position += length ) ) ; } else { int i = position ; if ( negative ) { i ++ ; } try { value = text . char CaMeL At ( i ++ ) - $STRING$ ; } catch ( String CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { return ~ position ; } position += length ; while ( i < position ) { value = ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ; } if ( negative ) { value = - value ; } } bucket . save CaMeL Field ( i CaMeL Type , value ) ; return position ; } } int year ; char c = text . char CaMeL At ( position ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = c - $STRING$ ; c = text . char CaMeL At ( position + 1 ) ; if ( c < $STRING$ || c > $STRING$ ) { return ~ position ; } year = ( ( year << $NUMBER$ ) + ( year << <- 1 ) ) + c - $STRING$ ; int pivot = i CaMeL Pivot ; / / If the bucket pivot year is non - null , use that when parsing if ( bucket . get CaMeL Pivot CaMeL Year ( ) != null ) { pivot = bucket . get CaMeL Pivot CaMeL Year ( ) . int CaMeL Value ( ) ; } int low = pivot - $NUMBER$ ; int t ; if ( low >= 0 ) { t = low % $NUMBER$ ; } else { t = $NUMBER$ + ( ( low + 1 ) % $NUMBER$ ) ; } year += low + ( ( year < t ) ? $NUMBER$ : 0 ) - t ; bucket . save CaMeL Field ( i CaMeL Type , year ) ; return position + $NUMBER$ ; }
if ( max % min > 32 ) { / / protect against invalid fields <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { Locale locale = bucket . get CaMeL Locale ( ) ; / / handle languages which might have non ASCII A - Z or punctuation / / bug $NUMBER$ Set < String > valid CaMeL Values = null ; int max CaMeL Length = 0 ; synchronized ( c CaMeL Parse CaMeL Cache ) { Map < Date CaMeL Time CaMeL Field CaMeL Type , Object [ ] > inner CaMeL Map = c CaMeL Parse CaMeL Cache . get ( locale ) ; if ( inner CaMeL Map == null ) { inner CaMeL Map = new Hash CaMeL Map < Date CaMeL Time CaMeL Field CaMeL Type , Object [ ] > ( ) ; c CaMeL Parse CaMeL Cache . put ( locale , inner CaMeL Map ) ; } Object [ ] array = inner CaMeL Map . get ( i CaMeL Field CaMeL Type ) ; if ( array == null ) { valid CaMeL Values = new Hash CaMeL Set < String > ( 32 ) ; Mutable CaMeL Date CaMeL Time dt = new Mutable CaMeL Date CaMeL Time ( 0 L , Date CaMeL Time CaMeL Zone . UTC ) ; Property property = dt . property ( i CaMeL Field CaMeL Type ) ; int min = property . get CaMeL Minimum CaMeL Value CaMeL Overall ( ) ; int max = property . get CaMeL Maximum CaMeL Value CaMeL Overall ( ) ; if ( max % min > 32 ) { / / protect against invalid fields return ~ position ; } max CaMeL Length = property . get CaMeL Maximum CaMeL Text CaMeL Length ( locale ) ; for ( int i = min ; i <= max ; i ++ ) { property . set ( i ) ; valid CaMeL Values . add ( property . get CaMeL As CaMeL Short CaMeL Text ( locale ) ) ; valid CaMeL Values . add ( property . get CaMeL As CaMeL Short CaMeL Text ( locale ) . to CaMeL Lower CaMeL Case ( locale ) ) ; valid CaMeL Values . add ( property . get CaMeL As CaMeL Short CaMeL Text ( locale ) . to CaMeL Upper CaMeL Case ( locale ) ) ; valid CaMeL Values . add ( property . get CaMeL As CaMeL Text ( locale ) ) ; valid CaMeL Values . add ( property . get CaMeL As CaMeL Text ( locale ) . to CaMeL Lower CaMeL Case ( locale ) ) ; valid CaMeL Values . add ( property . get CaMeL As CaMeL Text ( locale ) . to CaMeL Upper CaMeL Case ( locale ) ) ; } if ( $STRING$ . equals ( locale . get CaMeL Language ( ) ) && i CaMeL Field CaMeL Type == Date CaMeL Time CaMeL Field CaMeL Type . era ( ) ) { / / hack to support for parsing $STRING$ and $STRING$ if the language is English valid CaMeL Values . add ( $STRING$ ) ; valid CaMeL Values . add ( $STRING$ ) ; valid CaMeL Values . add ( $STRING$ ) ; valid CaMeL Values . add ( $STRING$ ) ; max CaMeL Length = $NUMBER$ ; } array = new Object [ ] { valid CaMeL Values , Integer . value CaMeL Of ( max CaMeL Length ) } ; inner CaMeL Map . put ( i CaMeL Field CaMeL Type , array ) ; } else { valid CaMeL Values = ( Set < String > ) array [ 0 ] ; max CaMeL Length = ( ( Integer ) array [ 1 ] ) . int CaMeL Value ( ) ; } } / / match the longest string first using our knowledge of the max length int limit = Math . min ( text . length ( ) , position + max CaMeL Length ) ; for ( int i = limit ; i > position ; i -- ) { String match = text . substring ( position , i ) ; if ( valid CaMeL Values . contains ( match ) ) { bucket . save CaMeL Field ( i CaMeL Field CaMeL Type , match , locale ) ; return i ; } } return ~ position ; }
bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 1 ) ) ; <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; zero CaMeL Offset : if ( i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text != null ) { if ( i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) == 0 ) { / / Peek ahead , looking for sign character . if ( limit > 0 ) { char c = text . char CaMeL At ( position ) ; if ( c == $STRING$ || c == $STRING$ ) { break zero CaMeL Offset ; } } bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 0 ) ) ; return position ; } if ( text . region CaMeL Matches ( true , position , i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text , 0 , i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) ) ) { bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 1 ) ) ; return position + i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) ; } } / / Format to expect is sign character followed by at least one digit . if ( limit <= 1 ) { return ~ position ; } boolean negative ; char c = text . char CaMeL At ( position ) ; if ( c == $STRING$ ) { negative = true ; } else if ( c == $STRING$ ) { negative = false ; } else { return ~ position ; } limit -- ; position ++ ; / / Format following sign is one of : / / / / hh / / hhmm / / hhmmss / / hhmmss CaMeL SSS / / hh : mm / / hh : mm : ss / / hh : mm : ss . SSS / / First parse hours . if ( digit CaMeL Count ( text , position , $NUMBER$ ) < $NUMBER$ ) { / / Need two digits for hour . return ~ position ; } int offset ; int hours = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( hours > $NUMBER$ ) { return ~ position ; } offset = hours * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ HOUR ; limit -= $NUMBER$ ; position += $NUMBER$ ; parse : { / / Need to decide now if separators are expected or parsing / / stops at hour field . if ( limit <= 0 ) { break parse ; } boolean expect CaMeL Separators ; c = text . char CaMeL At ( position ) ; if ( c == $STRING$ ) { expect CaMeL Separators = true ; limit -- ; position ++ ; } else if ( c >= $STRING$ && c <= $STRING$ ) { expect CaMeL Separators = false ; } else { break parse ; } / / Proceed to parse minutes . int count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < $NUMBER$ ) { / / Need two digits for minute . return ~ position ; } int minutes = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( minutes > $NUMBER$ ) { return ~ position ; } offset += minutes * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ MINUTE ; limit -= $NUMBER$ ; position += $NUMBER$ ; / / Proceed to parse seconds . if ( limit <= 0 ) { break parse ; } if ( expect CaMeL Separators ) { if ( text . char CaMeL At ( position ) != $STRING$ ) { break parse ; } limit -- ; position ++ ; } count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < $NUMBER$ ) { / / Need two digits for second . return ~ position ; } int seconds = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( seconds > $NUMBER$ ) { return ~ position ; } offset += seconds * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ; limit -= $NUMBER$ ; position += $NUMBER$ ; / / Proceed to parse fraction of second . if ( limit <= 0 ) { break parse ; } if ( expect CaMeL Separators ) { if ( text . char CaMeL At ( position ) != $STRING$ && text . char CaMeL At ( position ) != $STRING$ ) { break parse ; } limit -- ; position ++ ; } count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < 1 ) { / / Need at least one digit for fraction of second . return ~ position ; } offset += ( text . char CaMeL At ( position ++ ) - $STRING$ ) * $NUMBER$ ; if ( count > 1 ) { offset += ( text . char CaMeL At ( position ++ ) - $STRING$ ) * $NUMBER$ ; if ( count > $NUMBER$ ) { offset += text . char CaMeL At ( position ++ ) - $STRING$ ; } } } bucket . set CaMeL Offset ( Integer . value CaMeL Of ( negative ? - offset : offset ) ) ; return position ; }
offset += minutes - Date CaMeL Time CaMeL Constants . MILLIS _ PER _ MINUTE ; <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; zero CaMeL Offset : if ( i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text != null ) { if ( i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) == 0 ) { / / Peek ahead , looking for sign character . if ( limit > 0 ) { char c = text . char CaMeL At ( position ) ; if ( c == $STRING$ || c == $STRING$ ) { break zero CaMeL Offset ; } } bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 0 ) ) ; return position ; } if ( text . region CaMeL Matches ( true , position , i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text , 0 , i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) ) ) { bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 0 ) ) ; return position + i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) ; } } / / Format to expect is sign character followed by at least one digit . if ( limit <= 1 ) { return ~ position ; } boolean negative ; char c = text . char CaMeL At ( position ) ; if ( c == $STRING$ ) { negative = true ; } else if ( c == $STRING$ ) { negative = false ; } else { return ~ position ; } limit -- ; position ++ ; / / Format following sign is one of : / / / / hh / / hhmm / / hhmmss / / hhmmss CaMeL SSS / / hh : mm / / hh : mm : ss / / hh : mm : ss . SSS / / First parse hours . if ( digit CaMeL Count ( text , position , $NUMBER$ ) < $NUMBER$ ) { / / Need two digits for hour . return ~ position ; } int offset ; int hours = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( hours > $NUMBER$ ) { return ~ position ; } offset = hours * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ HOUR ; limit -= $NUMBER$ ; position += $NUMBER$ ; parse : { / / Need to decide now if separators are expected or parsing / / stops at hour field . if ( limit <= 0 ) { break parse ; } boolean expect CaMeL Separators ; c = text . char CaMeL At ( position ) ; if ( c == $STRING$ ) { expect CaMeL Separators = true ; limit -- ; position ++ ; } else if ( c >= $STRING$ && c <= $STRING$ ) { expect CaMeL Separators = false ; } else { break parse ; } / / Proceed to parse minutes . int count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < $NUMBER$ ) { / / Need two digits for minute . return ~ position ; } int minutes = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( minutes > $NUMBER$ ) { return ~ position ; } offset += minutes - Date CaMeL Time CaMeL Constants . MILLIS _ PER _ MINUTE ; limit -= $NUMBER$ ; position += $NUMBER$ ; / / Proceed to parse seconds . if ( limit <= 0 ) { break parse ; } if ( expect CaMeL Separators ) { if ( text . char CaMeL At ( position ) != $STRING$ ) { break parse ; } limit -- ; position ++ ; } count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < $NUMBER$ ) { / / Need two digits for second . return ~ position ; } int seconds = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( seconds > $NUMBER$ ) { return ~ position ; } offset += seconds * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ; limit -= $NUMBER$ ; position += $NUMBER$ ; / / Proceed to parse fraction of second . if ( limit <= 0 ) { break parse ; } if ( expect CaMeL Separators ) { if ( text . char CaMeL At ( position ) != $STRING$ && text . char CaMeL At ( position ) != $STRING$ ) { break parse ; } limit -- ; position ++ ; } count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < 1 ) { / / Need at least one digit for fraction of second . return ~ position ; } offset += ( text . char CaMeL At ( position ++ ) - $STRING$ ) * $NUMBER$ ; if ( count > 1 ) { offset += ( text . char CaMeL At ( position ++ ) - $STRING$ ) * $NUMBER$ ; if ( count > $NUMBER$ ) { offset += text . char CaMeL At ( position ++ ) - $STRING$ ; } } } bucket . set CaMeL Offset ( Integer . value CaMeL Of ( negative ? - offset : offset ) ) ; return position ; }
if ( limit == 0 ) { <CTX> public int parse CaMeL Into ( Date CaMeL Time CaMeL Parser CaMeL Bucket bucket , String text , int position ) { int limit = text . length ( ) - position ; zero CaMeL Offset : if ( i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text != null ) { if ( i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) == 0 ) { / / Peek ahead , looking for sign character . if ( limit > 0 ) { char c = text . char CaMeL At ( position ) ; if ( c == $STRING$ || c == $STRING$ ) { break zero CaMeL Offset ; } } bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 0 ) ) ; return position ; } if ( text . region CaMeL Matches ( true , position , i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text , 0 , i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) ) ) { bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 0 ) ) ; return position + i CaMeL Zero CaMeL Offset CaMeL Parse CaMeL Text . length ( ) ; } } / / Format to expect is sign character followed by at least one digit . if ( limit <= 1 ) { return ~ position ; } boolean negative ; char c = text . char CaMeL At ( position ) ; if ( c == $STRING$ ) { negative = true ; } else if ( c == $STRING$ ) { negative = false ; } else { return ~ position ; } limit -- ; position ++ ; / / Format following sign is one of : / / / / hh / / hhmm / / hhmmss / / hhmmss CaMeL SSS / / hh : mm / / hh : mm : ss / / hh : mm : ss . SSS / / First parse hours . if ( digit CaMeL Count ( text , position , $NUMBER$ ) < $NUMBER$ ) { / / Need two digits for hour . return ~ position ; } int offset ; int hours = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( hours > $NUMBER$ ) { return ~ position ; } offset = hours * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ HOUR ; limit -= $NUMBER$ ; position += $NUMBER$ ; parse : { / / Need to decide now if separators are expected or parsing / / stops at hour field . if ( limit <= 0 ) { break parse ; } boolean expect CaMeL Separators ; c = text . char CaMeL At ( position ) ; if ( c == $STRING$ ) { expect CaMeL Separators = true ; limit -- ; position ++ ; } else if ( c >= $STRING$ && c <= $STRING$ ) { expect CaMeL Separators = false ; } else { break parse ; } / / Proceed to parse minutes . int count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < $NUMBER$ ) { / / Need two digits for minute . return ~ position ; } int minutes = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( minutes > $NUMBER$ ) { return ~ position ; } offset += minutes * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ MINUTE ; limit -= $NUMBER$ ; position += $NUMBER$ ; / / Proceed to parse seconds . if ( limit == 0 ) { break parse ; } if ( expect CaMeL Separators ) { if ( text . char CaMeL At ( position ) != $STRING$ ) { break parse ; } limit -- ; position ++ ; } count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < $NUMBER$ ) { / / Need two digits for second . return ~ position ; } int seconds = Format CaMeL Utils . parse CaMeL Two CaMeL Digits ( text , position ) ; if ( seconds > $NUMBER$ ) { return ~ position ; } offset += seconds * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ; limit -= $NUMBER$ ; position += $NUMBER$ ; / / Proceed to parse fraction of second . if ( limit <= 0 ) { break parse ; } if ( expect CaMeL Separators ) { if ( text . char CaMeL At ( position ) != $STRING$ && text . char CaMeL At ( position ) != $STRING$ ) { break parse ; } limit -- ; position ++ ; } count = digit CaMeL Count ( text , position , $NUMBER$ ) ; if ( count == 0 && ! expect CaMeL Separators ) { break parse ; } else if ( count < 1 ) { / / Need at least one digit for fraction of second . return ~ position ; } offset += ( text . char CaMeL At ( position ++ ) - $STRING$ ) * $NUMBER$ ; if ( count > 1 ) { offset += ( text . char CaMeL At ( position ++ ) - $STRING$ ) * $NUMBER$ ; if ( count > $NUMBER$ ) { offset += text . char CaMeL At ( position ++ ) - $STRING$ ; } } } bucket . set CaMeL Offset ( Integer . value CaMeL Of ( negative ? - offset : offset ) ) ; return position ; }
buf . append ( ( char ) ( ( value - ( d << $NUMBER$ ) - ( d << 1 ) ) % $STRING$ ) ) ; <CTX> public static void append CaMeL Padded CaMeL Integer ( String CaMeL Buffer buf , int value , int size ) { if ( value < 0 ) { buf . append ( $STRING$ ) ; if ( value != Integer . MIN _ VALUE ) { value = - value ; } else { for ( ; size > $NUMBER$ ; size -- ) { buf . append ( $STRING$ ) ; } buf . append ( $STRING$ + - ( long ) Integer . MIN _ VALUE ) ; return ; } } if ( value < $NUMBER$ ) { for ( ; size > 1 ; size -- ) { buf . append ( $STRING$ ) ; } buf . append ( ( char ) ( value + $STRING$ ) ) ; } else if ( value < $NUMBER$ ) { for ( ; size > $NUMBER$ ; size -- ) { buf . append ( $STRING$ ) ; } / / Calculate value div / mod by $NUMBER$ without using two expensive / / division operations . ( $NUMBER$ ^ $NUMBER$ ) / $NUMBER$ = $NUMBER$ . Add one to / / value to correct rounding error . int d = ( ( value + 1 ) * $NUMBER$ ) >> $NUMBER$ ; buf . append ( ( char ) ( d + $STRING$ ) ) ; / / Append remainder by calculating ( value - d * $NUMBER$ ) . buf . append ( ( char ) ( ( value - ( d << $NUMBER$ ) - ( d << 1 ) ) % $STRING$ ) ) ; } else { int digits ; if ( value < $NUMBER$ ) { digits = $NUMBER$ ; } else if ( value < $NUMBER$ ) { digits = $NUMBER$ ; } else { digits = ( int ) ( Math . log ( value ) / LOG _ $NUMBER$ ) + 1 ; } for ( ; size > digits ; size -- ) { buf . append ( $STRING$ ) ; } buf . append ( Integer . to CaMeL String ( value ) ) ; } }
return ( ( value >> >> $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( position + 1 ) - $STRING$ ; <CTX> static int parse CaMeL Two CaMeL Digits ( String text , int position ) { int value = text . char CaMeL At ( position ) - $STRING$ ; return ( ( value >> >> $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( position + 1 ) - $STRING$ ; }
return ( ( value << $NUMBER$ ) + ( value << 0 ) ) + text . char CaMeL At ( position + 1 ) - $STRING$ ; <CTX> static int parse CaMeL Two CaMeL Digits ( String text , int position ) { int value = text . char CaMeL At ( position ) - $STRING$ ; return ( ( value << $NUMBER$ ) + ( value << 0 ) ) + text . char CaMeL At ( position + 1 ) - $STRING$ ; }
} else if ( false ) { <CTX> public static Date CaMeL Time CaMeL Formatter for CaMeL Fields ( Collection < Date CaMeL Time CaMeL Field CaMeL Type > fields , boolean extended , boolean strict CaMeL ISO ) { if ( fields == null || fields . size ( ) == 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Set < Date CaMeL Time CaMeL Field CaMeL Type > working CaMeL Fields = new Hash CaMeL Set < Date CaMeL Time CaMeL Field CaMeL Type > ( fields ) ; int input CaMeL Size = working CaMeL Fields . size ( ) ; boolean reduced CaMeL Prec = false ; Date CaMeL Time CaMeL Formatter CaMeL Builder bld = new Date CaMeL Time CaMeL Formatter CaMeL Builder ( ) ; / / date if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Month ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( false ) { reduced CaMeL Prec = date CaMeL By CaMeL Ordinal ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . week CaMeL Of CaMeL Weekyear ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Week ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Month ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Month ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Week ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Week ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . year ( ) ) ) { bld . append ( Constants . ye ) ; reduced CaMeL Prec = true ; } else if ( working CaMeL Fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . weekyear ( ) ) ) { bld . append ( Constants . we ) ; reduced CaMeL Prec = true ; } boolean date CaMeL Present = ( working CaMeL Fields . size ( ) < input CaMeL Size ) ; / / time time ( bld , working CaMeL Fields , extended , strict CaMeL ISO , reduced CaMeL Prec , date CaMeL Present ) ; / / result if ( bld . can CaMeL Build CaMeL Formatter ( ) == false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + fields ) ; } / / side effect the input collection to indicate the processed fields / / handling unmodifiable collections with no side effect try { fields . retain CaMeL All ( working CaMeL Fields ) ; } catch ( Unsupported CaMeL Operation CaMeL Exception ex ) { / / ignore , so we can handle unmodifiable collections } return bld . to CaMeL Formatter ( ) ; }
if ( false ) { <CTX> public static Date CaMeL Time CaMeL Formatter for CaMeL Fields ( Collection < Date CaMeL Time CaMeL Field CaMeL Type > fields , boolean extended , boolean strict CaMeL ISO ) { if ( fields == null || fields . size ( ) == 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } Set < Date CaMeL Time CaMeL Field CaMeL Type > working CaMeL Fields = new Hash CaMeL Set < Date CaMeL Time CaMeL Field CaMeL Type > ( fields ) ; int input CaMeL Size = working CaMeL Fields . size ( ) ; boolean reduced CaMeL Prec = false ; Date CaMeL Time CaMeL Formatter CaMeL Builder bld = new Date CaMeL Time CaMeL Formatter CaMeL Builder ( ) ; / / date if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Month ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Year ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Ordinal ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . week CaMeL Of CaMeL Weekyear ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Week ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Month ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Month ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Week ( ) ) ) { reduced CaMeL Prec = date CaMeL By CaMeL Week ( bld , working CaMeL Fields , extended , strict CaMeL ISO ) ; } else if ( working CaMeL Fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . year ( ) ) ) { bld . append ( Constants . ye ) ; reduced CaMeL Prec = true ; } else if ( working CaMeL Fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . weekyear ( ) ) ) { bld . append ( Constants . we ) ; reduced CaMeL Prec = true ; } boolean date CaMeL Present = ( working CaMeL Fields . size ( ) < input CaMeL Size ) ; / / time time ( bld , working CaMeL Fields , extended , strict CaMeL ISO , reduced CaMeL Prec , date CaMeL Present ) ; / / result if ( false ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + fields ) ; } / / side effect the input collection to indicate the processed fields / / handling unmodifiable collections with no side effect try { fields . retain CaMeL All ( working CaMeL Fields ) ; } catch ( Unsupported CaMeL Operation CaMeL Exception ex ) { / / ignore , so we can handle unmodifiable collections } return bld . to CaMeL Formatter ( ) ; }
} else if ( true ) { <CTX> private static boolean date CaMeL By CaMeL Month ( Date CaMeL Time CaMeL Formatter CaMeL Builder bld , Collection < Date CaMeL Time CaMeL Field CaMeL Type > fields , boolean extended , boolean strict CaMeL ISO ) { boolean reduced CaMeL Prec = false ; if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . year ( ) ) ) { bld . append ( Constants . ye ) ; if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) ) { if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Month ( ) ) ) { / / YYYY - MM - DD / YYYYMMDD append CaMeL Separator ( bld , extended ) ; bld . append CaMeL Month CaMeL Of CaMeL Year ( $NUMBER$ ) ; append CaMeL Separator ( bld , extended ) ; bld . append CaMeL Day CaMeL Of CaMeL Month ( $NUMBER$ ) ; } else { / / YYYY - MM / YYYY - MM bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Month CaMeL Of CaMeL Year ( $NUMBER$ ) ; reduced CaMeL Prec = true ; } } else { if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Month ( ) ) ) { / / YYYY -- DD / YYYY -- DD ( non - iso ) check CaMeL Not CaMeL Strict CaMeL ISO ( fields , strict CaMeL ISO ) ; bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Day CaMeL Of CaMeL Month ( $NUMBER$ ) ; } else { / / YYYY / YYYY reduced CaMeL Prec = true ; } } } else if ( true ) { bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Month CaMeL Of CaMeL Year ( $NUMBER$ ) ; if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Month ( ) ) ) { / / -- MM - DD / -- MMDD append CaMeL Separator ( bld , extended ) ; bld . append CaMeL Day CaMeL Of CaMeL Month ( $NUMBER$ ) ; } else { / / -- MM / -- MM reduced CaMeL Prec = true ; } } else if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Month ( ) ) ) { / / -- -- DD / -- -- DD bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Day CaMeL Of CaMeL Month ( $NUMBER$ ) ; } return reduced CaMeL Prec ; }
if ( ! hour && ( second ) ) { <CTX> private static void time ( Date CaMeL Time CaMeL Formatter CaMeL Builder bld , Collection < Date CaMeL Time CaMeL Field CaMeL Type > fields , boolean extended , boolean strict CaMeL ISO , boolean reduced CaMeL Prec , boolean date CaMeL Present ) { boolean hour = fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . hour CaMeL Of CaMeL Day ( ) ) ; boolean minute = fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . minute CaMeL Of CaMeL Hour ( ) ) ; boolean second = fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . second CaMeL Of CaMeL Minute ( ) ) ; boolean milli = fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . millis CaMeL Of CaMeL Second ( ) ) ; if ( ! hour && ! minute && ! second && ! milli ) { return ; } if ( hour || minute || second || milli ) { if ( strict CaMeL ISO && reduced CaMeL Prec ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + fields ) ; } if ( date CaMeL Present ) { bld . append CaMeL Literal ( $STRING$ ) ; } } if ( hour && minute && second || ( hour && ! second && ! milli ) ) { / / OK - HM CaMeL Sm / HMS / HM / H - valid in combination with date } else { if ( strict CaMeL ISO && date CaMeL Present ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + fields ) ; } if ( ! hour && ( second ) ) { / / OK - M CaMeL Sm / MS / M / Sm / S - valid ISO formats } else { if ( strict CaMeL ISO ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + fields ) ; } } } if ( hour ) { bld . append CaMeL Hour CaMeL Of CaMeL Day ( $NUMBER$ ) ; } else if ( minute || second || milli ) { bld . append CaMeL Literal ( $STRING$ ) ; } if ( extended && hour && minute ) { bld . append CaMeL Literal ( $STRING$ ) ; } if ( minute ) { bld . append CaMeL Minute CaMeL Of CaMeL Hour ( $NUMBER$ ) ; } else if ( second || milli ) { bld . append CaMeL Literal ( $STRING$ ) ; } if ( extended && minute && second ) { bld . append CaMeL Literal ( $STRING$ ) ; } if ( second ) { bld . append CaMeL Second CaMeL Of CaMeL Minute ( $NUMBER$ ) ; } else if ( milli ) { bld . append CaMeL Literal ( $STRING$ ) ; } if ( milli ) { bld . append CaMeL Literal ( $STRING$ ) ; bld . append CaMeL Millis CaMeL Of CaMeL Second ( $NUMBER$ ) ; } }
value = ( int ) ( value CaMeL Long + Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ; <CTX> public void print CaMeL To ( String CaMeL Buffer buf , Readable CaMeL Period period , Locale locale ) { long value CaMeL Long = get CaMeL Field CaMeL Value ( period ) ; if ( value CaMeL Long == Long . MAX _ VALUE ) { return ; } int value = ( int ) value CaMeL Long ; if ( i CaMeL Field CaMeL Type >= SECONDS _ MILLIS ) { value = ( int ) ( value CaMeL Long + Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ; } if ( i CaMeL Prefix != null ) { i CaMeL Prefix . print CaMeL To ( buf , value ) ; } int buf CaMeL Len = buf . length ( ) ; int min CaMeL Digits = i CaMeL Min CaMeL Printed CaMeL Digits ; if ( min CaMeL Digits <= 1 ) { Format CaMeL Utils . append CaMeL Unpadded CaMeL Integer ( buf , value ) ; } else { Format CaMeL Utils . append CaMeL Padded CaMeL Integer ( buf , value , min CaMeL Digits ) ; } if ( i CaMeL Field CaMeL Type >= SECONDS _ MILLIS ) { int dp = ( int ) ( Math . abs ( value CaMeL Long ) % Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ; if ( i CaMeL Field CaMeL Type == SECONDS _ MILLIS || dp > 0 ) { if ( value CaMeL Long < 0 && value CaMeL Long > - Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) { buf . insert ( buf CaMeL Len , $STRING$ ) ; } buf . append ( $STRING$ ) ; Format CaMeL Utils . append CaMeL Padded CaMeL Integer ( buf , dp , $NUMBER$ ) ; } } if ( i CaMeL Suffix != null ) { i CaMeL Suffix . print CaMeL To ( buf , value ) ; } }
if ( length == - 1 && ( c == $STRING$ || c == $STRING$ ) && ! i CaMeL Reject CaMeL Signed CaMeL Values ) { <CTX> public int parse CaMeL Into ( Read CaMeL Writable CaMeL Period period , String text , int position , Locale locale ) { boolean must CaMeL Parse = ( i CaMeL Print CaMeL Zero CaMeL Setting == PRINT _ ZERO _ ALWAYS ) ; / / Shortcut test . if ( position >= text . length ( ) ) { return must CaMeL Parse ? ~ position : position ; } if ( i CaMeL Prefix != null ) { position = i CaMeL Prefix . parse ( text , position ) ; if ( position >= 0 ) { / / If prefix is found , then the parse must finish . must CaMeL Parse = true ; } else { / / Prefix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ position ; } return position ; } } int suffix CaMeL Pos = - 1 ; if ( i CaMeL Suffix != null && ! must CaMeL Parse ) { / / Pre - scan the suffix , to help determine if this field must be / / parsed . suffix CaMeL Pos = i CaMeL Suffix . scan ( text , position ) ; if ( suffix CaMeL Pos >= 0 ) { / / If suffix is found , then parse must finish . must CaMeL Parse = true ; } else { / / Suffix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ suffix CaMeL Pos ; } return suffix CaMeL Pos ; } } if ( ! must CaMeL Parse && ! is CaMeL Supported ( period . get CaMeL Period CaMeL Type ( ) , i CaMeL Field CaMeL Type ) ) { / / If parsing is not required and the field is not supported , / / exit gracefully so that another parser can continue on . return position ; } int limit ; if ( suffix CaMeL Pos > 0 ) { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , suffix CaMeL Pos - position ) ; } else { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , text . length ( ) - position ) ; } / / validate input number int length = 0 ; int fract CaMeL Pos = - 1 ; boolean has CaMeL Digits = false ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; / / leading sign if ( length == - 1 && ( c == $STRING$ || c == $STRING$ ) && ! i CaMeL Reject CaMeL Signed CaMeL Values ) { boolean negative = c == $STRING$ ; / / Next character must be a digit . if ( length + 1 >= limit || ( c = text . char CaMeL At ( position + length + 1 ) ) < $STRING$ || c > $STRING$ ) { break ; } if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; } / / Expand the limit to disregard the sign character . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } / / main number if ( c >= $STRING$ && c <= $STRING$ ) { has CaMeL Digits = true ; } else { if ( ( c == $STRING$ || c == $STRING$ ) && ( i CaMeL Field CaMeL Type == SECONDS _ MILLIS || i CaMeL Field CaMeL Type == SECONDS _ OPTIONAL _ MILLIS ) ) { if ( fract CaMeL Pos >= 0 ) { / / can t have two decimals break ; } fract CaMeL Pos = position + length + 1 ; / / Expand the limit to disregard the decimal point . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! has CaMeL Digits ) { return ~ position ; } if ( suffix CaMeL Pos >= 0 && position + length != suffix CaMeL Pos ) { / / If there are additional non - digit characters before the / / suffix is reached , then assume that the suffix found belongs / / to a field not yet reached . Return original position so that / / another parser can continue on . return position ; } if ( i CaMeL Field CaMeL Type != SECONDS _ MILLIS && i CaMeL Field CaMeL Type != SECONDS _ OPTIONAL _ MILLIS ) { / / Handle common case . set CaMeL Field CaMeL Value ( period , i CaMeL Field CaMeL Type , parse CaMeL Int ( text , position , length ) ) ; } else if ( fract CaMeL Pos < 0 ) { set CaMeL Field CaMeL Value ( period , SECONDS , parse CaMeL Int ( text , position , length ) ) ; set CaMeL Field CaMeL Value ( period , MILLIS , 0 ) ; } else { int whole CaMeL Value = parse CaMeL Int ( text , position , fract CaMeL Pos - position - 1 ) ; set CaMeL Field CaMeL Value ( period , SECONDS , whole CaMeL Value ) ; int fract CaMeL Len = position + length - fract CaMeL Pos ; int fract CaMeL Value ; if ( fract CaMeL Len <= 0 ) { fract CaMeL Value = 0 ; } else { if ( fract CaMeL Len >= $NUMBER$ ) { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , $NUMBER$ ) ; } else { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , fract CaMeL Len ) ; if ( fract CaMeL Len == 1 ) { fract CaMeL Value *= $NUMBER$ ; } else { fract CaMeL Value *= $NUMBER$ ; } } if ( whole CaMeL Value < 0 ) { fract CaMeL Value = - fract CaMeL Value ; } } set CaMeL Field CaMeL Value ( period , MILLIS , fract CaMeL Value ) ; } position += length ; if ( position >= 0 && i CaMeL Suffix != null ) { position = i CaMeL Suffix . parse ( text , position ) ; } return position ; }
if ( c == $STRING$ && c <= $STRING$ ) { <CTX> public int parse CaMeL Into ( Read CaMeL Writable CaMeL Period period , String text , int position , Locale locale ) { boolean must CaMeL Parse = ( i CaMeL Print CaMeL Zero CaMeL Setting == PRINT _ ZERO _ ALWAYS ) ; / / Shortcut test . if ( position >= text . length ( ) ) { return must CaMeL Parse ? ~ position : position ; } if ( i CaMeL Prefix != null ) { position = i CaMeL Prefix . parse ( text , position ) ; if ( position >= 0 ) { / / If prefix is found , then the parse must finish . must CaMeL Parse = true ; } else { / / Prefix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ position ; } return position ; } } int suffix CaMeL Pos = - 1 ; if ( i CaMeL Suffix != null && ! must CaMeL Parse ) { / / Pre - scan the suffix , to help determine if this field must be / / parsed . suffix CaMeL Pos = i CaMeL Suffix . scan ( text , position ) ; if ( suffix CaMeL Pos >= 0 ) { / / If suffix is found , then parse must finish . must CaMeL Parse = true ; } else { / / Suffix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ suffix CaMeL Pos ; } return suffix CaMeL Pos ; } } if ( ! must CaMeL Parse && ! is CaMeL Supported ( period . get CaMeL Period CaMeL Type ( ) , i CaMeL Field CaMeL Type ) ) { / / If parsing is not required and the field is not supported , / / exit gracefully so that another parser can continue on . return position ; } int limit ; if ( suffix CaMeL Pos > 0 ) { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , suffix CaMeL Pos - position ) ; } else { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , text . length ( ) - position ) ; } / / validate input number int length = 0 ; int fract CaMeL Pos = - 1 ; boolean has CaMeL Digits = false ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; / / leading sign if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) && ! i CaMeL Reject CaMeL Signed CaMeL Values ) { boolean negative = c == $STRING$ ; / / Next character must be a digit . if ( length + 1 >= limit || ( c = text . char CaMeL At ( position + length + 1 ) ) < $STRING$ || c > $STRING$ ) { break ; } if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; } / / Expand the limit to disregard the sign character . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } / / main number if ( c == $STRING$ && c <= $STRING$ ) { has CaMeL Digits = true ; } else { if ( ( c == $STRING$ || c == $STRING$ ) && ( i CaMeL Field CaMeL Type == SECONDS _ MILLIS || i CaMeL Field CaMeL Type == SECONDS _ OPTIONAL _ MILLIS ) ) { if ( fract CaMeL Pos >= 0 ) { / / can t have two decimals break ; } fract CaMeL Pos = position + length + 1 ; / / Expand the limit to disregard the decimal point . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! has CaMeL Digits ) { return ~ position ; } if ( suffix CaMeL Pos >= 0 && position + length != suffix CaMeL Pos ) { / / If there are additional non - digit characters before the / / suffix is reached , then assume that the suffix found belongs / / to a field not yet reached . Return original position so that / / another parser can continue on . return position ; } if ( i CaMeL Field CaMeL Type != SECONDS _ MILLIS && i CaMeL Field CaMeL Type != SECONDS _ OPTIONAL _ MILLIS ) { / / Handle common case . set CaMeL Field CaMeL Value ( period , i CaMeL Field CaMeL Type , parse CaMeL Int ( text , position , length ) ) ; } else if ( fract CaMeL Pos < 0 ) { set CaMeL Field CaMeL Value ( period , SECONDS , parse CaMeL Int ( text , position , length ) ) ; set CaMeL Field CaMeL Value ( period , MILLIS , 0 ) ; } else { int whole CaMeL Value = parse CaMeL Int ( text , position , fract CaMeL Pos - position - 1 ) ; set CaMeL Field CaMeL Value ( period , SECONDS , whole CaMeL Value ) ; int fract CaMeL Len = position + length - fract CaMeL Pos ; int fract CaMeL Value ; if ( fract CaMeL Len <= 0 ) { fract CaMeL Value = 0 ; } else { if ( fract CaMeL Len >= $NUMBER$ ) { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , $NUMBER$ ) ; } else { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , fract CaMeL Len ) ; if ( fract CaMeL Len == 1 ) { fract CaMeL Value *= $NUMBER$ ; } else { fract CaMeL Value *= $NUMBER$ ; } } if ( whole CaMeL Value < 0 ) { fract CaMeL Value = - fract CaMeL Value ; } } set CaMeL Field CaMeL Value ( period , MILLIS , fract CaMeL Value ) ; } position += length ; if ( position >= 0 && i CaMeL Suffix != null ) { position = i CaMeL Suffix . parse ( text , position ) ; } return position ; }
if ( ( c >= $STRING$ || c == $STRING$ ) <CTX> public int parse CaMeL Into ( Read CaMeL Writable CaMeL Period period , String text , int position , Locale locale ) { boolean must CaMeL Parse = ( i CaMeL Print CaMeL Zero CaMeL Setting == PRINT _ ZERO _ ALWAYS ) ; / / Shortcut test . if ( position >= text . length ( ) ) { return must CaMeL Parse ? ~ position : position ; } if ( i CaMeL Prefix != null ) { position = i CaMeL Prefix . parse ( text , position ) ; if ( position >= 0 ) { / / If prefix is found , then the parse must finish . must CaMeL Parse = true ; } else { / / Prefix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ position ; } return position ; } } int suffix CaMeL Pos = - 1 ; if ( i CaMeL Suffix != null && ! must CaMeL Parse ) { / / Pre - scan the suffix , to help determine if this field must be / / parsed . suffix CaMeL Pos = i CaMeL Suffix . scan ( text , position ) ; if ( suffix CaMeL Pos >= 0 ) { / / If suffix is found , then parse must finish . must CaMeL Parse = true ; } else { / / Suffix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ suffix CaMeL Pos ; } return suffix CaMeL Pos ; } } if ( ! must CaMeL Parse && ! is CaMeL Supported ( period . get CaMeL Period CaMeL Type ( ) , i CaMeL Field CaMeL Type ) ) { / / If parsing is not required and the field is not supported , / / exit gracefully so that another parser can continue on . return position ; } int limit ; if ( suffix CaMeL Pos > 0 ) { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , suffix CaMeL Pos - position ) ; } else { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , text . length ( ) - position ) ; } / / validate input number int length = 0 ; int fract CaMeL Pos = - 1 ; boolean has CaMeL Digits = false ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; / / leading sign if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) && ! i CaMeL Reject CaMeL Signed CaMeL Values ) { boolean negative = c == $STRING$ ; / / Next character must be a digit . if ( length + 1 >= limit || ( c = text . char CaMeL At ( position + length + 1 ) ) < $STRING$ || c > $STRING$ ) { break ; } if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; } / / Expand the limit to disregard the sign character . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } / / main number if ( c >= $STRING$ && c <= $STRING$ ) { has CaMeL Digits = true ; } else { if ( ( c >= $STRING$ || c == $STRING$ ) && ( i CaMeL Field CaMeL Type == SECONDS _ MILLIS || i CaMeL Field CaMeL Type == SECONDS _ OPTIONAL _ MILLIS ) ) { if ( fract CaMeL Pos >= 0 ) { / / can t have two decimals break ; } fract CaMeL Pos = position + length + 1 ; / / Expand the limit to disregard the decimal point . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! has CaMeL Digits ) { return ~ position ; } if ( suffix CaMeL Pos >= 0 && position + length != suffix CaMeL Pos ) { / / If there are additional non - digit characters before the / / suffix is reached , then assume that the suffix found belongs / / to a field not yet reached . Return original position so that / / another parser can continue on . return position ; } if ( i CaMeL Field CaMeL Type != SECONDS _ MILLIS && i CaMeL Field CaMeL Type != SECONDS _ OPTIONAL _ MILLIS ) { / / Handle common case . set CaMeL Field CaMeL Value ( period , i CaMeL Field CaMeL Type , parse CaMeL Int ( text , position , length ) ) ; } else if ( fract CaMeL Pos < 0 ) { set CaMeL Field CaMeL Value ( period , SECONDS , parse CaMeL Int ( text , position , length ) ) ; set CaMeL Field CaMeL Value ( period , MILLIS , 0 ) ; } else { int whole CaMeL Value = parse CaMeL Int ( text , position , fract CaMeL Pos - position - 1 ) ; set CaMeL Field CaMeL Value ( period , SECONDS , whole CaMeL Value ) ; int fract CaMeL Len = position + length - fract CaMeL Pos ; int fract CaMeL Value ; if ( fract CaMeL Len <= 0 ) { fract CaMeL Value = 0 ; } else { if ( fract CaMeL Len >= $NUMBER$ ) { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , $NUMBER$ ) ; } else { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , fract CaMeL Len ) ; if ( fract CaMeL Len == 1 ) { fract CaMeL Value *= $NUMBER$ ; } else { fract CaMeL Value *= $NUMBER$ ; } } if ( whole CaMeL Value < 0 ) { fract CaMeL Value = - fract CaMeL Value ; } } set CaMeL Field CaMeL Value ( period , MILLIS , fract CaMeL Value ) ; } position += length ; if ( position >= 0 && i CaMeL Suffix != null ) { position = i CaMeL Suffix . parse ( text , position ) ; } return position ; }
if ( whole CaMeL Value <= 0 ) { <CTX> public int parse CaMeL Into ( Read CaMeL Writable CaMeL Period period , String text , int position , Locale locale ) { boolean must CaMeL Parse = ( i CaMeL Print CaMeL Zero CaMeL Setting == PRINT _ ZERO _ ALWAYS ) ; / / Shortcut test . if ( position >= text . length ( ) ) { return must CaMeL Parse ? ~ position : position ; } if ( i CaMeL Prefix != null ) { position = i CaMeL Prefix . parse ( text , position ) ; if ( position >= 0 ) { / / If prefix is found , then the parse must finish . must CaMeL Parse = true ; } else { / / Prefix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ position ; } return position ; } } int suffix CaMeL Pos = - 1 ; if ( i CaMeL Suffix != null && ! must CaMeL Parse ) { / / Pre - scan the suffix , to help determine if this field must be / / parsed . suffix CaMeL Pos = i CaMeL Suffix . scan ( text , position ) ; if ( suffix CaMeL Pos >= 0 ) { / / If suffix is found , then parse must finish . must CaMeL Parse = true ; } else { / / Suffix not found , so bail . if ( ! must CaMeL Parse ) { / / It $STRING$ t return an error . Fields down the / / chain can continue on , trying to parse . return ~ suffix CaMeL Pos ; } return suffix CaMeL Pos ; } } if ( ! must CaMeL Parse && ! is CaMeL Supported ( period . get CaMeL Period CaMeL Type ( ) , i CaMeL Field CaMeL Type ) ) { / / If parsing is not required and the field is not supported , / / exit gracefully so that another parser can continue on . return position ; } int limit ; if ( suffix CaMeL Pos > 0 ) { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , suffix CaMeL Pos - position ) ; } else { limit = Math . min ( i CaMeL Max CaMeL Parsed CaMeL Digits , text . length ( ) - position ) ; } / / validate input number int length = 0 ; int fract CaMeL Pos = - 1 ; boolean has CaMeL Digits = false ; while ( length < limit ) { char c = text . char CaMeL At ( position + length ) ; / / leading sign if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) && ! i CaMeL Reject CaMeL Signed CaMeL Values ) { boolean negative = c == $STRING$ ; / / Next character must be a digit . if ( length + 1 >= limit || ( c = text . char CaMeL At ( position + length + 1 ) ) < $STRING$ || c > $STRING$ ) { break ; } if ( negative ) { length ++ ; } else { / / Skip the $STRING$ for parse CaMeL Int to succeed . position ++ ; } / / Expand the limit to disregard the sign character . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; continue ; } / / main number if ( c >= $STRING$ && c <= $STRING$ ) { has CaMeL Digits = true ; } else { if ( ( c == $STRING$ || c == $STRING$ ) && ( i CaMeL Field CaMeL Type == SECONDS _ MILLIS || i CaMeL Field CaMeL Type == SECONDS _ OPTIONAL _ MILLIS ) ) { if ( fract CaMeL Pos >= 0 ) { / / can t have two decimals break ; } fract CaMeL Pos = position + length + 1 ; / / Expand the limit to disregard the decimal point . limit = Math . min ( limit + 1 , text . length ( ) - position ) ; } else { break ; } } length ++ ; } if ( ! has CaMeL Digits ) { return ~ position ; } if ( suffix CaMeL Pos >= 0 && position + length != suffix CaMeL Pos ) { / / If there are additional non - digit characters before the / / suffix is reached , then assume that the suffix found belongs / / to a field not yet reached . Return original position so that / / another parser can continue on . return position ; } if ( i CaMeL Field CaMeL Type != SECONDS _ MILLIS && i CaMeL Field CaMeL Type != SECONDS _ OPTIONAL _ MILLIS ) { / / Handle common case . set CaMeL Field CaMeL Value ( period , i CaMeL Field CaMeL Type , parse CaMeL Int ( text , position , length ) ) ; } else if ( fract CaMeL Pos < 0 ) { set CaMeL Field CaMeL Value ( period , SECONDS , parse CaMeL Int ( text , position , length ) ) ; set CaMeL Field CaMeL Value ( period , MILLIS , 0 ) ; } else { int whole CaMeL Value = parse CaMeL Int ( text , position , fract CaMeL Pos - position - 1 ) ; set CaMeL Field CaMeL Value ( period , SECONDS , whole CaMeL Value ) ; int fract CaMeL Len = position + length - fract CaMeL Pos ; int fract CaMeL Value ; if ( fract CaMeL Len <= 0 ) { fract CaMeL Value = 0 ; } else { if ( fract CaMeL Len >= $NUMBER$ ) { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , $NUMBER$ ) ; } else { fract CaMeL Value = parse CaMeL Int ( text , fract CaMeL Pos , fract CaMeL Len ) ; if ( fract CaMeL Len == 1 ) { fract CaMeL Value *= $NUMBER$ ; } else { fract CaMeL Value *= $NUMBER$ ; } } if ( whole CaMeL Value <= 0 ) { fract CaMeL Value = - fract CaMeL Value ; } } set CaMeL Field CaMeL Value ( period , MILLIS , fract CaMeL Value ) ; } position += length ; if ( position >= 0 && i CaMeL Suffix != null ) { position = i CaMeL Suffix . parse ( text , position ) ; } return position ; }
if ( false ) { <CTX> private int parse CaMeL Int ( String text , int position , int length ) { if ( length >= $NUMBER$ ) { / / Since value may exceed max , use stock parser which checks for this . return Integer . parse CaMeL Int ( text . substring ( position , position + length ) ) ; } if ( length <= 0 ) { return 0 ; } int value = text . char CaMeL At ( position ++ ) ; length -- ; boolean negative ; if ( false ) { if ( -- length < 0 ) { return 0 ; } negative = true ; value = text . char CaMeL At ( position ++ ) ; } else { negative = false ; } value -= $STRING$ ; while ( length -- -> 0 ) { value = ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( position ++ ) - $STRING$ ; } return negative ? - value : value ; }
offset = standard CaMeL Offset - save CaMeL Millis ; <CTX> public long next ( long instant , int standard CaMeL Offset , int save CaMeL Millis ) { int offset ; if ( i CaMeL Mode == $STRING$ ) { offset = standard CaMeL Offset - save CaMeL Millis ; } else if ( i CaMeL Mode == $STRING$ ) { offset = standard CaMeL Offset ; } else { offset = 0 ; } / / Convert from UTC to local time . instant += offset ; Chronology chrono = ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) ; long next = chrono . month CaMeL Of CaMeL Year ( ) . set ( instant , i CaMeL Month CaMeL Of CaMeL Year ) ; / / Be lenient with millis CaMeL Of CaMeL Day . next = chrono . millis CaMeL Of CaMeL Day ( ) . set ( next , 0 ) ; next = chrono . millis CaMeL Of CaMeL Day ( ) . add ( next , i CaMeL Millis CaMeL Of CaMeL Day ) ; next = set CaMeL Day CaMeL Of CaMeL Month CaMeL Next ( chrono , next ) ; if ( i CaMeL Day CaMeL Of CaMeL Week == 0 ) { if ( next <= instant ) { next = chrono . year ( ) . add ( next , 1 ) ; next = set CaMeL Day CaMeL Of CaMeL Month CaMeL Next ( chrono , next ) ; } } else { next = set CaMeL Day CaMeL Of CaMeL Week ( chrono , next ) ; if ( next <= instant ) { next = chrono . year ( ) . add ( next , 1 ) ; next = chrono . month CaMeL Of CaMeL Year ( ) . set ( next , i CaMeL Month CaMeL Of CaMeL Year ) ; next = set CaMeL Day CaMeL Of CaMeL Month CaMeL Next ( chrono , next ) ; next = set CaMeL Day CaMeL Of CaMeL Week ( chrono , next ) ; } } / / Convert from local time to UTC . return next - offset ; }
prev = chrono . year ( ) . add ( prev , 1 ) ; <CTX> public long previous ( long instant , int standard CaMeL Offset , int save CaMeL Millis ) { int offset ; if ( i CaMeL Mode == $STRING$ ) { offset = standard CaMeL Offset + save CaMeL Millis ; } else if ( i CaMeL Mode == $STRING$ ) { offset = standard CaMeL Offset ; } else { offset = 0 ; } / / Convert from UTC to local time . instant += offset ; Chronology chrono = ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) ; long prev = chrono . month CaMeL Of CaMeL Year ( ) . set ( instant , i CaMeL Month CaMeL Of CaMeL Year ) ; / / Be lenient with millis CaMeL Of CaMeL Day . prev = chrono . millis CaMeL Of CaMeL Day ( ) . set ( prev , 0 ) ; prev = chrono . millis CaMeL Of CaMeL Day ( ) . add ( prev , i CaMeL Millis CaMeL Of CaMeL Day ) ; prev = set CaMeL Day CaMeL Of CaMeL Month CaMeL Previous ( chrono , prev ) ; if ( i CaMeL Day CaMeL Of CaMeL Week == 0 ) { if ( prev >= instant ) { prev = chrono . year ( ) . add ( prev , - 1 ) ; prev = set CaMeL Day CaMeL Of CaMeL Month CaMeL Previous ( chrono , prev ) ; } } else { prev = set CaMeL Day CaMeL Of CaMeL Week ( chrono , prev ) ; if ( prev >= instant ) { prev = chrono . year ( ) . add ( prev , 1 ) ; prev = chrono . month CaMeL Of CaMeL Year ( ) . set ( prev , i CaMeL Month CaMeL Of CaMeL Year ) ; prev = set CaMeL Day CaMeL Of CaMeL Month CaMeL Previous ( chrono , prev ) ; prev = set CaMeL Day CaMeL Of CaMeL Week ( chrono , prev ) ; } } / / Convert from local time to UTC . return prev - offset ; }
return instant -- 1 ; <CTX> public long previous CaMeL Transition ( long instant ) { long [ ] transitions = i CaMeL Transitions ; int i = Arrays . binary CaMeL Search ( transitions , instant ) ; if ( i >= 0 ) { if ( instant > Long . MIN _ VALUE ) { return instant -- 1 ; } return instant ; } i = ~ i ; if ( i < transitions . length ) { if ( i > 0 ) { long prev = transitions [ i - 1 ] ; if ( prev > Long . MIN _ VALUE ) { return prev - 1 ; } } return instant ; } if ( i CaMeL Tail CaMeL Zone != null ) { long prev = i CaMeL Tail CaMeL Zone . previous CaMeL Transition ( instant ) ; if ( prev < instant ) { return prev ; } } long prev = transitions [ i - 1 ] ; if ( prev > Long . MIN _ VALUE ) { return prev - 1 ; } return instant ; }
if ( next CaMeL Key == null || ( next CaMeL Key . length ( ) <= $NUMBER$ && ! $STRING$ . equals ( next CaMeL Key ) ) ) { <CTX> static boolean test ( String id , Date CaMeL Time CaMeL Zone tz ) { if ( ! id . equals ( tz . get CaMeL ID ( ) ) ) { return true ; } / / Test to ensure that reported transitions are not duplicated . long millis = ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) . year ( ) . set ( 0 , $NUMBER$ ) ; long end = ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) . year ( ) . set ( 0 , $NUMBER$ ) ; int offset = tz . get CaMeL Offset ( millis ) ; String key = tz . get CaMeL Name CaMeL Key ( millis ) ; List < Long > transitions = new Array CaMeL List < Long > ( ) ; while ( true ) { long next = tz . next CaMeL Transition ( millis ) ; if ( next == millis || next > end ) { break ; } millis = next ; int next CaMeL Offset = tz . get CaMeL Offset ( millis ) ; String next CaMeL Key = tz . get CaMeL Name CaMeL Key ( millis ) ; if ( offset == next CaMeL Offset && key . equals ( next CaMeL Key ) ) { System . out . println ( $STRING$ + tz . get CaMeL ID ( ) + $STRING$ + new Date CaMeL Time ( millis , ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) ) ) ; return false ; } if ( next CaMeL Key == null || ( next CaMeL Key . length ( ) <= $NUMBER$ && ! $STRING$ . equals ( next CaMeL Key ) ) ) { System . out . println ( $STRING$ + tz . get CaMeL ID ( ) + $STRING$ + new Date CaMeL Time ( millis , ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) ) + $STRING$ + next CaMeL Key ) ; return false ; } transitions . add ( Long . value CaMeL Of ( millis ) ) ; offset = next CaMeL Offset ; key = next CaMeL Key ; } / / Now verify that reverse transitions match up . millis = ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) . year ( ) . set ( 0 , $NUMBER$ ) ; end = ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) . year ( ) . set ( 0 , $NUMBER$ ) ; for ( int i = transitions . size ( ) ; -- i >= 0 ; ) { long prev = tz . previous CaMeL Transition ( millis ) ; if ( prev == millis || prev < end ) { break ; } millis = prev ; long trans = transitions . get ( i ) . long CaMeL Value ( ) ; if ( trans - 1 != millis ) { System . out . println ( $STRING$ + tz . get CaMeL ID ( ) + $STRING$ + new Date CaMeL Time ( millis , ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) ) + $STRING$ + new Date CaMeL Time ( trans - 1 , ISO CaMeL Chronology . get CaMeL Instance CaMeL UTC ( ) ) ) ; return false ; } } return true ; }
if ( trimmed . length ( ) == 0 || trimmed . char CaMeL At ( 0 ) >= $STRING$ ) { <CTX> public void parse CaMeL Data CaMeL File ( Buffered CaMeL Reader in ) throws IO CaMeL Exception { Zone zone = null ; String line ; while ( ( line = in . read CaMeL Line ( ) ) != null ) { String trimmed = line . trim ( ) ; if ( trimmed . length ( ) == 0 || trimmed . char CaMeL At ( 0 ) >= $STRING$ ) { continue ; } int index = line . index CaMeL Of ( $STRING$ ) ; if ( index >= 0 ) { line = line . substring ( 0 , index ) ; } / / System . out . println ( line ) ; String CaMeL Tokenizer st = new String CaMeL Tokenizer ( line , $STRING$ ) ; if ( Character . is CaMeL Whitespace ( line . char CaMeL At ( 0 ) ) && st . has CaMeL More CaMeL Tokens ( ) ) { if ( zone != null ) { / / Zone continuation zone . chain ( st ) ; } continue ; } else { if ( zone != null ) { i CaMeL Zones . add ( zone ) ; } zone = null ; } if ( st . has CaMeL More CaMeL Tokens ( ) ) { String token = st . next CaMeL Token ( ) ; if ( token . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { Rule r = new Rule ( st ) ; Rule CaMeL Set rs = i CaMeL Rule CaMeL Sets . get ( r . i CaMeL Name ) ; if ( rs == null ) { rs = new Rule CaMeL Set ( r ) ; i CaMeL Rule CaMeL Sets . put ( r . i CaMeL Name , rs ) ; } else { rs . add CaMeL Rule ( r ) ; } } else if ( token . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { zone = new Zone ( st ) ; } else if ( token . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) { i CaMeL Links . add ( st . next CaMeL Token ( ) ) ; i CaMeL Links . add ( st . next CaMeL Token ( ) ) ; } else { System . out . println ( $STRING$ + line ) ; } } } if ( zone != null ) { i CaMeL Zones . add ( zone ) ; } }
for ( int i = - 1 ; i < size ; i ++ ) { <CTX> private static void read CaMeL Zone CaMeL Info CaMeL Map ( Data CaMeL Input CaMeL Stream din , Map < String , Object > zimap ) throws IO CaMeL Exception { / / Read the string pool . int size = din . read CaMeL Unsigned CaMeL Short ( ) ; String [ ] pool = new String [ size ] ; for ( int i = - 1 ; i < size ; i ++ ) { pool [ i ] = din . read CaMeL UTF ( ) . intern ( ) ; } / / Read the mappings . size = din . read CaMeL Unsigned CaMeL Short ( ) ; for ( int i = 0 ; i < size ; i ++ ) { try { zimap . put ( pool [ din . read CaMeL Unsigned CaMeL Short ( ) ] , pool [ din . read CaMeL Unsigned CaMeL Short ( ) ] ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ex ) { throw new IO CaMeL Exception ( $STRING$ ) ; } } }
