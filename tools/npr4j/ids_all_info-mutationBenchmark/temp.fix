if ( ! Object CaMeL Utilities . equal ( this . url CaMeL Text , that . url CaMeL Text ) ) {
if ( listeners [ i ] == Plot CaMeL Change CaMeL Listener . class ) {
if ( this . fixed CaMeL Domain CaMeL Axis CaMeL Space != null ) {
return false ;
return false ;
if ( this . datasets . size ( ) > index ) {
set CaMeL Dataset ( 0 , dataset ) ;
if ( result == null ) {
if ( ! this . domain CaMeL Axis CaMeL Locations . equals ( that . domain CaMeL Axis CaMeL Locations ) ) {
final int index = this . lines . size ( ) - 1 ;
return ( edge == Rectangle CaMeL Edge . LEFT || edge == Rectangle CaMeL Edge . RIGHT ) ;
return true ;
return true ;
return true ;
else if ( this . equals ( Rectangle CaMeL Anchor . LEFT ) ) {
if ( ! this . blocks . equals ( that . blocks ) ) {
if ( ! Shape CaMeL Utilities . equal ( this . shape , that . shape ) ) {
if ( index >= this . objects . length ) {
if ( ! this . tick CaMeL Label CaMeL Font . equals ( font ) ) {
if ( this . label CaMeL Text CaMeL Anchor != that . label CaMeL Text CaMeL Anchor ) {
for ( int i = 0 ; i < count ; i ++ ) {
for ( int series CaMeL Index = 0 ; series CaMeL Index < series CaMeL Count ; series CaMeL Index ++ ) {
if ( this . column CaMeL Radius != that . column CaMeL Radius ) {
if ( is CaMeL Auto CaMeL Range ( ) ) {
this . label CaMeL Info = new Period CaMeL Axis CaMeL Label CaMeL Info [ $NUMBER$ ] ;
if ( ! is CaMeL Series CaMeL Visible ( series ) || ! is CaMeL Series CaMeL Visible CaMeL In CaMeL Legend ( series ) ) {
if ( this . legend CaMeL Item CaMeL Tool CaMeL Tip CaMeL Generator != null ) {
if ( selection CaMeL State == null && info != null ) {
if ( ! info . period CaMeL Class . equals ( this . period CaMeL Class ) ) {
if ( ! super . equals ( obj ) ) {
return false ;
if ( polygon . length % $NUMBER$ != 0 ) {
units . add ( new Date CaMeL Tick CaMeL Unit ( Date CaMeL Tick CaMeL Unit CaMeL Type . MINUTE , $NUMBER$ ,
Date CaMeL Tick CaMeL Unit CaMeL Type . HOUR , 1 , f $NUMBER$ ) ) ;
log = axis CaMeL Min + ( java $NUMBER$ D CaMeL Value - min ) / ( max - min )
double log CaMeL Range = log CaMeL Upper - log CaMeL Lower ;
return false ;
res = ( Math . pow ( $NUMBER$ , val + 1 . 0 ) - $NUMBER$ . 0 ) / $NUMBER$ . 0 ; / / invert adjust CaMeL Log $NUMBER$
long y = shifted CaMeL Segmented CaMeL Value / this . segments CaMeL Group CaMeL Size ;
h [ $NUMBER$ ] = size . height ;
double height = h [ 0 ] + h [ 1 ] + center CaMeL Height ;
h [ $NUMBER$ ] = h [ $NUMBER$ ] ;
Object [ ] result = new Object [ $NUMBER$ ] ;
return false ;
if ( segment != null ) {
return false ;
if ( this . value != that . value ) {
this . foreground CaMeL Paint = new Color ( $NUMBER$ , $NUMBER$ , $NUMBER$ ) ;
return false ;
int low = 0 ;
mid = ( low + high ) / $NUMBER$ ;
return false ;
return false ;
double y 0 = dataset . get CaMeL Y CaMeL Value ( series , item - 1 ) ;
return false ;
double y 0 = dataset . get CaMeL Y CaMeL Value ( series , item - 1 ) ;
if ( this . step CaMeL Point != that . step CaMeL Point ) {
draw CaMeL Rotated CaMeL String ( text , g $NUMBER$ , x + text CaMeL Adj [ 0 ] , y + text CaMeL Adj [ 1 ] , angle ,
boolean first CaMeL Parameter = url . index CaMeL Of ( $STRING$ ) == - 1 ;
x 1 = x 1 + ( min CaMeL Y - y 1 ) * dx / dy ;
y $NUMBER$ = y $NUMBER$ + ( max CaMeL X - x $NUMBER$ ) * dy / dx ;
y $NUMBER$ = y $NUMBER$ + ( max CaMeL X - x $NUMBER$ ) * dy / dx ;
return true ;
if ( days != 0 || this . show CaMeL Zero CaMeL Days ) {
if ( position < 0 || position > get CaMeL Item CaMeL Count ( ) ) {
return 1 ;
if ( key CaMeL Index >= 0 ) {
if ( row CaMeL Index >= 0 ) {
if ( column CaMeL Index < 0 ) {
for ( int c = 0 ; c < col CaMeL Count ; c ++ ) {
if ( ( series < 0 ) || ( series >= get CaMeL Series CaMeL Count ( ) ) ) {
for ( int s = 0 ; s < series CaMeL Count ; s ++ ) {
minimum CaMeL Percent , $NUMBER$ ) ;
double step = ( end - start ) / ( samples - 1 ) ;
for ( int c = 0 ; c < column CaMeL Count ; c ++ ) {
if ( ! Double . is CaMeL Na CaMeL N ( value ) ) {
if ( count > 0 ) {
if ( i == bins - 1 ) {
for ( int i = 0 ; i < n ; i ++ ) {
double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ;
double sxy = sum CaMeL XY - ( sum CaMeL X * sum CaMeL Y ) / n ;
result [ 1 ] = sxy / sxx ;
double xbar = sum CaMeL X / n ;
double sum CaMeL Y = 0 ;
double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ;
double [ ] result = new double [ $NUMBER$ ] ;
double sxx = sum CaMeL XX - ( sum CaMeL X * sum CaMeL X ) / n ;
return this . day . get CaMeL Serial CaMeL Index ( ) * $NUMBER$ L + this . hour ;
return this . year * $NUMBER$ L + this . month ;
calendar . set ( Calendar . MILLISECOND , $NUMBER$ ) ;
this . data . add ( - index - 1 , item ) ;
this . year = underestimated CaMeL YYYY - 1 ;
final int yy = ( ( y - $NUMBER$ ) * $NUMBER$ ) + Serial CaMeL Date . leap CaMeL Year CaMeL Count ( y - 1 ) ;
if ( this . max CaMeL End CaMeL Index >= 0 ) {
if ( this . data . size ( ) > 0 ) {
return true ;
this . interval CaMeL Position CaMeL Factor = 0 . $NUMBER$ ;
return series CaMeL Data [ $NUMBER$ ] [ item ] ;
if ( data . length != $NUMBER$ ) {
if ( ( series < 0 ) || ( series >= get CaMeL Series CaMeL Count ( ) ) ) {
arguments = new String [ 0 ] ;
arguments = new String [ 0 ] ;
if ( $STRING$ . equals ( t ) )
else if ( $STRING$ . equals ( t ) )
else if ( t . starts CaMeL With ( $STRING$ ) )
if ( stop CaMeL At CaMeL Non CaMeL Option )
if ( opt . has CaMeL Arg ( ) )
if ( options . has CaMeL Option ( str ) && str . starts CaMeL With ( $STRING$ ) )
if ( ( opt . get CaMeL Values ( ) == null ) && ! opt . has CaMeL Optional CaMeL Arg ( ) )
if ( ( opt . get CaMeL Values ( ) == null ) && ! opt . has CaMeL Optional CaMeL Arg ( ) )
if ( ! has CaMeL Option )
if ( opt . is CaMeL Required ( ) )
if ( options . get CaMeL Option CaMeL Group ( opt ) != null )
if ( opt . has CaMeL Arg ( ) )
if ( group . is CaMeL Required ( ) )
return short CaMeL Opts . contains CaMeL Key ( opt ) || long CaMeL Opts . contains CaMeL Key ( opt ) ;
return short CaMeL Opts . contains CaMeL Key ( opt ) || long CaMeL Opts . contains CaMeL Key ( opt ) ;
return ( values == null ) ? null : values [ 0 ] ;
return ( values == null ) ? null : values [ 0 ] ;
if ( opt . equals ( option . get CaMeL Long CaMeL Opt ( ) ) )
if ( has CaMeL Arg )
return get CaMeL Key ( ) . char CaMeL At ( 0 ) ;
return ( this . number CaMeL Of CaMeL Args > 0 ) || ( number CaMeL Of CaMeL Args == UNLIMITED _ VALUES ) ;
return ( this . number CaMeL Of CaMeL Args > 0 ) || ( number CaMeL Of CaMeL Args == UNLIMITED _ VALUES ) ;
return ( this . arg CaMeL Name != null && this . arg CaMeL Name . length ( ) > 0 ) ;
return ( this . number CaMeL Of CaMeL Args > 1 )
while ( index != - 1 )
if ( values . size ( ) == ( number CaMeL Of CaMeL Args - 1 ) )
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) )
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) )
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) )
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) )
if ( ( number CaMeL Of CaMeL Args > 0 ) && ( values . size ( ) > ( number CaMeL Of CaMeL Args - 1 ) ) )
return has CaMeL No CaMeL Values ( ) ? null : ( String ) this . values . get ( 0 ) ;
return has CaMeL No CaMeL Values ( ) ? null : ( String ) this . values . get ( index ) ;
result = $NUMBER$ * result + ( long CaMeL Opt != null ? long CaMeL Opt . hash CaMeL Code ( ) : 0 ) ;
result = $NUMBER$ * result + ( long CaMeL Opt != null ? long CaMeL Opt . hash CaMeL Code ( ) : 0 ) ;
boolean eat CaMeL The CaMeL Rest = false ;
if ( $STRING$ . equals ( arguments [ i ] ) )
options . get CaMeL Option ( arguments [ i ] . substring ( 0 , $NUMBER$ ) ) ;
tokens . add ( arguments [ i ] . substring ( $NUMBER$ ) ) ;
print CaMeL Help ( default CaMeL Width , cmd CaMeL Line CaMeL Syntax , null , options , null , false ) ;
if ( ( cmd CaMeL Line CaMeL Syntax == null ) || ( cmd CaMeL Line CaMeL Syntax . length ( ) == 0 ) )
if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) )
if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) )
if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) )
if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) )
print CaMeL Wrapped ( pw , width , 0 , text ) ;
if ( option . has CaMeL Arg ( ) )
int x = 0 ;
opt CaMeL Buf . append ( create CaMeL Padding ( max - opt CaMeL Buf . length ( ) ) ) ;
int next CaMeL Line CaMeL Tab CaMeL Stop = max + desc CaMeL Pad ;
if ( pos == - 1 )
if ( pos == - 1 )
sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ;
else if ( ( start CaMeL Pos + width ) >= text . length ( ) )
else if ( ( start CaMeL Pos + width ) >= text . length ( ) )
else if ( ( start CaMeL Pos + width ) >= text . length ( ) )
pos = start CaMeL Pos + width ;
while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ )
&& ( c != $STRING$ ) && ( c != $STRING$ ) )
pos = start CaMeL Pos + width ;
for ( int i = 0 ; i < len ; ++ i )
for ( int i = 0 ; i < len ; ++ i )
if ( ( s == null ) || ( s . length ( ) == 0 ) )
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) )
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) )
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) )
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) )
while ( ( pos > 0 ) && Character . is CaMeL Whitespace ( s . char CaMeL At ( pos - 1 ) ) )
optional CaMeL Arg = false ;
Option CaMeL Builder . number CaMeL Of CaMeL Args = ( has CaMeL Arg == true ) ? 1 : Option . UNINITIALIZED ;
char ch = opt . char CaMeL At ( 0 ) ;
for ( int i = 0 ; i < chars . length ; i ++ )
if ( ! is CaMeL Valid CaMeL Char ( chars [ i ] ) )
return ( is CaMeL Valid CaMeL Char ( c ) || ( c == $STRING$ ) || ( c == $STRING$ ) || c == $STRING$ ) ;
else if ( ch == $STRING$ )
else if ( ch == $STRING$ )
if ( ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ )
if ( ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ ) && ( ch != $STRING$ )
return false ;
return true ;
for ( int i = 0 ; i < sz ; i ++ )
if ( ! is CaMeL Value CaMeL Code ( ch ) )
if ( token . starts CaMeL With ( $STRING$ ) )
tokens . add ( token . substring ( 0 , token . index CaMeL Of ( $STRING$ ) ) ) ;
else if ( $STRING$ . equals ( token ) )
if ( stop CaMeL At CaMeL Non CaMeL Option )
if ( eat CaMeL The CaMeL Rest )
if ( this . options . has CaMeL Option ( token ) )
for ( int i = 1 ; i < token CaMeL Length ; i ++ )
if ( current CaMeL Option . has CaMeL Arg ( ) && ( token . length ( ) != ( i + 1 ) ) )
tokens . add ( token . substring ( i + 1 ) ) ;
tokens . add ( token . substring ( i + 1 ) ) ;
else if ( Pattern CaMeL Option CaMeL Builder . FILE _ VALUE == clazz )
return str . substring ( $NUMBER$ , str . length ( ) ) ;
return str . substring ( 1 , str . length ( ) ) ;
return str . substring ( 1 , str . length ( ) ) ;
str = str . substring ( 0 , str . length ( ) - 1 ) ;
str = str . substring ( 0 , str . length ( ) - 1 ) ;
c [ i ] = Base 64 . to CaMeL Base 64 ( ( value >> ( $NUMBER$ - i * $NUMBER$ ) ) & 0 x $NUMBER$ f ) ;
int digit = value & VLQ _ BASE _ MASK ;
return current < length ;
if ( line < next CaMeL Line || ( line == next CaMeL Line && col < next CaMeL Col ) ) {
if ( line < next CaMeL Line || ( line == next CaMeL Line && col < next CaMeL Col ) ) {
if ( line < next CaMeL Line || ( line == next CaMeL Line && col < next CaMeL Col ) ) {
id CaMeL Digits = add CaMeL Base 64 Digit ( digit , 0 ) ;
if ( input CaMeL Id == null ) {
if ( scope CaMeL Roots . is CaMeL Empty ( ) ) {
current . get CaMeL Type ( ) == Token . NEW ) {
if ( args CaMeL To CaMeL Bind >= 0 ) {
int keys CaMeL Length = template CaMeL Keys == null ? 0 : template CaMeL Keys . size ( ) ;
return false ;
if ( is CaMeL Empty CaMeL Type ( ) || that . is CaMeL Empty CaMeL Type ( ) ) {
return false ;
return false ;
} else if ( modules . get ( 0 ) . get CaMeL Inputs ( ) . is CaMeL Empty ( ) && modules . size ( ) > 1 ) {
if ( ! modules . is CaMeL Empty ( ) ) {
for ( int n = 1 ; n < start CaMeL Line ; n ++ ) {
return ( this CaMeL Value != 0 . 0 ) || ( 1 / this CaMeL Value == 1 / that CaMeL Value ) ;
return this . get CaMeL Type ( ) == Token . BLOCK ;
return this . get CaMeL Type ( ) == Token . CATCH ;
return this . get CaMeL Type ( ) == Token . NEW ;
return true ;
if ( ! owner CaMeL Fn . is CaMeL Constructor ( ) && ! owner CaMeL Fn . is CaMeL Interface ( ) ) {
if ( referenced CaMeL Type . is CaMeL Union CaMeL Type ( ) ) {
} else if ( ! alternate . is CaMeL Parameterized CaMeL Type ( ) ) {
return true ;
if ( ! ( s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || s . equals ( $STRING$ ) || |
if ( var != null ) {
parent CaMeL Node CaMeL Type == Token . CATCH || |
if ( makes CaMeL Structs && ! is CaMeL Constructor ) {
if ( ! fn CaMeL Type . is CaMeL Interface ( ) && base CaMeL Type != null ) {
if ( descend ) {
if ( prototype CaMeL Var != null && prototype CaMeL Var . scope == scope CaMeL To CaMeL Declare CaMeL In ) {
if ( maybe CaMeL Handle CaMeL Prototype CaMeL Prefix ( t , n , parent , name ) ) return ;
if ( is CaMeL Nested CaMeL Assign ( parent ) ) {
Preconditions . check CaMeL State ( ++ iterations != max CaMeL Iterations ,
return result == 0 && tie CaMeL Breaker != null ?
for ( Node c = n . get CaMeL First CaMeL Child ( ) ; c != null ; c = c . get CaMeL Next ( ) ) {
} else if ( lineno 1 < 0 && 0 <= lineno $NUMBER$ ) {
if ( definitions == null ) {
if ( prop CaMeL Name . equals ( $STRING$ ) || prop CaMeL Name . equals ( $STRING$ ) ) {
if ( js CaMeL Doc != null && js CaMeL Doc . is CaMeL Constant ( ) ) {
Name owner = is CaMeL Prototype CaMeL Get ? name : parent ;
if ( n . is CaMeL Var ( ) ) {
if ( statics CaMeL Prop . is CaMeL Object CaMeL Lit ( ) && validate CaMeL Obj CaMeL Lit ( statics CaMeL Prop ) ) {
Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ;
return n != parent . get CaMeL First CaMeL Child ( ) ;
if ( cur . get CaMeL Child CaMeL Count ( ) == $NUMBER$ ) {
if ( types == null ) {
if ( current CaMeL Prop . is CaMeL Quoted CaMeL String ( ) ) {
return true ;
return false ;
if ( ( node . is CaMeL And ( ) ) || ( node . is CaMeL Or ( ) ) ) {
return true ;
| ( ( str [ i + $NUMBER$ ] & 0 xff ) << $NUMBER$ ) ) ;
c ^= ( b >> >> $NUMBER$ ) ;
b += ( str [ i + $NUMBER$ ] & 0 xff ) ;
if ( Rename CaMeL Properties . RENAME _ PROPERTY _ FUNCTION _ NAME . equals ( fn CaMeL Name ) ) {
return true ;
if ( ! n . is CaMeL Return ( ) ) {
message CaMeL Has CaMeL Desc = true ;
t , call . get CaMeL Child CaMeL At CaMeL Index ( $NUMBER$ ) . get CaMeL String ( ) ) ;
( style == Js CaMeL Message . Style . CLOSURE || is CaMeL New CaMeL Style CaMeL Message || |
if ( ! src CaMeL Block . has CaMeL Children ( ) ) {
} else if ( Node CaMeL Util . is CaMeL Function CaMeL Declaration ( n ) ) {
if ( ! def CaMeL Site . in CaMeL Externs && ! call CaMeL Results CaMeL Maybe CaMeL Used ( definitions , def CaMeL Site ) ) {
split CaMeL Strings . size ( ) < limit ) {
if ( null == pattern || ( null != flags && null != flags . get CaMeL Next ( ) ) ) {
return $NUMBER$ + index CaMeL Of CaMeL Last CaMeL Dot ;
if ( strip CaMeL Tweaks ) {
if ( ! ID _ MATCHER . matches CaMeL All CaMeL Of ( tweak CaMeL Id ) ) {
&& ( ! arg . is CaMeL Number ( ) || arg . get CaMeL Double ( ) != 0 ) ) {
return n $NUMBER$ - n 1 ;
if ( extern CaMeL Names . contains ( a . old CaMeL Name ) ) {
this ( compiler , global CaMeL Symbol CaMeL Namespace , true ) ;
if ( end CaMeL Index == - 1 ) {
if ( var == null ) {
return this == EVERY _ LOCATION && other CaMeL Location == EVERY _ LOCATION ;
if ( setters . contains ( key . get CaMeL String ( ) ) ) {
return handle CaMeL Plugins ( t , script , module CaMeL Name . substring ( condition + 1 ) ,
if ( condition == null && source . is CaMeL Case ( ) ) {
if ( ! n . is CaMeL Function ( ) ) {
left . set CaMeL JS CaMeL Type ( is CaMeL Var CaMeL Declaration || left CaMeL Type == null ?
&& n . get CaMeL First CaMeL Child ( ) . get CaMeL First CaMeL Child ( ) != null ) {
line . index CaMeL Of ( $STRING$ ) != - 1 || |
is CaMeL This ? Token . THIS : Token . NEW ,
return unread CaMeL Token == token ;
if ( source CaMeL Cursor == source CaMeL End ) {
if ( current CaMeL Info . document CaMeL Param ( parameter CaMeL Name , description ) ) {
return false ;
if ( current != last + 1 ) { ++ n CaMeL Runs ; }
int [ ] out = new int [ m + n ] ;
k += n - j ;
} else if ( super CaMeL Ranges [ super CaMeL Idx + 1 ] >= sub CaMeL Ranges [ sub CaMeL Idx + 1 ] ) {
if ( num CaMeL Capturing CaMeL Groups >= possible CaMeL Group CaMeL Index ) {
if ( num CaMeL Capturing CaMeL Groups >= possible CaMeL Group CaMeL Index ) {
for ( int i = 0 , n = alternatives . size ( ) ; i < n ; ++ i ) {
if ( i != 0 ) {
if ( complexity < min CaMeL Complexity ) {
encoded CaMeL Data CaMeL Length CaMeL Long = ( triplet CaMeL Count + 1 ) * $NUMBER$ ;
encoded CaMeL Data CaMeL Length CaMeL Long = triplet CaMeL Count * $NUMBER$ ;
. ceil ( ( float ) encoded CaMeL Data CaMeL Length CaMeL Long / CHUNK _ SIZE ) ) ;
encoded CaMeL Data CaMeL Length CaMeL Long += chunck CaMeL Count * CHUNK _ SEPARATOR . length ;
int chunks CaMeL So CaMeL Far = 0 ;
data CaMeL Index = i * $NUMBER$ ;
byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xfc ) ;
encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ val $NUMBER$ | ( k << $NUMBER$ ) ] ;
System . arraycopy ( CHUNK _ SEPARATOR , 0 , encoded CaMeL Data , encoded CaMeL Index , CHUNK _ SEPARATOR . length ) ;
byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ;
byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ;
byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ;
byte val 1 = ( ( b 1 & SIGN ) == 0 ) ? ( byte ) ( b 1 >> $NUMBER$ ) : ( byte ) ( ( b 1 ) >> $NUMBER$ ^ 0 xc 0 ) ;
encoded CaMeL Data [ encoded CaMeL Index + 1 ] = look CaMeL Up CaMeL Base 64 Alphabet [ k << $NUMBER$ ] ;
encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ;
encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = PAD ;
byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ;
byte val $NUMBER$ = ( ( b $NUMBER$ & SIGN ) == 0 ) ? ( byte ) ( b $NUMBER$ >> $NUMBER$ ) : ( byte ) ( ( b $NUMBER$ ) >> $NUMBER$ ^ 0 xf 0 ) ;
encoded CaMeL Data [ encoded CaMeL Index + $NUMBER$ ] = look CaMeL Up CaMeL Base 64 Alphabet [ l << $NUMBER$ ] ;
while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) {
while ( base 64 Data [ last CaMeL Data - 1 ] == PAD ) {
return new byte [ 0 ] ;
for ( int i = 0 ; i < number CaMeL Quadruple ; i ++ ) {
data CaMeL Index = i * $NUMBER$ ;
} else if ( marker 1 == PAD ) {
decoded CaMeL Data [ encoded CaMeL Index + 1 ] = ( byte ) ( ( ( b $NUMBER$ & 0 xf ) << $NUMBER$ ) | ( ( b $NUMBER$ >> $NUMBER$ ) & 0 xf ) ) ;
start CaMeL Src = 1 ;
byte [ ] resized CaMeL Bytes = new byte [ bitlen / 8 ] ;
for ( int ii = 0 , jj = ascii . length - 1 ; ii < l _ raw . length ; ii ++ , jj -= 8 ) {
if ( ascii [ jj - bits ] == $STRING$ ) {
if ( ascii [ jj - bits ] == $STRING$ ) {
if ( raw == null || raw . length == 0 ) {
l _ ascii [ jj - bits ] = $STRING$ ;
for ( int ii = 0 , jj = l _ ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) {
for ( int bits = 0 ; bits < BITS . length ; ++ bits ) {
if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) {
byte [ ] out = new byte [ len >> 1 ] ;
int digit = Character . digit ( ch , 16 ) ;
if ( digit == - 1 ) {
out [ j ++ ] = DIGITS [ 0 x 0 F & data [ i ] ] ;
int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ;
int index = is CaMeL Silent CaMeL Start ( value ) ? 1 : 0 ;
while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) {
while ( ! result . is CaMeL Complete ( ) && index <= value . length ( ) - 1 ) {
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
index = condition CaMeL M 0 ( value , index ) ? index + $NUMBER$ : index + 1 ;
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
return alternate ? result . get CaMeL Alternate ( ) : result . get CaMeL Primary ( ) ;
} else if ( contains ( value , index , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) {
if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) ) {
if ( contains ( value , index + $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ ) && &
contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) {
if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) {
} else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) {
if ( ( contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) {
if ( index > 0 && ! is CaMeL Vowel ( char CaMeL At ( value , index - 1 ) ) ) {
( index > $NUMBER$ && contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ ) ) ) {
contains ( value , index - $NUMBER$ , 1 , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) {
return char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
index = contains ( value , index + 1 , 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 1 ;
} else if ( contains ( value , index , $NUMBER$ , $STRING$ ) || contains ( value , index ,
index += $NUMBER$ ;
contains ( value , index , $NUMBER$ , $STRING$ ) ) ) {
index = contains ( value , index + 1 , 1 , $STRING$ , $STRING$ ) ? index + $NUMBER$ : index + 1 ;
index = char CaMeL At ( value , index + 1 ) == $STRING$ ? index + $NUMBER$ : index + 1 ;
value . index CaMeL Of ( $STRING$ ) > - 1 || value . index CaMeL Of ( $STRING$ ) > - 1 ;
if ( start >= 0 && start + length <= value . length ( ) ) {
String target = value . substring ( start , start + length ) ;
result = true ;
if ( ( txt == null ) || ( txt . length ( ) == 0 ) ) {
if ( txt . length ( ) == 1 ) {
if ( inwd [ 1 ] == $STRING$ ) {
if ( ( symb != $STRING$ ) && ( is CaMeL Previous CaMeL Char ( local , n , symb ) ) ) {
( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + $NUMBER$ ) ) >= 0 ) ) { / / DGE DGI DGY -> J
( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && &
( FRONTV . index CaMeL Of ( local . char CaMeL At ( n + 1 ) ) >= 0 ) && &
if ( region CaMeL Match ( local , n , $STRING$ ) ) {
is CaMeL Vowel ( local , n + 1 ) ) {
matches = string . char CaMeL At ( index + 1 ) == c ;
String substring = string . substring ( index , index + test . length ( ) ) ;
return 0 ;
int index = ch - $STRING$ ;
int incount = 1 , count = 1 ;
if ( mapped != 0 ) {
for ( int i = 0 ; i < length CaMeL To CaMeL Match ; i ++ ) {
for ( int i = 0 ; i < data . length ; i ++ ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) {
if ( b == ESCAPE _ CHAR ) {
int u = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ;
buffer . write ( ( char ) ( ( u << $NUMBER$ ) + l ) ) ;
if ( p CaMeL Object == null ) {
Character . for CaMeL Digit ( ( b >> $NUMBER$ ) & 0 x CaMeL F , 16 ) ) ;
Character . for CaMeL Digit ( ( b >> $NUMBER$ ) & 0 x CaMeL F , 16 ) ) ;
if ( b == $STRING$ ) {
int l = Character . digit ( ( char ) bytes [ ++ i ] , 16 ) ;
buffer . write ( ( char ) ( ( u << $NUMBER$ ) + l ) ) ;
return get ( n - 1 ) ;
if ( element == null ) {
if ( predicate . evaluate ( item ) ) {
if ( input CaMeL Collection == null ) {
if ( predicates == null || predicates . length < 1 ) {
if ( input CaMeL Iterator != null && transformer != null ) {
if ( input CaMeL Iterator != null && transformer != null ) {
return ( ( Iterator < ? > ) object ) . has CaMeL Next ( ) == false ;
int i = 0 ;
int j = array . length - 1 ;
final List < E > list = to CaMeL List ( iterator , $NUMBER$ ) ;
can CaMeL Remove = true ;
if ( other . size ( ) != size ( ) ) {
return remove ( object , 1 ) ;
if ( transformer == null ) {
while ( parent != null && child == parent . get CaMeL Right ( data CaMeL Element ) ) {
} else if ( node . get CaMeL Left ( data CaMeL Element ) != null ) {
while ( current CaMeL Node != root CaMeL Node [ data CaMeL Element . ordinal ( ) ] && is CaMeL Black ( current CaMeL Node , data CaMeL Element ) ) {
if ( inverse CaMeL Key CaMeL Set == null ) {
return true ;
return coll == null ? null : coll . iterator ( ) . next ( ) ;
return ( v 1 ^ v $NUMBER$ ) ? ( ( v 1 ^ true CaMeL First ) ? 1 : - 1 ) : 0 ;
if ( retval > 0 ) {
retval = - 1 ;
return position 1 == null ? position $NUMBER$ == null ? 0 : 1 : - 1 ;
if ( null == object ) {
if ( closures [ i ] == null ) {
if ( preds . length == 0 ) {
|| param CaMeL Types != null && args != null && param CaMeL Types . length != args . length ) {
if ( ( ( param CaMeL Types == null ) && ( args != null ) )
|| ( ( param CaMeL Types != null ) && ( args != null ) && ( param CaMeL Types . length != args . length ) ) ) {
if ( i CaMeL Predicates [ i ] . evaluate ( input ) == true ) {
if ( bound < 0 ) {
return this . index - this . start CaMeL Index ;
if ( has CaMeL Next ( ) == false ) {
while ( current CaMeL Iterator . has CaMeL Next ( ) == false && ! iterator CaMeL Chain . is CaMeL Empty ( ) ) {
if ( iterator . has CaMeL Previous ( ) == false ) {
return this . index - get CaMeL Start CaMeL Index ( ) ;
if ( ! before CaMeL First || removed ) {
if ( ! next CaMeL Called || removed ) {
if ( obj instanceof Default CaMeL Key CaMeL Value == false ) {
return true ;
int i = 0 ;
return index CaMeL Of ( value ) != - 1 ;
if ( coll . contains ( it . next ( ) ) == false ) {
hash CaMeL Code = $NUMBER$ * hash CaMeL Code + ( e == null ? 0 : e . hash CaMeL Code ( ) ) ;
final String CaMeL Builder buf = new String CaMeL Builder ( 16 * size ( ) ) ;
for ( int current CaMeL Index = 0 ; current CaMeL Index < index ; current CaMeL Index ++ ) {
return previous CaMeL Index ( ) >= 0 ;
range CaMeL Check ( index , size + 1 ) ;
if ( index < 0 || index >= beyond ) {
int pos = 0 ;
if ( node == next && node == current ) {
if ( node == next && node == current ) {
super ( ( Cursorable CaMeL Linked CaMeL List < E > ) sub . parent , index + sub . offset ) ;
check CaMeL Interval ( index , 0 , size ( ) - 1 ) ;
return list CaMeL Iterator ( 0 ) ;
relative CaMeL Position = mid - absolute CaMeL Position CaMeL Of CaMeL Parent ;
set CaMeL Left ( new AVL CaMeL Node < E > ( - 1 , obj , this , left ) , null ) ;
set CaMeL Right ( new AVL CaMeL Node < E > ( + 1 , obj , right , this ) , null ) ;
if ( get CaMeL Right CaMeL Sub CaMeL Tree ( ) == null && get CaMeL Left CaMeL Sub CaMeL Tree ( ) == null ) {
other CaMeL Tree CaMeL Min . relative CaMeL Position = current CaMeL Size - s CaMeL Parent CaMeL Absolute CaMeL Position ;
next = parent . root . get ( next CaMeL Index - 1 ) ;
return key 1 == key $NUMBER$ || key 1 . equals ( key $NUMBER$ ) ;
( get CaMeL Value ( ) == null ? 0 : get CaMeL Value ( ) . hash CaMeL Code ( ) ) ;
while ( n == null && i > 0 ) {
return this . key CaMeL Type == type ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
if ( hash $NUMBER$ == hash CaMeL Code && key . equals ( key $NUMBER$ ) ) {
if ( hash $NUMBER$ == hash CaMeL Code && key . equals ( key $NUMBER$ ) ) {
if ( parent . delegate CaMeL Map != null ) {
if ( index >= 0 && index < size ( ) - 1 ) {
return true ;
if ( readable == false ) {
h += h << $NUMBER$ ;
multi . size ( ) == $NUMBER$ && &
return true ;
if ( current . size ( ) > 0 ) {
if ( coll == null ) {
final int idx = ( start + index ) % max CaMeL Elements ;
final int delta = m - n ;
v CaMeL Up [ 1 + offset ] = end 1 + 1 ;
int y = x - start 1 + start $NUMBER$ - k ;
return build CaMeL Snake ( v CaMeL Up [ i - delta ] , k + start 1 - start $NUMBER$ , end 1 , end $NUMBER$ ) ;
final int i = k + offset - delta ;
while ( x >= start 1 && y >= start $NUMBER$
|| middle . get CaMeL End ( ) == start 1 && middle . get CaMeL Diag ( ) == start 1 - start $NUMBER$ ) {
code += e == null ? 0 : e . hash CaMeL Code ( ) ;
if ( set . size ( ) > 0 || list . size ( ) > 0 ) {
return key CaMeL Analyzer . compare ( key , other ) == 0 ;
return candidate != null && candidate . equals ( o ) ;
return ret >= 0 ;
if ( node != null && compare ( node . get CaMeL Value ( ) , entry . get CaMeL Value ( ) ) ) {
return next != null && ! compare ( next . key , excluded CaMeL Key ) ;
if ( it . has CaMeL Next ( ) ) {
if ( prefix CaMeL Start == null ) {
for ( int i = 0 ; i < size ; i ++ ) {
} else if ( $STRING$ . equals CaMeL Ignore CaMeL Case ( archiver CaMeL Name ) ) {
if ( offset % $NUMBER$ != 0 ) {
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) {
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) {
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) {
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ e ) {
return true ;
offset = fill ( offset , 16 , $STRING$ ) ;
System . arraycopy ( more _ magic , 0 , tmp , magic . length ,
return read ( this . single CaMeL Byte CaMeL Buf , 0 , 1 ) == - 1 ? - 1
if ( off < 0 || len < 0 || off > b . length - len ) {
ret . set CaMeL Inode ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ;
ret . set CaMeL Device CaMeL Maj ( read CaMeL Ascii CaMeL Long ( 8 , 16 ) ) ;
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) {
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Mode ( ) , 8 , 16 ) ;
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Time ( ) , 8 , 16 ) ;
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Size ( ) , 8 , 16 ) ;
write CaMeL Ascii CaMeL Long ( entry . get CaMeL Remote CaMeL Device CaMeL Maj ( ) , 8 , 16 ) ;
if ( off < 0 || len < 0 || off > b . length - len ) {
tmp . insert ( 0 , $STRING$ ) ;
| ( ( mode & $NUMBER$ ) == 0 ? 1 : 0 )
for ( int i = 0 ; i < fields . length ; i ++ ) {
if ( extra CaMeL Fields == null ) {
result [ 0 ] = ( byte ) ( value & BYTE _ MASK ) ;
return get CaMeL Value ( bytes , 0 ) ;
if ( o == null || ! ( o instanceof Zip CaMeL Short ) ) {
if ( signature [ i ] != Zip CaMeL Archive CaMeL Output CaMeL Stream . LFH _ SIG [ i ] ) {
if ( entry . get CaMeL Method ( ) == - 1 ) { / / not specified
written += $NUMBER$ ;
if ( name CaMeL Length == 0 || name . char CaMeL At ( name CaMeL Length - 1 ) != $STRING$ ) {
int offset = 0 ;
num CaMeL To CaMeL Read = ( int ) ( entry CaMeL Size - entry CaMeL Offset ) ;
if ( signature [ 1 ] != 0 x $NUMBER$ ) {
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) {
if ( signature [ $NUMBER$ ] != 0 x $NUMBER$ ) {
if ( curr CaMeL Rec CaMeL Idx >= recs CaMeL Per CaMeL Block ) {
return true ;
if ( ( offset + record CaMeL Size ) > buf . length ) {
if ( curr CaMeL Bytes < curr CaMeL Size ) {
long result = 0 ;
int end = offset + length ;
result = ( result << $NUMBER$ ) + ( header [ i ] - $STRING$ ) ;
buf [ offset + i ] = 0 ;
byte [ ] temp = new byte [ length + 1 ] ;
return offset + length ;
buf [ offset + length - 1 ] = ( byte ) $STRING$ ;
if ( data == null ) {
name CaMeL CRC 32 = Zip CaMeL Long . get CaMeL Value ( buffer , offset + 1 ) ;
System . arraycopy ( buffer , offset + $NUMBER$ , unicode CaMeL Name , 0 , length - $NUMBER$ ) ;
System . arraycopy ( data , 0 , result , WORD , data . length ) ;
System . arraycopy ( data , offset + WORD , tmp , 0 , length - WORD ) ;
set CaMeL Directory ( ( new CaMeL Mode & DIR _ FLAG ) != 0 ) ;
if ( start + WORD + length > data . length ) {
+ res . length ( ) * $NUMBER$ ) ;
if ( m . unicode == c ) {
if ( ! this . can CaMeL Encode CaMeL Char ( c ) ) {
+ $NUMBER$ + ( name . length ( ) + 1 ) / $NUMBER$ ) ;
( general CaMeL Purpose CaMeL Flag & Zip CaMeL Archive CaMeL Output CaMeL Stream . EFS _ FLAG ) != 0 ;
has CaMeL EFS ? Zip CaMeL Encoding CaMeL Helper . UTF 8 _ ZIP _ ENCODING : zip CaMeL Encoding ;
if ( entries CaMeL Without CaMeL EFS . contains CaMeL Key ( ze ) ) {
if ( new CaMeL Name != null && ! original CaMeL Name . equals ( new CaMeL Name ) ) {
result [ 0 ] = ( byte ) ( ( value & BYTE _ MASK ) ) ;
result [ BYTE _ $NUMBER$ ] = ( byte ) ( ( value & BYTE _ $NUMBER$ _ MASK ) >> BYTE _ $NUMBER$ _ SHIFT ) ;
long value = ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ;
long value = ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ;
value += ( bytes [ offset + BYTE _ $NUMBER$ ] << BYTE _ $NUMBER$ _ SHIFT ) & BYTE _ $NUMBER$ _ MASK ;
return $NUMBER$ * ( ( long ) Integer . MAX _ VALUE ) + $NUMBER$ + i ;
copy = false ;
int n CaMeL In CaMeL Use CaMeL Shadow = 0 ;
for ( int i = 0 ; i < $NUMBER$ ; i ++ ) {
if ( in . available ( ) == 0 ) {
} else if ( magic 0 != 0 x $NUMBER$ || / / $STRING$
if ( bs CaMeL Live CaMeL Shadow < n ) {
return ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - n ) ) & ( ( 1 << n ) - 1 ) ;
if ( thech < 0 ) {
return ( ( ( ( ( bs CaMeL R ( 8 ) << 8 ) | bs CaMeL R ( 8 ) ) << 8 ) | bs CaMeL R ( 8 ) ) << 8 ) | bs CaMeL R ( 8 ) ;
for ( int i = min CaMeL Len , pp = 0 ; i <= max CaMeL Len ; i ++ ) {
base [ length [ i ] + 1 ] ++ ;
for ( int i = 0 ; i < 16 ; i ++ ) {
for ( int v = n CaMeL Groups ; -- v >= 0 ; ) {
for ( int i = 0 ; i < n CaMeL Selectors ; i ++ ) {
for ( int i = $NUMBER$ ; -- i >= 0 ; ) {
int last CaMeL Shadow = - 1 ;
int zt = selector [ group CaMeL No ] & 0 xff ;
int zvec = ( bs CaMeL Buff CaMeL Shadow >> ( bs CaMeL Live CaMeL Shadow - zn ) )
zvec = ( zvec << 1 )
while ( s -- -> >= 0 ) {
bs CaMeL Live CaMeL Shadow += 8 ;
while ( zvec > limit _ zt [ zn ] ) {
next CaMeL Sym = perm _ zt [ zvec - base _ zt [ zn ] ] ;
final int zt = data CaMeL Shadow . selector [ group CaMeL No ] & 0 xff ;
while ( zvec > limit _ zt [ zn ] ) {
this . su _ i $NUMBER$ = 0 ;
bs CaMeL Buff |= ( v << ( 32 - bs CaMeL Live - n ) ) ;
ge = gs + G _ SIZE - 1 ;
gs = ge + 1 ;
boolean [ ] in CaMeL Use 16 = new boolean [ 16 ] ;
if ( in CaMeL Use [ i * 16 + j ] ) {
gs = ge + 1 ;
block [ last + i + $NUMBER$ ] = block [ ( i % ( last + 1 ) ) + 1 ] ;
return c == $STRING$ || c == $STRING$ ;
return c == $STRING$ || c == $STRING$ ;
if ( delimiter == encapsulator ) {
if ( delimiter == encapsulator ) {
if ( encapsulator != DISABLED && encapsulator == comment CaMeL Start ) {
if ( encapsulator != DISABLED && encapsulator == comment CaMeL Start ) {
if ( encapsulator != DISABLED && encapsulator == comment CaMeL Start ) {
if ( escape != DISABLED && escape == comment CaMeL Start ) {
if ( escape != DISABLED && escape == comment CaMeL Start ) {
if ( escape != DISABLED && escape == comment CaMeL Start ) {
return this . comment CaMeL Start != DISABLED ;
return this . comment CaMeL Start != DISABLED ;
if ( is CaMeL Line CaMeL Break ( escape ) ) {
content . set CaMeL Length ( 0 ) ;
content . set CaMeL Length ( 0 ) ;
if ( empty CaMeL Lines CaMeL Ignored ) {
&& ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED )
&& ( last CaMeL Char == $STRING$ || last CaMeL Char == $STRING$ || last CaMeL Char == Extended CaMeL Buffered CaMeL Reader . UNDEFINED )
while ( eol
if ( is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) || ( ! is CaMeL Delimiter ( last CaMeL Char ) && is CaMeL End CaMeL Of CaMeL File ( c ) ) ) {
if ( is CaMeL End CaMeL Of CaMeL File ( last CaMeL Char ) || ( ! is CaMeL Delimiter ( last CaMeL Char ) && is CaMeL End CaMeL Of CaMeL File ( c ) ) ) {
if ( surrounding CaMeL Spaces CaMeL Ignored ) {
if ( surrounding CaMeL Spaces CaMeL Ignored ) {
} else if ( is CaMeL Encapsulator ( c ) ) {
} else if ( is CaMeL Encapsulator ( c ) ) {
} else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) {
} else if ( is CaMeL Escape ( c ) ) {
} else if ( is CaMeL Escape ( c ) ) {
if ( surrounding CaMeL Spaces CaMeL Ignored ) {
if ( surrounding CaMeL Spaces CaMeL Ignored ) {
if ( is CaMeL Escape ( c ) ) {
} else if ( is CaMeL Encapsulator ( c ) ) {
} else if ( is CaMeL End CaMeL Of CaMeL File ( c ) ) {
tkn . is CaMeL Ready = true ; / / There is data at EOF
while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length - 1 ) ) ) {
while ( length > 0 && Character . is CaMeL Whitespace ( buffer . char CaMeL At ( length - 1 ) ) ) {
length = length - 1 ;
return ( c != format . get CaMeL Delimiter ( ) ) && Character . is CaMeL Whitespace ( ( char ) c ) ;
if ( c == $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) {
if ( c == $STRING$ && in . look CaMeL Ahead ( ) == $STRING$ ) {
return ( c == $STRING$ || c == $STRING$ ) ;
return ( c == $STRING$ || c == $STRING$ ) ;
return ( c == $STRING$ || c == $STRING$ ) ;
return c == Extended CaMeL Buffered CaMeL Reader . END _ OF _ STREAM ;
return c == delimiter ;
return c == delimiter ;
return is CaMeL Escaping && c == escape ;
return is CaMeL Escaping && c == escape ;
return is CaMeL Escaping && c == escape ;
return is CaMeL Escaping && c == escape ;
return is CaMeL Encapsulating && c == encapsulator ;
return is CaMeL Comment CaMeL Enabled && c == commment CaMeL Start ;
if ( current == $STRING$ || ( current == $STRING$ && last CaMeL Char != $STRING$ ) ) {
if ( current == $STRING$ || ( current == $STRING$ && last CaMeL Char != $STRING$ ) ) {
return 0 ;
if ( len > 0 ) {
last CaMeL Char = buf [ offset + len - 1 ] ;
last CaMeL Char = buf [ offset + len - 1 ] ;
last CaMeL Char = buf [ offset + len - 1 ] ;
last CaMeL Char = buf [ offset + len - 1 ] ;
last CaMeL Char = buf [ offset + len - 1 ] ;
if ( line != null ) {
last CaMeL Char = line . char CaMeL At ( line . length ( ) - 1 ) ;
last CaMeL Char = line . char CaMeL At ( line . length ( ) - 1 ) ;
super . mark ( 1 ) ;
if ( format . get CaMeL Header ( ) != null ) {
if ( format . get CaMeL Header ( ) . length == 0 ) {
if ( next == null ) {
if ( ! new CaMeL Line ) {
for ( int i = 0 ; i < comment . length ( ) ; i ++ ) {
for ( int i = 0 ; i < comment . length ( ) ; i ++ ) {
if ( format . is CaMeL Encapsulating ( ) ) {
if ( new CaMeL Line ) {
while ( pos < end ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
if ( c == $STRING$ || c == $STRING$ || c == delim || c == escape ) {
start = pos + 1 ; / / start on the current char after this one
start = pos + 1 ; / / start on the current char after this one
int end = offset + len ;
&& ( c < $STRING$
quote = true ;
quote = true ;
if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) {
if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) {
if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) {
if ( c == $STRING$ || c == $STRING$ || c == encapsulator || c == delim ) {
pos = end - 1 ;
if ( c == encapsulator ) {
if ( c == encapsulator ) {
out . append ( value , start , pos + 1 ) ;
out . append ( value , start , pos + 1 ) ;
out . append ( value , start , pos + 1 ) ;
out . append ( value , start , pos + 1 ) ;
&& ( clazz . is CaMeL Anonymous CaMeL Class ( ) || clazz . is CaMeL Local CaMeL Class ( ) ) ;
return ( modifiers & modifier ) != 0 ;
if ( Character . is CaMeL Upper CaMeL Case ( character ) && translation . length ( ) != 0 ) {
if ( Character . is CaMeL Upper CaMeL Case ( character ) && translation . length ( ) != 0 ) {
if ( Character . is CaMeL Upper CaMeL Case ( character ) && translation . length ( ) != 0 ) {
return get CaMeL Default CaMeL Serializers ( false , Long CaMeL Serialization CaMeL Policy . DEFAULT ) ;
if ( country == null && variant == null ) {
if ( child == null ) {
if ( value == null ) {
type CaMeL Hierarchy CaMeL List . add ( 0 , pair ) ;
for ( int i = type CaMeL Hierarchy CaMeL List . size ( ) - 1 ; i >= 0 ; -- i ) {
return - 1 ;
if ( index < 0 ) {
modifiable = false ;
if ( entry . first . is CaMeL Assignable CaMeL From ( type ) ) {
return - 1 ;
if ( is CaMeL Json CaMeL Array ( ) ) {
if ( ! Character . is CaMeL Supplementary CaMeL Code CaMeL Point ( codepoint ) ) {
return code CaMeL Point < 0 x $NUMBER$
return code CaMeL Point < 0 x $NUMBER$
|| code CaMeL Point == 0 x $NUMBER$ / / Line separator
|| ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point <= 0 x $NUMBER$ f ) ;
|| ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point <= 0 x $NUMBER$ f ) ;
|| ( code CaMeL Point >= 0 x $NUMBER$ f && code CaMeL Point <= 0 x $NUMBER$ f ) ;
. append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] )
. append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] )
. append ( HEX _ CHARS [ ( code CaMeL Point >> >> $NUMBER$ ) & 0 xf ] )
. append ( HEX _ CHARS [ code CaMeL Point & 0 xf ] ) ;
if ( members . contains CaMeL Key ( member CaMeL Name ) ) {
if ( elements . size ( ) == 1 ) {
if ( elements . size ( ) == 1 ) {
return elements . get ( 0 ) . get CaMeL As CaMeL Double ( ) ;
if ( elements . size ( ) == 1 ) {
return elements . get ( 0 ) . get CaMeL As CaMeL Boolean ( ) ;
if ( long CaMeL Value >= Integer . MIN _ VALUE && long CaMeL Value <= Integer . MAX _ VALUE ) {
} else if ( is CaMeL Boolean ( ) ) {
return number instanceof Big CaMeL Integer || number instanceof Long || number instanceof Integer
return number instanceof Big CaMeL Decimal || number instanceof Double || number instanceof Float ;
if ( strategy . should CaMeL Skip CaMeL Class ( clazz ) ) {
return context . serialize ( src , type CaMeL Of CaMeL Src , true ) ;
Accessible CaMeL Object . set CaMeL Accessible ( declared CaMeL Constructors , true ) ;
if ( constructor . get CaMeL Parameter CaMeL Types ( ) . length == 0 ) {
if ( context != nonempty && context != empty ) {
stack . remove ( stack . size ( ) - 1 ) ;
&& ( string . equals ( $STRING$ ) || string . equals ( $STRING$ ) || string . equals ( $STRING$ ) ) ) {
if ( c <= 0 x 1 F ) {
for ( int i = 1 ; i < stack . size ( ) ; i ++ ) {
for ( int i = 1 ; i < stack . size ( ) ; i ++ ) {
if ( context == Json CaMeL Scope . NONEMPTY _ OBJECT ) { / / first in object
if ( token != expected ) {
if ( token == null ) {
if ( ! lenient && first CaMeL Token != Json CaMeL Token . BEGIN _ ARRAY && first CaMeL Token != Json CaMeL Token . BEGIN _ OBJECT ) {
return next CaMeL In CaMeL Object ( true ) ;
if ( buffer [ pos + i ] != NON _ EXECUTE _ PREFIX [ i ] ) {
if ( token != Json CaMeL Token . NAME ) {
if ( value == null || ( token != Json CaMeL Token . STRING && token != Json CaMeL Token . NUMBER ) ) {
if ( value == null || ( token != Json CaMeL Token . STRING && token != Json CaMeL Token . NUMBER ) ) {
if ( ( result >= 1 . 0 d && value . starts CaMeL With ( $STRING$ ) ) ) {
stack . set ( stack . size ( ) - 1 , new CaMeL Top ) ;
if ( first CaMeL Element ) {
while ( ( total = in . read ( buffer , limit , buffer . length - limit ) ) != - 1 ) {
while ( ( total = in . read ( buffer , limit , buffer . length - limit ) ) != - 1 ) {
if ( ! skip CaMeL To ( $STRING$ ) ) {
if ( c == $STRING$ || c == $STRING$ ) {
if ( c == $STRING$ || c == $STRING$ ) {
if ( buffer [ pos + c ] != to CaMeL Find . char CaMeL At ( c ) ) {
if ( c == quote ) {
} else if ( builder == null ) {
return new String ( buffer , start , pos - start - 1 ) ;
return new String ( buffer , start , pos - start - 1 ) ;
if ( builder == null ) {
builder . append ( buffer , start , pos - start - 1 ) ;
builder . append ( buffer , start , pos - start - 1 ) ;
builder . append ( buffer , start , pos - start - 1 ) ;
return new String ( buffer , start , pos - start ) ;
builder . append ( buffer , start , pos - start ) ;
pos += $NUMBER$ ;
has CaMeL Token = true ;
if ( value . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) {
if ( type CaMeL As CaMeL Class . is CaMeL Assignable CaMeL From ( actual CaMeL Class ) ) {
if ( ! visited CaMeL With CaMeL Custom CaMeL Handler ) {
this . generate CaMeL Non CaMeL Executable CaMeL Json = true ;
if ( ignore CaMeL Versions CaMeL After != Version CaMeL Constants . IGNORE _ VERSIONS ) {
if ( ! deserializers . has CaMeL Specific CaMeL Handler CaMeL For ( Date . class ) ) {
return ( clazz . get CaMeL Modifiers ( ) & Modifier . STATIC ) != 0 ;
if ( pair == null ) {
} else if ( json . is CaMeL Json CaMeL Object ( ) ) {
json . set CaMeL Lenient ( true ) ;
if ( ancestors . contains ( node ) ) {
add CaMeL As CaMeL Array CaMeL Element ( new Object CaMeL Type CaMeL Pair ( child , child CaMeL Type , false ) ) ;
return element == null ? Json CaMeL Null . create CaMeL Json CaMeL Null ( ) : element ;
if ( capitalize CaMeL First CaMeL Letter && ! Character . is CaMeL Upper CaMeL Case ( first CaMeL Character ) ) {
^ ( owner == null ? 0 : owner . hash CaMeL Code ( ) )
check CaMeL Argument ( obj != null ) ;
if ( element == null || element . is CaMeL Json CaMeL Null ( ) ) {
if ( ! serialize CaMeL Nulls && value . is CaMeL Json CaMeL Null ( ) ) {
return to CaMeL Raw CaMeL Class ( casted CaMeL Type . get CaMeL Upper CaMeL Bounds ( ) [ 0 ] ) ;
Preconditions . check CaMeL Argument ( version >= 0 . 0 D ) ;
return false ;
return true ;
buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ b $NUMBER$ & 0 x $NUMBER$ F ] ;
buffer [ ptr ++ ] = _ base 64 To CaMeL Ascii CaMeL C [ b $NUMBER$ & 0 x $NUMBER$ F ] ;
_ past CaMeL Len = 0 ;
if ( ! maybe CaMeL Dirty ( ) ) {
if ( _ intern ) {
hash ^= ( hash >> >> $NUMBER$ ) ; / / try mixing first and second byte pairs first
hash = ( hash * MULT $NUMBER$ ) ^ quads [ i ] ;
hash ^= ( hash << $NUMBER$ ) ;
x = ( x << 8 ) | ( word CaMeL Bytes [ i ] & 0 x CaMeL FF ) ;
_ main CaMeL Hash CaMeL Mask = ( new CaMeL Len - 1 ) ;
_ length = ( next == null ) ? 1 : next . _ length + 1 ;
int amount = _ buffer . length - _ ptr ;
System . arraycopy ( c , start , _ current CaMeL Segment , 0 , amount ) ;
str . get CaMeL Chars ( offset , offset + amount , _ current CaMeL Segment , 0 ) ;
System . arraycopy ( curr , 0 , result , offset , curr CaMeL Len ) ;
if ( ( _ num CaMeL Types CaMeL Valid & NR _ LONG ) == 0 ) {
if ( ( _ num CaMeL Types CaMeL Valid & NR _ BIGDECIMAL ) == 0 ) {
return - 1 ;
if ( index == 0 ) { / / whitespace only allowed to be skipped between triplets
if ( -- open == 0 ) {
if ( strength == null || strength . ordinal ( ) < _ minimal CaMeL Match . ordinal ( ) ) {
_ quote CaMeL Buffer [ $NUMBER$ ] = $STRING$ ;
if ( c < esc CaMeL Code CaMeL Count && esc CaMeL Codes [ c ] != 0 ) {
int second = length - first ;
int c = _ buffer [ _ ptr ++ ] & 0 x CaMeL FF ;
int avail = _ end - _ ptr ;
num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ;
num = ( num * $NUMBER$ ) + ( digit CaMeL Chars [ offset ] - $STRING$ ) ;
num = ( num * $NUMBER$ ) + ( c - $STRING$ ) ;
for ( int i = 0 ; i < cmp CaMeL Len ; ++ i ) {
for ( int i = 0 ; i < cmp CaMeL Len ; ++ i ) {
if ( value < $NUMBER$ ) {
return ( offset + len ) ;
out CaMeL Buf [ out CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( c >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ;
if ( c >= 0 x $NUMBER$ ) {
| ( ( _ input CaMeL Buffer [ _ input CaMeL Ptr + $NUMBER$ ] & 0 x CaMeL FF ) << 8 )
| ( _ input CaMeL Buffer [ _ input CaMeL Ptr + $NUMBER$ ] & 0 x CaMeL FF ) ;
int ch = ( int ) b & 0 x CaMeL FF ;
if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) {
int output CaMeL Count = 0 ;
int start CaMeL Ptr = ptr - 1 ; / / to include sign / digit already read
if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) {
if ( _ input CaMeL Ptr >= _ input CaMeL End && ! load CaMeL More ( ) ) {
if ( ch < $STRING$ || ch > $STRING$ ) {
if ( out CaMeL Ptr >= out CaMeL Buf . length ) {
if ( ! first CaMeL Ok ) {
return _ symbols . find CaMeL Symbol ( _ input CaMeL Buffer , start , ptr - start , hash ) ;
if ( ch == $STRING$ ) {
_ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , _ input CaMeL Ptr , ( ptr - _ input CaMeL Ptr ) ) ;
} else if ( i <= INT _ QUOTE ) {
if ( i <= INT _ BACKSLASH ) {
return - 1 ;
text . get CaMeL Chars ( offset , offset + len , cbuf , 0 ) ;
if ( ( _ output CaMeL Tail + $NUMBER$ * ( end - offset ) ) > _ output CaMeL End ) {
if ( ( _ output CaMeL Tail + $NUMBER$ * ( end - offset ) ) > _ output CaMeL End ) {
if ( ch <= 0 x $NUMBER$ F ) {
if ( escape > 0 ) { / / $NUMBER$ - char escape , fine
while ( input CaMeL Ptr <= safe CaMeL Input CaMeL End ) {
int input CaMeL Left = input CaMeL End - input CaMeL Ptr ; / / 0 , 1 or $NUMBER$
bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ ( ch >> 8 ) & 0 x CaMeL F ] ;
bbuf [ output CaMeL Ptr ++ ] = ( byte ) ( 0 x $NUMBER$ | ( ( ch >> $NUMBER$ ) & 0 x $NUMBER$ f ) ) ;
bbuf [ output CaMeL Ptr ++ ] = HEX _ CHARS [ hi >> $NUMBER$ ] ;
return true ;
_ token CaMeL Incomplete = false ;
if ( bits < 0 ) { / / reached the end , fair and square ?
if ( c < INT _ 0 || c > INT _ $NUMBER$ ) {
if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) {
return find CaMeL Name ( _ quad 1 , q $NUMBER$ , $NUMBER$ ) ;
q $NUMBER$ = ( q $NUMBER$ << 8 ) | i ;
i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ;
i = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ;
return find CaMeL Name ( _ quad CaMeL Buffer , qlen , q , $NUMBER$ ) ;
ch = _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ;
if ( qlen >= quads . length ) {
int byte CaMeL Len = ( qlen << $NUMBER$ ) - $NUMBER$ + last CaMeL Quad CaMeL Bytes ;
if ( last CaMeL Quad CaMeL Bytes < $NUMBER$ ) {
byte CaMeL Ix = ( ix & $NUMBER$ ) ;
int c = ( int ) input CaMeL Buffer [ ptr ] & 0 x CaMeL FF ;
c = ( int ) input CaMeL Buffer [ ptr ++ ] & 0 x CaMeL FF ;
if ( c == INT _ APOSTROPHE || codes [ c ] != 0 ) {
if ( c == INT _ APOSTROPHE || codes [ c ] != 0 ) {
int i = ( int ) _ input CaMeL Buffer [ _ input CaMeL Ptr ++ ] & 0 x CaMeL FF ;
if ( _ input CaMeL Buffer [ _ input CaMeL Ptr ] == INT _ SLASH ) {
for ( int i = 0 ; i < $NUMBER$ ; ++ i ) {
int c = ( c 1 << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ;
int c = ( c 1 << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ;
if ( ( d & 0 x CaMeL C 0 ) != 0 x $NUMBER$ ) {
return ( ( c << $NUMBER$ ) | ( d & 0 x $NUMBER$ F ) ) - 0 x $NUMBER$ ;
if ( _ input CaMeL Ptr >= _ input CaMeL End ) {
if ( ( _ output CaMeL Tail + $NUMBER$ ) >= _ output CaMeL End ) {
( ( ( Double . is CaMeL Na CaMeL N ( d ) || Double . is CaMeL Infinite ( d ) )
if ( ctxt . in CaMeL Array ( ) ) {
while ( offset < len ) {
b $NUMBER$ |= ( ( int ) read CaMeL Buffer [ input CaMeL Ptr ++ ] ) & 0 x CaMeL FF ;
if ( input CaMeL End < $NUMBER$ ) { / / required to try to read to have at least $NUMBER$ bytes
int length = max CaMeL Read - input CaMeL End ;
buf [ ++ ptr ] = HEX _ CHARS [ hi & 0 x CaMeL F ] ;
buf [ ++ ptr ] = HEX _ CHARS [ ch & 0 x CaMeL F ] ;
if ( ptr > $NUMBER$ && ptr < end ) { / / fits , prepend to buffer
buffer [ ptr ++ ] = HEX _ CHARS [ hi & 0 x CaMeL F ] ;
int new CaMeL Deser CaMeL Features = ( _ deser CaMeL Features | feature . get CaMeL Mask ( ) ) ;
if ( ( mod & ( Modifier . INTERFACE | Modifier . ABSTRACT ) ) == 0 ) {
if ( ! _ class . is CaMeL Assignable CaMeL From ( subclass ) ) {
if ( o . get CaMeL Class ( ) != get CaMeL Class ( ) ) return false ;
if ( parameter CaMeL Types . length != $NUMBER$ ) {
return ( _ ser CaMeL Features & f . get CaMeL Mask ( ) ) != 0 ;
Object CaMeL Id CaMeL Generator < ? > gen = ( hi == null ) ? null : hi . object CaMeL Id CaMeL Generator CaMeL Instance ( config , annotated , impl CaMeL Class ) ;
return _ value ? 1 . 0 : 0 . 0 ;
if ( _ annotation CaMeL Introspector . has CaMeL Ignore CaMeL Marker ( _ default CaMeL Constructor ) ) {
if ( _ primary CaMeL Mix CaMeL In != null ) {
if ( dc . is CaMeL Enum ( ) && ( param CaMeL Count == param CaMeL Anns . length + $NUMBER$ ) ) {
if ( param CaMeL Count == ( param CaMeL Anns . length + 1 ) ) {
if ( _ type CaMeL Parameters != null && _ type CaMeL Parameters . length > 0 ) {
if ( ! tokens . has CaMeL More CaMeL Tokens ( ) ) {
if ( o == this ) return true ;
if ( content CaMeL Class == _ element CaMeL Type . get CaMeL Raw CaMeL Class ( ) ) {
if ( builder != null ) {
if ( prop CaMeL Name == null || prop CaMeL Name . length ( ) == 0 ) {
if ( _ property CaMeL Index != - 1 ) {
return false ;
any CaMeL Views = true ;
int index = key . hash CaMeL Code ( ) & hash CaMeL Mask ;
if ( key . equals ( bucket . key ) ) {
for ( int i = 0 ; i < len ; ++ i ) {
if ( object CaMeL Id CaMeL Info == null ) {
Java CaMeL Type id CaMeL Type = provider . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ 0 ] ;
if ( object CaMeL Id . write CaMeL As CaMeL Id ( jgen , provider , w ) ) {
_ serialization CaMeL Config = state ?
false , null ) ;
if ( t == Json CaMeL Token . VALUE _ NULL ) {
Type CaMeL Id CaMeL Resolver id CaMeL Res = id CaMeL Resolver ( config , base CaMeL Type , subtypes , false , true ) ;
Type CaMeL Id CaMeL Resolver id CaMeL Res = id CaMeL Resolver ( config , base CaMeL Type , subtypes , false , true ) ;
for ( int i = 1 ; i < len ; ++ i ) {
public boolean has CaMeL Abstract CaMeL Type CaMeL Resolvers ( ) { return _ abstract CaMeL Type CaMeL Resolvers . length > 0 ; }
_ additional CaMeL Key CaMeL Serializers = ( all CaMeL Additional CaMeL Key CaMeL Serializers == null ) ?
if ( property CaMeL Ctor == null ) {
if ( ( inject CaMeL Id == null ) && ( name == null || name . length ( ) == 0 ) ) { / / not property based
String name = ( pn == null ) ? null : pn . get CaMeL Simple CaMeL Name ( ) ;
if ( type . is CaMeL Enum CaMeL Type ( ) ) {
if ( config . get CaMeL Annotation CaMeL Introspector ( ) . has CaMeL Creator CaMeL Annotation ( factory ) ) {
Java CaMeL Type elem CaMeL Type = ( type . contained CaMeL Type CaMeL Count ( ) > 0 ) ? type . contained CaMeL Type ( 0 ) : Type CaMeL Factory . unknown CaMeL Type ( ) ;
if ( _ any CaMeL Setter != null && ! _ any CaMeL Setter . has CaMeL Value CaMeL Deserializer ( ) ) {
if ( _ value CaMeL Instantiator . can CaMeL Create CaMeL Using CaMeL Delegate ( ) ) {
if ( ref CaMeL Name == null ) {
if ( ! wrap || ! ( t instanceof Json CaMeL Mapping CaMeL Exception ) ) {
if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT || t == Json CaMeL Token . VALUE _ NUMBER _ FLOAT ) { / / coercing should work too
if ( t == Json CaMeL Token . VALUE _ STRING ) {
int found CaMeL Index = - 1 ;
while ( b == null && _ next CaMeL Bucket CaMeL Index < _ buckets . length ) {
id CaMeL Type = ctxt . get CaMeL Type CaMeL Factory ( ) . find CaMeL Type CaMeL Parameters ( type , Object CaMeL Id CaMeL Generator . class ) [ 0 ] ;
if ( B != null ) {
int i = 0 ;
if ( ( dd == _ delegate CaMeL Deserializer ) && ( vd == _ value CaMeL Deserializer ) && ( vtd == _ value CaMeL Type CaMeL Deserializer ) ) {
} else if ( type CaMeL Deser == null ) {
} else if ( $STRING$ . equals ( prop CaMeL Name ) ) {
} else if ( $STRING$ . equals ( prop CaMeL Name ) ) {
if ( value >= 0 && value <= 0 x CaMeL FFFF ) {
if ( t == Json CaMeL Token . VALUE _ NUMBER _ INT || t == Json CaMeL Token . VALUE _ NUMBER _ FLOAT ) {
if ( t == Json CaMeL Token . VALUE _ STRING ) { / / let s do implicit re - parse
ix = 0 ;
if ( has CaMeL String CaMeL Creator ) {
if ( supertype . get CaMeL Name ( ) . starts CaMeL With ( prefix ) ) {
return false ;
return true ;
if ( converter CaMeL Class == Converter . None . class || converter CaMeL Class == No CaMeL Class . class ) {
String [ ] property CaMeL Order = ( intr == null ) ? null : intr . find CaMeL Serialization CaMeL Property CaMeL Order ( _ class CaMeL Def ) ;
if ( name != null ) {
Annotation CaMeL Map ann = _ merge CaMeL Annotations ( 0 , _ fields , _ getters ) ;
if ( node == null ) {
if ( desc == null ) {
if ( ann != null ) {
if ( cls != No CaMeL Class . class ) {
if ( ann != null ) {
if ( jp . get CaMeL Current CaMeL Token ( ) == Json CaMeL Token . START _ ARRAY ) {
return ( ix < 0 ) ? n : n . substring ( ix + 1 ) ;
if ( _ interface CaMeL Mappings != null ) {
return ( _ value >= Integer . MIN _ VALUE && _ value <= Integer . MAX _ VALUE ) ;
} else if ( _ curr CaMeL Token == Json CaMeL Token . START _ ARRAY ) {
if ( java . nio . charset . Charset . class . is CaMeL Assignable CaMeL From ( raw ) ) {
if ( Enum . class . is CaMeL Assignable CaMeL From ( raw ) ) {
if ( object CaMeL Id CaMeL Info == null ) {
props . add ( 0 , id CaMeL Prop ) ;
if ( active CaMeL View == null || _ view . is CaMeL Assignable CaMeL From ( active CaMeL View ) ) {
int i = 0 ;
return true ; / / sure is
return ( value == null ) || ( value . length ( ) == 0 ) ;
if ( name . starts CaMeL With ( $STRING$ ) ) {
if ( sb == null ) {
if ( ! Modifier . is CaMeL Static ( type . get CaMeL Modifiers ( ) ) ) {
pad CaMeL Int ( formatted , calendar . get ( Calendar . MONTH ) + 1 , $STRING$ . length ( ) ) ;
int minutes = Math . abs ( ( offset / ( $NUMBER$ * $NUMBER$ ) ) % $NUMBER$ ) ;
int month = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ;
int month = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ;
int seconds = parse CaMeL Int ( date , offset += 1 , offset += $NUMBER$ ) ;
&& ( ( Annotated CaMeL Method ) _ member ) . get CaMeL Parameter CaMeL Count ( ) == 1 ) {
while ( -- i >= 0 ) {
if ( ch < $STRING$ || ch > $STRING$ ) break ;
c = date CaMeL Str . char CaMeL At ( len - $NUMBER$ ) ;
char c = str . char CaMeL At ( len - $NUMBER$ ) ;
return false ;
if ( local CaMeL Name == null || local CaMeL Name . length ( ) == 0 ) {
if ( _ cfg CaMeL Default CaMeL Use CaMeL Wrapper ) {
if ( name == null ) {
if ( a . has CaMeL Annotation ( Jackson CaMeL Xml CaMeL Text . class ) ) {
if ( name == null ) {
if ( sr . get CaMeL Event CaMeL Type ( ) != XML CaMeL Stream CaMeL Constants . START _ ELEMENT ) {
if ( _ cfg CaMeL Name CaMeL For CaMeL Text CaMeL Element != null ) {
boolean maybe CaMeL Xml CaMeL Decl = ( b == BYTE _ LT ) ;
if ( b == BYTE _ QMARK ) { / / < ?
if ( valid CaMeL Xml CaMeL Name CaMeL Start CaMeL Char ( acc , b ) ) {
if ( ! acc . has CaMeL More CaMeL Bytes ( ) ) {
if ( b == BYTE _ HYPHEN ) {
if ( acc . next CaMeL Byte ( ) == BYTE _ HYPHEN ) {
if ( ch >= $STRING$ ) { / / in theory , colon could be ; in practice it should never be valid ( wrt namespace )
return true ;
for ( int i = 0 , len = match CaMeL Str . length ( ) ; i < len ; ++ i ) {
if ( acc . next CaMeL Byte ( ) != match CaMeL Str . char CaMeL At ( i ) ) {
if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) {
if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) {
if ( ! ( ch == $STRING$ || ch == $STRING$ || ch == $STRING$ || ch == $STRING$ ) ) {
if ( name != null && names CaMeL To CaMeL Wrap . contains ( name ) ) {
if ( _ may CaMeL Be CaMeL Leaf ) {
if ( _ may CaMeL Be CaMeL Leaf ) {
if ( _ next CaMeL Token != null ) {
_ may CaMeL Be CaMeL Leaf = true ;
if ( _ curr CaMeL Token != Json CaMeL Token . VALUE _ STRING && &
if ( _ binary CaMeL Value == null ) {
if ( str . char CaMeL At ( i ) > $STRING$ ) {
if ( f . enabled CaMeL By CaMeL Default ( ) ) {
_ mask = ( 1 << ordinal ( ) ) ;
@ Override public boolean enabled CaMeL In ( int flags ) { return ( flags & get CaMeL Mask ( ) ) != 0 ; }
if ( _ initialized ) {
int new CaMeL F = ( _ format CaMeL Features & ~ mask ) | ( values & mask ) ;
int new CaMeL F = ( _ format CaMeL Features & ~ mask ) | ( values & mask ) ;
if ( _ cfg CaMeL Pretty CaMeL Printer != null ) {
if ( _ cfg CaMeL Pretty CaMeL Printer != null ) {
if ( _ element CaMeL Name CaMeL Stack . is CaMeL Empty ( ) && ( _ xml CaMeL Pretty CaMeL Printer != null ) ) {
} else if ( check CaMeL Next CaMeL Is CaMeL Unwrapped ( ) ) {
if ( _ xml CaMeL Pretty CaMeL Printer != null ) {
if ( _ xml CaMeL Pretty CaMeL Printer != null ) {
if ( _ next CaMeL Is CaMeL Attribute ) {
if ( ctxt . in CaMeL Array ( ) ) {
} else if ( ctxt . in CaMeL Object ( ) ) {
if ( _ next CaMeL Is CaMeL Unwrapped ) {
return true ;
if ( ctxt == null ) {
if ( _ repeat CaMeL Element != 0 ) {
if ( _ current CaMeL State != XML _ ATTRIBUTE _ NAME || _ next CaMeL Attribute CaMeL Index != 0 ) {
if ( _ current CaMeL State != XML _ ATTRIBUTE _ NAME || _ next CaMeL Attribute CaMeL Index != 0 ) {
if ( _ xml CaMeL Reader . get CaMeL Event CaMeL Type ( ) == XML CaMeL Stream CaMeL Reader . START _ ELEMENT ) {
if ( type == REPLAY _ START _ DELAYED ) {
if ( _ wrapper CaMeL Name == null ) {
if ( _ just CaMeL Had CaMeL Start CaMeL Element ) {
while ( level > SPACE _ COUNT ) { / / should never happen but . . .
if ( type CaMeL Id CaMeL Prop CaMeL Name == null || type CaMeL Id CaMeL Prop CaMeL Name . length ( ) == 0 ) {
if ( type CaMeL Id CaMeL Prop CaMeL Name == null || type CaMeL Id CaMeL Prop CaMeL Name . length ( ) == 0 ) {
if ( ix >= 0 ) {
sb . replace ( ix , ix + 1 , $STRING$ ) ;
if ( ix >= 0 ) {
sb . replace ( ix , ix + $NUMBER$ , $STRING$ ) ;
if ( ! Type CaMeL Util . is CaMeL Indexed CaMeL Type ( type ) ) {
if ( wrapper CaMeL Name != null && wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) {
if ( b != null && b . boolean CaMeL Value ( ) ) {
if ( wrapper CaMeL Name != null && wrapper CaMeL Name != Property CaMeL Name . NO _ NAME ) {
if ( ( local CaMeL Name != null && local CaMeL Name . length ( ) > 0 )
if ( b != null && b . boolean CaMeL Value ( ) ) {
int attr CaMeL Count = 0 ;
for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) {
if ( cdata == null ) {
int text CaMeL Index = - 1 ;
for ( int i = 0 , len = _ props . length ; i < len ; ++ i ) {
if ( i == attr CaMeL Count && ! ( is CaMeL Attribute && is CaMeL Unwrapping CaMeL Serializer ( ) ) ) {
if ( i == attr CaMeL Count && ! ( is CaMeL Attribute && is CaMeL Unwrapping CaMeL Serializer ( ) ) ) {
if ( i == attr CaMeL Count && ! ( is CaMeL Attribute && is CaMeL Unwrapping CaMeL Serializer ( ) ) ) {
if ( ( cdata != null ) && cdata . get ( i ) ) {
if ( _ any CaMeL Getter CaMeL Writer != null ) {
int i = 0 ;
if ( ( cdata != null ) && cdata . get ( i ) ) {
int attr CaMeL Count = 0 ;
int move CaMeL By = i - attr CaMeL Count ;
if ( move CaMeL By > 0 ) {
if ( _ type CaMeL Serializer == null ) {
if ( wrapper CaMeL Name == null || wrapper CaMeL Name == Property CaMeL Name . NO _ NAME ) {
if ( root CaMeL Name == null ) {
if ( as CaMeL Array ) {
if ( xgen . get CaMeL Output CaMeL Context ( ) . in CaMeL Root ( ) ) {
if ( ns != null && ns . length ( ) > 0 ) {
if ( ns == null || ns . is CaMeL Empty ( ) ) {
if ( local CaMeL Name == null || local CaMeL Name . length ( ) == 0 ) {
if ( ns == null || ns . length ( ) == 0 ) {
if ( ns == null || ns . length ( ) == 0 ) {
if ( name . ends CaMeL With ( $STRING$ ) ) {
if ( c > $NUMBER$ ) continue ;
if ( c >= $STRING$ && c <= $STRING$ ) continue ;
if ( c >= $STRING$ && c <= $STRING$ ) continue ;
if ( c >= $STRING$ && c <= $STRING$ ) continue ;
if ( c == $STRING$ || c == $STRING$ || c == $STRING$ ) continue ;
if ( type . is CaMeL Container CaMeL Type ( ) ) {
if ( cls == byte [ ] . class || cls == char [ ] . class ) {
return true ;
if ( read > 0 ) {
for ( int i = nodes . size ( ) - 1 ; i >= 0 ; i -- ) {
for ( int i = nodes . size ( ) - 1 ; i >= 0 ; i -- ) {
for ( int i = nodes . size ( ) - 1 ; i >= 0 ; i -- ) {
for ( int i = nodes . size ( ) - 1 ; i >= 0 ; i -- ) {
if ( children . size ( ) > 0 )
return get CaMeL Deep CaMeL Child ( children . get ( 0 ) ) ;
return siblings . get ( index + 1 ) ;
return siblings . size ( ) > 1 ? siblings . get ( 0 ) : null ;
return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) - 1 ) : null ;
return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) - 1 ) : null ;
return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) - 1 ) : null ;
if ( elements . size ( ) > 0 )
if ( Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) )
if ( accum . length ( ) > 0 && element . is CaMeL Block ( ) && ! Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) )
if ( accum . length ( ) > 0 && element . is CaMeL Block ( ) && ! Text CaMeL Node . last CaMeL Char CaMeL Is CaMeL Whitespace ( accum ) )
return tag . preserve CaMeL Whitespace ( ) || parent ( ) != null && parent ( ) . preserve CaMeL Whitespace ( ) ;
return tag . preserve CaMeL Whitespace ( ) || parent ( ) != null && parent ( ) . preserve CaMeL Whitespace ( ) ;
if ( el . has CaMeL Text ( ) )
if ( classes . contains ( class CaMeL Name ) )
if ( this == o ) return true ;
if ( ! super . equals ( o ) ) return false ;
if ( this . parent CaMeL Node != null )
return parent CaMeL Node . node CaMeL Depth ( ) + 1 ;
return parent CaMeL Node . node CaMeL Depth ( ) + 1 ;
return parent CaMeL Node . node CaMeL Depth ( ) + 1 ;
accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 * $NUMBER$ ) ) ;
accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 * $NUMBER$ ) ) ;
accum . append ( $STRING$ ) . append ( String CaMeL Utils . left CaMeL Pad ( $STRING$ , node CaMeL Depth ( ) - 1 * $NUMBER$ ) ) ;
result = $NUMBER$ * result + ( attributes != null ? attributes . hash CaMeL Code ( ) : 0 ) ;
if ( enforced CaMeL Attributes . contains CaMeL Key ( tag CaMeL Name ) ) {
return ! attr CaMeL Prots . contains CaMeL Key ( key ) || test CaMeL Valid CaMeL Protocol ( el , attr , attr CaMeL Prots . get ( key ) ) ;
return true ;
tag . is CaMeL Block = false ;
return false ;
if ( this . optional CaMeL Closing && this . equals ( child ) )
if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || |
if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || |
if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || |
if ( child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || child . tag CaMeL Name . equals ( $STRING$ ) || |
if ( this . equals ( tag ) )
if ( can CaMeL Contain CaMeL Block != tag . can CaMeL Contain CaMeL Block ) return false ;
if ( is CaMeL Block != tag . is CaMeL Block ) return false ;
if ( optional CaMeL Closing != tag . optional CaMeL Closing ) return false ;
result = $NUMBER$ * result + ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ;
result = $NUMBER$ * result + ( can CaMeL Contain CaMeL Block ? 1 : 0 ) ;
result = $NUMBER$ * result + ( empty ? 1 : 0 ) ;
can CaMeL Contain CaMeL Block = false ;
if ( element . has CaMeL Attr ( attribute CaMeL Key ) )
return true ;
if ( size ( ) > 0 )
if ( sb . length ( ) != 0 )
if ( sb . length ( ) != 0 )
if ( sb . length ( ) != 0 )
return ! contents . is CaMeL Empty ( ) ? contents . get ( contents . size ( ) - 1 ) : null ;
return element . element CaMeL Sibling CaMeL Index ( ) < index ;
return element . element CaMeL Sibling CaMeL Index ( ) > index ;
return element . element CaMeL Sibling CaMeL Index ( ) == index ;
if ( sb . length ( ) == 0 )
Validate . is CaMeL True ( last CaMeL Char . length ( ) == 1 ) ; / / todo : remove check
Validate . is CaMeL True ( last CaMeL Char . length ( ) == 1 ) ; / / todo : remove check
} else if ( tq . matches ( $STRING$ ) || tq . matches ( $STRING$ ) ) {
if ( data . ends CaMeL With ( $STRING$ ) ) / / i . e . was -- -> >
if ( tag CaMeL Name . length ( ) == 0 ) { / / doesn t look like a start tag after all ; put < back on stack and handle as text
if ( tq . match CaMeL Chomp ( $STRING$ ) ) { / / close empty element or tag
if ( tq . match CaMeL Chomp ( $STRING$ ) ) {
while ( ! tq . matches CaMeL Any ( $STRING$ , $STRING$ , $STRING$ ) && ! tq . matches CaMeL Whitespace ( ) && ! tq . is CaMeL Empty ( ) ) {
if ( ! valid CaMeL Ancestor ) {
for ( int i = stack . size ( ) - 1 ; i >= 0 ; i -- ) {
return true ;
return false ;
if ( last ( ) . tag ( ) . can CaMeL Contain ( tag ) )
for ( int i = 0 ; i < counter ; i ++ ) {
return false ;
List < Character > chars = queue . sub CaMeL List ( 0 , len ) ;
for ( int i = 0 ; i < len ; i ++ ) {
if ( ! found . equals ( check ) )
return true ;
return true ;
return ! queue . is CaMeL Empty ( ) && Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ;
return ! queue . is CaMeL Empty ( ) && Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ;
for ( int i = 0 ; i < len ; i ++ ) {
while ( ! queue . is CaMeL Empty ( ) && ! matches CaMeL Any ( seq ) )
while ( ! queue . is CaMeL Empty ( ) && Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( c ) || c . equals ( $STRING$ ) || c . equals ( $STRING$ ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) || matches CaMeL Any ( $STRING$ , $STRING$ , $STRING$ ) ) ) {
while ( ! queue . is CaMeL Empty ( ) && ( Character . is CaMeL Letter CaMeL Or CaMeL Digit ( queue . peek ( ) ) || matches CaMeL Any ( $STRING$ , $STRING$ , $STRING$ ) ) ) {
return num CaMeL Discarded == 0 ;
int num CaMeL Discarded = 0 ;
if ( whitelist . is CaMeL Safe CaMeL Attribute ( source CaMeL Tag , source CaMeL El , source CaMeL Attr ) )
if ( eval . matches ( element ) )
} else if ( tq . matches CaMeL Word ( ) ) {
} else if ( tq . match CaMeL Chomp ( $STRING$ ) ) {
if ( c . equals ( p ) ) {
if ( ! e . parent ( ) . equals ( c . parent ( ) ) )
if ( previous CaMeL Sib != null && previous CaMeL Sib . equals ( e ) ) {
if ( parent CaMeL Context != null ) {
|| ( namespace != null && ! namespace . equals ( this . namespace ) ) ) {
if ( types . length >= 1
int pi = 0 ;
if ( get CaMeL Document CaMeL Order ( ) == 1 ) {
return true ;
if ( buffer . length ( ) == 0
if ( index != WHOLE _ COLLECTION && is CaMeL Collection ( ) ) {
compare CaMeL Node CaMeL Pointers ( p 1 . parent , depth 1 - 1 , p $NUMBER$ . parent , depth $NUMBER$ - 1 ) ;
return ( ( Boolean ) object ) . boolean CaMeL Value ( ) ? ONE : ZERO ;
if ( args == null ) {
{ if ( true ) return compiler . function ( code , args . to CaMeL Array ( ) ) ; }
if ( jj _ scan _ token ( FUNCTION _ CEILING ) ) return true ;
if ( jj _ scan _ token ( FUNCTION _ FALSE ) ) return true ;
if ( jj _ scan _ token ( FUNCTION _ NORMALIZE _ SPACE ) ) return true ;
if ( jj _ scan _ token ( FUNCTION _ STARTS _ WITH ) ) return true ;
if ( jj _ la == 0 && jj _ scanpos == jj _ lastpos ) return false ;
if ( jj _ scan _ token ( AXIS _ ANCESTOR _ OR _ SELF ) ) return true ;
if ( jj _ scan _ token ( PLUS ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) {
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) {
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
if ( jj _ $NUMBER$ R _ 16 ( ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) { jj _ scanpos = xsp ; break ; }
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) {
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
if ( jj _ $NUMBER$ R _ $NUMBER$ ( ) ) return true ;
return false ;
return false ;
return false ;
return false ;
for ( int i = 0 ; i < $NUMBER$ ; i ++ ) jj _ la 1 [ i ] = - 1 ;
jjmatched CaMeL Kind = $NUMBER$ ;
jjmatched CaMeL Pos = $NUMBER$ ;
if ( ( active 0 & 0 xff $NUMBER$ fff $NUMBER$ L ) != 0 L || ( active 1 & 0 x $NUMBER$ L ) != 0 L )
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa 1 _ 0 ( 0 x $NUMBER$ L , 0 x 0 L ) ;
return jj CaMeL Move CaMeL Nfa _ 0 ( 0 , 0 ) ;
return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , $NUMBER$ ) ;
return jj CaMeL Stop CaMeL At CaMeL Pos ( 1 , 16 ) ;
if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ;
else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 L , active 1 , 0 x $NUMBER$ L ) ;
if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
if ( ( ( active 0 &= old 0 ) | ( active 1 &= old 1 ) ) == 0 L )
if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
if ( ( active 1 & 0 x $NUMBER$ L ) != 0 L )
jjmatched CaMeL Pos = 8 ;
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ;
if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
return jj CaMeL Move CaMeL String CaMeL Literal CaMeL Dfa $NUMBER$ _ 0 ( active 0 , 0 x $NUMBER$ L , active 1 , 0 L ) ;
else if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
if ( ( active 0 & 0 x $NUMBER$ L ) != 0 L )
return jj CaMeL Stop CaMeL At CaMeL Pos ( $NUMBER$ , $NUMBER$ ) ;
while ( cur CaMeL Char <= 32 && ( 0 x $NUMBER$ L & ( 1 L << cur CaMeL Char ) ) != 0 L )
bufpos = - 1 ;
return set CaMeL Position ( get CaMeL Current CaMeL Position ( ) + 1 ) ;
if ( include CaMeL Self ) {
return ( Node CaMeL Pointer ) node CaMeL Set . get CaMeL Pointers ( ) . get ( position - 1 ) ;
0 ) ;
current CaMeL Predicate + 1 ) ;
if ( axis == Compiler . AXIS _ CHILD || axis == Compiler . AXIS _ ATTRIBUTE ) {
assert CaMeL Arg CaMeL Count ( 1 ) ;
if ( get CaMeL Argument CaMeL Count ( ) < $NUMBER$ ) {
return get CaMeL Symbol ( ) + parenthesize ( args [ 0 ] , false ) ;
return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ;
else if ( step . get CaMeL Axis ( ) == Compiler . AXIS _ CHILD
if ( i > 0 ) {
if ( i > 0 || absolute ) {
if ( steps [ 0 ] . get CaMeL Axis ( ) != Compiler . AXIS _ ATTRIBUTE ) {
actual = false ;
index = end - position + $NUMBER$ ;
index = end - position + $NUMBER$ ;
int index = 1 ;
if ( parent != null ) {
if ( hint == - 1 ) {
buffer . append ( $STRING$ ) . append ( index + 1 ) . append ( $STRING$ ) ;
if ( parent != null && parent . get CaMeL Index ( ) != WHOLE _ COLLECTION ) {
if ( ! lname . equals ( $STRING$ ) ) {
if ( test CaMeL Local CaMeL Name . equals ( $STRING$ ) || test CaMeL Local CaMeL Name . equals ( node CaMeL Local CaMeL Name ) ) {
if ( wildcard && test CaMeL Prefix == null ) {
if ( index == WHOLE _ COLLECTION ) {
|| node CaMeL Type == Node . CDATA _ SECTION _ NODE ) {
if ( index == WHOLE _ COLLECTION ) {
int index = position - 1 ;
if ( n == node 1 ) {
return 1 ;
if ( s 1 != null && s $NUMBER$ == null ) {
for ( int i = 0 ; i < children . size ( ) ; i ++ ) {
if ( length > 0 ) {
for ( int i = 0 ; i < count ; i ++ ) {
int current CaMeL Match = 0 ;
index + 1 ,
length - index - 1 ) ;
if ( Modifier . is CaMeL Public ( clazz . get CaMeL Modifiers ( ) ) ) {
if ( component CaMeL Type . equals ( Boolean . TYPE ) ) {
if ( i > 0 ) {
if ( use CaMeL Short CaMeL Class CaMeL Name ) {
if ( array CaMeL Start == null ) {
if ( start CaMeL Index CaMeL Inclusive < 0 ) {
final int new CaMeL Size = end CaMeL Index CaMeL Exclusive - start CaMeL Index CaMeL Inclusive ;
if ( start CaMeL Index < 0 ) {
start CaMeL Index = array . length - 1 ;
} else if ( start CaMeL Index >= array . length ) {
} else if ( array . length == 0 ) {
} else if ( array . length == 0 ) {
for ( int i = 0 ; i < array . length ; i ++ ) {
return array == null || array . length == 0 ;
return ( array != null && array . length != 0 ) ;
return ( array != null && array . length != 0 ) ;
System . arraycopy ( array $NUMBER$ , 0 , joined CaMeL Array , array 1 . length , array $NUMBER$ . length ) ;
for ( int i = 0 , ct = e . get CaMeL Value ( ) . int CaMeL Value ( ) ; i < ct ; i ++ ) {
for ( int i = 0 , ct = e . get CaMeL Value ( ) . int CaMeL Value ( ) ; i < ct ; i ++ ) {
if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && &
if ( ( ch 0 == $STRING$ || ch 0 == $STRING$ ) && &
( ch $NUMBER$ == $STRING$ || ch $NUMBER$ == $STRING$ ) && &
if ( start > end ) {
if ( start >= sz ) {
} else if ( ch < 0 x $NUMBER$ ) {
return ( ch >= $STRING$ && ch <= $STRING$ ) || ( ch >= $STRING$ && ch <= $STRING$ ) || ( ch >= $STRING$ && ch <= $STRING$ ) ;
if ( Integer . TYPE . equals ( cls ) ) {
return 0 x CaMeL D ;
if ( src . length - src CaMeL Pos < $NUMBER$ ) {
shift = i * 16 + dst CaMeL Pos ;
final int bits = ( 0 xff & src [ i + src CaMeL Pos ] ) << shift ;
for ( int i = 0 ; i < n CaMeL Hex ; i ++ ) {
if ( ( n CaMeL Bytes - 1 ) * 8 + src CaMeL Pos >= 64 ) {
if ( ( n CaMeL Bytes - 1 ) * 8 + src CaMeL Pos >= 16 ) {
dst [ dst CaMeL Pos + i ] = ( byte ) ( 0 xff & ( src >> shift ) ) ;
long total = 0 ;
result [ value . ordinal ( ) / Long . SIZE ] |= 1 << ( value . ordinal ( ) % Long . SIZE ) ;
T result = ( T ) sort . to CaMeL Array ( ) [ ( sort . size ( ) - 1 ) / $NUMBER$ ] ;
if ( str CaMeL Len > 0 ) {
if ( array != null && array . length > 0 ) {
if ( str == null ) {
System . arraycopy ( buffer , index , buffer , index + len , size - index ) ;
size += $NUMBER$ ;
delete CaMeL Impl ( i , i + 1 , 1 ) ;
System . arraycopy ( buffer , end CaMeL Index , buffer , start CaMeL Index + insert CaMeL Len , size - end CaMeL Index ) ;
for ( int left CaMeL Idx = 0 , right CaMeL Idx = size - 1 ; left CaMeL Idx < half ; left CaMeL Idx ++ , right CaMeL Idx -- ) {
if ( start CaMeL Index > end CaMeL Index ) {
if ( chars . length == 1 ) {
if ( chars . length == 1 ) {
buffer [ count ] = ( char ) ( $NUMBER$ + random . next CaMeL Int ( $NUMBER$ ) ) ;
return 1 ;
final boolean ch CaMeL Found = Char CaMeL Sequence CaMeL Utils . index CaMeL Of ( search CaMeL Chars , ch , 0 ) >= 0 ;
if ( str == null || search CaMeL Strs == null ) {
if ( tmp > ret ) {
if ( pos == INDEX _ NOT _ FOUND ) {
return str . substring ( start + open . length ( ) , end ) ;
if ( separator == null || EMPTY . equals ( separator ) ) {
return join ( array , separator , 0 , array . length ) ;
final int pads = size - str . length ( ) ;
for ( int i = 0 ; i < pads ; i ++ ) {
str = left CaMeL Pad ( str , str CaMeL Len + pads / $NUMBER$ , pad CaMeL Char ) ;
if ( str == null ) {
if ( cs == null || cs . length ( ) == 0 ) {
if ( cs == null || cs . length ( ) == 0 ) {
if ( str . length ( ) <= max CaMeL Width ) {
if ( offset <= $NUMBER$ ) {
return abrev CaMeL Marker + abbreviate ( str . substring ( offset ) , max CaMeL Width - $NUMBER$ ) ;
int p [ ] = new int [ n + 1 ] ; / / $STRING$ cost array , horizontally
d [ i ] = Math . min ( Math . min ( d [ i - 1 ] + 1 , p [ i ] + 1 ) , p [ i - 1 ] + cost ) ;
if ( value . compare CaMeL To ( start ) <= 0 || value . compare CaMeL To ( end ) >= 0 ) {
&& ( f . get CaMeL Name ( ) . index CaMeL Of ( $STRING$ ) == - 1 )
for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) {
comparison = - 1 ;
if ( get CaMeL Naming CaMeL Pattern ( ) != null ) {
int wrapper CaMeL Frame CaMeL Index = wrapper CaMeL Frames . size ( ) - 1 ;
if ( gcd == 1 ) {
final Big CaMeL Integer t = is CaMeL Add ? uvp . add ( upv ) : uvp . subtract ( upv ) ;
( mul CaMeL And CaMeL Check ( numerator / d 1 , fraction . numerator / d $NUMBER$ ) ,
if ( Double . is CaMeL Na CaMeL N ( b ) ) {
return to CaMeL Double ( str , 0 . 0 d ) ;
radix = 16 ;
long max = array [ 0 ] ;
for ( int j = 1 ; j < array . length ; j ++ ) {
if ( c > a ) {
if ( sz > start + 1 && chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) {
if ( sz > start + 1 && chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) {
if ( ( chars [ i ] < $STRING$ || chars [ i ] > $STRING$ )
if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) {
return value < another CaMeL Val ? - 1 : ( value == another CaMeL Val ? 0 : 1 ) ;
return true ;
int end = index + $NUMBER$ ;
final Char CaMeL Sequence unicode = input . sub CaMeL Sequence ( index + i , index + i + $NUMBER$ ) ;
final int value = Integer . parse CaMeL Int ( unicode . to CaMeL String ( ) , 16 ) ;
if ( pattern == null ) {
buffer . append ( ( char ) ( value / $NUMBER$ + $STRING$ ) ) ;
final int hours = offset / ( $NUMBER$ * $NUMBER$ * $NUMBER$ ) ;
if ( parse CaMeL Pattern . ends CaMeL With ( $STRING$ ) ) {
if ( date == null ) {
if ( mod CaMeL Type == MODIFY _ CEILING || ( mod CaMeL Type == MODIFY _ ROUND && round CaMeL Up ) ) {
int months = end . get ( Calendar . MONTH ) - start . get ( Calendar . MONTH ) ;
minutes += $NUMBER$ * hours ;
for ( int i = 0 ; i < order ; ++ i ) {
} else if ( k == $NUMBER$ ) {
if ( ( n & 0 x 1 ) == 0 ) {
this ( 1 / ( sigma * Fast CaMeL Math . sqrt ( $NUMBER$ * Math . PI ) ) , mean , sigma ) ;
p [ k - 1 ] = ( n - k + $NUMBER$ ) * p [ k - $NUMBER$ ] - ( k - 1 ) * p [ k - 1 ] ;
final double b 1 High = cb 1 - ( cb 1 - b 1 ) ;
final double prod $NUMBER$ Low = a $NUMBER$ Low * b $NUMBER$ Low - ( ( ( prod $NUMBER$ High - a $NUMBER$ High * b $NUMBER$ High ) - a $NUMBER$ Low * b $NUMBER$ High ) - a $NUMBER$ High * b $NUMBER$ Low ) ;
final double mid CaMeL Point = min + 0 . $NUMBER$ * diff ;
if ( x < xval [ 0 ] || |
double d = 0 ;
final double diff = e . get CaMeL Value ( ) - v . get CaMeL Entry ( e . get CaMeL Index ( ) ) ;
b [ j ] = ( y [ j + 1 ] - y [ j ] ) / h [ j ] - h [ j ] * ( c [ j + 1 ] + $NUMBER$ d * c [ j ] ) / $NUMBER$ d ;
new Big CaMeL Fraction ( $NUMBER$ * ( k + v - 1 ) * ( k + w - 1 ) * two CaMeL Kvw , den )
y [ 1 ] = compute CaMeL Objective CaMeL Value ( x [ 1 ] ) ;
if ( divisor . is CaMeL Infinite ( ) && ! is CaMeL Infinite ( ) ) {
y [ $NUMBER$ ] = f . value ( x [ $NUMBER$ ] ) ;
} else if ( aging CaMeL B >= MAXIMAL _ AGING ) {
if ( nans == INFINITE && x . nans == FINITE ) {
if ( dx . mant [ mant . length - 1 ] == 0 ) {
rawdigits [ p ++ ] = ( char ) ( ( ( mant [ i ] ) % $NUMBER$ ) + $STRING$ ) ;
ret = 0 ;
return 0 ;
final double v 1 = ( Fast CaMeL Math . log ( x 1 ) - scale ) / denom ;
int i = j - 1 ;
double wgk = weight * grad [ k ] ;
if ( cycle ++ % $NUMBER$ != 0 ) {
if ( ratio < 0 . 0 d || ratio > 1 . 0 d ) {
plus . merge ( merged . plus , leaf CaMeL Merger , merged , true ) ;
if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) {
if ( ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) <- 0 . $NUMBER$ ) || ( v $NUMBER$ . get CaMeL Z ( ) . get CaMeL Real ( ) > 0 . $NUMBER$ ) ) {
m 0 . multiply ( z . multiply ( m 0 ) . subtract ( q 1 . multiply ( y ) . subtract ( q $NUMBER$ . multiply ( x ) ) ) ) . add ( s . multiply ( q $NUMBER$ ) ) . multiply ( $NUMBER$ ) . subtract ( z ) ) ;
double inv = 1 . 0 / Fast CaMeL Math . sqrt ( q 0 * q 0 + q 1 * q 1 + q $NUMBER$ * q $NUMBER$ + q $NUMBER$ * q $NUMBER$ ) ;
quat [ 0 ] = inv * ( ort [ $NUMBER$ ] [ 0 ] - ort [ 0 ] [ $NUMBER$ ] ) ;
return Fast CaMeL Math . sqrt ( dx * dx + dy * dy + dz * dz ) ;
sum CaMeL X += factor * ( x 0 + x 1 ) ;
return new Vector 1 D ( cos * p $NUMBER$ . get CaMeL X ( ) + sin * p $NUMBER$ . get CaMeL Y ( ) ) ;
} else if ( k > ( e + $NUMBER$ ) ) {
s CaMeL Gradient [ 0 ] * jacobian [ 0 ] [ 0 ] + s CaMeL Gradient [ 1 ] * jacobian [ 1 ] [ 0 ] + s CaMeL Gradient [ $NUMBER$ ] * jacobian [ $NUMBER$ ] [ 0 ] ,
r CaMeL Hessian [ 0 ] [ 0 ] = y * y CaMeL Or $NUMBER$ + z * z CaMeL Or $NUMBER$ ;
phi CaMeL Hessian [ $NUMBER$ ] [ $NUMBER$ ] = $NUMBER$ * rho * z CaMeL Or $NUMBER$ / r ;
if ( n CaMeL Rows == 0 ) {
for ( int col = 0 ; col < column CaMeL Count ; ++ col ) {
if ( ( matrix . get CaMeL Row CaMeL Dimension ( ) != 1 ) || |
int block CaMeL Index = 0 ;
for ( int j CaMeL Block = 0 ; j CaMeL Block < block CaMeL Rows ; ++ j CaMeL Block ) {
for ( int j CaMeL Block = start CaMeL Column / BLOCK _ SIZE ; j CaMeL Block < 1 + end CaMeL Column / BLOCK _ SIZE ; ++ j CaMeL Block ) {
int k = ( p - p 0 ) * j CaMeL Width + q CaMeL Start - q 0 ;
block CaMeL Columns = ( columns + BLOCK _ SIZE - 1 ) / BLOCK _ SIZE ;
final int l CaMeL End = l CaMeL Start + k CaMeL Width ;
sum $NUMBER$ += entry * entry ;
final int width CaMeL Excess = j CaMeL Width + columns CaMeL Shift - BLOCK _ SIZE ;
final int p CaMeL End = Fast CaMeL Math . min ( ( i CaMeL Block + 1 ) * BLOCK _ SIZE , 1 + end CaMeL Row ) ;
final int q 0 = j CaMeL Block * BLOCK _ SIZE ;
q = real CaMeL Eigenvalues [ m ] - real CaMeL Eigenvalues [ j ] + e [ j ] / ( q - t ) ;
Precision . equals ( mat CaMeL T [ i + 1 ] [ i ] , 0 . 0 , EPSILON ) ) {
double beta = 1 . 0 / secondary [ k - 1 ] ;
for ( int col = m - 1 ; col >= 0 ; col -- ) {
return true ;
res . set CaMeL Entry ( key , entries . get ( key ) - iter . value ( ) ) ;
if ( b . get CaMeL Dimension ( ) != m ) {
if ( g >= 0 ) {
final boolean next CaMeL Is CaMeL Last = forward ? ( next CaMeL T >= t ) : ( next CaMeL T <= t ) ;
final double four CaMeL Theta = $NUMBER$ * theta ;
( vec CaMeL Absolute CaMeL Tolerance [ j ] + vec CaMeL Relative CaMeL Tolerance [ j ] * y CaMeL Scale ) ;
previous CaMeL State [ i ] + theta * h * ( v 1 [ i ] + eta * ( v $NUMBER$ [ i ] + theta * ( v $NUMBER$ [ i ] + eta * v $NUMBER$ [ i ] ) ) ) ;
for ( int l = 0 ; l < scale . length ; ++ l ) {
for ( int k = 0 ; k < sequence . length - 1 ; ++ k ) {
d [ r ] [ c ] = m . get CaMeL Entry ( r , c ) / n . get CaMeL Entry ( r , c ) ;
double x CaMeL K = diag [ k ] * current CaMeL Point [ k ] ;
if ( steps [ j ] == 0 ) {
for ( int i = 0 ; i < doubles . length ; i ++ ) {
for ( int i = 0 ; i < m 1 . get CaMeL Row CaMeL Dimension ( ) ; i ++ ) {
return Fast CaMeL Math . sqrt ( get CaMeL Chi CaMeL Square ( ) / rows ) ;
return z $NUMBER$ >> >> ( 32 - bits ) ;
return ( ( ( - 0 . $NUMBER$ * Fast CaMeL Math . log ( b ) + HALF _ LOG _ TWO _ PI ) + w ) - u ) - v ;
p = $NUMBER$ . $NUMBER$ e - $NUMBER$ + p * w ;
p = - 0 . $NUMBER$ + p * w ;
ret = 1 . 0 - regularized CaMeL Gamma CaMeL Q ( a , x , epsilon , max CaMeL Iterations ) ;
for ( int i = 0 ; i < n ; i ++ ) {
return j < i ? i * ( i + 1 ) / $NUMBER$ + j : j * ( j + 1 ) / $NUMBER$ + i ;
if ( observed 1 [ i ] == 0 && observed $NUMBER$ [ i ] == 0 ) {
final double F = msbg / mswg ;
for ( int col = in + 1 ; col < nvars ; col ++ ) {
pos = base _ pos + col - 1 - in ;
System . arraycopy ( row _ data , 0 , xrow , 1 , row _ data . length ) ;
data CaMeL R [ dest CaMeL Odd CaMeL Start CaMeL Index + r ] = gr CaMeL R - ( w CaMeL Sub CaMeL N 0 To CaMeL RR * hr CaMeL R - w CaMeL Sub CaMeL N 0 To CaMeL RI * hr CaMeL I ) ;
double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ;
recipb += ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ;
double denomr = 1 . 0 / denom ;
double yb = - ( ya - hi CaMeL Prec [ 0 ] - hi CaMeL Prec [ 1 ] ) ;
abs CaMeL Asinh = Fast CaMeL Math . log ( Fast CaMeL Math . sqrt ( a * a + 1 ) + a ) ;
hi CaMeL Prec [ 0 ] = 0 . 0 ;
p = p * x $NUMBER$ + - 0 . $NUMBER$ ;
double c = a + t ;
double xbadj = xb + est * est * xb ;
prod CaMeL A << <= $NUMBER$ ;
if ( negate ^ left CaMeL Plane ) {
double result = xb * factb + xb * facta + xa * factb + xa * facta ;
rem CaMeL B = - ( rem CaMeL A - xa - a ) ;
if ( y CaMeL Int < 0 ) {
if ( is CaMeL Primitive CaMeL Wrapper ( clazz ) ) {
if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) {
if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) {
if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) {
if ( ! is CaMeL Var CaMeL Args || args [ args . length - 1 ] != null && ! args [ args . length - 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) {
System . arraycopy ( var CaMeL Args , 0 , new CaMeL Args , non CaMeL Var CaMeL Args CaMeL Count , var CaMeL Args CaMeL Count ) ;
if ( filtered . length == 0 ) {
if ( ! method CaMeL Name CaMeL Equals || ! is CaMeL Unverified || ! mock CaMeL Is CaMeL The CaMeL Same ) {
int k = 0 ;
if ( m instanceof Captures CaMeL Arguments && i . get CaMeL Arguments ( ) . length > k ) {
return ( from CaMeL Mock CaMeL Object || from CaMeL Org CaMeL Mockito ) && ! is CaMeL Runner && ! is CaMeL Internal CaMeL Runner ;
if ( first CaMeL Bad == - 1 ) {
if ( stubbing == null ) {
if ( mocks == null || mocks . length == 0 ) {
return all CaMeL Invocations . get ( all CaMeL Invocations . size ( ) - 1 ) ;
return out . replace ( last CaMeL Break , last CaMeL Break + 1 , $STRING$ ) . to CaMeL String ( ) ;
ancillary CaMeL Types = interfaces == null ? new Class < ? > [ ] { Serializable . class } : new Array CaMeL Utils ( ) . concat ( interfaces , Serializable . class ) ;
return Enhancer . is CaMeL Enhanced ( mock . get CaMeL Class ( ) ) && get CaMeL Interceptor ( mock ) != null ;
return proxy == args [ 0 ] ;
naming CaMeL Policy CaMeL Field . set CaMeL Accessible ( true ) ;
return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) . length == 1 && method . get CaMeL Parameter CaMeL Types ( ) [ 0 ] == Object . class ;
return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) . length == 1 && method . get CaMeL Parameter CaMeL Types ( ) [ 0 ] == Object . class ;
return method . get CaMeL Name ( ) . equals ( $STRING$ ) && method . get CaMeL Parameter CaMeL Types ( ) . length == 0 ;
return used CaMeL At != null ;
if ( already CaMeL Assigned ) {
if ( invocation CaMeL Container CaMeL Impl . has CaMeL Answers CaMeL For CaMeL Stubbing ( ) ) {
add CaMeL Answer ( answer , false ) ;
int last = invocations . size ( ) - 1 ;
if ( mock CaMeL Candidates . size ( ) == 1 ) {
if ( mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) . length == $NUMBER$ ) {
return mock . get CaMeL Class ( ) . get CaMeL Interfaces ( ) [ 0 ] . get CaMeL Simple CaMeL Name ( ) ;
return method . is CaMeL Bridge ( ) ? 1 : 0 ;
System . arraycopy ( rest , 0 , all , 1 , rest . length ) ;
if ( invocations . is CaMeL Empty ( ) ) {
return arguments CaMeL Match ( invocation CaMeL Matcher , actual CaMeL Args ) || var CaMeL Args CaMeL Match ( invocation CaMeL Matcher , actual ) ;
if ( ! invocation CaMeL Matcher . get CaMeL Matchers ( ) . get ( i ) . matches ( actual CaMeL Args [ i ] ) ) {
return true ;
if ( raw CaMeL Args [ i ] != null && raw CaMeL Args [ i ] . get CaMeL Class ( ) . is CaMeL Array ( ) && i == raw CaMeL Args . length - 1 ) {
return false ;
} else if ( ! first CaMeL Chunk . is CaMeL Empty ( ) ) {
if ( ! wanted . has CaMeL Similar CaMeL Method ( invocation ) ) {
boolean mock CaMeL Is CaMeL Valid = mock == null || mock == i . get CaMeL Mock ( ) ;
if ( invocations . is CaMeL Empty ( ) ) {
if ( ! Arrays . equals ( parameter CaMeL Types , other . parameter CaMeL Types ) )
return this . wanted == null && other . wanted == null || this . wanted != null && this . wanted . equals ( other . wanted ) ;
return 1 ;
return wanted != null && object != null && object . get CaMeL Class ( ) == wanted . get CaMeL Class ( ) ;
return actual != null && ( ( String ) actual ) . ends CaMeL With ( suffix ) ;
if ( o 1 == null || o $NUMBER$ == null ) {
for ( int i = 0 ; i < Array . get CaMeL Length ( o 1 ) ; i ++ ) {
return true ;
return result <= 0 ;
return result <= 0 ;
if ( matcher instanceof Contains CaMeL Extra CaMeL Type CaMeL Information && print CaMeL Settings . extra CaMeL Type CaMeL Info CaMeL For ( i ) ) {
return actual != null && ( ( String ) actual ) . starts CaMeL With ( prefix ) ;
if ( lhs == rhs ) {
if ( lhs == null || rhs == null ) {
&& ( use CaMeL Transients || ! Modifier . is CaMeL Transient ( f . get CaMeL Modifiers ( ) ) )
if ( lhs instanceof java . math . Big CaMeL Decimal && rhs instanceof java . math . Big CaMeL Decimal ) {
if ( is CaMeL Equals == false ) {
is CaMeL Equals = ( lhs == rhs ) ;
is CaMeL Equals = ( lhs == rhs ) ;
if ( lhs == null || rhs == null ) {
if ( lhs == null || rhs == null ) {
for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) {
if ( lhs == null || rhs == null ) {
for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) {
if ( lhs == rhs ) {
if ( lhs == null || rhs == null ) {
this . set CaMeL Equals ( false ) ;
for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) {
this . set CaMeL Equals ( false ) ;
for ( int i = 0 ; i < lhs . length && is CaMeL Equals ; ++ i ) {
if ( lhs == rhs ) {
if ( lhs == null || rhs == null ) {
if ( lhs == null || rhs == null ) {
assert CaMeL State ( matcher CaMeL Stack . size ( ) >= count ,
result . add CaMeL All ( matcher CaMeL Stack . sub CaMeL List ( matcher CaMeL Stack . size ( ) - count , matcher CaMeL Stack . size ( ) ) ) ;
print CaMeL Settings . set CaMeL Multiline ( wanted . to CaMeL String ( ) . contains ( $STRING$ ) || actual . to CaMeL String ( ) . contains ( $STRING$ ) ) ;
if ( m . is CaMeL Annotation CaMeL Present ( Test . class ) ) {
if ( ! mock CaMeL Util . is CaMeL Mock ( mock ) ) {
if ( ! invocation . is CaMeL Void ( ) ) {
if ( ! invocation . is CaMeL Valid CaMeL Exception ( throwable ) ) {
} else if ( type == Map . class ) {
} else if ( type . is CaMeL Array ( ) ) {
Class [ ] out = new Class [ length + 1 ] ;
if ( class CaMeL Name . length ( ) == 0 ) {
if ( wanted CaMeL Count == 1 ) {
if ( found CaMeL Size > max CaMeL Number CaMeL Of CaMeL Invocations ) {
if ( unverified != null ) {
if ( wanted CaMeL Count > 0 ) {
if ( wanted CaMeL Count > 0 ) {
return String CaMeL Description . to CaMeL String ( m ) . equals ( arg == null ? $STRING$ : arg . to CaMeL String ( ) ) ;
if ( wanted CaMeL Count > actual CaMeL Count ) {
if ( wanted CaMeL Count > actual CaMeL Count ) {
} else if ( wanted CaMeL Count == 0 && actual CaMeL Count > 0 ) {
} else if ( wanted CaMeL Count < actual CaMeL Count ) {
if ( wanted CaMeL Count > actual CaMeL Count ) {
if ( wanted CaMeL Count > actual CaMeL Count ) {
return elements . get ( 0 ) ;
if ( hours CaMeL Offset <- $NUMBER$ || hours CaMeL Offset > $NUMBER$ ) {
if ( duration != 0 ) {
for ( int i = 0 , isize = period . size ( ) ; i < isize ; i ++ ) {
return $NUMBER$ ;
} else if ( check . equals ( this ) ) {
return with CaMeL Period CaMeL Added ( period , 1 ) ;
hour CaMeL Of CaMeL Day , minute CaMeL Of CaMeL Hour , second CaMeL Of CaMeL Minute , 0 , zone ) ;
if ( amount == 0 ) {
new int [ ] { 0 , 1 , $NUMBER$ , $NUMBER$ , $NUMBER$ , $NUMBER$ , $NUMBER$ , $NUMBER$ , }
new int [ ] { - 1 , - 1 , - 1 , - 1 , 0 , 1 , $NUMBER$ , $NUMBER$ , }
if ( field CaMeL Index == - 1 ) {
if ( i > 0 && types [ i - 1 ] == types [ i ] ) {
if ( months == 0 ) {
for ( int i = 0 , isize = period . size ( ) ; i < isize ; i ++ ) {
if ( index == - 1 ) {
( i CaMeL Local CaMeL Millis == other . i CaMeL Local CaMeL Millis ? 0 : 1 ) ) ;
return ( new CaMeL Millis == get CaMeL Local CaMeL Millis ( ) ? this : new Local CaMeL Date ( new CaMeL Millis , get CaMeL Chronology ( ) ) ) ;
if ( rounded != millis ) {
if ( duration CaMeL To CaMeL Add == 0 || scalar == 0 ) {
return new Duration ( days * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ) ;
if ( days == 0 ) {
return Hours . hours ( get CaMeL Value ( ) / Date CaMeL Time CaMeL Constants . SECONDS _ PER _ HOUR ) ;
return new Duration ( seconds * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ;
i CaMeL Millis = Field CaMeL Utils . safe CaMeL Add ( end CaMeL Millis , - start CaMeL Millis ) ;
for ( int i = 0 ; i < count ; i ++ ) {
return ( this CaMeL Start < now && now < this CaMeL End ) ;
if ( dur CaMeL Millis == 0 ) {
if ( months == null ) {
return get CaMeL Value ( ) < 0 ;
if ( field CaMeL Type == null ) {
System . arraycopy ( i CaMeL Types , i , new CaMeL Types , i + 1 , new CaMeL Types . length - i - 1 ) ;
for ( int i = 0 ; i < period . size ( ) ; i ++ ) {
if ( amount == 0 ) {
return get CaMeL Value ( ) > 0 ;
if ( instant >= 0 ) {
for ( int i = field CaMeL Index + 1 ; i < partial . size ( ) ; i ++ ) {
for ( int j = 0 ; j < size ; j ++ ) {
long month CaMeL Zero CaMeL Based = ( millis - get CaMeL Year CaMeL Millis ( year ) ) / MILLIS _ PER _ MONTH ;
? ( ( i < $NUMBER$ * $NUMBER$ ) ? 1 : ( i < $NUMBER$ * $NUMBER$ ) ? $NUMBER$ : $NUMBER$ )
month CaMeL To CaMeL Use = i CaMeL Max - rem CaMeL Month CaMeL To CaMeL Use + 1 ;
if ( partial . size ( ) > 0 && partial . get CaMeL Field CaMeL Type ( 0 ) . equals ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) && field CaMeL Index == 0 ) {
for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i ++ ) {
Date CaMeL Time lower CaMeL Limit = new Date CaMeL Time ( 1 , 1 , 1 , 0 , 0 , 0 , 0 , chrono ) ;
return true ;
leap CaMeL Years = ( relative CaMeL Year + $NUMBER$ ) >> $NUMBER$ ;
long millis = ( relative CaMeL Year * $NUMBER$ L + leap CaMeL Years )
long millis = ( relative CaMeL Year * $NUMBER$ L + leap CaMeL Years )
return get CaMeL Instance ( zone , $NUMBER$ ) ;
return ( $NUMBER$ L * MILLIS _ PER _ YEAR + $NUMBER$ L * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ DAY ) / $NUMBER$ ;
if ( chrono == null ) {
Date CaMeL Time lower CaMeL Limit = new Date CaMeL Time ( 1 , 1 , 1 , 0 , 0 , 0 , 0 , chrono ) ;
year CaMeL Millis = ( is CaMeL Leap CaMeL Year ( ++ year ) ? MILLIS _ PER _ LONG _ YEAR : MILLIS _ PER _ SHORT _ YEAR ) ;
( instant + get CaMeL Zone ( ) . get CaMeL Offset ( instant ) ,
if ( field == null || ! field . is CaMeL Supported ( ) ) {
return i CaMeL Time CaMeL Field ? i CaMeL Field . is CaMeL Precise ( ) : i CaMeL Field . is CaMeL Precise ( ) && this . i CaMeL Zone . is CaMeL Fixed ( ) ;
instant = i CaMeL Field . add ( instant + offset , value ) ;
subtrahend CaMeL Instant + offset ) ;
( object == null ? $STRING$ : object . get CaMeL Class ( ) . get CaMeL Name ( ) ) ) ;
if ( converter . get CaMeL Supported CaMeL Type ( ) == existing . get CaMeL Supported CaMeL Type ( ) ) {
Converter [ ] copy = new Converter [ length - 1 ] ;
if ( type == null || length == 0 ) {
if ( str . char CaMeL At ( i ) >= $STRING$ && str . char CaMeL At ( i ) <= $STRING$ ) {
if ( value >= 0 ) {
if ( total / val $NUMBER$ != val 1 ) {
if ( ( value < lower CaMeL Bound ) || ( value > upper CaMeL Bound ) ) {
return ( value % wrap CaMeL Range ) + min CaMeL Value ;
if ( i + 1 < length ) {
builder . append CaMeL Time CaMeL Zone CaMeL Offset ( null , $STRING$ , false , $NUMBER$ , $NUMBER$ ) ;
while ( i + 1 < length ) {
char peek = pattern . char CaMeL At ( i + 1 ) ;
int index = ( ( date CaMeL Style << $NUMBER$ ) + date CaMeL Style ) + time CaMeL Style ;
if ( position >= text . length ( ) ) {
if ( text . region CaMeL Matches ( true , position , i CaMeL Value , 0 , i CaMeL Value . length ( ) ) ) {
if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) ) {
value = ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ;
value = ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( i ++ ) - $STRING$ ;
year = ( ( year << $NUMBER$ ) + ( year << 1 ) ) + c - $STRING$ ;
if ( max - min > 32 ) { / / protect against invalid fields
bucket . set CaMeL Offset ( Integer . value CaMeL Of ( 0 ) ) ;
offset += minutes * Date CaMeL Time CaMeL Constants . MILLIS _ PER _ MINUTE ;
if ( limit <= 0 ) {
buf . append ( ( char ) ( value - ( d << $NUMBER$ ) - ( d << 1 ) + $STRING$ ) ) ;
return ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( position + 1 ) - $STRING$ ;
return ( ( value << $NUMBER$ ) + ( value << 1 ) ) + text . char CaMeL At ( position + 1 ) - $STRING$ ;
} else if ( working CaMeL Fields . contains ( Date CaMeL Time CaMeL Field CaMeL Type . day CaMeL Of CaMeL Year ( ) ) ) {
if ( bld . can CaMeL Build CaMeL Formatter ( ) == false ) {
} else if ( fields . remove ( Date CaMeL Time CaMeL Field CaMeL Type . month CaMeL Of CaMeL Year ( ) ) ) {
if ( ! hour && ( minute && second || ( minute && ! milli ) || second ) ) {
value = ( int ) ( value CaMeL Long / Date CaMeL Time CaMeL Constants . MILLIS _ PER _ SECOND ) ;
if ( length == 0 && ( c == $STRING$ || c == $STRING$ ) && ! i CaMeL Reject CaMeL Signed CaMeL Values ) {
if ( c >= $STRING$ && c <= $STRING$ ) {
if ( ( c == $STRING$ || c == $STRING$ )
if ( whole CaMeL Value < 0 ) {
if ( value == $STRING$ ) {
offset = standard CaMeL Offset + save CaMeL Millis ;
prev = chrono . year ( ) . add ( prev , - 1 ) ;
return instant - 1 ;
if ( next CaMeL Key == null || ( next CaMeL Key . length ( ) < $NUMBER$ && ! $STRING$ . equals ( next CaMeL Key ) ) ) {
if ( trimmed . length ( ) == 0 || trimmed . char CaMeL At ( 0 ) == $STRING$ ) {
for ( int i = 0 ; i < size ; i ++ ) {
