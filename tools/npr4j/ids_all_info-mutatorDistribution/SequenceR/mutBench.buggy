protected int hash ( final Object key ) { int h = key . hashCode ( ) ; <START_BUG> h += ~ ( h > > > 9 ) ; <END_BUG> h ^= h > > > 14 ; h += h << 4 ; h ^= h > > > 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } h += ~ ( h << 9 ) ; h ^= h > > > 14 ; h += h << 4 ; <START_BUG> h ^= h << 10 ; <END_BUG> return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } if ( key4 != null ) { h ^= key4 . hashCode ( ) ; } <START_BUG> h += ~ ( h > > 9 ) ; <END_BUG> h ^= h > > > 14 ; h += h << 4 ; h ^= h > > > 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } h += ~ ( h << 9 ) ; <START_BUG> h ^= h > > 14 ; <END_BUG> h += h << 4 ; h ^= h > > > 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } if ( key4 != null ) { h ^= key4 . hashCode ( ) ; } h += ~ ( h << 9 ) ; <START_BUG> h ^= h << 14 ; <END_BUG> h += h << 4 ; h ^= h > > > 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } h += ~ ( h << 9 ) ; h ^= h > > > 14 ; <START_BUG> h += h > > > 4 ; <END_BUG> h ^= h > > > 10 ; return h ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { final int i = k + offset ; <START_BUG> if ( k == ~ d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { <END_BUG> vDown [ i ] = vDown [ i + 1 ] ; } else { vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; while ( x < end1 && y < end2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vDown [ i ] = ++ x ; ++ y ; } if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { final int i = k + offset - delta ; if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) { vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && equator . equate ( sequence1 . get ( x ) , sequence2 . get ( y ) ) ) { vUp [ i ] = x -- ; y -- ; } if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; } } } } throw new RuntimeException ( "Internal Error" ) ; }
protected int hash ( final Object key ) { int h = key . hashCode ( ) ; <START_BUG> h += - ( h << 9 ) ; <END_BUG> h ^= h > > > 14 ; h += h << 4 ; h ^= h > > > 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } if ( key4 != null ) { h ^= key4 . hashCode ( ) ; } if ( key5 != null ) { h ^= key5 . hashCode ( ) ; } <START_BUG> h += + ( h << 9 ) ; <END_BUG> h ^= h > > > 14 ; h += h << 4 ; h ^= h > > > 10 ; return h ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; <START_BUG> return ( key . charAt ( index ) | mask ( bit ) ) != 0 ; <END_BUG> }
public int compare ( final Boolean b1 , final Boolean b2 ) { final boolean v1 = b1 . booleanValue ( ) ; final boolean v2 = b2 . booleanValue ( ) ; <START_BUG> return ( v1 & v2 ) ? ( ( v1 ^ trueFirst ) ? 1 : - 1 ) : 0 ; <END_BUG> }
public int hashCode ( ) { int total = 0 ; for ( final Entry < E , MutableInteger > entry : map . entrySet ( ) ) { final E element = entry . getKey ( ) ; final MutableInteger count = entry . getValue ( ) ; <START_BUG> total += ( element == null ? 0 : element . hashCode ( ) ) & count . value ; <END_BUG> } return total ; }
static long readMillis ( DataInput in ) throws IOException { int v = in . readUnsignedByte ( ) ; switch ( v > > 6 ) { case 0 : default : <START_BUG> v = ( v > > > ( 32 - 6 ) ) > > ( 32 - 6 ) ; <END_BUG> return v * ( 30 * 60000L ) ; case 1 : v = ( v << ( 32 - 6 ) ) > > ( 32 - 30 ) ; v |= ( in . readUnsignedByte ( ) ) << 16 ; v |= ( in . readUnsignedByte ( ) ) << 8 ; v |= ( in . readUnsignedByte ( ) ) ; return v * 60000L ; case 2 : long w = ( ( ( long ) v ) << ( 64 - 6 ) ) > > ( 64 - 38 ) ; w |= ( in . readUnsignedByte ( ) ) << 24 ; w |= ( in . readUnsignedByte ( ) ) << 16 ; w |= ( in . readUnsignedByte ( ) ) << 8 ; w |= ( in . readUnsignedByte ( ) ) ; return w * 1000L ; case 3 : return in . readLong ( ) ; } }
long calculateFirstDayOfYearMillis ( int year ) { int leapYears = year / 100 ; if ( year < 0 ) { <START_BUG> leapYears = ( ( year + 3 ) > > 2 ) - leapYears + ( ( leapYears + 3 ) << 2 ) - 1 ; <END_BUG> } else { leapYears = ( year > > 2 ) - leapYears + ( leapYears > > 2 ) ; if ( isLeapYear ( year ) ) { leapYears -- ; } } return ( year * 365L + ( leapYears - DAYS_0000_TO_1970 ) ) * DateTimeConstants . MILLIS_PER_DAY ; }
public static void appendPaddedInteger ( StringBuffer buf , int value , int size ) { if ( value < 0 ) { buf . append ( '-' ) ; if ( value != Integer . MIN_VALUE ) { value = - value ; } else { for ( ; size > 10 ; size -- ) { buf . append ( '0' ) ; } buf . append ( "" + - ( long ) Integer . MIN_VALUE ) ; return ; } } if ( value < 10 ) { for ( ; size > 1 ; size -- ) { buf . append ( '0' ) ; } buf . append ( ( char ) ( value + '0' ) ) ; } else if ( value < 100 ) { for ( ; size > 2 ; size -- ) { buf . append ( '0' ) ; } int d = ( ( value + 1 ) * 13421772 ) > > 27 ; buf . append ( ( char ) ( d + '0' ) ) ; <START_BUG> buf . append ( ( char ) ( value - ( d << 3 ) - ( d > > 1 ) + '0' ) ) ; <END_BUG> } else { int digits ; if ( value < 1000 ) { digits = 3 ; } else if ( value < 10000 ) { digits = 4 ; } else { digits = ( int ) ( Math . log ( value ) / LOG_10 ) + 1 ; } for ( ; size > digits ; size -- ) { buf . append ( '0' ) ; } buf . append ( Integer . toString ( value ) ) ; } }
protected BaseDuration ( ReadableInstant start , ReadableInstant end ) { super ( ) ; if ( start == end ) { iMillis = 0L ; } else { long startMillis = DateTimeUtils . getInstantMillis ( start ) ; long endMillis = DateTimeUtils . getInstantMillis ( end ) ; <START_BUG> iMillis = FieldUtils . safeAdd ( endMillis , ~ startMillis ) ; <END_BUG> } }
public long subtract ( long instant , int value ) { if ( value == Integer . MIN_VALUE ) { return subtract ( instant , ( long ) value ) ; } <START_BUG> return add ( instant , + value ) ; <END_BUG> }
public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 == Long . MIN_VALUE ) { throw new ArithmeticException ( "Multiplication overflows a long: " + val1 + " * " + val2 ) ; } <START_BUG> return + val1 ; <END_BUG> case 0 : return 0L ; case 1 : return val1 ; } long total = val1 * val2 ; if ( total / val2 != val1 ) { throw new ArithmeticException ( "Multiplication overflows a long: " + val1 + " * " + val2 ) ; } return total ; }
public Period minusMillis ( int millis ) { <START_BUG> return plusMillis ( + millis ) ; <END_BUG> }
public int getStandardOffset ( long instant ) { long [ ] transitions = iTransitions ; int i = Arrays . binarySearch ( transitions , instant ) ; if ( i >= 0 ) { return iStandardOffsets [ i ] ; } <START_BUG> i = - i ; <END_BUG> if ( i < transitions . length ) { if ( i > 0 ) { return iStandardOffsets [ i - 1 ] ; } return 0 ; } if ( iTailZone == null ) { return iStandardOffsets [ i - 1 ] ; } return iTailZone . getStandardOffset ( instant ) ; }
public long set ( long instant , int era ) { FieldUtils . verifyValueBounds ( this , era , DateTimeConstants . BCE , DateTimeConstants . CE ) ; int oldEra = get ( instant ) ; if ( oldEra != era ) { int year = iChronology . getYear ( instant ) ; <START_BUG> return iChronology . setYear ( instant , + year ) ; <END_BUG> } else { return instant ; } }
public Period minusHours ( int hours ) { <START_BUG> return plusHours ( ~ hours ) ; <END_BUG> }
protected BaseDuration ( long startInstant , long endInstant ) { super ( ) ; <START_BUG> iMillis = FieldUtils . safeAdd ( endInstant , + startInstant ) ; <END_BUG> }
public long getDifferenceAsLong ( long minuendInstant , long subtrahendInstant ) { if ( minuendInstant < subtrahendInstant ) { <START_BUG> return ~ iChronology . getYearDifference ( subtrahendInstant , minuendInstant ) ; <END_BUG> } return iChronology . getYearDifference ( minuendInstant , subtrahendInstant ) ; }
Converter select ( Class < ? > type ) throws IllegalStateException { Entry [ ] entries = iSelectEntries ; int length = entries . length ; int index = type == null ? 0 : type . hashCode ( ) & ( length - 1 ) ; Entry e ; while ( ( e = entries [ index ] ) != null ) { if ( e . iType == type ) { return e . iConverter ; } if ( ++ index >= length ) { index = 0 ; } } Converter converter = selectSlow ( this , type ) ; e = new Entry ( type , converter ) ; entries = ( Entry [ ] ) entries . clone ( ) ; entries [ index ] = e ; for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; Entry [ ] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ; <START_BUG> index = type == null ? 0 : type . hashCode ( ) ^ ( newLength - 1 ) ; <END_BUG> while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ; } iSelectEntries = newEntries ; return converter ; }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = v [ indexRm1 ] ; final int z1 = v0 ^ ( vM1 ^ ( vM1 > > > 8 ) ) ; final int z2 = ( vM2 ^ ( vM2 << 19 ) ) ^ ( vM3 ^ ( vM3 << 14 ) ) ; final int z3 = z1 ^ z2 ; final int z4 = ( z0 ^ ( z0 << 11 ) ) ^ ( z1 ^ ( z1 << 7 ) ) ^ ( z2 ^ ( z2 << 13 ) ) ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; index = indexRm1 ; <START_BUG> return z4 > > ( 32 - bits ) ; <END_BUG> }
public static float scalb ( final float f , final int n ) { if ( ( n > - 127 ) && ( n < 128 ) ) { return f * Float . intBitsToFloat ( ( n + 127 ) << 23 ) ; } if ( Float . isNaN ( f ) || Float . isInfinite ( f ) || ( f == 0f ) ) { return f ; } if ( n < - 277 ) { return ( f > 0 ) ? 0.0f : - 0.0f ; } if ( n > 276 ) { return ( f > 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } final int bits = Float . floatToIntBits ( f ) ; final int sign = bits & 0x80000000 ; int exponent = ( bits > > > 23 ) & 0xff ; int mantissa = bits & 0x007fffff ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else if ( scaledExponent > - 24 ) { mantissa = mantissa | ( 1 << 23 ) ; final int mostSignificantLostBit = mantissa & ( 1 << ( - scaledExponent ) ) ; mantissa = mantissa > > > ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return Float . intBitsToFloat ( sign | mantissa ) ; } else { return ( sign == 0 ) ? 0.0f : - 0.0f ; } } else { if ( exponent == 0 ) { while ( ( mantissa > > > 23 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 0x007fffff ; if ( scaledExponent < 255 ) { <START_BUG> return Float . intBitsToFloat ( sign | ( scaledExponent > > 23 ) | mantissa ) ; <END_BUG> } else { return ( sign == 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 255 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else { return ( sign == 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } } }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0xFFFF8000 & v [ indexRm1 ] ) ^ ( 0x00007FFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 24 ) ) ^ ( vM1 ^ ( vM1 > > > 30 ) ) ; final int z2 = ( vM2 ^ ( vM2 << 10 ) ) ^ ( vM3 << 26 ) ; final int z3 = z1 ^ z2 ; final int z2Prime = ( ( z2 << 9 ) ^ ( z2 > > > 23 ) ) & 0xfbffffff ; final int z2Second = ( ( z2 & 0x00020000 ) != 0 ) ? ( z2Prime ^ 0xb729fcec ) : z2Prime ; int z4 = z0 ^ ( z1 ^ ( z1 > > > 20 ) ) ^ z2Second ^ z3 ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0xFFFF8000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0x93dd1400 ) ; <START_BUG> z4 = z4 ^ ( ( z4 > > 15 ) & 0xfa118000 ) ; <END_BUG> return z4 > > > ( 32 - bits ) ; }
private static int gcdPositive ( int a , int b ) { if ( a == 0 ) { return b ; } else if ( b == 0 ) { return a ; } final int aTwos = Integer . numberOfTrailingZeros ( a ) ; a >>= aTwos ; final int bTwos = Integer . numberOfTrailingZeros ( b ) ; b >>= bTwos ; final int shift = Math . min ( aTwos , bTwos ) ; while ( a != b ) { final int delta = a - b ; b = Math . min ( a , b ) ; a = Math . abs ( delta ) ; a >>= Integer . numberOfTrailingZeros ( a ) ; } <START_BUG> return a > > > shift ; <END_BUG> }
public static double scalb ( final double d , final int n ) { if ( ( n > - 1023 ) && ( n < 1024 ) ) { return d * Double . longBitsToDouble ( ( ( long ) ( n + 1023 ) ) << 52 ) ; } if ( Double . isNaN ( d ) || Double . isInfinite ( d ) || ( d == 0 ) ) { return d ; } if ( n < - 2098 ) { return ( d > 0 ) ? 0.0 : - 0.0 ; } if ( n > 2097 ) { return ( d > 0 ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } final long bits = Double . doubleToRawLongBits ( d ) ; final long sign = bits & 0x8000000000000000L ; int exponent = ( ( int ) ( bits > > > 52 ) ) & 0x7ff ; long mantissa = bits & 0x000fffffffffffffL ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { <START_BUG> return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) > > 52 ) | mantissa ) ; <END_BUG> } else if ( scaledExponent > - 53 ) { mantissa = mantissa | ( 1L << 52 ) ; final long mostSignificantLostBit = mantissa & ( 1L << ( - scaledExponent ) ) ; mantissa = mantissa > > > ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return Double . longBitsToDouble ( sign | mantissa ) ; } else { return ( sign == 0L ) ? 0.0 : - 0.0 ; } } else { if ( exponent == 0 ) { while ( ( mantissa > > > 52 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 0x000fffffffffffffL ; if ( scaledExponent < 2047 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0L ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 2047 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0L ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } } }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0xFFFF8000 & v [ indexRm1 ] ) ^ ( 0x00007FFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 24 ) ) ^ ( vM1 ^ ( vM1 > > > 30 ) ) ; <START_BUG> final int z2 = ( vM2 ^ ( vM2 << 10 ) ) ^ ( vM3 > > 26 ) ; <END_BUG> final int z3 = z1 ^ z2 ; final int z2Prime = ( ( z2 << 9 ) ^ ( z2 > > > 23 ) ) & 0xfbffffff ; final int z2Second = ( ( z2 & 0x00020000 ) != 0 ) ? ( z2Prime ^ 0xb729fcec ) : z2Prime ; int z4 = z0 ^ ( z1 ^ ( z1 > > > 20 ) ) ^ z2Second ^ z3 ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0xFFFF8000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0x93dd1400 ) ; z4 = z4 ^ ( ( z4 << 15 ) & 0xfa118000 ) ; return z4 > > > ( 32 - bits ) ; }
private static void reducePayneHanek ( double x , double result [ ] ) { long inbits = Double . doubleToRawLongBits ( x ) ; int exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; inbits &= 0x000fffffffffffffL ; inbits |= 0x0010000000000000L ; exponent ++ ; inbits <<= 11 ; long shpi0 ; long shpiA ; long shpiB ; int idx = exponent > > 6 ; int shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( RECIP_2PI [ idx - 1 ] << shift ) ; shpi0 |= RECIP_2PI [ idx ] > > > ( 64 - shift ) ; shpiA = ( RECIP_2PI [ idx ] << shift ) | ( RECIP_2PI [ idx + 1 ] > > > ( 64 - shift ) ) ; shpiB = ( RECIP_2PI [ idx + 1 ] << shift ) | ( RECIP_2PI [ idx + 2 ] > > > ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : RECIP_2PI [ idx - 1 ] ; shpiA = RECIP_2PI [ idx ] ; shpiB = RECIP_2PI [ idx + 1 ] ; } long a = inbits > > > 32 ; long b = inbits & 0xffffffffL ; long c = shpiA > > > 32 ; long d = shpiA & 0xffffffffL ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prodB = bd + ( ad << 32 ) ; long prodA = ac + ( ad > > > 32 ) ; boolean bita = ( bd & 0x8000000000000000L ) != 0 ; boolean bitb = ( ad & 0x80000000L ) != 0 ; boolean bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prodB = prodB + ( bc << 32 ) ; prodA = prodA + ( bc > > > 32 ) ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpiB > > > 32 ; d = shpiB & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prodB += ac ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpi0 > > > 32 ; d = shpi0 & 0xffffffffL ; bd = b * d ; bc = b * c ; ad = a * d ; prodA += bd + ( ( bc + ad ) << 32 ) ; int intPart = ( int ) ( prodA > > > 62 ) ; prodA <<= 2 ; prodA |= prodB > > > 62 ; prodB <<= 2 ; <START_BUG> a = prodA > > 32 ; <END_BUG> b = prodA & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod2B = bd + ( ad << 32 ) ; long prod2A = ac + ( ad > > > 32 ) ; bita = ( bd & 0x8000000000000000L ) != 0 ; bitb = ( ad & 0x80000000L ) != 0 ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prod2B = prod2B + ( bc << 32 ) ; prod2A = prod2A + ( bc > > > 32 ) ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } c = PI_O_4_BITS [ 1 ] > > > 32 ; d = PI_O_4_BITS [ 1 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } a = prodB > > > 32 ; b = prodB & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } double tmpA = ( prod2A > > > 12 ) / TWO_POWER_52 ; double tmpB = ( ( ( prod2A & 0xfffL ) << 40 ) + ( prod2B > > > 24 ) ) / TWO_POWER_52 / TWO_POWER_52 ; double sumA = tmpA + tmpB ; double sumB = - ( sumA - tmpA - tmpB ) ; result [ 0 ] = intPart ; result [ 1 ] = sumA * 2.0 ; result [ 2 ] = sumB * 2.0 ; }
private void encode ( final int minOffset ) { offset = minOffset + 31 ; offset -= offset % 32 ; if ( ( encoding != null ) && ( encoding . length == 1 ) && ( encoding [ 0 ] == 0x0L ) ) { return ; } final int neededBits = offset + 1 - lsb ; final int neededLongs = ( neededBits + 62 ) / 63 ; encoding = new long [ components . length * neededLongs ] ; int eIndex = 0 ; int shift = 62 ; long word = 0x0L ; for ( int k = offset ; eIndex < encoding . length ; -- k ) { for ( int vIndex = 0 ; vIndex < components . length ; ++ vIndex ) { if ( getBit ( vIndex , k ) != 0 ) { <START_BUG> word |= 1L > > > shift ; <END_BUG> } if ( shift -- == 0 ) { encoding [ eIndex ++ ] = word ; word = 0x0L ; shift = 62 ; } } } }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0x80000000 & v [ indexRm1 ] ) ^ ( 0x7FFFFFFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 25 ) ) ^ ( vM1 ^ ( vM1 > > > 27 ) ) ; <START_BUG> final int z2 = ( vM2 > > > 9 ) ^ ( vM3 ^ ( vM3 << 1 ) ) ; <END_BUG> final int z3 = z1 ^ z2 ; int z4 = z0 ^ ( z1 ^ ( z1 << 9 ) ) ^ ( z2 ^ ( z2 << 21 ) ) ^ ( z3 ^ ( z3 > > > 21 ) ) ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0x80000000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0xe46e1700 ) ; z4 = z4 ^ ( ( z4 << 15 ) & 0x9b868000 ) ; return z4 > > > ( 32 - bits ) ; }
public static double cbrt ( double x ) { long inbits = Double . doubleToRawLongBits ( x ) ; <START_BUG> int exponent = ( int ) ( ( inbits << 52 ) & 0x7ff ) - 1023 ; <END_BUG> boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984E16 ; inbits = Double . doubleToRawLongBits ( x ) ; exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } int exp3 = exponent / 3 ; double p2 = Double . longBitsToDouble ( ( inbits & 0x8000000000000000L ) | ( long ) ( ( ( exp3 + 1023 ) & 0x7ff ) ) << 52 ) ; final double mant = Double . longBitsToDouble ( ( inbits & 0x000fffffffffffffL ) | 0x3ff0000000000000L ) ; double est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= CBRTTWO [ exponent % 3 + 2 ] ; final double xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; double temp = est * HEX_40000000 ; double ya = est + temp - temp ; double yb = est - ya ; double za = ya * ya ; double zb = ya * yb * 2.0 + yb * yb ; temp = za * HEX_40000000 ; double temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; double na = xs - za ; double nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625E-6 ; } return est ; }
private static void reducePayneHanek ( double x , double result [ ] ) { long inbits = Double . doubleToRawLongBits ( x ) ; int exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; inbits &= 0x000fffffffffffffL ; inbits |= 0x0010000000000000L ; exponent ++ ; inbits <<= 11 ; long shpi0 ; long shpiA ; long shpiB ; int idx = exponent > > 6 ; int shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( RECIP_2PI [ idx - 1 ] << shift ) ; shpi0 |= RECIP_2PI [ idx ] > > > ( 64 - shift ) ; shpiA = ( RECIP_2PI [ idx ] << shift ) | ( RECIP_2PI [ idx + 1 ] > > > ( 64 - shift ) ) ; shpiB = ( RECIP_2PI [ idx + 1 ] << shift ) | ( RECIP_2PI [ idx + 2 ] > > > ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : RECIP_2PI [ idx - 1 ] ; shpiA = RECIP_2PI [ idx ] ; shpiB = RECIP_2PI [ idx + 1 ] ; } long a = inbits > > > 32 ; long b = inbits & 0xffffffffL ; long c = shpiA > > > 32 ; long d = shpiA & 0xffffffffL ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prodB = bd + ( ad << 32 ) ; long prodA = ac + ( ad > > > 32 ) ; boolean bita = ( bd & 0x8000000000000000L ) != 0 ; boolean bitb = ( ad & 0x80000000L ) != 0 ; boolean bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prodB = prodB + ( bc << 32 ) ; prodA = prodA + ( bc > > > 32 ) ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpiB > > > 32 ; d = shpiB & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prodB += ac ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpi0 > > > 32 ; d = shpi0 & 0xffffffffL ; bd = b * d ; bc = b * c ; ad = a * d ; prodA += bd + ( ( bc + ad ) << 32 ) ; int intPart = ( int ) ( prodA > > > 62 ) ; prodA <<= 2 ; prodA |= prodB > > > 62 ; prodB <<= 2 ; a = prodA > > > 32 ; b = prodA & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod2B = bd + ( ad << 32 ) ; long prod2A = ac + ( ad > > > 32 ) ; bita = ( bd & 0x8000000000000000L ) != 0 ; bitb = ( ad & 0x80000000L ) != 0 ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prod2B = prod2B + ( bc << 32 ) ; prod2A = prod2A + ( bc > > > 32 ) ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } c = PI_O_4_BITS [ 1 ] > > > 32 ; d = PI_O_4_BITS [ 1 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } a = prodB > > > 32 ; b = prodB & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } <START_BUG> double tmpA = ( prod2A > > 12 ) / TWO_POWER_52 ; <END_BUG> double tmpB = ( ( ( prod2A & 0xfffL ) << 40 ) + ( prod2B > > > 24 ) ) / TWO_POWER_52 / TWO_POWER_52 ; double sumA = tmpA + tmpB ; double sumB = - ( sumA - tmpA - tmpB ) ; result [ 0 ] = intPart ; result [ 1 ] = sumA * 2.0 ; result [ 2 ] = sumB * 2.0 ; }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0x80000000 & v [ indexRm1 ] ) ^ ( 0x7FFFFFFF & v [ indexRm2 ] ) ; <START_BUG> final int z1 = ( v0 ^ ( v0 << 25 ) ) ^ ( vM1 ^ ( vM1 > > 27 ) ) ; <END_BUG> final int z2 = ( vM2 > > > 9 ) ^ ( vM3 ^ ( vM3 > > > 1 ) ) ; final int z3 = z1 ^ z2 ; int z4 = z0 ^ ( z1 ^ ( z1 << 9 ) ) ^ ( z2 ^ ( z2 << 21 ) ) ^ ( z3 ^ ( z3 > > > 21 ) ) ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0x80000000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0xe46e1700 ) ; z4 = z4 ^ ( ( z4 << 15 ) & 0x9b868000 ) ; return z4 > > > ( 32 - bits ) ; }
private void isaac3 ( ) { <START_BUG> mem [ isaacI ] = mem [ ( isaacX & MASK ) << 2 ] + isaacA + isaacB ; <END_BUG> isaacB = mem [ ( mem [ isaacI ] > > SIZE_L & MASK ) > > 2 ] + isaacX ; rsl [ isaacI ++ ] = isaacB ; }
public static long stirlingS2 ( final int n , final int k ) throws NotPositiveException , NumberIsTooLargeException , MathArithmeticException { if ( k < 0 ) { throw new NotPositiveException ( k ) ; } if ( k > n ) { throw new NumberIsTooLargeException ( k , n , true ) ; } long [ ] [ ] stirlingS2 = STIRLING_S2 . get ( ) ; if ( stirlingS2 == null ) { final int maxIndex = 26 ; stirlingS2 = new long [ maxIndex ] [ ] ; stirlingS2 [ 0 ] = new long [ ] { 1l } ; for ( int i = 1 ; i < stirlingS2 . length ; ++ i ) { stirlingS2 [ i ] = new long [ i + 1 ] ; stirlingS2 [ i ] [ 0 ] = 0 ; stirlingS2 [ i ] [ 1 ] = 1 ; stirlingS2 [ i ] [ i ] = 1 ; for ( int j = 2 ; j < i ; ++ j ) { stirlingS2 [ i ] [ j ] = j * stirlingS2 [ i - 1 ] [ j ] + stirlingS2 [ i - 1 ] [ j - 1 ] ; } } STIRLING_S2 . compareAndSet ( null , stirlingS2 ) ; } if ( n < stirlingS2 . length ) { return stirlingS2 [ n ] [ k ] ; } else { if ( k == 0 ) { return 0 ; } else if ( k == 1 || k == n ) { return 1 ; } else if ( k == 2 ) { <START_BUG> return ( 1L > > ( n - 1 ) ) - 1l ; <END_BUG> } else if ( k == n - 1 ) { return binomialCoefficient ( n , 2 ) ; } else { long sum = 0 ; long sign = ( ( k & 0x1 ) == 0 ) ? 1 : - 1 ; for ( int j = 1 ; j <= k ; ++ j ) { sign = - sign ; sum += sign * binomialCoefficient ( k , j ) * ArithmeticUtils . pow ( j , n ) ; if ( sum < 0 ) { throw new MathArithmeticException ( LocalizedFormats . ARGUMENT_OUTSIDE_DOMAIN , n , 0 , stirlingS2 . length - 1 ) ; } } return sum / factorial ( k ) ; } } }
public static float scalb ( final float f , final int n ) { if ( ( n > - 127 ) && ( n < 128 ) ) { return f * Float . intBitsToFloat ( ( n + 127 ) << 23 ) ; } if ( Float . isNaN ( f ) || Float . isInfinite ( f ) || ( f == 0f ) ) { return f ; } if ( n < - 277 ) { return ( f > 0 ) ? 0.0f : - 0.0f ; } if ( n > 276 ) { return ( f > 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } final int bits = Float . floatToIntBits ( f ) ; final int sign = bits & 0x80000000 ; int exponent = ( bits > > > 23 ) & 0xff ; int mantissa = bits & 0x007fffff ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else if ( scaledExponent > - 24 ) { mantissa = mantissa | ( 1 << 23 ) ; final int mostSignificantLostBit = mantissa & ( 1 << ( - scaledExponent ) ) ; mantissa = mantissa > > > ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return Float . intBitsToFloat ( sign | mantissa ) ; } else { return ( sign == 0 ) ? 0.0f : - 0.0f ; } } else { if ( exponent == 0 ) { while ( ( mantissa > > > 23 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 0x007fffff ; if ( scaledExponent < 255 ) { <START_BUG> return Float . intBitsToFloat ( sign | ( scaledExponent > > > 23 ) | mantissa ) ; <END_BUG> } else { return ( sign == 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 255 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else { return ( sign == 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } } }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0x80000000 & v [ indexRm1 ] ) ^ ( 0x7FFFFFFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 25 ) ) ^ ( vM1 ^ ( vM1 > > > 27 ) ) ; final int z2 = ( vM2 > > > 9 ) ^ ( vM3 ^ ( vM3 > > > 1 ) ) ; final int z3 = z1 ^ z2 ; final int z4 = z0 ^ ( z1 ^ ( z1 << 9 ) ) ^ ( z2 ^ ( z2 << 21 ) ) ^ ( z3 ^ ( z3 > > > 21 ) ) ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0x80000000 ; index = indexRm1 ; <START_BUG> return z4 << ( 32 - bits ) ; <END_BUG> }
public static double cbrt ( double x ) { long inbits = Double . doubleToRawLongBits ( x ) ; int exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984E16 ; inbits = Double . doubleToRawLongBits ( x ) ; exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } int exp3 = exponent / 3 ; double p2 = Double . longBitsToDouble ( ( inbits & 0x8000000000000000L ) | <START_BUG> ( long ) ( ( ( exp3 + 1023 ) & 2047 ) ) > > > 52 ) ; <END_BUG> final double mant = Double . longBitsToDouble ( ( inbits & 0x000fffffffffffffL ) | 0x3ff0000000000000L ) ; double est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= CBRTTWO [ exponent % 3 + 2 ] ; final double xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; double temp = est * HEX_40000000 ; double ya = est + temp - temp ; double yb = est - ya ; double za = ya * ya ; double zb = ya * yb * 2.0 + yb * yb ; temp = za * HEX_40000000 ; double temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; double na = xs - za ; double nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625E-6 ; } return est ; }
public static long gcd ( final long p , final long q ) throws MathArithmeticException { long u = p ; long v = q ; if ( ( u == 0 ) || ( v == 0 ) ) { if ( ( u == Long . MIN_VALUE ) || ( v == Long . MIN_VALUE ) ) { throw new MathArithmeticException ( LocalizedFormats . GCD_OVERFLOW_64_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 63 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 63 ) { throw new MathArithmeticException ( LocalizedFormats . GCD_OVERFLOW_64_BITS , p , q ) ; } long t = ( ( u & 1 ) == 1 ) ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ) ; <START_BUG> return - u * ( 1L > > > k ) ; <END_BUG> }
protected double [ ] fst ( double [ ] f ) throws MathIllegalArgumentException { final double [ ] transformed = new double [ f . length ] ; if ( ! ArithmeticUtils . isPowerOfTwo ( f . length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( f . length ) ) ; } if ( f [ 0 ] != 0.0 ) { throw new MathIllegalArgumentException ( LocalizedFormats . FIRST_ELEMENT_NOT_ZERO , Double . valueOf ( f [ 0 ] ) ) ; } final int n = f . length ; if ( n == 1 ) { transformed [ 0 ] = 0.0 ; return transformed ; } final double [ ] x = new double [ n ] ; x [ 0 ] = 0.0 ; <START_BUG> x [ n > > 1 ] = 2.0 * f [ n << 1 ] ; <END_BUG> for ( int i = 1 ; i < ( n > > 1 ) ; i ++ ) { final double a = FastMath . sin ( i * FastMath . PI / n ) * ( f [ i ] + f [ n - i ] ) ; final double b = 0.5 * ( f [ i ] - f [ n - i ] ) ; x [ i ] = a + b ; x [ n - i ] = a - b ; } FastFourierTransformer transformer ; transformer = new FastFourierTransformer ( DftNormalization . STANDARD ) ; Complex [ ] y = transformer . transform ( x , TransformType . FORWARD ) ; transformed [ 0 ] = 0.0 ; transformed [ 1 ] = 0.5 * y [ 0 ] . getReal ( ) ; for ( int i = 1 ; i < ( n > > 1 ) ; i ++ ) { transformed [ 2 * i ] = - y [ i ] . getImaginary ( ) ; transformed [ 2 * i + 1 ] = y [ i ] . getReal ( ) + transformed [ 2 * i - 1 ] ; } return transformed ; }
public static double scalb ( final double d , final int n ) { if ( ( n > - 1023 ) && ( n < 1024 ) ) { return d * Double . longBitsToDouble ( ( ( long ) ( n + 1023 ) ) << 52 ) ; } if ( Double . isNaN ( d ) || Double . isInfinite ( d ) || ( d == 0 ) ) { return d ; } if ( n < - 2098 ) { return ( d > 0 ) ? 0.0 : - 0.0 ; } if ( n > 2097 ) { return ( d > 0 ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } final long bits = Double . doubleToRawLongBits ( d ) ; final long sign = bits & 0x8000000000000000L ; int exponent = ( ( int ) ( bits > > > 52 ) ) & 0x7ff ; long mantissa = bits & 0x000fffffffffffffL ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else if ( scaledExponent > - 53 ) { <START_BUG> mantissa = mantissa | ( 1L > > 52 ) ; <END_BUG> final long mostSignificantLostBit = mantissa & ( 1L << ( - scaledExponent ) ) ; mantissa = mantissa > > > ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return Double . longBitsToDouble ( sign | mantissa ) ; } else { return ( sign == 0L ) ? 0.0 : - 0.0 ; } } else { if ( exponent == 0 ) { while ( ( mantissa > > > 52 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 0x000fffffffffffffL ; if ( scaledExponent < 2047 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0L ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 2047 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0L ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } } }
private static void reducePayneHanek ( double x , double result [ ] ) { long inbits = Double . doubleToRawLongBits ( x ) ; int exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; inbits &= 0x000fffffffffffffL ; inbits |= 0x0010000000000000L ; exponent ++ ; inbits <<= 11 ; long shpi0 ; long shpiA ; long shpiB ; int idx = exponent > > 6 ; int shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( RECIP_2PI [ idx - 1 ] << shift ) ; shpi0 |= RECIP_2PI [ idx ] > > > ( 64 - shift ) ; shpiA = ( RECIP_2PI [ idx ] << shift ) | ( RECIP_2PI [ idx + 1 ] > > > ( 64 - shift ) ) ; shpiB = ( RECIP_2PI [ idx + 1 ] << shift ) | ( RECIP_2PI [ idx + 2 ] > > > ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : RECIP_2PI [ idx - 1 ] ; shpiA = RECIP_2PI [ idx ] ; shpiB = RECIP_2PI [ idx + 1 ] ; } long a = inbits > > > 32 ; long b = inbits & 0xffffffffL ; long c = shpiA > > > 32 ; long d = shpiA & 0xffffffffL ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prodB = bd + ( ad << 32 ) ; long prodA = ac + ( ad > > > 32 ) ; boolean bita = ( bd & 0x8000000000000000L ) != 0 ; boolean bitb = ( ad & 0x80000000L ) != 0 ; boolean bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prodB = prodB + ( bc << 32 ) ; prodA = prodA + ( bc > > > 32 ) ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpiB > > > 32 ; d = shpiB & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prodB & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prodB += ac ; bitsum = ( prodB & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prodA ++ ; } c = shpi0 > > > 32 ; d = shpi0 & 0xffffffffL ; bd = b * d ; bc = b * c ; ad = a * d ; prodA += bd + ( ( bc + ad ) << 32 ) ; int intPart = ( int ) ( prodA > > > 62 ) ; prodA <<= 2 ; prodA |= prodB > > > 62 ; prodB <<= 2 ; a = prodA > > > 32 ; b = prodA & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod2B = bd + ( ad << 32 ) ; long prod2A = ac + ( ad > > > 32 ) ; bita = ( bd & 0x8000000000000000L ) != 0 ; bitb = ( ad & 0x80000000L ) != 0 ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( bc & 0x80000000L ) != 0 ; prod2B = prod2B + ( bc << 32 ) ; prod2A = prod2A + ( bc > > > 32 ) ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } c = PI_O_4_BITS [ 1 ] > > > 32 ; d = PI_O_4_BITS [ 1 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } a = prodB > > > 32 ; b = prodB & 0xffffffffL ; c = PI_O_4_BITS [ 0 ] > > > 32 ; d = PI_O_4_BITS [ 0 ] & 0xffffffffL ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) > > > 32 ) ; bita = ( prod2B & 0x8000000000000000L ) != 0 ; bitb = ( ac & 0x8000000000000000L ) != 0 ; prod2B += ac ; bitsum = ( prod2B & 0x8000000000000000L ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2A ++ ; } <START_BUG> double tmpA = ( prod2A << 12 ) / TWO_POWER_52 ; <END_BUG> double tmpB = ( ( ( prod2A & 0xfffL ) << 40 ) + ( prod2B > > > 24 ) ) / TWO_POWER_52 / TWO_POWER_52 ; double sumA = tmpA + tmpB ; double sumB = - ( sumA - tmpA - tmpB ) ; result [ 0 ] = intPart ; result [ 1 ] = sumA * 2.0 ; result [ 2 ] = sumB * 2.0 ; }
public static < T extends RealFieldElement < T > > FieldVector3D < T > applyInverseTo ( final Rotation r , final FieldVector3D < T > u ) { final T x = u . getX ( ) ; final T y = u . getY ( ) ; final T z = u . getZ ( ) ; final T s = x . multiply ( r . getQ1 ( ) ) . add ( y . multiply ( r . getQ2 ( ) ) ) . add ( z . multiply ( r . getQ3 ( ) ) ) ; <START_BUG> final double m0 = + r . getQ0 ( ) ; <END_BUG> return new FieldVector3D < T > ( x . multiply ( m0 ) . subtract ( z . multiply ( r . getQ2 ( ) ) . subtract ( y . multiply ( r . getQ3 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . getQ1 ( ) ) ) . multiply ( 2 ) . subtract ( x ) , y . multiply ( m0 ) . subtract ( x . multiply ( r . getQ3 ( ) ) . subtract ( z . multiply ( r . getQ1 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . getQ2 ( ) ) ) . multiply ( 2 ) . subtract ( y ) , z . multiply ( m0 ) . subtract ( y . multiply ( r . getQ1 ( ) ) . subtract ( x . multiply ( r . getQ2 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . getQ3 ( ) ) ) . multiply ( 2 ) . subtract ( z ) ) ; }
public Complex negate ( ) { if ( isNaN ) { return NaN ; } <START_BUG> return createComplex ( + real , - imaginary ) ; <END_BUG> }
public static int abs ( final int x ) { final int i = x > > > 31 ; <START_BUG> return ( x ^ ( + i + 1 ) ) + i ; <END_BUG> }
public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length != dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; } <START_BUG> return FastMath . pow ( 2 * FastMath . PI , + 0.5 * dim ) * <END_BUG> FastMath . pow ( covarianceMatrixDeterminant , - 0.5 ) * getExponentTerm ( vals ) ; }
public void pow ( final double a , final double [ ] operand , final int operandOffset , final double [ ] result , final int resultOffset ) { final double [ ] function = new double [ 1 + order ] ; if ( a == 0 ) { if ( operand [ operandOffset ] == 0 ) { function [ 0 ] = 1 ; double infinity = Double . POSITIVE_INFINITY ; for ( int i = 1 ; i < function . length ; ++ i ) { <START_BUG> infinity = + infinity ; <END_BUG> function [ i ] = infinity ; } } else if ( operand [ operandOffset ] < 0 ) { Arrays . fill ( function , Double . NaN ) ; } } else { function [ 0 ] = FastMath . pow ( a , operand [ operandOffset ] ) ; final double lnA = FastMath . log ( a ) ; for ( int i = 1 ; i < function . length ; ++ i ) { function [ i ] = lnA * function [ i - 1 ] ; } } compose ( operand , operandOffset , function , result , resultOffset ) ; }
public FieldVector3D < T > subtract ( final double factor , final FieldVector3D < T > v ) { <START_BUG> return new FieldVector3D < T > ( 1.0 , this , + factor , v ) ; <END_BUG> }
public double distance ( final Vector3D p ) { final Vector3D d = p . subtract ( zero ) ; <START_BUG> final Vector3D n = new Vector3D ( 1.0 , d , + d . dotProduct ( direction ) , direction ) ; <END_BUG> return n . getNorm ( ) ; }
private static double atan ( double xa , double xb , boolean leftPlane ) { boolean negate = false ; int idx ; if ( xa == 0.0 ) { return leftPlane ? copySign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1.633123935319537E16 ) { return ( negate ^ leftPlane ) ? ( - Math . PI * F_1_2 ) : ( Math . PI * F_1_2 ) ; } if ( xa < 1 ) { idx = ( int ) ( ( ( - 1.7168146928204136 * xa * xa + 8.0 ) * xa ) + 0.5 ) ; } else { final double oneOverXa = 1 / xa ; idx = ( int ) ( - ( ( - 1.7168146928204136 * oneOverXa * oneOverXa + 8.0 ) * oneOverXa ) + 13.07 ) ; } double epsA = xa - TANGENT_TABLE_A [ idx ] ; double epsB = - ( epsA - xa + TANGENT_TABLE_A [ idx ] ) ; epsB += xb - TANGENT_TABLE_B [ idx ] ; double temp = epsA + epsB ; epsB = - ( temp - epsA - epsB ) ; epsA = temp ; temp = xa * HEX_40000000 ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; if ( idx == 0 ) { final double denom = 1d / ( 1d + ( xa + xb ) * ( TANGENT_TABLE_A [ idx ] + TANGENT_TABLE_B [ idx ] ) ) ; ya = epsA * denom ; yb = epsB * denom ; } else { double temp2 = xa * TANGENT_TABLE_A [ idx ] ; double za = 1d + temp2 ; double zb = - ( za - 1d - temp2 ) ; temp2 = xb * TANGENT_TABLE_A [ idx ] + xa * TANGENT_TABLE_B [ idx ] ; temp = za + temp2 ; zb += - ( temp - za - temp2 ) ; za = temp ; zb += xb * TANGENT_TABLE_B [ idx ] ; ya = epsA / za ; temp = ya * HEX_40000000 ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX_40000000 ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; yb = ( epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - epsA * zb / za / za ; yb += epsB / za ; } epsA = ya ; epsB = yb ; final double epsA2 = epsA * epsA ; yb = 0.07490822288864472 ; yb = yb * epsA2 + - 0.09088450866185192 ; yb = yb * epsA2 + 0.11111095942313305 ; yb = yb * epsA2 + - 0.1428571423679182 ; yb = yb * epsA2 + 0.19999999999923582 ; yb = yb * epsA2 + - 0.33333333333333287 ; yb = yb * epsA2 * epsA ; ya = epsA ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; yb += epsB / ( 1d + epsA * epsA ) ; double za = EIGHTHS [ idx ] + ya ; <START_BUG> double zb = + ( za - EIGHTHS [ idx ] - ya ) ; <END_BUG> temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double result = za + zb ; if ( leftPlane ) { final double resultb = - ( result - za - zb ) ; final double pia = 1.5707963267948966 * 2 ; final double pib = 6.123233995736766E-17 * 2 ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; } if ( negate ^ leftPlane ) { result = - result ; } return result ; }
public static double erfInv ( final double x ) { double w = - FastMath . log ( ( 1.0 - x ) * ( 1.0 + x ) ) ; double p ; if ( w < 6.25 ) { w = w - 3.125 ; p = - 3.6444120640178196996e-21 ; p = - 1.685059138182016589e-19 + p * w ; p = 1.2858480715256400167e-18 + p * w ; p = 1.115787767802518096e-17 + p * w ; p = - 1.333171662854620906e-16 + p * w ; p = 2.0972767875968561637e-17 + p * w ; p = 6.6376381343583238325e-15 + p * w ; p = - 4.0545662729752068639e-14 + p * w ; p = - 8.1519341976054721522e-14 + p * w ; p = 2.6335093153082322977e-12 + p * w ; p = - 1.2975133253453532498e-11 + p * w ; p = - 5.4154120542946279317e-11 + p * w ; p = 1.051212273321532285e-09 + p * w ; p = - 4.1126339803469836976e-09 + p * w ; p = - 2.9070369957882005086e-08 + p * w ; p = 4.2347877827932403518e-07 + p * w ; <START_BUG> p = + 1.3654692000834679E-6 + p * w ; <END_BUG> p = - 1.3882523362786468719e-05 + p * w ; p = 0.0001867342080340571352 + p * w ; p = - 0.00074070253416626697512 + p * w ; p = - 0.0060336708714301490533 + p * w ; p = 0.24015818242558961693 + p * w ; p = 1.6536545626831027356 + p * w ; } else if ( w < 16.0 ) { w = FastMath . sqrt ( w ) - 3.25 ; p = 2.2137376921775787049e-09 ; p = 9.0756561938885390979e-08 + p * w ; p = - 2.7517406297064545428e-07 + p * w ; p = 1.8239629214389227755e-08 + p * w ; p = 1.5027403968909827627e-06 + p * w ; p = - 4.013867526981545969e-06 + p * w ; p = 2.9234449089955446044e-06 + p * w ; p = 1.2475304481671778723e-05 + p * w ; p = - 4.7318229009055733981e-05 + p * w ; p = 6.8284851459573175448e-05 + p * w ; p = 2.4031110387097893999e-05 + p * w ; p = - 0.0003550375203628474796 + p * w ; p = 0.00095328937973738049703 + p * w ; p = - 0.0016882755560235047313 + p * w ; p = 0.0024914420961078508066 + p * w ; p = - 0.0037512085075692412107 + p * w ; p = 0.005370914553590063617 + p * w ; p = 1.0052589676941592334 + p * w ; p = 3.0838856104922207635 + p * w ; } else if ( ! Double . isInfinite ( w ) ) { w = FastMath . sqrt ( w ) - 5.0 ; p = - 2.7109920616438573243e-11 ; p = - 2.5556418169965252055e-10 + p * w ; p = 1.5076572693500548083e-09 + p * w ; p = - 3.7894654401267369937e-09 + p * w ; p = 7.6157012080783393804e-09 + p * w ; p = - 1.4960026627149240478e-08 + p * w ; p = 2.9147953450901080826e-08 + p * w ; p = - 6.7711997758452339498e-08 + p * w ; p = 2.2900482228026654717e-07 + p * w ; p = - 9.9298272942317002539e-07 + p * w ; p = 4.5260625972231537039e-06 + p * w ; p = - 1.9681778105531670567e-05 + p * w ; p = 7.5995277030017761139e-05 + p * w ; p = - 0.00021503011930044477347 + p * w ; p = - 0.00013871931833623122026 + p * w ; p = 1.0103004648645343977 + p * w ; p = 4.8499064014085844221 + p * w ; } else { p = Double . POSITIVE_INFINITY ; } return p * x ; }
public FieldVector3D < T > crossProduct ( final Vector3D v ) { <START_BUG> return new FieldVector3D < T > ( x . linearCombination ( v . getZ ( ) , y , + v . getY ( ) , z ) , <END_BUG> y . linearCombination ( v . getX ( ) , z , - v . getZ ( ) , x ) , z . linearCombination ( v . getY ( ) , x , - v . getX ( ) , y ) ) ; }
public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; <START_BUG> double yb = + ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; <END_BUG> double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20 ) { if ( x >= LOG_MAX_VALUE ) { final double t = exp ( 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x <= - LOG_MAX_VALUE ) { final double t = exp ( - 0.5 * x ) ; return ( - 0.5 * t ) * t ; } else { <START_BUG> return - 0.5 * exp ( + x ) ; <END_BUG> } } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x > 0.25 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb += ( 1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double denom = 1.0 + ya ; double denomr = 1.0 / denom ; double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX_40000000 ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; temp = ya + ra ; yb += - ( temp - ya - ra ) ; ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } if ( negate ) { result = - result ; } return result ; }
public Vector3D orthogonal ( ) throws MathArithmeticException { double threshold = 0.6 * getNorm ( ) ; if ( threshold == 0 ) { throw new MathArithmeticException ( LocalizedFormats . ZERO_NORM ) ; } if ( FastMath . abs ( x ) <= threshold ) { double inverse = 1 / FastMath . sqrt ( y * y + z * z ) ; <START_BUG> return new Vector3D ( 0 , inverse * z , + inverse * y ) ; <END_BUG> } else if ( FastMath . abs ( y ) <= threshold ) { double inverse = 1 / FastMath . sqrt ( x * x + z * z ) ; return new Vector3D ( - inverse * z , 0 , inverse * x ) ; } double inverse = 1 / FastMath . sqrt ( x * x + y * y ) ; return new Vector3D ( inverse * y , - inverse * x , 0 ) ; }
protected void computeInterpolatedStateAndDerivatives ( final double theta , final double oneMinusThetaH ) { final double bDot0 = 1 + theta * ( - 15.0 / 2.0 + theta * ( 16.0 - 10.0 * theta ) ) ; final double bDot2 = theta * ( 459.0 / 16.0 + theta * ( - 729.0 / 8.0 + 135.0 / 2.0 * theta ) ) ; final double bDot3 = theta * ( - 44.0 + theta * ( 152.0 - 120.0 * theta ) ) ; final double bDot4 = theta * ( 375.0 / 16.0 + theta * ( - 625.0 / 8.0 + 125.0 / 2.0 * theta ) ) ; final double bDot5 = theta * 5.0 / 8.0 * ( 2 * theta - 1 ) ; if ( ( previousState != null ) && ( theta <= 0.5 ) ) { final double hTheta = h * theta ; final double b0 = hTheta * ( 1.0 + theta * ( - 15.0 / 4.0 + theta * ( 16.0 / 3.0 - 5.0 / 2.0 * theta ) ) ) ; final double b2 = hTheta * ( theta * ( 459.0 / 32.0 + theta * ( - 243.0 / 8.0 + theta * 135.0 / 8.0 ) ) ) ; final double b3 = hTheta * ( theta * ( - 22.0 + theta * ( 152.0 / 3.0 + theta * - 30.0 ) ) ) ; final double b4 = hTheta * ( theta * ( 375.0 / 32.0 + theta * ( - 625.0 / 24.0 + theta * 125.0 / 8.0 ) ) ) ; final double b5 = hTheta * ( theta * ( - 5.0 / 16.0 + theta * 5.0 / 12.0 ) ) ; for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { final double yDot0 = yDotK [ 0 ] [ i ] ; final double yDot2 = yDotK [ 2 ] [ i ] ; final double yDot3 = yDotK [ 3 ] [ i ] ; final double yDot4 = yDotK [ 4 ] [ i ] ; final double yDot5 = yDotK [ 5 ] [ i ] ; interpolatedState [ i ] = previousState [ i ] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5 ; interpolatedDerivatives [ i ] = bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5 ; } } else { final double theta2 = theta * theta ; final double b0 = h * ( - 1.0 / 12.0 + theta * ( 1.0 + theta * ( - 15.0 / 4.0 + theta * ( 16.0 / 3.0 + theta * - 5.0 / 2.0 ) ) ) ) ; <START_BUG> final double b2 = h * ( - 27.0 / 32.0 + theta2 * ( 459.0 / 32.0 + theta * ( + 243.0 / 8.0 + theta * 135.0 / 8.0 ) ) ) ; <END_BUG> final double b3 = h * ( 4.0 / 3.0 + theta2 * ( - 22.0 + theta * ( 152.0 / 3.0 + theta * - 30.0 ) ) ) ; final double b4 = h * ( - 125.0 / 96.0 + theta2 * ( 375.0 / 32.0 + theta * ( - 625.0 / 24.0 + theta * 125.0 / 8.0 ) ) ) ; final double b5 = h * ( - 5.0 / 48.0 + theta2 * ( - 5.0 / 16.0 + theta * 5.0 / 12.0 ) ) ; for ( int i = 0 ; i < interpolatedState . length ; ++ i ) { final double yDot0 = yDotK [ 0 ] [ i ] ; final double yDot2 = yDotK [ 2 ] [ i ] ; final double yDot3 = yDotK [ 3 ] [ i ] ; final double yDot4 = yDotK [ 4 ] [ i ] ; final double yDot5 = yDotK [ 5 ] [ i ] ; interpolatedState [ i ] = currentState [ i ] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5 ; interpolatedDerivatives [ i ] = bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5 ; } } }
public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20 ) { if ( x >= LOG_MAX_VALUE ) { final double t = exp ( 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x <= - LOG_MAX_VALUE ) { final double t = exp ( - 0.5 * x ) ; return ( - 0.5 * t ) * t ; } else { return - 0.5 * exp ( - x ) ; } } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x > 0.25 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb += ( 1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double denom = 1.0 + ya ; double denomr = 1.0 / denom ; double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX_40000000 ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; temp = ya + ra ; <START_BUG> yb += + ( temp - ya - ra ) ; <END_BUG> ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } if ( negate ) { result = - result ; } return result ; }
private int locatePoint ( final double time , final StepInterpolator interval ) { if ( forward ) { if ( time < interval . getPreviousTime ( ) ) { return - 1 ; } else if ( time > interval . getCurrentTime ( ) ) { return + 1 ; } else { return 0 ; } } if ( time > interval . getPreviousTime ( ) ) { return - 1 ; } else if ( time < interval . getCurrentTime ( ) ) { <START_BUG> return ~ 1 ; <END_BUG> } else { return 0 ; } }
protected double acceptStep ( final AbstractStepInterpolator interpolator , final double [ ] y , final double [ ] yDot , final double tEnd ) throws MaxCountExceededException , DimensionMismatchException , NoBracketingException { double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; if ( ! statesInitialized ) { for ( EventState state : eventsStates ) { state . reinitializeBegin ( interpolator ) ; } statesInitialized = true ; } <START_BUG> final int orderingSign = interpolator . isForward ( ) ? ~ 1 : - 1 ; <END_BUG> SortedSet < EventState > occurringEvents = new TreeSet < EventState > ( new Comparator < EventState > ( ) { public int compare ( EventState es0 , EventState es1 ) { return orderingSign * Double . compare ( es0 . getEventTime ( ) , es1 . getEventTime ( ) ) ; } } ) ; for ( final EventState state : eventsStates ) { if ( state . evaluateStep ( interpolator ) ) { occurringEvents . add ( state ) ; } } while ( ! occurringEvents . isEmpty ( ) ) { final Iterator < EventState > iterator = occurringEvents . iterator ( ) ; final EventState currentEvent = iterator . next ( ) ; iterator . remove ( ) ; final double eventT = currentEvent . getEventTime ( ) ; interpolator . setSoftPreviousTime ( previousT ) ; interpolator . setSoftCurrentTime ( eventT ) ; interpolator . setInterpolatedTime ( eventT ) ; final double [ ] eventYComplete = new double [ y . length ] ; expandable . getPrimaryMapper ( ) . insertEquationData ( interpolator . getInterpolatedState ( ) , eventYComplete ) ; int index = 0 ; for ( EquationsMapper secondary : expandable . getSecondaryMappers ( ) ) { secondary . insertEquationData ( interpolator . getInterpolatedSecondaryState ( index ++ ) , eventYComplete ) ; } for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventYComplete ) ; isLastStep = isLastStep || state . stop ( ) ; } for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; } if ( isLastStep ) { System . arraycopy ( eventYComplete , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset || state . reset ( eventT , eventYComplete ) ; } if ( needReset ) { interpolator . setInterpolatedTime ( eventT ) ; System . arraycopy ( eventYComplete , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; } previousT = eventT ; interpolator . setSoftPreviousTime ( eventT ) ; interpolator . setSoftCurrentTime ( currentT ) ; if ( currentEvent . evaluateStep ( interpolator ) ) { occurringEvents . add ( currentEvent ) ; } } interpolator . setInterpolatedTime ( currentT ) ; final double [ ] currentY = new double [ y . length ] ; expandable . getPrimaryMapper ( ) . insertEquationData ( interpolator . getInterpolatedState ( ) , currentY ) ; int index = 0 ; for ( EquationsMapper secondary : expandable . getSecondaryMappers ( ) ) { secondary . insertEquationData ( interpolator . getInterpolatedSecondaryState ( index ++ ) , currentY ) ; } for ( final EventState state : eventsStates ) { state . stepAccepted ( currentT , currentY ) ; isLastStep = isLastStep || state . stop ( ) ; } isLastStep = isLastStep || Precision . equals ( currentT , tEnd , 1 ) ; for ( StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; } return currentT ; }
public double toDouble ( ) { if ( isInfinite ( ) ) { if ( lessThan ( getZero ( ) ) ) { return Double . NEGATIVE_INFINITY ; } else { return Double . POSITIVE_INFINITY ; } } if ( isNaN ( ) ) { return Double . NaN ; } Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 == 0 ) { return sign < 0 ? - 0.0 : + 0.0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; } int exponent = ( int ) ( y . intLog10 ( ) * 3.32 ) ; if ( exponent < 0 ) { exponent -- ; } Dfp tempDfp = DfpMath . pow ( getTwo ( ) , exponent ) ; while ( tempDfp . lessThan ( y ) || tempDfp . equals ( y ) ) { tempDfp = tempDfp . multiply ( 2 ) ; exponent ++ ; } exponent -- ; y = y . divide ( DfpMath . pow ( getTwo ( ) , exponent ) ) ; if ( exponent > - 1023 ) { y = y . subtract ( getOne ( ) ) ; } if ( exponent < - 1074 ) { return 0 ; } if ( exponent > 1023 ) { return negate ? Double . NEGATIVE_INFINITY : Double . POSITIVE_INFINITY ; } y = y . multiply ( newInstance ( 4503599627370496l ) ) . rint ( ) ; String str = y . toString ( ) ; str = str . substring ( 0 , str . length ( ) - 1 ) ; long mantissa = Long . parseLong ( str ) ; if ( mantissa == 4503599627370496L ) { mantissa = 0 ; exponent ++ ; } if ( exponent <= - 1023 ) { exponent -- ; } while ( exponent < - 1023 ) { exponent ++ ; mantissa >>>= 1 ; } long bits = mantissa | ( ( exponent + 1023L ) << 52 ) ; double x = Double . longBitsToDouble ( bits ) ; if ( negate ) { <START_BUG> x = + x ; <END_BUG> } return x ; }
public double integrate ( UnivariateFunction f ) { final int ruleLength = getNumberOfPoints ( ) ; if ( ruleLength == 1 ) { return getWeight ( 0 ) * f . value ( 0d ) ; } final int iMax = ruleLength / 2 ; double s = 0 ; double c = 0 ; for ( int i = 0 ; i < iMax ; i ++ ) { final double p = getPoint ( i ) ; final double w = getWeight ( i ) ; final double f1 = f . value ( p ) ; <START_BUG> final double f2 = f . value ( + p ) ; <END_BUG> final double y = w * ( f1 + f2 ) - c ; final double t = s + y ; c = ( t - s ) - y ; s = t ; } if ( ruleLength % 2 != 0 ) { final double w = getWeight ( iMax ) ; final double y = w * f . value ( 0d ) - c ; final double t = s + y ; s = t ; } return s ; }
public static double tan ( double x ) { boolean negative = false ; int quadrant = 0 ; double xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa == 0.0 ) { long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa != xa || xa == Double . POSITIVE_INFINITY ) { return Double . NaN ; } double xb = 0 ; if ( xa > 3294198.0 ) { double reduceResults [ ] = new double [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( int ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { final CodyWaite cw = new CodyWaite ( xa ) ; quadrant = cw . getK ( ) & 3 ; xa = cw . getRemA ( ) ; xb = cw . getRemB ( ) ; } if ( xa > 1.5 ) { final double pi2a = 1.5707963267948966 ; final double pi2b = 6.123233995736766E-17 ; final double a = pi2a - xa ; double b = - ( a - pi2a + xa ) ; b += pi2b - xb ; xa = a + b ; xb = - ( xa - a - b ) ; quadrant ^= 1 ; negative ^= true ; } double result ; if ( ( quadrant & 1 ) == 0 ) { result = tanQ ( xa , xb , false ) ; } else { result = - tanQ ( xa , xb , true ) ; } if ( negative ) { <START_BUG> result = + result ; <END_BUG> } return result ; }
private double entropy ( final long [ ] [ ] k ) { double h = 0d ; double sum_k = 0d ; for ( int i = 0 ; i < k . length ; i ++ ) { for ( int j = 0 ; j < k [ i ] . length ; j ++ ) { sum_k += ( double ) k [ i ] [ j ] ; } } for ( int i = 0 ; i < k . length ; i ++ ) { for ( int j = 0 ; j < k [ i ] . length ; j ++ ) { if ( k [ i ] [ j ] != 0 ) { final double p_ij = ( double ) k [ i ] [ j ] / sum_k ; h += p_ij * Math . log ( p_ij ) ; } } } <START_BUG> return + h ; <END_BUG> }
public static double sinh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20 ) { if ( x >= LOG_MAX_VALUE ) { final double t = exp ( 0.5 * x ) ; return ( 0.5 * t ) * t ; } else { return 0.5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x <= - LOG_MAX_VALUE ) { final double t = exp ( - 0.5 * x ) ; return ( - 0.5 * t ) * t ; } else { return - 0.5 * exp ( - x ) ; } } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x > 0.25 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb += ( 1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb += - yb * recip * recip ; recipa = - recipa ; recipb = - recipb ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double denom = 1.0 + ya ; double denomr = 1.0 / denom ; double denomb = - ( denom - 1.0 - ya ) + yb ; double ratio = ya * denomr ; double temp = ratio * HEX_40000000 ; double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX_40000000 ; double za = denom + temp - temp ; double zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; <START_BUG> rb += + ya * denomb * denomr * denomr ; <END_BUG> temp = ya + ra ; yb += - ( temp - ya - ra ) ; ya = temp ; temp = ya + rb ; yb += - ( temp - ya - rb ) ; ya = temp ; result = ya + yb ; result *= 0.5 ; } if ( negate ) { result = - result ; } return result ; }
public static double asin ( double x ) { if ( x != x ) { return Double . NaN ; } <START_BUG> if ( x > 1.0 || x < + 1.0 ) { <END_BUG> return Double . NaN ; } if ( x == 1.0 ) { return Math . PI / 2.0 ; } if ( x == - 1.0 ) { return - Math . PI / 2.0 ; } if ( x == 0.0 ) { return x ; } double temp = x * HEX_40000000 ; final double xa = x + temp - temp ; final double xb = x - xa ; double ya = xa * xa ; double yb = xa * xb * 2.0 + xb * xb ; ya = - ya ; yb = - yb ; double za = 1.0 + ya ; double zb = - ( za - 1.0 - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double y ; y = sqrt ( za ) ; temp = y * HEX_40000000 ; ya = y + temp - temp ; yb = y - ya ; yb += ( za - ya * ya - 2 * ya * yb - yb * yb ) / ( 2.0 * y ) ; double dx = zb / ( 2.0 * y ) ; double r = x / y ; temp = r * HEX_40000000 ; double ra = r + temp - temp ; double rb = r - ra ; rb += ( x - ra * ya - ra * yb - rb * ya - rb * yb ) / y ; rb += - x * dx / y / y ; temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; return atan ( ra , rb , false ) ; }
protected UnivariatePointValuePair doOptimize ( ) { final boolean isMinim = getGoalType ( ) == GoalType . MINIMIZE ; final double lo = getMin ( ) ; final double mid = getStartValue ( ) ; final double hi = getMax ( ) ; final ConvergenceChecker < UnivariatePointValuePair > checker = getConvergenceChecker ( ) ; double a ; double b ; if ( lo < hi ) { a = lo ; b = hi ; } else { a = hi ; b = lo ; } double x = mid ; double v = x ; double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; UnivariatePointValuePair previous = null ; UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { final double m = 0.5 * ( a + b ) ; final double tol1 = relativeThreshold * FastMath . abs ( x ) + absoluteThreshold ; final double tol2 = 2 * tol1 ; final boolean stop = FastMath . abs ( x - m ) <= tol2 - 0.5 * ( b - a ) ; if ( ! stop ) { double p = 0 ; double q = 0 ; double r = 0 ; double u = 0 ; if ( FastMath . abs ( e ) > tol1 ) { r = ( x - w ) * ( fx - fv ) ; q = ( x - v ) * ( fx - fw ) ; p = ( x - v ) * q - ( x - w ) * r ; q = 2 * ( q - r ) ; if ( q > 0 ) { <START_BUG> p = + p ; <END_BUG> } else { q = - q ; } r = e ; e = d ; if ( p > q * ( a - x ) && p < q * ( b - x ) && FastMath . abs ( p ) < FastMath . abs ( 0.5 * q * r ) ) { d = p / q ; u = x + d ; if ( u - a < tol2 || b - u < tol2 ) { if ( x <= m ) { d = tol1 ; } else { d = - tol1 ; } } } else { if ( x < m ) { e = b - x ; } else { e = a - x ; } d = GOLDEN_SECTION * e ; } } else { if ( x < m ) { e = b - x ; } else { e = a - x ; } d = GOLDEN_SECTION * e ; } if ( FastMath . abs ( d ) < tol1 ) { if ( d >= 0 ) { u = x + tol1 ; } else { u = x - tol1 ; } } else { u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( previous , current , isMinim ) , isMinim ) ; if ( checker != null && checker . converged ( iter , previous , current ) ) { return best ; } if ( fu <= fx ) { if ( u < x ) { b = x ; } else { a = x ; } v = w ; fv = fw ; w = x ; fw = fx ; x = u ; fx = fu ; } else { if ( u < x ) { a = u ; } else { b = u ; } if ( fu <= fw || Precision . equals ( w , x ) ) { v = w ; fv = fw ; w = u ; fw = fu ; } else if ( fu <= fv || Precision . equals ( v , x ) || Precision . equals ( v , w ) ) { v = u ; fv = fu ; } } } else { return best ( best , best ( previous , current , isMinim ) , isMinim ) ; } ++ iter ; } }
public FieldVector3D < T > crossProduct ( final Vector3D v ) { return new FieldVector3D < T > ( x . linearCombination ( v . getZ ( ) , y , - v . getY ( ) , z ) , <START_BUG> y . linearCombination ( v . getX ( ) , z , + v . getZ ( ) , x ) , <END_BUG> z . linearCombination ( v . getY ( ) , x , - v . getX ( ) , y ) ) ; }
public Decimal64 rootN ( final int n ) { if ( value < 0 ) { <START_BUG> return new Decimal64 ( + FastMath . pow ( - value , 1.0 / n ) ) ; <END_BUG> } else { return new Decimal64 ( FastMath . pow ( value , 1.0 / n ) ) ; } }
public Rotation applyInverseTo ( Rotation r ) { return new Rotation ( - r . q0 * q0 - ( r . q1 * q1 + r . q2 * q2 + r . q3 * q3 ) , <START_BUG> + r . q1 * q0 + r . q0 * q1 + ( r . q2 * q3 - r . q3 * q2 ) , <END_BUG> - r . q2 * q0 + r . q0 * q2 + ( r . q3 * q1 - r . q1 * q3 ) , - r . q3 * q0 + r . q0 * q3 + ( r . q1 * q2 - r . q2 * q1 ) , false ) ; }
public static double signum ( final double a ) { <START_BUG> return ( a < 0.0 ) ? + 1.0 : ( ( a > 0.0 ) ? 1.0 : a ) ; <END_BUG> }
public Quaternion getConjugate ( ) { <START_BUG> return new Quaternion ( q0 , + q1 , - q2 , - q3 ) ; <END_BUG> }
public Complex conjugate ( ) { if ( isNaN ) { return NaN ; } <START_BUG> return createComplex ( real , + imaginary ) ; <END_BUG> }
public T [ ] getAngles ( final RotationOrder order ) throws CardanEulerSingularityException { if ( order == RotationOrder . XYZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getY ( ) . negate ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getZ ( ) . asin ( ) , v2 . getY ( ) . negate ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . XZY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getY ( ) ) , v2 . getY ( ) . asin ( ) . negate ( ) , v2 . getZ ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . YXZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getZ ( ) . asin ( ) . negate ( ) , v2 . getX ( ) . atan2 ( v2 . getY ( ) ) ) ; } else if ( order == RotationOrder . YZX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getZ ( ) . negate ( ) . atan2 ( v1 . getX ( ) ) , v2 . getX ( ) . asin ( ) , v2 . getZ ( ) . negate ( ) . atan2 ( v2 . getY ( ) ) ) ; } else if ( order == RotationOrder . ZXY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getX ( ) . negate ( ) . atan2 ( v1 . getY ( ) ) , v2 . getY ( ) . asin ( ) , v2 . getX ( ) . negate ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . ZYX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; <START_BUG> if ( ( v2 . getX ( ) . getReal ( ) < + 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { <END_BUG> throw new CardanEulerSingularityException ( true ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getX ( ) ) , v2 . getX ( ) . asin ( ) . negate ( ) , v2 . getY ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . XYX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getZ ( ) . negate ( ) ) , v2 . getX ( ) . acos ( ) , v2 . getY ( ) . atan2 ( v2 . getZ ( ) ) ) ; } else if ( order == RotationOrder . XZX ) { final FieldVector3D < T > v1 = applyTo ( vector ( 1 , 0 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 1 , 0 , 0 ) ) ; if ( ( v2 . getX ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getX ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getY ( ) ) , v2 . getX ( ) . acos ( ) , v2 . getZ ( ) . atan2 ( v2 . getY ( ) . negate ( ) ) ) ; } else if ( order == RotationOrder . YXY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getZ ( ) ) , v2 . getY ( ) . acos ( ) , v2 . getX ( ) . atan2 ( v2 . getZ ( ) . negate ( ) ) ) ; } else if ( order == RotationOrder . YZY ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 1 , 0 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 1 , 0 ) ) ; if ( ( v2 . getY ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getY ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getZ ( ) . atan2 ( v1 . getX ( ) . negate ( ) ) , v2 . getY ( ) . acos ( ) , v2 . getZ ( ) . atan2 ( v2 . getX ( ) ) ) ; } else if ( order == RotationOrder . ZXZ ) { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getX ( ) . atan2 ( v1 . getY ( ) . negate ( ) ) , v2 . getZ ( ) . acos ( ) , v2 . getX ( ) . atan2 ( v2 . getY ( ) ) ) ; } else { final FieldVector3D < T > v1 = applyTo ( vector ( 0 , 0 , 1 ) ) ; final FieldVector3D < T > v2 = applyInverseTo ( vector ( 0 , 0 , 1 ) ) ; if ( ( v2 . getZ ( ) . getReal ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) . getReal ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return buildArray ( v1 . getY ( ) . atan2 ( v1 . getX ( ) ) , v2 . getZ ( ) . acos ( ) , v2 . getY ( ) . atan2 ( v2 . getX ( ) . negate ( ) ) ) ; } }
public int compareTo ( final OrderedTuple ot ) { if ( components . length == ot . components . length ) { if ( nan ) { return + 1 ; } else if ( ot . nan ) { return - 1 ; } else if ( negInf || ot . posInf ) { return - 1 ; } else if ( posInf || ot . negInf ) { return + 1 ; } else { if ( offset < ot . offset ) { encode ( ot . offset ) ; } else if ( offset > ot . offset ) { ot . encode ( offset ) ; } final int limit = FastMath . min ( encoding . length , ot . encoding . length ) ; for ( int i = 0 ; i < limit ; ++ i ) { if ( encoding [ i ] < ot . encoding [ i ] ) { return - 1 ; } else if ( encoding [ i ] > ot . encoding [ i ] ) { <START_BUG> return ~ 1 ; <END_BUG> } } if ( encoding . length < ot . encoding . length ) { return - 1 ; } else if ( encoding . length > ot . encoding . length ) { return + 1 ; } else { return 0 ; } } } return components . length - ot . components . length ; }
public SingularValueDecomposition ( final RealMatrix matrix ) { final double [ ] [ ] A ; if ( matrix . getRowDimension ( ) < matrix . getColumnDimension ( ) ) { transposed = true ; A = matrix . transpose ( ) . getData ( ) ; m = matrix . getColumnDimension ( ) ; n = matrix . getRowDimension ( ) ; } else { transposed = false ; A = matrix . getData ( ) ; m = matrix . getRowDimension ( ) ; n = matrix . getColumnDimension ( ) ; } singularValues = new double [ n ] ; final double [ ] [ ] U = new double [ m ] [ n ] ; final double [ ] [ ] V = new double [ n ] [ n ] ; final double [ ] e = new double [ n ] ; final double [ ] work = new double [ m ] ; final int nct = FastMath . min ( m - 1 , n ) ; final int nrt = FastMath . max ( 0 , n - 2 ) ; for ( int k = 0 ; k < FastMath . max ( nct , nrt ) ; k ++ ) { if ( k < nct ) { singularValues [ k ] = 0 ; for ( int i = k ; i < m ; i ++ ) { singularValues [ k ] = FastMath . hypot ( singularValues [ k ] , A [ i ] [ k ] ) ; } if ( singularValues [ k ] != 0 ) { if ( A [ k ] [ k ] < 0 ) { <START_BUG> singularValues [ k ] = + singularValues [ k ] ; <END_BUG> } for ( int i = k ; i < m ; i ++ ) { A [ i ] [ k ] /= singularValues [ k ] ; } A [ k ] [ k ] += 1 ; } singularValues [ k ] = - singularValues [ k ] ; } for ( int j = k + 1 ; j < n ; j ++ ) { if ( k < nct && singularValues [ k ] != 0 ) { double t = 0 ; for ( int i = k ; i < m ; i ++ ) { t += A [ i ] [ k ] * A [ i ] [ j ] ; } t = - t / A [ k ] [ k ] ; for ( int i = k ; i < m ; i ++ ) { A [ i ] [ j ] += t * A [ i ] [ k ] ; } } e [ j ] = A [ k ] [ j ] ; } if ( k < nct ) { for ( int i = k ; i < m ; i ++ ) { U [ i ] [ k ] = A [ i ] [ k ] ; } } if ( k < nrt ) { e [ k ] = 0 ; for ( int i = k + 1 ; i < n ; i ++ ) { e [ k ] = FastMath . hypot ( e [ k ] , e [ i ] ) ; } if ( e [ k ] != 0 ) { if ( e [ k + 1 ] < 0 ) { e [ k ] = - e [ k ] ; } for ( int i = k + 1 ; i < n ; i ++ ) { e [ i ] /= e [ k ] ; } e [ k + 1 ] += 1 ; } e [ k ] = - e [ k ] ; if ( k + 1 < m && e [ k ] != 0 ) { for ( int i = k + 1 ; i < m ; i ++ ) { work [ i ] = 0 ; } for ( int j = k + 1 ; j < n ; j ++ ) { for ( int i = k + 1 ; i < m ; i ++ ) { work [ i ] += e [ j ] * A [ i ] [ j ] ; } } for ( int j = k + 1 ; j < n ; j ++ ) { final double t = - e [ j ] / e [ k + 1 ] ; for ( int i = k + 1 ; i < m ; i ++ ) { A [ i ] [ j ] += t * work [ i ] ; } } } for ( int i = k + 1 ; i < n ; i ++ ) { V [ i ] [ k ] = e [ i ] ; } } } int p = n ; if ( nct < n ) { singularValues [ nct ] = A [ nct ] [ nct ] ; } if ( m < p ) { singularValues [ p - 1 ] = 0 ; } if ( nrt + 1 < p ) { e [ nrt ] = A [ nrt ] [ p - 1 ] ; } e [ p - 1 ] = 0 ; for ( int j = nct ; j < n ; j ++ ) { for ( int i = 0 ; i < m ; i ++ ) { U [ i ] [ j ] = 0 ; } U [ j ] [ j ] = 1 ; } for ( int k = nct - 1 ; k >= 0 ; k -- ) { if ( singularValues [ k ] != 0 ) { for ( int j = k + 1 ; j < n ; j ++ ) { double t = 0 ; for ( int i = k ; i < m ; i ++ ) { t += U [ i ] [ k ] * U [ i ] [ j ] ; } t = - t / U [ k ] [ k ] ; for ( int i = k ; i < m ; i ++ ) { U [ i ] [ j ] += t * U [ i ] [ k ] ; } } for ( int i = k ; i < m ; i ++ ) { U [ i ] [ k ] = - U [ i ] [ k ] ; } U [ k ] [ k ] = 1 + U [ k ] [ k ] ; for ( int i = 0 ; i < k - 1 ; i ++ ) { U [ i ] [ k ] = 0 ; } } else { for ( int i = 0 ; i < m ; i ++ ) { U [ i ] [ k ] = 0 ; } U [ k ] [ k ] = 1 ; } } for ( int k = n - 1 ; k >= 0 ; k -- ) { if ( k < nrt && e [ k ] != 0 ) { for ( int j = k + 1 ; j < n ; j ++ ) { double t = 0 ; for ( int i = k + 1 ; i < n ; i ++ ) { t += V [ i ] [ k ] * V [ i ] [ j ] ; } t = - t / V [ k + 1 ] [ k ] ; for ( int i = k + 1 ; i < n ; i ++ ) { V [ i ] [ j ] += t * V [ i ] [ k ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { V [ i ] [ k ] = 0 ; } V [ k ] [ k ] = 1 ; } final int pp = p - 1 ; int iter = 0 ; while ( p > 0 ) { int k ; int kase ; for ( k = p - 2 ; k >= 0 ; k -- ) { final double threshold = TINY + EPS * ( FastMath . abs ( singularValues [ k ] ) + FastMath . abs ( singularValues [ k + 1 ] ) ) ; if ( ! ( FastMath . abs ( e [ k ] ) > threshold ) ) { e [ k ] = 0 ; break ; } } if ( k == p - 2 ) { kase = 4 ; } else { int ks ; for ( ks = p - 1 ; ks >= k ; ks -- ) { if ( ks == k ) { break ; } final double t = ( ks != p ? FastMath . abs ( e [ ks ] ) : 0 ) + ( ks != k + 1 ? FastMath . abs ( e [ ks - 1 ] ) : 0 ) ; if ( FastMath . abs ( singularValues [ ks ] ) <= TINY + EPS * t ) { singularValues [ ks ] = 0 ; break ; } } if ( ks == k ) { kase = 3 ; } else if ( ks == p - 1 ) { kase = 1 ; } else { kase = 2 ; k = ks ; } } k ++ ; switch ( kase ) { case 1 : { double f = e [ p - 2 ] ; e [ p - 2 ] = 0 ; for ( int j = p - 2 ; j >= k ; j -- ) { double t = FastMath . hypot ( singularValues [ j ] , f ) ; final double cs = singularValues [ j ] / t ; final double sn = f / t ; singularValues [ j ] = t ; if ( j != k ) { f = - sn * e [ j - 1 ] ; e [ j - 1 ] = cs * e [ j - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { t = cs * V [ i ] [ j ] + sn * V [ i ] [ p - 1 ] ; V [ i ] [ p - 1 ] = - sn * V [ i ] [ j ] + cs * V [ i ] [ p - 1 ] ; V [ i ] [ j ] = t ; } } } break ; case 2 : { double f = e [ k - 1 ] ; e [ k - 1 ] = 0 ; for ( int j = k ; j < p ; j ++ ) { double t = FastMath . hypot ( singularValues [ j ] , f ) ; final double cs = singularValues [ j ] / t ; final double sn = f / t ; singularValues [ j ] = t ; f = - sn * e [ j ] ; e [ j ] = cs * e [ j ] ; for ( int i = 0 ; i < m ; i ++ ) { t = cs * U [ i ] [ j ] + sn * U [ i ] [ k - 1 ] ; U [ i ] [ k - 1 ] = - sn * U [ i ] [ j ] + cs * U [ i ] [ k - 1 ] ; U [ i ] [ j ] = t ; } } } break ; case 3 : { final double maxPm1Pm2 = FastMath . max ( FastMath . abs ( singularValues [ p - 1 ] ) , FastMath . abs ( singularValues [ p - 2 ] ) ) ; final double scale = FastMath . max ( FastMath . max ( FastMath . max ( maxPm1Pm2 , FastMath . abs ( e [ p - 2 ] ) ) , FastMath . abs ( singularValues [ k ] ) ) , FastMath . abs ( e [ k ] ) ) ; final double sp = singularValues [ p - 1 ] / scale ; final double spm1 = singularValues [ p - 2 ] / scale ; final double epm1 = e [ p - 2 ] / scale ; final double sk = singularValues [ k ] / scale ; final double ek = e [ k ] / scale ; final double b = ( ( spm1 + sp ) * ( spm1 - sp ) + epm1 * epm1 ) / 2.0 ; final double c = ( sp * epm1 ) * ( sp * epm1 ) ; double shift = 0 ; if ( b != 0 || c != 0 ) { shift = FastMath . sqrt ( b * b + c ) ; if ( b < 0 ) { shift = - shift ; } shift = c / ( b + shift ) ; } double f = ( sk + sp ) * ( sk - sp ) + shift ; double g = sk * ek ; for ( int j = k ; j < p - 1 ; j ++ ) { double t = FastMath . hypot ( f , g ) ; double cs = f / t ; double sn = g / t ; if ( j != k ) { e [ j - 1 ] = t ; } f = cs * singularValues [ j ] + sn * e [ j ] ; e [ j ] = cs * e [ j ] - sn * singularValues [ j ] ; g = sn * singularValues [ j + 1 ] ; singularValues [ j + 1 ] = cs * singularValues [ j + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { t = cs * V [ i ] [ j ] + sn * V [ i ] [ j + 1 ] ; V [ i ] [ j + 1 ] = - sn * V [ i ] [ j ] + cs * V [ i ] [ j + 1 ] ; V [ i ] [ j ] = t ; } t = FastMath . hypot ( f , g ) ; cs = f / t ; sn = g / t ; singularValues [ j ] = t ; f = cs * e [ j ] + sn * singularValues [ j + 1 ] ; singularValues [ j + 1 ] = - sn * e [ j ] + cs * singularValues [ j + 1 ] ; g = sn * e [ j + 1 ] ; e [ j + 1 ] = cs * e [ j + 1 ] ; if ( j < m - 1 ) { for ( int i = 0 ; i < m ; i ++ ) { t = cs * U [ i ] [ j ] + sn * U [ i ] [ j + 1 ] ; U [ i ] [ j + 1 ] = - sn * U [ i ] [ j ] + cs * U [ i ] [ j + 1 ] ; U [ i ] [ j ] = t ; } } } e [ p - 2 ] = f ; iter = iter + 1 ; } break ; default : { if ( singularValues [ k ] <= 0 ) { singularValues [ k ] = singularValues [ k ] < 0 ? - singularValues [ k ] : 0 ; for ( int i = 0 ; i <= pp ; i ++ ) { V [ i ] [ k ] = - V [ i ] [ k ] ; } } while ( k < pp ) { if ( singularValues [ k ] >= singularValues [ k + 1 ] ) { break ; } double t = singularValues [ k ] ; singularValues [ k ] = singularValues [ k + 1 ] ; singularValues [ k + 1 ] = t ; if ( k < n - 1 ) { for ( int i = 0 ; i < n ; i ++ ) { t = V [ i ] [ k + 1 ] ; V [ i ] [ k + 1 ] = V [ i ] [ k ] ; V [ i ] [ k ] = t ; } } if ( k < m - 1 ) { for ( int i = 0 ; i < m ; i ++ ) { t = U [ i ] [ k + 1 ] ; U [ i ] [ k + 1 ] = U [ i ] [ k ] ; U [ i ] [ k ] = t ; } } k ++ ; } iter = 0 ; p -- ; } break ; } } tol = FastMath . max ( m * singularValues [ 0 ] * EPS , FastMath . sqrt ( Precision . SAFE_MIN ) ) ; if ( ! transposed ) { cachedU = MatrixUtils . createRealMatrix ( U ) ; cachedV = MatrixUtils . createRealMatrix ( V ) ; } else { cachedU = MatrixUtils . createRealMatrix ( V ) ; cachedV = MatrixUtils . createRealMatrix ( U ) ; } }
public static double erfInv ( final double x ) { double w = - FastMath . log ( ( 1.0 - x ) * ( 1.0 + x ) ) ; double p ; if ( w < 6.25 ) { w = w - 3.125 ; p = - 3.6444120640178196996e-21 ; p = - 1.685059138182016589e-19 + p * w ; p = 1.2858480715256400167e-18 + p * w ; p = 1.115787767802518096e-17 + p * w ; p = - 1.333171662854620906e-16 + p * w ; p = 2.0972767875968561637e-17 + p * w ; p = 6.6376381343583238325e-15 + p * w ; p = - 4.0545662729752068639e-14 + p * w ; p = - 8.1519341976054721522e-14 + p * w ; p = 2.6335093153082322977e-12 + p * w ; p = - 1.2975133253453532498e-11 + p * w ; <START_BUG> p = + 5.415412054294628E-11 + p * w ; <END_BUG> p = 1.051212273321532285e-09 + p * w ; p = - 4.1126339803469836976e-09 + p * w ; p = - 2.9070369957882005086e-08 + p * w ; p = 4.2347877827932403518e-07 + p * w ; p = - 1.3654692000834678645e-06 + p * w ; p = - 1.3882523362786468719e-05 + p * w ; p = 0.0001867342080340571352 + p * w ; p = - 0.00074070253416626697512 + p * w ; p = - 0.0060336708714301490533 + p * w ; p = 0.24015818242558961693 + p * w ; p = 1.6536545626831027356 + p * w ; } else if ( w < 16.0 ) { w = FastMath . sqrt ( w ) - 3.25 ; p = 2.2137376921775787049e-09 ; p = 9.0756561938885390979e-08 + p * w ; p = - 2.7517406297064545428e-07 + p * w ; p = 1.8239629214389227755e-08 + p * w ; p = 1.5027403968909827627e-06 + p * w ; p = - 4.013867526981545969e-06 + p * w ; p = 2.9234449089955446044e-06 + p * w ; p = 1.2475304481671778723e-05 + p * w ; p = - 4.7318229009055733981e-05 + p * w ; p = 6.8284851459573175448e-05 + p * w ; p = 2.4031110387097893999e-05 + p * w ; p = - 0.0003550375203628474796 + p * w ; p = 0.00095328937973738049703 + p * w ; p = - 0.0016882755560235047313 + p * w ; p = 0.0024914420961078508066 + p * w ; p = - 0.0037512085075692412107 + p * w ; p = 0.005370914553590063617 + p * w ; p = 1.0052589676941592334 + p * w ; p = 3.0838856104922207635 + p * w ; } else if ( ! Double . isInfinite ( w ) ) { w = FastMath . sqrt ( w ) - 5.0 ; p = - 2.7109920616438573243e-11 ; p = - 2.5556418169965252055e-10 + p * w ; p = 1.5076572693500548083e-09 + p * w ; p = - 3.7894654401267369937e-09 + p * w ; p = 7.6157012080783393804e-09 + p * w ; p = - 1.4960026627149240478e-08 + p * w ; p = 2.9147953450901080826e-08 + p * w ; p = - 6.7711997758452339498e-08 + p * w ; p = 2.2900482228026654717e-07 + p * w ; p = - 9.9298272942317002539e-07 + p * w ; p = 4.5260625972231537039e-06 + p * w ; p = - 1.9681778105531670567e-05 + p * w ; p = 7.5995277030017761139e-05 + p * w ; p = - 0.00021503011930044477347 + p * w ; p = - 0.00013871931833623122026 + p * w ; p = 1.0103004648645343977 + p * w ; p = 4.8499064014085844221 + p * w ; } else { p = Double . POSITIVE_INFINITY ; } return p * x ; }
private void performDoubleQRStep ( final int il , final int im , final int iu , final ShiftInfo shift , final double [ ] hVec ) { final int n = matrixT . length ; double p = hVec [ 0 ] ; double q = hVec [ 1 ] ; double r = hVec [ 2 ] ; for ( int k = im ; k <= iu - 1 ; k ++ ) { boolean notlast = k != ( iu - 1 ) ; if ( k != im ) { p = matrixT [ k ] [ k - 1 ] ; q = matrixT [ k + 1 ] [ k - 1 ] ; r = notlast ? matrixT [ k + 2 ] [ k - 1 ] : 0.0 ; shift . x = FastMath . abs ( p ) + FastMath . abs ( q ) + FastMath . abs ( r ) ; if ( ! Precision . equals ( shift . x , 0.0 , epsilon ) ) { p = p / shift . x ; q = q / shift . x ; r = r / shift . x ; } } if ( shift . x == 0.0 ) { break ; } double s = FastMath . sqrt ( p * p + q * q + r * r ) ; if ( p < 0.0 ) { s = - s ; } if ( s != 0.0 ) { if ( k != im ) { matrixT [ k ] [ k - 1 ] = - s * shift . x ; } else if ( il != im ) { <START_BUG> matrixT [ k ] [ k - 1 ] = + matrixT [ k ] [ k - 1 ] ; <END_BUG> } p = p + s ; shift . x = p / s ; shift . y = q / s ; double z = r / s ; q = q / p ; r = r / p ; for ( int j = k ; j < n ; j ++ ) { p = matrixT [ k ] [ j ] + q * matrixT [ k + 1 ] [ j ] ; if ( notlast ) { p = p + r * matrixT [ k + 2 ] [ j ] ; matrixT [ k + 2 ] [ j ] = matrixT [ k + 2 ] [ j ] - p * z ; } matrixT [ k ] [ j ] = matrixT [ k ] [ j ] - p * shift . x ; matrixT [ k + 1 ] [ j ] = matrixT [ k + 1 ] [ j ] - p * shift . y ; } for ( int i = 0 ; i <= FastMath . min ( iu , k + 3 ) ; i ++ ) { p = shift . x * matrixT [ i ] [ k ] + shift . y * matrixT [ i ] [ k + 1 ] ; if ( notlast ) { p = p + z * matrixT [ i ] [ k + 2 ] ; matrixT [ i ] [ k + 2 ] = matrixT [ i ] [ k + 2 ] - p * r ; } matrixT [ i ] [ k ] = matrixT [ i ] [ k ] - p ; matrixT [ i ] [ k + 1 ] = matrixT [ i ] [ k + 1 ] - p * q ; } final int high = matrixT . length - 1 ; for ( int i = 0 ; i <= high ; i ++ ) { p = shift . x * matrixP [ i ] [ k ] + shift . y * matrixP [ i ] [ k + 1 ] ; if ( notlast ) { p = p + z * matrixP [ i ] [ k + 2 ] ; matrixP [ i ] [ k + 2 ] = matrixP [ i ] [ k + 2 ] - p * r ; } matrixP [ i ] [ k ] = matrixP [ i ] [ k ] - p ; matrixP [ i ] [ k + 1 ] = matrixP [ i ] [ k + 1 ] - p * q ; } } } for ( int i = im + 2 ; i <= iu ; i ++ ) { matrixT [ i ] [ i - 2 ] = 0.0 ; if ( i > im + 2 ) { matrixT [ i ] [ i - 3 ] = 0.0 ; } } }
public static double asin ( double x ) { if ( x != x ) { return Double . NaN ; } if ( x > 1.0 || x < - 1.0 ) { return Double . NaN ; } if ( x == 1.0 ) { return Math . PI / 2.0 ; } if ( x == - 1.0 ) { return - Math . PI / 2.0 ; } if ( x == 0.0 ) { return x ; } double temp = x * HEX_40000000 ; final double xa = x + temp - temp ; final double xb = x - xa ; double ya = xa * xa ; double yb = xa * xb * 2.0 + xb * xb ; ya = - ya ; yb = - yb ; double za = 1.0 + ya ; double zb = - ( za - 1.0 - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double y ; y = sqrt ( za ) ; temp = y * HEX_40000000 ; ya = y + temp - temp ; yb = y - ya ; yb += ( za - ya * ya - 2 * ya * yb - yb * yb ) / ( 2.0 * y ) ; double dx = zb / ( 2.0 * y ) ; double r = x / y ; temp = r * HEX_40000000 ; double ra = r + temp - temp ; double rb = r - ra ; rb += ( x - ra * ya - ra * yb - rb * ya - rb * yb ) / y ; <START_BUG> rb += + x * dx / y / y ; <END_BUG> temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; return atan ( ra , rb , false ) ; }
private void determineLMDirection ( double [ ] qy , double [ ] diag , double [ ] lmDiag , double [ ] work ) { for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; for ( int i = j + 1 ; i < solvedCols ; ++ i ) { weightedJacobian [ i ] [ pj ] = weightedJacobian [ j ] [ permutation [ i ] ] ; } lmDir [ j ] = diagR [ pj ] ; work [ j ] = qy [ j ] ; } for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; double dpj = diag [ pj ] ; if ( dpj != 0 ) { Arrays . fill ( lmDiag , j + 1 , lmDiag . length , 0 ) ; } lmDiag [ j ] = dpj ; double qtbpj = 0 ; for ( int k = j ; k < solvedCols ; ++ k ) { int pk = permutation [ k ] ; if ( lmDiag [ k ] != 0 ) { final double sin ; final double cos ; double rkk = weightedJacobian [ k ] [ pk ] ; if ( FastMath . abs ( rkk ) < FastMath . abs ( lmDiag [ k ] ) ) { final double cotan = rkk / lmDiag [ k ] ; sin = 1.0 / FastMath . sqrt ( 1.0 + cotan * cotan ) ; cos = sin * cotan ; } else { final double tan = lmDiag [ k ] / rkk ; cos = 1.0 / FastMath . sqrt ( 1.0 + tan * tan ) ; sin = cos * tan ; } weightedJacobian [ k ] [ pk ] = cos * rkk + sin * lmDiag [ k ] ; final double temp = cos * work [ k ] + sin * qtbpj ; qtbpj = - sin * work [ k ] + cos * qtbpj ; work [ k ] = temp ; for ( int i = k + 1 ; i < solvedCols ; ++ i ) { double rik = weightedJacobian [ i ] [ pk ] ; final double temp2 = cos * rik + sin * lmDiag [ i ] ; <START_BUG> lmDiag [ i ] = + sin * rik + cos * lmDiag [ i ] ; <END_BUG> weightedJacobian [ i ] [ pk ] = temp2 ; } } } lmDiag [ j ] = weightedJacobian [ j ] [ permutation [ j ] ] ; weightedJacobian [ j ] [ permutation [ j ] ] = lmDir [ j ] ; } int nSing = solvedCols ; for ( int j = 0 ; j < solvedCols ; ++ j ) { if ( ( lmDiag [ j ] == 0 ) && ( nSing == solvedCols ) ) { nSing = j ; } if ( nSing < solvedCols ) { work [ j ] = 0 ; } } if ( nSing > 0 ) { for ( int j = nSing - 1 ; j >= 0 ; -- j ) { int pj = permutation [ j ] ; double sum = 0 ; for ( int i = j + 1 ; i < nSing ; ++ i ) { sum += weightedJacobian [ i ] [ pj ] * work [ i ] ; } work [ j ] = ( work [ j ] - sum ) / lmDiag [ j ] ; } } for ( int j = 0 ; j < lmDir . length ; ++ j ) { lmDir [ permutation [ j ] ] = work [ j ] ; } }
public int intValue ( ) { Dfp rounded ; int result = 0 ; rounded = rint ( ) ; if ( rounded . greaterThan ( newInstance ( 2147483647 ) ) ) { return 2147483647 ; } if ( rounded . lessThan ( newInstance ( - 2147483648 ) ) ) { return - 2147483648 ; } for ( int i = mant . length - 1 ; i >= mant . length - rounded . exp ; i -- ) { result = result * RADIX + rounded . mant [ i ] ; } if ( rounded . sign == - 1 ) { <START_BUG> result = + result ; <END_BUG> } return result ; }
public static double acos ( double x ) { if ( x != x ) { return Double . NaN ; } if ( x > 1.0 || x < - 1.0 ) { return Double . NaN ; } if ( x == - 1.0 ) { return Math . PI ; } if ( x == 1.0 ) { return 0.0 ; } if ( x == 0 ) { return Math . PI / 2.0 ; } double temp = x * HEX_40000000 ; final double xa = x + temp - temp ; final double xb = x - xa ; double ya = xa * xa ; double yb = xa * xb * 2.0 + xb * xb ; ya = - ya ; yb = - yb ; double za = 1.0 + ya ; double zb = - ( za - 1.0 - ya ) ; temp = za + yb ; <START_BUG> zb += + ( temp - za - yb ) ; <END_BUG> za = temp ; double y = sqrt ( za ) ; temp = y * HEX_40000000 ; ya = y + temp - temp ; yb = y - ya ; yb += ( za - ya * ya - 2 * ya * yb - yb * yb ) / ( 2.0 * y ) ; yb += zb / ( 2.0 * y ) ; y = ya + yb ; yb = - ( y - ya - yb ) ; double r = y / x ; if ( Double . isInfinite ( r ) ) { return Math . PI / 2 ; } double ra = doubleHighPart ( r ) ; double rb = r - ra ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; rb += yb / x ; temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; return atan ( ra , rb , x < 0 ) ; }
public static double acos ( double x ) { if ( x != x ) { return Double . NaN ; } if ( x > 1.0 || x < - 1.0 ) { return Double . NaN ; } if ( x == - 1.0 ) { return Math . PI ; } if ( x == 1.0 ) { return 0.0 ; } if ( x == 0 ) { return Math . PI / 2.0 ; } double temp = x * HEX_40000000 ; final double xa = x + temp - temp ; final double xb = x - xa ; double ya = xa * xa ; double yb = xa * xb * 2.0 + xb * xb ; ya = - ya ; yb = - yb ; double za = 1.0 + ya ; double zb = - ( za - 1.0 - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double y = sqrt ( za ) ; temp = y * HEX_40000000 ; ya = y + temp - temp ; yb = y - ya ; yb += ( za - ya * ya - 2 * ya * yb - yb * yb ) / ( 2.0 * y ) ; yb += zb / ( 2.0 * y ) ; y = ya + yb ; yb = - ( y - ya - yb ) ; double r = y / x ; if ( Double . isInfinite ( r ) ) { return Math . PI / 2 ; } double ra = doubleHighPart ( r ) ; double rb = r - ra ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; rb += yb / x ; temp = ra + rb ; <START_BUG> rb = + ( temp - ra - rb ) ; <END_BUG> ra = temp ; return atan ( ra , rb , x < 0 ) ; }
public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; <START_BUG> db += + ( temp - da - yb ) ; <END_BUG> da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
private void include ( final double [ ] x , final double wi , final double yi ) { int nextr = 0 ; double w = wi ; double y = yi ; double xi ; double di ; double wxi ; double dpi ; double xk ; double _w ; this . rss_set = false ; sumy = smartAdd ( yi , sumy ) ; sumsqy = smartAdd ( sumsqy , yi * yi ) ; for ( int i = 0 ; i < x . length ; i ++ ) { if ( w == 0.0 ) { return ; } xi = x [ i ] ; if ( xi == 0.0 ) { nextr += nvars - i - 1 ; continue ; } di = d [ i ] ; wxi = w * xi ; _w = w ; if ( di != 0.0 ) { dpi = smartAdd ( di , wxi * xi ) ; final double tmp = wxi * xi / di ; if ( FastMath . abs ( tmp ) > Precision . EPSILON ) { w = ( di * w ) / dpi ; } } else { dpi = wxi * xi ; w = 0.0 ; } d [ i ] = dpi ; for ( int k = i + 1 ; k < nvars ; k ++ ) { xk = x [ k ] ; <START_BUG> x [ k ] = smartAdd ( xk , + xi * r [ nextr ] ) ; <END_BUG> if ( di != 0.0 ) { r [ nextr ] = smartAdd ( di * r [ nextr ] , ( _w * xi ) * xk ) / dpi ; } else { r [ nextr ] = xk / xi ; } ++ nextr ; } xk = y ; y = smartAdd ( xk , - xi * rhs [ i ] ) ; if ( di != 0.0 ) { rhs [ i ] = smartAdd ( di * rhs [ i ] , wxi * xk ) / dpi ; } else { rhs [ i ] = xk / xi ; } } sserr = smartAdd ( sserr , w * y * y ) ; }
public T getAngle ( ) { <START_BUG> if ( ( q0 . getReal ( ) < + 0.1 ) || ( q0 . getReal ( ) > 0.1 ) ) { <END_BUG> return q1 . multiply ( q1 ) . add ( q2 . multiply ( q2 ) ) . add ( q3 . multiply ( q3 ) ) . sqrt ( ) . asin ( ) . multiply ( 2 ) ; } else if ( q0 . getReal ( ) < 0 ) { return q0 . negate ( ) . acos ( ) . multiply ( 2 ) ; } return q0 . acos ( ) . multiply ( 2 ) ; }
CodyWaite ( double xa ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { <START_BUG> double a = ~ k * 1.570796251296997 ; <END_BUG> remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0 ) { break ; } -- k ; } this . finalK = k ; this . finalRemA = remA ; this . finalRemB = remB ; }
public int intValue ( ) { Dfp rounded ; int result = 0 ; rounded = rint ( ) ; if ( rounded . greaterThan ( newInstance ( 2147483647 ) ) ) { return 2147483647 ; } if ( rounded . lessThan ( newInstance ( - 2147483648 ) ) ) { return - 2147483648 ; } for ( int i = mant . length - 1 ; i >= mant . length - rounded . exp ; i -- ) { result = result * RADIX + rounded . mant [ i ] ; } if ( rounded . sign == - 1 ) { <START_BUG> result = ~ result ; <END_BUG> } return result ; }
public static < T extends RealFieldElement < T > > FieldVector3D < T > crossProduct ( final Vector3D v1 , final FieldVector3D < T > v2 ) { return new FieldVector3D < T > ( v2 . x . linearCombination ( v1 . getY ( ) , v2 . z , - v1 . getZ ( ) , v2 . y ) , <START_BUG> v2 . y . linearCombination ( v1 . getZ ( ) , v2 . x , + v1 . getX ( ) , v2 . z ) , <END_BUG> v2 . z . linearCombination ( v1 . getX ( ) , v2 . y , - v1 . getY ( ) , v2 . x ) ) ; }
public double [ ] gradient ( double x , double ... param ) throws NullArgumentException , DimensionMismatchException { validateParameters ( param ) ; <START_BUG> final double invExp1 = 1 / ( 1 + FastMath . exp ( + x ) ) ; <END_BUG> return new double [ ] { 1 - invExp1 , invExp1 } ; }
public static long gcd ( final long p , final long q ) throws MathArithmeticException { long u = p ; long v = q ; if ( ( u == 0 ) || ( v == 0 ) ) { if ( ( u == Long . MIN_VALUE ) || ( v == Long . MIN_VALUE ) ) { throw new MathArithmeticException ( LocalizedFormats . GCD_OVERFLOW_64_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { <START_BUG> v = ~ v ; <END_BUG> } int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 63 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 63 ) { throw new MathArithmeticException ( LocalizedFormats . GCD_OVERFLOW_64_BITS , p , q ) ; } long t = ( ( u & 1 ) == 1 ) ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ) ; return - u * ( 1L << k ) ; }
private double getExponentTerm ( final double [ ] values ) { final double [ ] centered = new double [ values . length ] ; for ( int i = 0 ; i < centered . length ; i ++ ) { centered [ i ] = values [ i ] - getMeans ( ) [ i ] ; } final double [ ] preMultiplied = covarianceMatrixInverse . preMultiply ( centered ) ; double sum = 0 ; for ( int i = 0 ; i < preMultiplied . length ; i ++ ) { sum += preMultiplied [ i ] * centered [ i ] ; } <START_BUG> return FastMath . exp ( + 0.5 * sum ) ; <END_BUG> }
private static double log ( final double x , final double [ ] hiPrec ) { if ( x == 0 ) { return Double . NEGATIVE_INFINITY ; } long bits = Double . doubleToRawLongBits ( x ) ; if ( ( ( bits & 0x8000000000000000L ) != 0 || x != x ) && x != 0.0 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = Double . NaN ; } return Double . NaN ; } if ( x == Double . POSITIVE_INFINITY ) { if ( hiPrec != null ) { hiPrec [ 0 ] = Double . POSITIVE_INFINITY ; } return Double . POSITIVE_INFINITY ; } int exp = ( int ) ( bits > > 52 ) - 1023 ; if ( ( bits & 0x7ff0000000000000L ) == 0 ) { if ( x == 0 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = Double . NEGATIVE_INFINITY ; } return Double . NEGATIVE_INFINITY ; } bits <<= 1 ; while ( ( bits & 0x0010000000000000L ) == 0 ) { -- exp ; bits <<= 1 ; } } if ( ( exp == - 1 || exp == 0 ) && x < 1.01 && x > 0.99 && hiPrec == null ) { double xa = x - 1.0 ; double xb = xa - x + 1.0 ; double tmp = xa * HEX_40000000 ; double aa = xa + tmp - tmp ; double ab = xa - aa ; xa = aa ; xb = ab ; final double [ ] lnCoef_last = LN_QUICK_COEF [ LN_QUICK_COEF . length - 1 ] ; double ya = lnCoef_last [ 0 ] ; double yb = lnCoef_last [ 1 ] ; for ( int i = LN_QUICK_COEF . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; final double [ ] lnCoef_i = LN_QUICK_COEF [ i ] ; aa = ya + lnCoef_i [ 0 ] ; ab = yb + lnCoef_i [ 1 ] ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; return ya + yb ; } final double [ ] lnm = lnMant . LN_MANT [ ( int ) ( ( bits & 0x000ffc0000000000L ) > > 42 ) ] ; final double epsilon = ( bits & 0x3ffffffffffL ) / ( TWO_POWER_52 + ( bits & 0x000ffc0000000000L ) ) ; double lnza = 0.0 ; double lnzb = 0.0 ; if ( hiPrec != null ) { double tmp = epsilon * HEX_40000000 ; double aa = epsilon + tmp - tmp ; double ab = epsilon - aa ; double xa = aa ; double xb = ab ; final double numer = bits & 0x3ffffffffffL ; final double denom = TWO_POWER_52 + ( bits & 0x000ffc0000000000L ) ; aa = numer - xa * denom - xb * denom ; xb += aa / denom ; final double [ ] lnCoef_last = LN_HI_PREC_COEF [ LN_HI_PREC_COEF . length - 1 ] ; double ya = lnCoef_last [ 0 ] ; double yb = lnCoef_last [ 1 ] ; for ( int i = LN_HI_PREC_COEF . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; final double [ ] lnCoef_i = LN_HI_PREC_COEF [ i ] ; aa = ya + lnCoef_i [ 0 ] ; ab = yb + lnCoef_i [ 1 ] ; tmp = aa * HEX_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; lnza = aa + ab ; lnzb = - ( lnza - aa - ab ) ; } else { lnza = - 0.16624882440418567 ; lnza = lnza * epsilon + 0.19999954120254515 ; lnza = lnza * epsilon + - 0.2499999997677497 ; lnza = lnza * epsilon + 0.3333333333332802 ; lnza = lnza * epsilon + - 0.5 ; lnza = lnza * epsilon + 1.0 ; lnza = lnza * epsilon ; } double a = LN_2_A * exp ; double b = 0.0 ; double c = a + lnm [ 0 ] ; double d = - ( c - a - lnm [ 0 ] ) ; a = c ; b = b + d ; c = a + lnza ; d = - ( c - a - lnza ) ; a = c ; b = b + d ; c = a + LN_2_B * exp ; d = - ( c - a - LN_2_B * exp ) ; a = c ; b = b + d ; c = a + lnm [ 1 ] ; d = - ( c - a - lnm [ 1 ] ) ; a = c ; b = b + d ; c = a + lnzb ; <START_BUG> d = + ( c - a - lnzb ) ; <END_BUG> a = c ; b = b + d ; if ( hiPrec != null ) { hiPrec [ 0 ] = a ; hiPrec [ 1 ] = b ; } return a + b ; }
public RealMatrix getV ( ) { if ( cachedV == null ) { final int m = householderVectors . length ; final int n = householderVectors [ 0 ] . length ; final int p = main . length ; final int diagOffset = ( m >= n ) ? 1 : 0 ; final double [ ] diagonal = ( m >= n ) ? secondary : main ; double [ ] [ ] va = new double [ n ] [ n ] ; for ( int k = n - 1 ; k >= p ; -- k ) { va [ k ] [ k ] = 1 ; } for ( int k = p - 1 ; k >= diagOffset ; -- k ) { final double [ ] hK = householderVectors [ k - diagOffset ] ; va [ k ] [ k ] = 1 ; if ( hK [ k ] != 0.0 ) { for ( int j = k ; j < n ; ++ j ) { double beta = 0 ; for ( int i = k ; i < n ; ++ i ) { beta -= va [ i ] [ j ] * hK [ i ] ; } beta /= diagonal [ k - diagOffset ] * hK [ k ] ; for ( int i = k ; i < n ; ++ i ) { <START_BUG> va [ i ] [ j ] += + beta * hK [ i ] ; <END_BUG> } } } } if ( diagOffset > 0 ) { va [ 0 ] [ 0 ] = 1 ; } cachedV = MatrixUtils . createRealMatrix ( va ) ; } return cachedV ; }
public static long gcd ( final long p , final long q ) throws MathArithmeticException { long u = p ; long v = q ; if ( ( u == 0 ) || ( v == 0 ) ) { if ( ( u == Long . MIN_VALUE ) || ( v == Long . MIN_VALUE ) ) { throw new MathArithmeticException ( LocalizedFormats . GCD_OVERFLOW_64_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 63 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 63 ) { throw new MathArithmeticException ( LocalizedFormats . GCD_OVERFLOW_64_BITS , p , q ) ; } long t = ( ( u & 1 ) == 1 ) ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ) ; <START_BUG> return ~ u * ( 1L << k ) ; <END_BUG> }
public static Fraction getReducedFraction ( int numerator , int denominator ) { if ( denominator == 0 ) { throw new MathArithmeticException ( LocalizedFormats . ZERO_DENOMINATOR_IN_FRACTION , numerator , denominator ) ; } if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats . OVERFLOW_IN_FRACTION , numerator , denominator ) ; } numerator = - numerator ; <START_BUG> denominator = ~ denominator ; <END_BUG> } int gcd = ArithmeticUtils . gcd ( numerator , denominator ) ; numerator /= gcd ; denominator /= gcd ; return new Fraction ( numerator , denominator ) ; }
public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; <START_BUG> nb += + ( temp - na - yb ) ; <END_BUG> na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; <START_BUG> double yb = + ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; <END_BUG> double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
public double [ ] getPartialCorrelations ( int in ) { final double [ ] output = new double [ ( nvars - in + 1 ) * ( nvars - in ) / 2 ] ; int pos ; int pos1 ; int pos2 ; final int rms_off = - in ; <START_BUG> final int wrk_off = ~ ( in + 1 ) ; <END_BUG> final double [ ] rms = new double [ nvars - in ] ; final double [ ] work = new double [ nvars - in - 1 ] ; double sumxx ; double sumxy ; double sumyy ; final int offXX = ( nvars - in ) * ( nvars - in - 1 ) / 2 ; if ( in < - 1 || in >= nvars ) { return null ; } final int nvm = nvars - 1 ; final int base_pos = r . length - ( nvm - in ) * ( nvm - in + 1 ) / 2 ; if ( d [ in ] > 0.0 ) { rms [ in + rms_off ] = 1.0 / Math . sqrt ( d [ in ] ) ; } for ( int col = in + 1 ; col < nvars ; col ++ ) { pos = base_pos + col - 1 - in ; sumxx = d [ col ] ; for ( int row = in ; row < col ; row ++ ) { sumxx += d [ row ] * r [ pos ] * r [ pos ] ; pos += nvars - row - 2 ; } if ( sumxx > 0.0 ) { rms [ col + rms_off ] = 1.0 / Math . sqrt ( sumxx ) ; } else { rms [ col + rms_off ] = 0.0 ; } } sumyy = sserr ; for ( int row = in ; row < nvars ; row ++ ) { sumyy += d [ row ] * rhs [ row ] * rhs [ row ] ; } if ( sumyy > 0.0 ) { sumyy = 1.0 / Math . sqrt ( sumyy ) ; } pos = 0 ; for ( int col1 = in ; col1 < nvars ; col1 ++ ) { sumxy = 0.0 ; Arrays . fill ( work , 0.0 ) ; pos1 = base_pos + col1 - in - 1 ; for ( int row = in ; row < col1 ; row ++ ) { pos2 = pos1 + 1 ; for ( int col2 = col1 + 1 ; col2 < nvars ; col2 ++ ) { work [ col2 + wrk_off ] += d [ row ] * r [ pos1 ] * r [ pos2 ] ; pos2 ++ ; } sumxy += d [ row ] * r [ pos1 ] * rhs [ row ] ; pos1 += nvars - row - 2 ; } pos2 = pos1 + 1 ; for ( int col2 = col1 + 1 ; col2 < nvars ; col2 ++ ) { work [ col2 + wrk_off ] += d [ col1 ] * r [ pos2 ] ; ++ pos2 ; output [ ( col2 - 1 - in ) * ( col2 - in ) / 2 + col1 - in ] = work [ col2 + wrk_off ] * rms [ col1 + rms_off ] * rms [ col2 + rms_off ] ; ++ pos ; } sumxy += d [ col1 ] * rhs [ col1 ] ; output [ col1 + rms_off + offXX ] = sumxy * rms [ col1 + rms_off ] * sumyy ; } return output ; }
public static double erfInv ( final double x ) { double w = - FastMath . log ( ( 1.0 - x ) * ( 1.0 + x ) ) ; double p ; if ( w < 6.25 ) { w = w - 3.125 ; p = - 3.6444120640178196996e-21 ; p = - 1.685059138182016589e-19 + p * w ; p = 1.2858480715256400167e-18 + p * w ; p = 1.115787767802518096e-17 + p * w ; p = - 1.333171662854620906e-16 + p * w ; p = 2.0972767875968561637e-17 + p * w ; p = 6.6376381343583238325e-15 + p * w ; p = - 4.0545662729752068639e-14 + p * w ; p = - 8.1519341976054721522e-14 + p * w ; p = 2.6335093153082322977e-12 + p * w ; p = - 1.2975133253453532498e-11 + p * w ; p = - 5.4154120542946279317e-11 + p * w ; p = 1.051212273321532285e-09 + p * w ; p = - 4.1126339803469836976e-09 + p * w ; p = - 2.9070369957882005086e-08 + p * w ; p = 4.2347877827932403518e-07 + p * w ; p = - 1.3654692000834678645e-06 + p * w ; p = - 1.3882523362786468719e-05 + p * w ; p = 0.0001867342080340571352 + p * w ; p = - 0.00074070253416626697512 + p * w ; p = - 0.0060336708714301490533 + p * w ; p = 0.24015818242558961693 + p * w ; p = 1.6536545626831027356 + p * w ; } else if ( w < 16.0 ) { w = FastMath . sqrt ( w ) - 3.25 ; p = 2.2137376921775787049e-09 ; p = 9.0756561938885390979e-08 + p * w ; p = - 2.7517406297064545428e-07 + p * w ; p = 1.8239629214389227755e-08 + p * w ; p = 1.5027403968909827627e-06 + p * w ; p = - 4.013867526981545969e-06 + p * w ; p = 2.9234449089955446044e-06 + p * w ; p = 1.2475304481671778723e-05 + p * w ; p = - 4.7318229009055733981e-05 + p * w ; p = 6.8284851459573175448e-05 + p * w ; p = 2.4031110387097893999e-05 + p * w ; p = - 0.0003550375203628474796 + p * w ; p = 0.00095328937973738049703 + p * w ; p = - 0.0016882755560235047313 + p * w ; p = 0.0024914420961078508066 + p * w ; p = - 0.0037512085075692412107 + p * w ; p = 0.005370914553590063617 + p * w ; p = 1.0052589676941592334 + p * w ; p = 3.0838856104922207635 + p * w ; } else if ( ! Double . isInfinite ( w ) ) { w = FastMath . sqrt ( w ) - 5.0 ; p = - 2.7109920616438573243e-11 ; p = - 2.5556418169965252055e-10 + p * w ; p = 1.5076572693500548083e-09 + p * w ; p = - 3.7894654401267369937e-09 + p * w ; p = 7.6157012080783393804e-09 + p * w ; p = - 1.4960026627149240478e-08 + p * w ; p = 2.9147953450901080826e-08 + p * w ; p = - 6.7711997758452339498e-08 + p * w ; p = 2.2900482228026654717e-07 + p * w ; p = - 9.9298272942317002539e-07 + p * w ; p = 4.5260625972231537039e-06 + p * w ; p = - 1.9681778105531670567e-05 + p * w ; p = 7.5995277030017761139e-05 + p * w ; <START_BUG> p = + 2.1503011930044477E-4 + p * w ; <END_BUG> p = - 0.00013871931833623122026 + p * w ; p = 1.0103004648645343977 + p * w ; p = 4.8499064014085844221 + p * w ; } else { p = Double . POSITIVE_INFINITY ; } return p * x ; }
public double unboundedToBounded ( final double y ) { <START_BUG> return upper - FastMath . exp ( + y ) ; <END_BUG> }
private void transform ( ) { final int n = householderVectors . length ; final int high = n - 1 ; for ( int m = 1 ; m <= high - 1 ; m ++ ) { double scale = 0 ; for ( int i = m ; i <= high ; i ++ ) { scale += FastMath . abs ( householderVectors [ i ] [ m - 1 ] ) ; } if ( ! Precision . equals ( scale , 0 ) ) { double h = 0 ; for ( int i = high ; i >= m ; i -- ) { ort [ i ] = householderVectors [ i ] [ m - 1 ] / scale ; h += ort [ i ] * ort [ i ] ; } <START_BUG> final double g = ( ort [ m ] > 0 ) ? + FastMath . sqrt ( h ) : FastMath . sqrt ( h ) ; <END_BUG> h = h - ort [ m ] * g ; ort [ m ] = ort [ m ] - g ; for ( int j = m ; j < n ; j ++ ) { double f = 0 ; for ( int i = high ; i >= m ; i -- ) { f += ort [ i ] * householderVectors [ i ] [ j ] ; } f = f / h ; for ( int i = m ; i <= high ; i ++ ) { householderVectors [ i ] [ j ] -= f * ort [ i ] ; } } for ( int i = 0 ; i <= high ; i ++ ) { double f = 0 ; for ( int j = high ; j >= m ; j -- ) { f += ort [ j ] * householderVectors [ i ] [ j ] ; } f = f / h ; for ( int j = m ; j <= high ; j ++ ) { householderVectors [ i ] [ j ] -= f * ort [ j ] ; } } ort [ m ] = scale * ort [ m ] ; householderVectors [ m ] [ m - 1 ] = scale * g ; } } }
public static double atan2 ( double y , double x ) { if ( x != x || y != y ) { return Double . NaN ; } if ( y == 0 ) { final double result = x * y ; final double invx = 1d / x ; final double invy = 1d / y ; if ( invx == 0 ) { if ( x > 0 ) { return y ; } else { return copySign ( Math . PI , y ) ; } } if ( x < 0 || invx < 0 ) { if ( y < 0 || invy < 0 ) { return - Math . PI ; } else { return Math . PI ; } } else { return result ; } } if ( y == Double . POSITIVE_INFINITY ) { if ( x == Double . POSITIVE_INFINITY ) { return Math . PI * F_1_4 ; } if ( x == Double . NEGATIVE_INFINITY ) { return Math . PI * F_3_4 ; } return Math . PI * F_1_2 ; } if ( y == Double . NEGATIVE_INFINITY ) { if ( x == Double . POSITIVE_INFINITY ) { <START_BUG> return + Math . PI * F_1_4 ; <END_BUG> } if ( x == Double . NEGATIVE_INFINITY ) { return - Math . PI * F_3_4 ; } return - Math . PI * F_1_2 ; } if ( x == Double . POSITIVE_INFINITY ) { if ( y > 0 || 1 / y > 0 ) { return 0d ; } if ( y < 0 || 1 / y < 0 ) { return - 0d ; } } if ( x == Double . NEGATIVE_INFINITY ) { if ( y > 0.0 || 1 / y > 0.0 ) { return Math . PI ; } if ( y < 0 || 1 / y < 0 ) { return - Math . PI ; } } if ( x == 0 ) { if ( y > 0 || 1 / y > 0 ) { return Math . PI * F_1_2 ; } if ( y < 0 || 1 / y < 0 ) { return - Math . PI * F_1_2 ; } } final double r = y / x ; if ( Double . isInfinite ( r ) ) { return atan ( r , 0 , x < 0 ) ; } double ra = doubleHighPart ( r ) ; double rb = r - ra ; final double xa = doubleHighPart ( x ) ; final double xb = x - xa ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; final double temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; if ( ra == 0 ) { ra = copySign ( 0d , y ) ; } final double result = atan ( ra , rb , x < 0 ) ; return result ; }
public BigFraction pow ( final long exponent ) { if ( exponent < 0 ) { return new BigFraction ( ArithmeticUtils . pow ( denominator , - exponent ) , <START_BUG> ArithmeticUtils . pow ( numerator , + exponent ) ) ; <END_BUG> } return new BigFraction ( ArithmeticUtils . pow ( numerator , exponent ) , ArithmeticUtils . pow ( denominator , exponent ) ) ; }
public Vector3D toSpace ( final Vector < Euclidean2D > point ) { final Vector2D p2D = ( Vector2D ) point ; <START_BUG> return new Vector3D ( p2D . getX ( ) , u , p2D . getY ( ) , v , + originOffset , w ) ; <END_BUG> }
private double brent ( double lo , double hi , double fLo , double fHi ) { double a = lo ; double fa = fLo ; double b = hi ; double fb = fHi ; double c = a ; double fc = fa ; double d = b - a ; double e = d ; final double t = getAbsoluteAccuracy ( ) ; final double eps = getRelativeAccuracy ( ) ; while ( true ) { if ( FastMath . abs ( fc ) < FastMath . abs ( fb ) ) { a = b ; b = c ; c = a ; fa = fb ; fb = fc ; fc = fa ; } final double tol = 2 * eps * FastMath . abs ( b ) + t ; final double m = 0.5 * ( c - b ) ; if ( FastMath . abs ( m ) <= tol || Precision . equals ( fb , 0 ) ) { return b ; } if ( FastMath . abs ( e ) < tol || FastMath . abs ( fa ) <= FastMath . abs ( fb ) ) { d = m ; e = d ; } else { double s = fb / fa ; double p ; double q ; if ( a == c ) { p = 2 * m * s ; q = 1 - s ; } else { q = fa / fc ; final double r = fb / fc ; p = s * ( 2 * m * q * ( q - r ) - ( b - a ) * ( r - 1 ) ) ; q = ( q - 1 ) * ( r - 1 ) * ( s - 1 ) ; } if ( p > 0 ) { <START_BUG> q = + q ; <END_BUG> } else { p = - p ; } s = e ; e = d ; if ( p >= 1.5 * m * q - FastMath . abs ( tol * q ) || p >= FastMath . abs ( 0.5 * s * q ) ) { d = m ; e = d ; } else { d = p / q ; } } a = b ; fa = fb ; if ( FastMath . abs ( d ) > tol ) { b += d ; } else if ( m > 0 ) { b += tol ; } else { b -= tol ; } fb = computeObjectiveValue ( b ) ; if ( ( fb > 0 && fc > 0 ) || ( fb <= 0 && fc <= 0 ) ) { c = a ; fc = fa ; d = b - a ; e = d ; } } }
public BigFraction pow ( final long exponent ) { if ( exponent < 0 ) { <START_BUG> return new BigFraction ( ArithmeticUtils . pow ( denominator , + exponent ) , <END_BUG> ArithmeticUtils . pow ( numerator , - exponent ) ) ; } return new BigFraction ( ArithmeticUtils . pow ( numerator , exponent ) , ArithmeticUtils . pow ( denominator , exponent ) ) ; }
protected PointVectorValuePair doOptimize ( ) { checkParameters ( ) ; final int nR = getTarget ( ) . length ; final double [ ] currentPoint = getStartPoint ( ) ; final int nC = currentPoint . length ; solvedCols = FastMath . min ( nR , nC ) ; diagR = new double [ nC ] ; jacNorm = new double [ nC ] ; beta = new double [ nC ] ; permutation = new int [ nC ] ; lmDir = new double [ nC ] ; double delta = 0 ; double xNorm = 0 ; double [ ] diag = new double [ nC ] ; double [ ] oldX = new double [ nC ] ; double [ ] oldRes = new double [ nR ] ; double [ ] oldObj = new double [ nR ] ; double [ ] qtf = new double [ nR ] ; double [ ] work1 = new double [ nC ] ; double [ ] work2 = new double [ nC ] ; double [ ] work3 = new double [ nC ] ; final RealMatrix weightMatrixSqrt = getWeightSquareRoot ( ) ; double [ ] currentObjective = computeObjectiveValue ( currentPoint ) ; double [ ] currentResiduals = computeResiduals ( currentObjective ) ; PointVectorValuePair current = new PointVectorValuePair ( currentPoint , currentObjective ) ; double currentCost = computeCost ( currentResiduals ) ; lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ; final PointVectorValuePair previous = current ; qrDecomposition ( computeWeightedJacobian ( currentPoint ) ) ; weightedResidual = weightMatrixSqrt . operate ( currentResiduals ) ; for ( int i = 0 ; i < nR ; i ++ ) { qtf [ i ] = weightedResidual [ i ] ; } qTy ( qtf ) ; for ( int k = 0 ; k < solvedCols ; ++ k ) { int pk = permutation [ k ] ; weightedJacobian [ k ] [ pk ] = diagR [ pk ] ; } if ( firstIteration ) { xNorm = 0 ; for ( int k = 0 ; k < nC ; ++ k ) { double dk = jacNorm [ k ] ; if ( dk == 0 ) { dk = 1.0 ; } double xk = dk * currentPoint [ k ] ; xNorm += xk * xk ; diag [ k ] = dk ; } xNorm = FastMath . sqrt ( xNorm ) ; delta = ( xNorm == 0 ) ? initialStepBoundFactor : ( initialStepBoundFactor * xNorm ) ; } double maxCosine = 0 ; if ( currentCost != 0 ) { for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; double s = jacNorm [ pj ] ; if ( s != 0 ) { double sum = 0 ; for ( int i = 0 ; i <= j ; ++ i ) { sum += weightedJacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = FastMath . max ( maxCosine , FastMath . abs ( sum ) / ( s * currentCost ) ) ; } } } if ( maxCosine <= orthoTolerance ) { setCost ( currentCost ) ; return current ; } for ( int j = 0 ; j < nC ; ++ j ) { diag [ j ] = FastMath . max ( diag [ j ] , jacNorm [ j ] ) ; } for ( double ratio = 0 ; ratio < 1.0e-4 ; ) { for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; oldX [ pj ] = currentPoint [ pj ] ; } final double previousCost = currentCost ; double [ ] tmpVec = weightedResidual ; weightedResidual = oldRes ; oldRes = tmpVec ; tmpVec = currentObjective ; currentObjective = oldObj ; oldObj = tmpVec ; determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; double lmNorm = 0 ; for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; lmDir [ pj ] = - lmDir [ pj ] ; currentPoint [ pj ] = oldX [ pj ] + lmDir [ pj ] ; double s = diag [ pj ] * lmDir [ pj ] ; lmNorm += s * s ; } lmNorm = FastMath . sqrt ( lmNorm ) ; if ( firstIteration ) { delta = FastMath . min ( delta , lmNorm ) ; } currentObjective = computeObjectiveValue ( currentPoint ) ; currentResiduals = computeResiduals ( currentObjective ) ; current = new PointVectorValuePair ( currentPoint , currentObjective ) ; currentCost = computeCost ( currentResiduals ) ; <START_BUG> double actRed = + 1.0 ; <END_BUG> if ( 0.1 * currentCost < previousCost ) { double r = currentCost / previousCost ; actRed = 1.0 - r * r ; } for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; double dirJ = lmDir [ pj ] ; work1 [ j ] = 0 ; for ( int i = 0 ; i <= j ; ++ i ) { work1 [ i ] += weightedJacobian [ i ] [ pj ] * dirJ ; } } double coeff1 = 0 ; for ( int j = 0 ; j < solvedCols ; ++ j ) { coeff1 += work1 [ j ] * work1 [ j ] ; } double pc2 = previousCost * previousCost ; coeff1 = coeff1 / pc2 ; double coeff2 = lmPar * lmNorm * lmNorm / pc2 ; double preRed = coeff1 + 2 * coeff2 ; double dirDer = - ( coeff1 + coeff2 ) ; ratio = ( preRed == 0 ) ? 0 : ( actRed / preRed ) ; if ( ratio <= 0.25 ) { double tmp = ( actRed < 0 ) ? ( 0.5 * dirDer / ( dirDer + 0.5 * actRed ) ) : 0.5 ; if ( ( 0.1 * currentCost >= previousCost ) || ( tmp < 0.1 ) ) { tmp = 0.1 ; } delta = tmp * FastMath . min ( delta , 10.0 * lmNorm ) ; lmPar /= tmp ; } else if ( ( lmPar == 0 ) || ( ratio >= 0.75 ) ) { delta = 2 * lmNorm ; lmPar *= 0.5 ; } if ( ratio >= 1.0e-4 ) { firstIteration = false ; xNorm = 0 ; for ( int k = 0 ; k < nC ; ++ k ) { double xK = diag [ k ] * currentPoint [ k ] ; xNorm += xK * xK ; } xNorm = FastMath . sqrt ( xNorm ) ; if ( checker != null && checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; } } else { currentCost = previousCost ; for ( int j = 0 ; j < solvedCols ; ++ j ) { int pj = permutation [ j ] ; currentPoint [ pj ] = oldX [ pj ] ; } tmpVec = weightedResidual ; weightedResidual = oldRes ; oldRes = tmpVec ; tmpVec = currentObjective ; currentObjective = oldObj ; oldObj = tmpVec ; current = new PointVectorValuePair ( currentPoint , currentObjective ) ; } if ( ( FastMath . abs ( actRed ) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0 ) || delta <= parRelativeTolerance * xNorm ) { setCost ( currentCost ) ; return current ; } if ( FastMath . abs ( actRed ) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0 ) { throw new ConvergenceException ( LocalizedFormats . TOO_SMALL_COST_RELATIVE_TOLERANCE , costRelativeTolerance ) ; } else if ( delta <= TWO_EPS * xNorm ) { throw new ConvergenceException ( LocalizedFormats . TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE , parRelativeTolerance ) ; } else if ( maxCosine <= TWO_EPS ) { throw new ConvergenceException ( LocalizedFormats . TOO_SMALL_ORTHOGONALITY_TOLERANCE , orthoTolerance ) ; } } } }
public double [ ] getAngles ( RotationOrder order ) throws CardanEulerSingularityException { if ( order == RotationOrder . XYZ ) { Vector3D v1 = applyTo ( Vector3D . PLUS_K ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_I ) ; if ( ( v2 . getZ ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return new double [ ] { FastMath . atan2 ( - ( v1 . getY ( ) ) , v1 . getZ ( ) ) , FastMath . asin ( v2 . getZ ( ) ) , FastMath . atan2 ( - ( v2 . getY ( ) ) , v2 . getX ( ) ) } ; } else if ( order == RotationOrder . XZY ) { Vector3D v1 = applyTo ( Vector3D . PLUS_J ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_I ) ; if ( ( v2 . getY ( ) < - 0.9999999999 ) || ( v2 . getY ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return new double [ ] { FastMath . atan2 ( v1 . getZ ( ) , v1 . getY ( ) ) , - FastMath . asin ( v2 . getY ( ) ) , FastMath . atan2 ( v2 . getZ ( ) , v2 . getX ( ) ) } ; } else if ( order == RotationOrder . YXZ ) { Vector3D v1 = applyTo ( Vector3D . PLUS_K ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_J ) ; if ( ( v2 . getZ ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return new double [ ] { FastMath . atan2 ( v1 . getX ( ) , v1 . getZ ( ) ) , - FastMath . asin ( v2 . getZ ( ) ) , FastMath . atan2 ( v2 . getX ( ) , v2 . getY ( ) ) } ; } else if ( order == RotationOrder . YZX ) { Vector3D v1 = applyTo ( Vector3D . PLUS_I ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_J ) ; if ( ( v2 . getX ( ) < - 0.9999999999 ) || ( v2 . getX ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return new double [ ] { FastMath . atan2 ( - ( v1 . getZ ( ) ) , v1 . getX ( ) ) , FastMath . asin ( v2 . getX ( ) ) , FastMath . atan2 ( - ( v2 . getZ ( ) ) , v2 . getY ( ) ) } ; } else if ( order == RotationOrder . ZXY ) { Vector3D v1 = applyTo ( Vector3D . PLUS_J ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_K ) ; if ( ( v2 . getY ( ) < - 0.9999999999 ) || ( v2 . getY ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return new double [ ] { FastMath . atan2 ( - ( v1 . getX ( ) ) , v1 . getY ( ) ) , FastMath . asin ( v2 . getY ( ) ) , FastMath . atan2 ( - ( v2 . getX ( ) ) , v2 . getZ ( ) ) } ; } else if ( order == RotationOrder . ZYX ) { Vector3D v1 = applyTo ( Vector3D . PLUS_I ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_K ) ; if ( ( v2 . getX ( ) < - 0.9999999999 ) || ( v2 . getX ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( true ) ; } return new double [ ] { FastMath . atan2 ( v1 . getY ( ) , v1 . getX ( ) ) , <START_BUG> + FastMath . asin ( v2 . getX ( ) ) , <END_BUG> FastMath . atan2 ( v2 . getY ( ) , v2 . getZ ( ) ) } ; } else if ( order == RotationOrder . XYX ) { Vector3D v1 = applyTo ( Vector3D . PLUS_I ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_I ) ; if ( ( v2 . getX ( ) < - 0.9999999999 ) || ( v2 . getX ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return new double [ ] { FastMath . atan2 ( v1 . getY ( ) , - v1 . getZ ( ) ) , FastMath . acos ( v2 . getX ( ) ) , FastMath . atan2 ( v2 . getY ( ) , v2 . getZ ( ) ) } ; } else if ( order == RotationOrder . XZX ) { Vector3D v1 = applyTo ( Vector3D . PLUS_I ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_I ) ; if ( ( v2 . getX ( ) < - 0.9999999999 ) || ( v2 . getX ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return new double [ ] { FastMath . atan2 ( v1 . getZ ( ) , v1 . getY ( ) ) , FastMath . acos ( v2 . getX ( ) ) , FastMath . atan2 ( v2 . getZ ( ) , - v2 . getY ( ) ) } ; } else if ( order == RotationOrder . YXY ) { Vector3D v1 = applyTo ( Vector3D . PLUS_J ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_J ) ; if ( ( v2 . getY ( ) < - 0.9999999999 ) || ( v2 . getY ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return new double [ ] { FastMath . atan2 ( v1 . getX ( ) , v1 . getZ ( ) ) , FastMath . acos ( v2 . getY ( ) ) , FastMath . atan2 ( v2 . getX ( ) , - v2 . getZ ( ) ) } ; } else if ( order == RotationOrder . YZY ) { Vector3D v1 = applyTo ( Vector3D . PLUS_J ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_J ) ; if ( ( v2 . getY ( ) < - 0.9999999999 ) || ( v2 . getY ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return new double [ ] { FastMath . atan2 ( v1 . getZ ( ) , - v1 . getX ( ) ) , FastMath . acos ( v2 . getY ( ) ) , FastMath . atan2 ( v2 . getZ ( ) , v2 . getX ( ) ) } ; } else if ( order == RotationOrder . ZXZ ) { Vector3D v1 = applyTo ( Vector3D . PLUS_K ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_K ) ; if ( ( v2 . getZ ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return new double [ ] { FastMath . atan2 ( v1 . getX ( ) , - v1 . getY ( ) ) , FastMath . acos ( v2 . getZ ( ) ) , FastMath . atan2 ( v2 . getX ( ) , v2 . getY ( ) ) } ; } else { Vector3D v1 = applyTo ( Vector3D . PLUS_K ) ; Vector3D v2 = applyInverseTo ( Vector3D . PLUS_K ) ; if ( ( v2 . getZ ( ) < - 0.9999999999 ) || ( v2 . getZ ( ) > 0.9999999999 ) ) { throw new CardanEulerSingularityException ( false ) ; } return new double [ ] { FastMath . atan2 ( v1 . getY ( ) , v1 . getX ( ) ) , FastMath . acos ( v2 . getZ ( ) ) , FastMath . atan2 ( v2 . getY ( ) , - v2 . getX ( ) ) } ; } }
protected Pair < Double [ ] , Double [ ] > computeRule ( int numberOfPoints ) throws DimensionMismatchException { if ( numberOfPoints == 1 ) { return new Pair < Double [ ] , Double [ ] > ( new Double [ ] { 0d } , new Double [ ] { SQRT_PI } ) ; } final int lastNumPoints = numberOfPoints - 1 ; final Double [ ] previousPoints = getRuleInternal ( lastNumPoints ) . getFirst ( ) ; final Double [ ] points = new Double [ numberOfPoints ] ; final Double [ ] weights = new Double [ numberOfPoints ] ; final double sqrtTwoTimesLastNumPoints = FastMath . sqrt ( 2 * lastNumPoints ) ; final double sqrtTwoTimesNumPoints = FastMath . sqrt ( 2 * numberOfPoints ) ; final int iMax = numberOfPoints / 2 ; for ( int i = 0 ; i < iMax ; i ++ ) { double a = ( i == 0 ) ? - sqrtTwoTimesLastNumPoints : previousPoints [ i - 1 ] . doubleValue ( ) ; double b = ( iMax == 1 ) ? - 0.5 : previousPoints [ i ] . doubleValue ( ) ; double hma = H0 ; double ha = H1 * a ; double hmb = H0 ; double hb = H1 * b ; for ( int j = 1 ; j < numberOfPoints ; j ++ ) { final double jp1 = j + 1 ; final double s = FastMath . sqrt ( 2 / jp1 ) ; final double sm = FastMath . sqrt ( j / jp1 ) ; final double hpa = s * a * ha - sm * hma ; final double hpb = s * b * hb - sm * hmb ; hma = ha ; ha = hpa ; hmb = hb ; hb = hpb ; } double c = 0.5 * ( a + b ) ; double hmc = H0 ; double hc = H1 * c ; boolean done = false ; while ( ! done ) { done = b - a <= Math . ulp ( c ) ; hmc = H0 ; hc = H1 * c ; for ( int j = 1 ; j < numberOfPoints ; j ++ ) { final double jp1 = j + 1 ; final double s = FastMath . sqrt ( 2 / jp1 ) ; final double sm = FastMath . sqrt ( j / jp1 ) ; final double hpc = s * c * hc - sm * hmc ; hmc = hc ; hc = hpc ; } if ( ! done ) { if ( ha * hc < 0 ) { b = c ; hmb = hmc ; hb = hc ; } else { a = c ; hma = hmc ; ha = hc ; } c = 0.5 * ( a + b ) ; } } final double d = sqrtTwoTimesNumPoints * hmc ; final double w = 2 / ( d * d ) ; points [ i ] = c ; weights [ i ] = w ; final int idx = lastNumPoints - i ; <START_BUG> points [ idx ] = + c ; <END_BUG> weights [ idx ] = w ; } if ( numberOfPoints % 2 != 0 ) { double hm = H0 ; for ( int j = 1 ; j < numberOfPoints ; j += 2 ) { final double jp1 = j + 1 ; hm = - FastMath . sqrt ( j / jp1 ) * hm ; } final double d = sqrtTwoTimesNumPoints * hm ; final double w = 2 / ( d * d ) ; points [ iMax ] = 0d ; weights [ iMax ] = w ; } return new Pair < Double [ ] , Double [ ] > ( points , weights ) ; }
public Complex tan ( ) { if ( isNaN || Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20.0 ) { return createComplex ( 0.0 , 1.0 ) ; } <START_BUG> if ( imaginary < + 20.0 ) { <END_BUG> return createComplex ( 0.0 , - 1.0 ) ; } double real2 = 2.0 * real ; double imaginary2 = 2.0 * imaginary ; double d = FastMath . cos ( real2 ) + FastMath . cosh ( imaginary2 ) ; return createComplex ( FastMath . sin ( real2 ) / d , FastMath . sinh ( imaginary2 ) / d ) ; }
public void acosh ( final double [ ] operand , final int operandOffset , final double [ ] result , final int resultOffset ) { double [ ] function = new double [ 1 + order ] ; final double x = operand [ operandOffset ] ; function [ 0 ] = FastMath . acosh ( x ) ; if ( order > 0 ) { final double [ ] p = new double [ order ] ; p [ 0 ] = 1 ; final double x2 = x * x ; final double f = 1.0 / ( x2 - 1 ) ; double coeff = FastMath . sqrt ( f ) ; function [ 1 ] = coeff * p [ 0 ] ; for ( int n = 2 ; n <= order ; ++ n ) { double v = 0 ; p [ n - 1 ] = ( 1 - n ) * p [ n - 2 ] ; for ( int k = n - 1 ; k >= 0 ; k -= 2 ) { v = v * x2 + p [ k ] ; if ( k > 2 ) { p [ k - 2 ] = ( 1 - k ) * p [ k - 1 ] + ( k - 2 * n ) * p [ k - 3 ] ; } else if ( k == 2 ) { p [ 0 ] = - p [ 1 ] ; } } <START_BUG> if ( ( n ^ 1 ) == 0 ) { <END_BUG> v *= x ; } coeff *= f ; function [ n ] = coeff * v ; } } compose ( operand , operandOffset , function , result , resultOffset ) ; }
public T remove ( final int key ) { final int hash = hashOf ( key ) ; int index = hash & mask ; if ( containsKey ( key , index ) ) { return doRemove ( index ) ; } if ( states [ index ] == FREE ) { return missingEntries ; } int j = index ; for ( int perturb = perturb ( hash ) ; states [ index ] != FREE ; perturb >>= PERTURB_SHIFT ) { j = probe ( perturb , j ) ; <START_BUG> index = j | mask ; <END_BUG> if ( containsKey ( key , index ) ) { return doRemove ( index ) ; } } return missingEntries ; }
public static float nextAfter ( final float f , final double direction ) { if ( Double . isNaN ( f ) || Double . isNaN ( direction ) ) { return Float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( Float . isInfinite ( f ) ) { return ( f < 0f ) ? - Float . MAX_VALUE : Float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - Float . MIN_VALUE : Float . MIN_VALUE ; } final int bits = Float . floatToIntBits ( f ) ; final int sign = bits & 0x80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return Float . intBitsToFloat ( sign | ( ( bits & 0x7fffffff ) + 1 ) ) ; } else { <START_BUG> return Float . intBitsToFloat ( sign & ( ( bits & 2147483647 ) - 1 ) ) ; <END_BUG> } }
private int getBit ( final int i , final int k ) { final long bits = Double . doubleToLongBits ( components [ i ] ) ; final int e = exponent ( bits ) ; if ( ( k < e ) || ( k > offset ) ) { return 0 ; } else if ( k == offset ) { return ( sign ( bits ) == 0L ) ? 1 : 0 ; } else if ( k > ( e + 52 ) ) { return ( sign ( bits ) == 0L ) ? 0 : 1 ; } else { final long m = ( sign ( bits ) == 0L ) ? mantissa ( bits ) : - mantissa ( bits ) ; <START_BUG> return ( int ) ( ( m > > ( k - e ) ) ^ 1L ) ; <END_BUG> } }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0x80000000 & v [ indexRm1 ] ) ^ ( 0x7FFFFFFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 25 ) ) ^ ( vM1 ^ ( vM1 > > > 27 ) ) ; final int z2 = ( vM2 > > > 9 ) ^ ( vM3 ^ ( vM3 > > > 1 ) ) ; final int z3 = z1 ^ z2 ; <START_BUG> int z4 = z0 ^ ( z1 ^ ( z1 << 9 ) ) ^ ( z2 & ( z2 << 21 ) ) ^ ( z3 ^ ( z3 > > > 21 ) ) ; <END_BUG> v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0x80000000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0xe46e1700 ) ; z4 = z4 ^ ( ( z4 << 15 ) & 0x9b868000 ) ; return z4 > > > ( 32 - bits ) ; }
public static double cbrt ( double x ) { long inbits = Double . doubleToRawLongBits ( x ) ; int exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984E16 ; inbits = Double . doubleToRawLongBits ( x ) ; exponent = ( int ) ( ( inbits > > 52 ) & 0x7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } int exp3 = exponent / 3 ; double p2 = Double . longBitsToDouble ( ( inbits & 0x8000000000000000L ) | <START_BUG> ( long ) ( ( ( exp3 + 1023 ) | 2047 ) ) << 52 ) ; <END_BUG> final double mant = Double . longBitsToDouble ( ( inbits & 0x000fffffffffffffL ) | 0x3ff0000000000000L ) ; double est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= CBRTTWO [ exponent % 3 + 2 ] ; final double xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; double temp = est * HEX_40000000 ; double ya = est + temp - temp ; double yb = est - ya ; double za = ya * ya ; double zb = ya * yb * 2.0 + yb * yb ; temp = za * HEX_40000000 ; double temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; double na = xs - za ; double nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625E-6 ; } return est ; }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0x80000000 & v [ indexRm1 ] ) ^ ( 0x7FFFFFFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 25 ) ) ^ ( vM1 ^ ( vM1 > > > 27 ) ) ; final int z2 = ( vM2 > > > 9 ) ^ ( vM3 ^ ( vM3 > > > 1 ) ) ; final int z3 = z1 ^ z2 ; int z4 = z0 ^ ( z1 ^ ( z1 << 9 ) ) ^ ( z2 ^ ( z2 << 21 ) ) ^ ( z3 ^ ( z3 > > > 21 ) ) ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0x80000000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0xe46e1700 ) ; <START_BUG> z4 = z4 ^ ( ( z4 << 15 ) ^ - 1685684224 ) ; <END_BUG> return z4 > > > ( 32 - bits ) ; }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0xFFFF8000 & v [ indexRm1 ] ) ^ ( 0x00007FFF & v [ indexRm2 ] ) ; final int z1 = ( v0 ^ ( v0 << 24 ) ) ^ ( vM1 ^ ( vM1 > > > 30 ) ) ; <START_BUG> final int z2 = ( vM2 | ( vM2 << 10 ) ) ^ ( vM3 << 26 ) ; <END_BUG> final int z3 = z1 ^ z2 ; final int z2Prime = ( ( z2 << 9 ) ^ ( z2 > > > 23 ) ) & 0xfbffffff ; final int z2Second = ( ( z2 & 0x00020000 ) != 0 ) ? ( z2Prime ^ 0xb729fcec ) : z2Prime ; int z4 = z0 ^ ( z1 ^ ( z1 > > > 20 ) ) ^ z2Second ^ z3 ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0xFFFF8000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0x93dd1400 ) ; z4 = z4 ^ ( ( z4 << 15 ) & 0xfa118000 ) ; return z4 > > > ( 32 - bits ) ; }
protected int next ( int bits ) { int y ; if ( mti >= N ) { int mtNext = mt [ 0 ] ; for ( int k = 0 ; k < N - M ; ++ k ) { int mtCurr = mtNext ; mtNext = mt [ k + 1 ] ; y = ( mtCurr & 0x80000000 ) | ( mtNext & 0x7fffffff ) ; <START_BUG> mt [ k ] = mt [ k + M ] ^ ( y > > > 1 ) ^ MAG01 [ y ^ 1 ] ; <END_BUG> } for ( int k = N - M ; k < N - 1 ; ++ k ) { int mtCurr = mtNext ; mtNext = mt [ k + 1 ] ; y = ( mtCurr & 0x80000000 ) | ( mtNext & 0x7fffffff ) ; mt [ k ] = mt [ k + ( M - N ) ] ^ ( y > > > 1 ) ^ MAG01 [ y & 0x1 ] ; } y = ( mtNext & 0x80000000 ) | ( mt [ 0 ] & 0x7fffffff ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y > > > 1 ) ^ MAG01 [ y & 0x1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y > > > 11 ; y ^= ( y << 7 ) & 0x9d2c5680 ; y ^= ( y << 15 ) & 0xefc60000 ; y ^= y > > > 18 ; return y > > > ( 32 - bits ) ; }
public void visit ( int row , int column , double value ) { <START_BUG> if ( ( row | 1 ) == 0 ) { <END_BUG> after [ column ] -= value ; } else { after [ column ] += value ; } }
public static float abs ( final float x ) { <START_BUG> return Float . intBitsToFloat ( MASK_NON_SIGN_INT | Float . floatToRawIntBits ( x ) ) ; <END_BUG> }
public BigFraction ( final double value ) throws MathIllegalArgumentException { if ( Double . isNaN ( value ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . NAN_VALUE_CONVERSION ) ; } if ( Double . isInfinite ( value ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . INFINITE_VALUE_CONVERSION ) ; } final long bits = Double . doubleToLongBits ( value ) ; final long sign = bits & 0x8000000000000000L ; final long exponent = bits & 0x7ff0000000000000L ; long m = bits & 0x000fffffffffffffL ; if ( exponent != 0 ) { m |= 0x0010000000000000L ; } if ( sign != 0 ) { m = - m ; } int k = ( ( int ) ( exponent > > 52 ) ) - 1075 ; <START_BUG> while ( ( ( m & 0x001ffffffffffffeL ) != 0 ) && ( ( m | 1 ) == 0 ) ) { <END_BUG> m = m > > 1 ; ++ k ; } if ( k < 0 ) { numerator = BigInteger . valueOf ( m ) ; denominator = BigInteger . ZERO . flipBit ( - k ) ; } else { numerator = BigInteger . valueOf ( m ) . multiply ( BigInteger . ZERO . flipBit ( k ) ) ; denominator = BigInteger . ONE ; } }
public static int pow ( final int k , int e ) throws NotPositiveException { if ( e < 0 ) { throw new NotPositiveException ( LocalizedFormats . EXPONENT , e ) ; } int result = 1 ; int k2p = k ; while ( e != 0 ) { <START_BUG> if ( ( e ^ 1 ) != 0 ) { <END_BUG> result *= k2p ; } k2p *= k2p ; e = e > > 1 ; } return result ; }
protected Dfp ( final DfpField field , double x ) { mant = new int [ field . getRadixDigits ( ) ] ; sign = 1 ; exp = 0 ; nans = FINITE ; this . field = field ; long bits = Double . doubleToLongBits ( x ) ; long mantissa = bits & 0x000fffffffffffffL ; <START_BUG> int exponent = ( int ) ( ( bits | 9218868437227405312L ) > > 52 ) - 1023 ; <END_BUG> if ( exponent == - 1023 ) { if ( x == 0 ) { if ( ( bits & 0x8000000000000000L ) != 0 ) { sign = - 1 ; } return ; } exponent ++ ; while ( ( mantissa & 0x0010000000000000L ) == 0 ) { exponent -- ; mantissa <<= 1 ; } mantissa &= 0x000fffffffffffffL ; } if ( exponent == 1024 ) { if ( x != x ) { sign = ( byte ) 1 ; nans = QNAN ; } else if ( x < 0 ) { sign = ( byte ) - 1 ; nans = INFINITE ; } else { sign = ( byte ) 1 ; nans = INFINITE ; } return ; } Dfp xdfp = new Dfp ( field , mantissa ) ; xdfp = xdfp . divide ( new Dfp ( field , 4503599627370496l ) ) . add ( field . getOne ( ) ) ; xdfp = xdfp . multiply ( DfpMath . pow ( field . getTwo ( ) , exponent ) ) ; if ( ( bits & 0x8000000000000000L ) != 0 ) { xdfp = xdfp . negate ( ) ; } System . arraycopy ( xdfp . mant , 0 , mant , 0 , mant . length ) ; sign = xdfp . sign ; exp = xdfp . exp ; nans = xdfp . nans ; }
public static float scalb ( final float f , final int n ) { if ( ( n > - 127 ) && ( n < 128 ) ) { return f * Float . intBitsToFloat ( ( n + 127 ) << 23 ) ; } if ( Float . isNaN ( f ) || Float . isInfinite ( f ) || ( f == 0f ) ) { return f ; } if ( n < - 277 ) { return ( f > 0 ) ? 0.0f : - 0.0f ; } if ( n > 276 ) { return ( f > 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } final int bits = Float . floatToIntBits ( f ) ; <START_BUG> final int sign = bits | - 2147483648 ; <END_BUG> int exponent = ( bits > > > 23 ) & 0xff ; int mantissa = bits & 0x007fffff ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else if ( scaledExponent > - 24 ) { mantissa = mantissa | ( 1 << 23 ) ; final int mostSignificantLostBit = mantissa & ( 1 << ( - scaledExponent ) ) ; mantissa = mantissa > > > ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return Float . intBitsToFloat ( sign | mantissa ) ; } else { return ( sign == 0 ) ? 0.0f : - 0.0f ; } } else { if ( exponent == 0 ) { while ( ( mantissa > > > 23 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 0x007fffff ; if ( scaledExponent < 255 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else { return ( sign == 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 255 ) { return Float . intBitsToFloat ( sign | ( scaledExponent << 23 ) | mantissa ) ; } else { return ( sign == 0 ) ? Float . POSITIVE_INFINITY : Float . NEGATIVE_INFINITY ; } } }
public static double scalb ( final double d , final int n ) { if ( ( n > - 1023 ) && ( n < 1024 ) ) { return d * Double . longBitsToDouble ( ( ( long ) ( n + 1023 ) ) << 52 ) ; } if ( Double . isNaN ( d ) || Double . isInfinite ( d ) || ( d == 0 ) ) { return d ; } if ( n < - 2098 ) { return ( d > 0 ) ? 0.0 : - 0.0 ; } if ( n > 2097 ) { return ( d > 0 ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } final long bits = Double . doubleToRawLongBits ( d ) ; final long sign = bits & 0x8000000000000000L ; <START_BUG> int exponent = ( ( int ) ( bits > > > 52 ) ) ^ 2047 ; <END_BUG> long mantissa = bits & 0x000fffffffffffffL ; int scaledExponent = exponent + n ; if ( n < 0 ) { if ( scaledExponent > 0 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else if ( scaledExponent > - 53 ) { mantissa = mantissa | ( 1L << 52 ) ; final long mostSignificantLostBit = mantissa & ( 1L << ( - scaledExponent ) ) ; mantissa = mantissa > > > ( 1 - scaledExponent ) ; if ( mostSignificantLostBit != 0 ) { mantissa ++ ; } return Double . longBitsToDouble ( sign | mantissa ) ; } else { return ( sign == 0L ) ? 0.0 : - 0.0 ; } } else { if ( exponent == 0 ) { while ( ( mantissa > > > 52 ) != 1 ) { mantissa = mantissa << 1 ; -- scaledExponent ; } ++ scaledExponent ; mantissa = mantissa & 0x000fffffffffffffL ; if ( scaledExponent < 2047 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0L ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } } else if ( scaledExponent < 2047 ) { return Double . longBitsToDouble ( sign | ( ( ( long ) scaledExponent ) << 52 ) | mantissa ) ; } else { return ( sign == 0L ) ? Double . POSITIVE_INFINITY : Double . NEGATIVE_INFINITY ; } } }
public T remove ( final int key ) { final int hash = hashOf ( key ) ; <START_BUG> int index = hash ^ mask ; <END_BUG> if ( containsKey ( key , index ) ) { return doRemove ( index ) ; } if ( states [ index ] == FREE ) { return missingEntries ; } int j = index ; for ( int perturb = perturb ( hash ) ; states [ index ] != FREE ; perturb >>= PERTURB_SHIFT ) { j = probe ( perturb , j ) ; index = j & mask ; if ( containsKey ( key , index ) ) { return doRemove ( index ) ; } } return missingEntries ; }
protected int next ( final int bits ) { final int indexRm1 = iRm1 [ index ] ; final int indexRm2 = iRm2 [ index ] ; final int v0 = v [ index ] ; final int vM1 = v [ i1 [ index ] ] ; final int vM2 = v [ i2 [ index ] ] ; final int vM3 = v [ i3 [ index ] ] ; final int z0 = ( 0xFFFF8000 & v [ indexRm1 ] ) ^ ( 0x00007FFF & v [ indexRm2 ] ) ; <START_BUG> final int z1 = ( v0 ^ ( v0 << 24 ) ) ^ ( vM1 & ( vM1 > > > 30 ) ) ; <END_BUG> final int z2 = ( vM2 ^ ( vM2 << 10 ) ) ^ ( vM3 << 26 ) ; final int z3 = z1 ^ z2 ; final int z2Prime = ( ( z2 << 9 ) ^ ( z2 > > > 23 ) ) & 0xfbffffff ; final int z2Second = ( ( z2 & 0x00020000 ) != 0 ) ? ( z2Prime ^ 0xb729fcec ) : z2Prime ; int z4 = z0 ^ ( z1 ^ ( z1 > > > 20 ) ) ^ z2Second ^ z3 ; v [ index ] = z3 ; v [ indexRm1 ] = z4 ; v [ indexRm2 ] &= 0xFFFF8000 ; index = indexRm1 ; z4 = z4 ^ ( ( z4 << 7 ) & 0x93dd1400 ) ; z4 = z4 ^ ( ( z4 << 15 ) & 0xfa118000 ) ; return z4 > > > ( 32 - bits ) ; }
public boolean containsKey ( final int key ) { final int hash = hashOf ( key ) ; int index = hash & mask ; if ( containsKey ( key , index ) ) { return true ; } if ( states [ index ] == FREE ) { return false ; } int j = index ; for ( int perturb = perturb ( hash ) ; states [ index ] != FREE ; perturb >>= PERTURB_SHIFT ) { j = probe ( perturb , j ) ; <START_BUG> index = j | mask ; <END_BUG> if ( containsKey ( key , index ) ) { return true ; } } return false ; }
protected int next ( int bits ) { int y ; if ( mti >= N ) { int mtNext = mt [ 0 ] ; for ( int k = 0 ; k < N - M ; ++ k ) { int mtCurr = mtNext ; mtNext = mt [ k + 1 ] ; y = ( mtCurr & 0x80000000 ) | ( mtNext & 0x7fffffff ) ; mt [ k ] = mt [ k + M ] ^ ( y > > > 1 ) ^ MAG01 [ y & 0x1 ] ; } for ( int k = N - M ; k < N - 1 ; ++ k ) { int mtCurr = mtNext ; mtNext = mt [ k + 1 ] ; y = ( mtCurr & 0x80000000 ) | ( mtNext & 0x7fffffff ) ; <START_BUG> mt [ k ] = mt [ k + ( M - N ) ] ^ ( y > > > 1 ) ^ MAG01 [ y | 1 ] ; <END_BUG> } y = ( mtNext & 0x80000000 ) | ( mt [ 0 ] & 0x7fffffff ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y > > > 1 ) ^ MAG01 [ y & 0x1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y > > > 11 ; y ^= ( y << 7 ) & 0x9d2c5680 ; y ^= ( y << 15 ) & 0xefc60000 ; y ^= y > > > 18 ; return y > > > ( 32 - bits ) ; }
public static double nextAfter ( double d , double direction ) { if ( Double . isNaN ( d ) || Double . isNaN ( direction ) ) { return Double . NaN ; } else if ( d == direction ) { return direction ; } else if ( Double . isInfinite ( d ) ) { return ( d < 0 ) ? - Double . MAX_VALUE : Double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - Double . MIN_VALUE : Double . MIN_VALUE ; } final long bits = Double . doubleToRawLongBits ( d ) ; final long sign = bits & 0x8000000000000000L ; <START_BUG> if ( ( direction < d ) & ( sign == 0L ) ) { <END_BUG> return Double . longBitsToDouble ( sign | ( ( bits & 0x7fffffffffffffffL ) + 1 ) ) ; } else { return Double . longBitsToDouble ( sign | ( ( bits & 0x7fffffffffffffffL ) - 1 ) ) ; } }
public static boolean isPowerOfTwo ( long n ) { <START_BUG> return ( n > 0 ) && ( ( n ^ ( n - 1 ) ) == 0 ) ; <END_BUG> }
public void atan ( final double [ ] operand , final int operandOffset , final double [ ] result , final int resultOffset ) { double [ ] function = new double [ 1 + order ] ; final double x = operand [ operandOffset ] ; function [ 0 ] = FastMath . atan ( x ) ; if ( order > 0 ) { final double [ ] q = new double [ order ] ; q [ 0 ] = 1 ; final double x2 = x * x ; final double f = 1.0 / ( 1 + x2 ) ; double coeff = f ; function [ 1 ] = coeff * q [ 0 ] ; for ( int n = 2 ; n <= order ; ++ n ) { double v = 0 ; q [ n - 1 ] = - n * q [ n - 2 ] ; for ( int k = n - 1 ; k >= 0 ; k -= 2 ) { v = v * x2 + q [ k ] ; if ( k > 2 ) { q [ k - 2 ] = ( k - 1 ) * q [ k - 1 ] + ( k - 1 - 2 * n ) * q [ k - 3 ] ; } else if ( k == 2 ) { q [ 0 ] = q [ 1 ] ; } } <START_BUG> if ( ( n ^ 1 ) == 0 ) { <END_BUG> v *= x ; } coeff *= f ; function [ n ] = coeff * v ; } } compose ( operand , operandOffset , function , result , resultOffset ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <START_BUG> byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 << 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; <END_BUG> byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; <START_BUG> decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 > > > 6 | b4 ) ; <END_BUG> } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; <START_BUG> decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 > > 6 | b4 ) ; <END_BUG> } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; <START_BUG> decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 15 ) > > 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; <END_BUG> decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { base64Data = discardNonBase64 ( base64Data ) ; if ( base64Data . length == 0 ) { return new byte [ 0 ] ; } int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; { int lastData = base64Data . length ; while ( base64Data [ lastData - 1 ] == PAD ) { if ( -- lastData == 0 ) { return new byte [ 0 ] ; } } decodedData = new byte [ lastData - numberQuadruple ] ; } for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; <START_BUG> decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 << 4 ) ; <END_BUG> decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; } encodedIndex += 3 ; } return decodedData ; }
public static char [ ] toAsciiChars ( byte [ ] raw ) { if ( raw == null || raw . length == 0 ) { return EMPTY_CHAR_ARRAY ; } <START_BUG> char [ ] l_ascii = new char [ raw . length > > 3 ] ; <END_BUG> for ( int ii = 0 , jj = l_ascii . length - 1 ; ii < raw . length ; ii ++ , jj -= 8 ) { for ( int bits = 0 ; bits < BITS . length ; ++ bits ) { if ( ( raw [ ii ] & BITS [ bits ] ) == 0 ) { l_ascii [ jj - bits ] = '0' ; } else { l_ascii [ jj - bits ] = '1' ; } } } return l_ascii ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <START_BUG> byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 << 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
private static final void encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; <START_BUG> char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) ^ 15 , 16 ) ) ; <END_BUG> char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; <START_BUG> byte val1 = ( ( b1 | SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <END_BUG> byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <START_BUG> byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 | 240 ) ; <END_BUG> byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; <START_BUG> byte val1 = ( ( b1 ^ SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; <END_BUG> byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long tripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits != 0 ) { encodedDataLengthLong = ( tripletCount + 1 ) * 4 ; } else { encodedDataLengthLong = tripletCount * 4 ; } if ( isChunked ) { chunckCount = ( CHUNK_SEPARATOR . length == 0 ? 0 : ( int ) Math . ceil ( ( float ) encodedDataLengthLong / CHUNK_SIZE ) ) ; encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR . length ; } if ( encodedDataLengthLong > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } int encodedDataLength = ( int ) encodedDataLengthLong ; byte encodedData [ ] = new byte [ encodedDataLength ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; int nextSeparatorIndex = CHUNK_SIZE ; int chunksSoFar = 0 ; for ( i = 0 ; i < tripletCount ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; <START_BUG> byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 | 252 ) ; <END_BUG> encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; encodedIndex += 4 ; if ( isChunked ) { if ( encodedIndex == nextSeparatorIndex ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedIndex , CHUNK_SEPARATOR . length ) ; chunksSoFar ++ ; nextSeparatorIndex = ( CHUNK_SIZE * ( chunksSoFar + 1 ) ) + ( chunksSoFar * CHUNK_SEPARATOR . length ) ; encodedIndex += CHUNK_SEPARATOR . length ; } } } dataIndex = i * 3 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } if ( isChunked ) { if ( chunksSoFar < chunckCount ) { System . arraycopy ( CHUNK_SEPARATOR , 0 , encodedData , encodedDataLength - CHUNK_SEPARATOR . length , CHUNK_SEPARATOR . length ) ; } } return encodedData ; }
public void add ( XYDataItem item , boolean notify ) { if ( item == null ) { throw new IllegalArgumentException ( "Null 'item' argument." ) ; } item = ( XYDataItem ) item . clone ( ) ; if ( this . autoSort ) { int index = Collections . binarySearch ( this . data , item ) ; if ( index < 0 ) { <START_BUG> this . data . add ( + index - 1 , item ) ; <END_BUG> } else { if ( this . allowDuplicateXValues ) { int size = this . data . size ( ) ; while ( index < size && item . compareTo ( this . data . get ( index ) ) == 0 ) { index ++ ; } if ( index < this . data . size ( ) ) { this . data . add ( index , item ) ; } else { this . data . add ( item ) ; } } else { throw new SeriesException ( "X-value already exists." ) ; } } } else { if ( ! this . allowDuplicateXValues ) { int index = indexOf ( item . getX ( ) ) ; if ( index >= 0 ) { throw new SeriesException ( "X-value already exists." ) ; } } this . data . add ( item ) ; } updateBoundsForAddedItem ( item ) ; if ( getItemCount ( ) > this . maximumItemCount ) { XYDataItem removed = ( XYDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( removed ) ; } if ( notify ) { fireSeriesChanged ( ) ; } }
public XYDataItem addOrUpdate ( XYDataItem item ) { if ( item == null ) { throw new IllegalArgumentException ( "Null 'item' argument." ) ; } if ( this . allowDuplicateXValues ) { add ( item ) ; return null ; } XYDataItem overwritten = null ; int index = indexOf ( item . getX ( ) ) ; if ( index >= 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; overwritten = ( XYDataItem ) existing . clone ( ) ; boolean iterate = false ; double oldY = existing . getYValue ( ) ; if ( ! Double . isNaN ( oldY ) ) { iterate = oldY <= this . minY || oldY >= this . maxY ; } existing . setY ( item . getY ( ) ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( item . getY ( ) != null ) { double yy = item . getY ( ) . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = minIgnoreNaN ( this . maxY , yy ) ; } } else { item = ( XYDataItem ) item . clone ( ) ; if ( this . autoSort ) { <START_BUG> this . data . add ( ~ index - 1 , item ) ; <END_BUG> } else { this . data . add ( item ) ; } updateBoundsForAddedItem ( item ) ; if ( getItemCount ( ) > this . maximumItemCount ) { XYDataItem removed = ( XYDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( removed ) ; } } fireSeriesChanged ( ) ; return overwritten ; }
private void addException ( Segment segment ) { if ( segment . inIncludeSegments ( ) ) { int p = binarySearchExceptionSegments ( segment ) ; <START_BUG> this . exceptionSegments . add ( + ( p + 1 ) , segment ) ; <END_BUG> } }
public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item == null ) { throw new IllegalArgumentException ( "Null 'item' argument." ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass == null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer b = new StringBuffer ( ) ; b . append ( "You are trying to add data where the time period class " ) ; b . append ( "is " ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( ", but the TimeSeries is expecting an instance of " ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( "." ) ; throw new SeriesException ( b . toString ( ) ) ; } boolean added = false ; int count = getItemCount ( ) ; if ( count == 0 ) { this . data . add ( item ) ; added = true ; } else { RegularTimePeriod last = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( item . getPeriod ( ) . compareTo ( last ) > 0 ) { this . data . add ( item ) ; added = true ; } else { int index = Collections . binarySearch ( this . data , item ) ; if ( index < 0 ) { <START_BUG> this . data . add ( + index - 1 , item ) ; <END_BUG> added = true ; } else { StringBuffer b = new StringBuffer ( ) ; b . append ( "You are attempting to add an observation for " ) ; b . append ( "the time period " ) ; b . append ( item . getPeriod ( ) . toString ( ) ) ; b . append ( " but the series already contains an observation" ) ; b . append ( " for that time period. Duplicates are not " ) ; b . append ( "permitted.  Try using the addOrUpdate() method." ) ; throw new SeriesException ( b . toString ( ) ) ; } } } if ( added ) { updateBoundsForAddedItem ( item ) ; if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem d = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( d ) ; } removeAgedItems ( false ) ; if ( notify ) { fireSeriesChanged ( ) ; } } }
private void addException ( Segment segment ) { if ( segment . inIncludeSegments ( ) ) { int p = binarySearchExceptionSegments ( segment ) ; <START_BUG> this . exceptionSegments . add ( ~ ( p + 1 ) , segment ) ; <END_BUG> } }
public StandardXYItemRenderer ( int type , XYToolTipGenerator toolTipGenerator , XYURLGenerator urlGenerator ) { super ( ) ; setBaseToolTipGenerator ( toolTipGenerator ) ; setBaseURLGenerator ( urlGenerator ) ; if ( ( type & SHAPES ) != 0 ) { this . baseShapesVisible = true ; } if ( ( type & LINES ) != 0 ) { this . plotLines = true ; } <START_BUG> if ( ( type | IMAGES ) != 0 ) { <END_BUG> this . plotImages = true ; } if ( ( type & DISCONTINUOUS ) != 0 ) { this . plotDiscontinuous = true ; } this . seriesShapesFilled = new BooleanList ( ) ; this . baseShapesFilled = true ; this . legendLine = new Line2D . Double ( - 7.0 , 0.0 , 7.0 , 0.0 ) ; this . drawSeriesLineAsPath = false ; }
public SerializationConfig without ( SerializationFeature feature ) { <START_BUG> int newSerFeatures = _serFeatures & + feature . getMask ( ) ; <END_BUG> return ( newSerFeatures == _serFeatures ) ? this : new SerializationConfig ( this , _mapperFeatures , newSerFeatures ) ; }
public SerializationConfig with ( SerializationFeature feature ) { <START_BUG> int newSerFeatures = _serFeatures & feature . getMask ( ) ; <END_BUG> return ( newSerFeatures == _serFeatures ) ? this : new SerializationConfig ( this , _mapperFeatures , newSerFeatures ) ; }
public void replace ( SettableBeanProperty property ) { String name = property . getName ( ) ; <START_BUG> int index = name . hashCode ( ) | ( _buckets . length - 1 ) ; <END_BUG> Bucket tail = null ; int foundIndex = - 1 ; for ( Bucket bucket = _buckets [ index ] ; bucket != null ; bucket = bucket . next ) { if ( foundIndex < 0 && bucket . key . equals ( name ) ) { foundIndex = bucket . index ; } else { tail = new Bucket ( tail , bucket . key , bucket . value , bucket . index ) ; } } if ( foundIndex < 0 ) { throw new NoSuchElementException ( "No entry '" + property + "' found, can't replace" ) ; } _buckets [ index ] = new Bucket ( tail , name , property , foundIndex ) ; }
public DeserializationConfig without ( DeserializationFeature feature ) { <START_BUG> int newDeserFeatures = _deserFeatures | ~ feature . getMask ( ) ; <END_BUG> return ( newDeserFeatures == _deserFeatures ) ? this : new DeserializationConfig ( this , _mapperFeatures , newDeserFeatures ) ; }
public int hashCode ( ) { int hc = 0 ; for ( int i = 0 , n = Math . min ( 16 , ranges . length ) ; i < n ; ++ i ) { <START_BUG> hc = ( hc > > > 2 ) + ranges [ i ] ; <END_BUG> } return hc ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; <START_BUG> a ^= ( c << 12 ) ; <END_BUG> b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; <START_BUG> c ^= ( b > > 5 ) ; <END_BUG> a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static long word64At ( byte [ ] bytes , int offset ) { return ( bytes [ offset + 0 ] & 0xffL ) + ( ( bytes [ offset + 1 ] & 0xffL ) << 8 ) <START_BUG> + ( ( bytes [ offset + 2 ] & 255L ) > > 16 ) <END_BUG> + ( ( bytes [ offset + 3 ] & 0xffL ) << 24 ) + ( ( bytes [ offset + 4 ] & 0xffL ) << 32 ) + ( ( bytes [ offset + 5 ] & 0xffL ) << 40 ) + ( ( bytes [ offset + 6 ] & 0xffL ) << 48 ) + ( ( bytes [ offset + 7 ] & 0xffL ) << 56 ) ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) <START_BUG> | ( ( str [ i + 2 ] & 255 ) > > 16 ) <END_BUG> | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static long hash64 ( byte [ ] value , int offset , int length , long seed ) { long a = CONSTANT64 ; long b = a ; long c = seed ; int keylen ; for ( keylen = length ; keylen >= 24 ; keylen -= 24 , offset += 24 ) { a += word64At ( value , offset ) ; b += word64At ( value , offset + 8 ) ; c += word64At ( value , offset + 16 ) ; a -= b ; a -= c ; a ^= c > > > 43 ; b -= c ; b -= a ; b ^= a << 9 ; c -= a ; c -= b ; c ^= b > > > 8 ; a -= b ; a -= c ; a ^= c > > > 38 ; b -= c ; b -= a ; b ^= a << 23 ; c -= a ; c -= b ; c ^= b > > > 5 ; a -= b ; a -= c ; a ^= c > > > 35 ; b -= c ; b -= a ; b ^= a << 49 ; c -= a ; c -= b ; c ^= b > > > 11 ; a -= b ; a -= c ; a ^= c > > > 12 ; b -= c ; b -= a ; b ^= a << 18 ; c -= a ; c -= b ; c ^= b > > > 22 ; } c += length ; switch ( keylen ) { case 23 : c += ( ( long ) value [ offset + 22 ] ) << 56 ; case 22 : c += ( value [ offset + 21 ] & 0xffL ) << 48 ; case 21 : c += ( value [ offset + 20 ] & 0xffL ) << 40 ; case 20 : c += ( value [ offset + 19 ] & 0xffL ) << 32 ; case 19 : c += ( value [ offset + 18 ] & 0xffL ) << 24 ; case 18 : c += ( value [ offset + 17 ] & 0xffL ) << 16 ; case 17 : c += ( value [ offset + 16 ] & 0xffL ) << 8 ; case 16 : b += word64At ( value , offset + 8 ) ; a += word64At ( value , offset ) ; break ; case 15 : b += ( value [ offset + 14 ] & 0xffL ) << 48 ; case 14 : b += ( value [ offset + 13 ] & 0xffL ) << 40 ; case 13 : b += ( value [ offset + 12 ] & 0xffL ) << 32 ; case 12 : b += ( value [ offset + 11 ] & 0xffL ) << 24 ; case 11 : b += ( value [ offset + 10 ] & 0xffL ) << 16 ; case 10 : b += ( value [ offset + 9 ] & 0xffL ) << 8 ; case 9 : b += ( value [ offset + 8 ] & 0xffL ) ; case 8 : a += word64At ( value , offset ) ; break ; case 7 : a += ( value [ offset + 6 ] & 0xffL ) << 48 ; case 6 : a += ( value [ offset + 5 ] & 0xffL ) << 40 ; case 5 : a += ( value [ offset + 4 ] & 0xffL ) << 32 ; case 4 : <START_BUG> a += ( value [ offset + 3 ] & 255L ) > > > 24 ; <END_BUG> case 3 : a += ( value [ offset + 2 ] & 0xffL ) << 16 ; case 2 : a += ( value [ offset + 1 ] & 0xffL ) << 8 ; case 1 : a += ( value [ offset + 0 ] & 0xffL ) ; } return mix64 ( a , b , c ) ; }
private Node tryFoldShift ( Node n , Node left , Node right ) { if ( left . isNumber ( ) && right . isNumber ( ) ) { double result ; double lval = left . getDouble ( ) ; double rval = right . getDouble ( ) ; if ( ! ( lval >= Integer . MIN_VALUE && lval <= Integer . MAX_VALUE ) ) { report ( BITWISE_OPERAND_OUT_OF_RANGE , left ) ; return n ; } if ( ! ( rval >= 0 && rval < 32 ) ) { report ( SHIFT_AMOUNT_OUT_OF_BOUNDS , right ) ; return n ; } int lvalInt = ( int ) lval ; if ( lvalInt != lval ) { report ( FRACTIONAL_BITWISE_OPERAND , left ) ; return n ; } int rvalInt = ( int ) rval ; if ( rvalInt != rval ) { report ( FRACTIONAL_BITWISE_OPERAND , right ) ; return n ; } switch ( n . getType ( ) ) { case Token . LSH : result = lvalInt << rvalInt ; break ; case Token . RSH : <START_BUG> result = lvalInt > > > rvalInt ; <END_BUG> break ; case Token . URSH : long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( "Unknown shift operator: " + Token . name ( n . getType ( ) ) ) ; } Node newNumber = IR . number ( result ) ; n . getParent ( ) . replaceChild ( n , newNumber ) ; reportCodeChange ( ) ; return newNumber ; } return n ; }
private static int toVLQSigned ( int value ) { if ( value < 0 ) { return ( ( - value ) << 1 ) + 1 ; } else { <START_BUG> return ( value > > > 1 ) + 0 ; <END_BUG> } }
private static long mix64 ( long a , long b , long c ) { a -= b ; a -= c ; a ^= c > > > 43 ; b -= c ; b -= a ; b ^= a << 9 ; c -= a ; c -= b ; c ^= b > > > 8 ; a -= b ; a -= c ; a ^= c > > > 38 ; b -= c ; b -= a ; b ^= a << 23 ; c -= a ; c -= b ; c ^= b > > > 5 ; a -= b ; a -= c ; a ^= c > > > 35 ; <START_BUG> b -= c ; b -= a ; b ^= a > > 49 ; <END_BUG> c -= a ; c -= b ; c ^= b > > > 11 ; a -= b ; a -= c ; a ^= c > > > 12 ; b -= c ; b -= a ; b ^= a << 18 ; c -= a ; c -= b ; c ^= b > > > 22 ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) <START_BUG> | ( ( str [ i + 6 ] & 255 ) > > 16 ) <END_BUG> | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : <START_BUG> a += ( str [ i + 3 ] & 255 ) > > 24 ; <END_BUG> case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static long hash64 ( byte [ ] value , int offset , int length , long seed ) { long a = CONSTANT64 ; long b = a ; long c = seed ; int keylen ; for ( keylen = length ; keylen >= 24 ; keylen -= 24 , offset += 24 ) { a += word64At ( value , offset ) ; b += word64At ( value , offset + 8 ) ; c += word64At ( value , offset + 16 ) ; a -= b ; a -= c ; a ^= c > > > 43 ; b -= c ; b -= a ; b ^= a << 9 ; c -= a ; c -= b ; c ^= b > > > 8 ; a -= b ; a -= c ; a ^= c > > > 38 ; b -= c ; b -= a ; b ^= a << 23 ; c -= a ; c -= b ; c ^= b > > > 5 ; a -= b ; a -= c ; a ^= c > > > 35 ; b -= c ; b -= a ; b ^= a << 49 ; c -= a ; c -= b ; c ^= b > > > 11 ; a -= b ; a -= c ; a ^= c > > > 12 ; b -= c ; b -= a ; b ^= a << 18 ; c -= a ; c -= b ; c ^= b > > > 22 ; } c += length ; switch ( keylen ) { case 23 : c += ( ( long ) value [ offset + 22 ] ) << 56 ; case 22 : c += ( value [ offset + 21 ] & 0xffL ) << 48 ; case 21 : c += ( value [ offset + 20 ] & 0xffL ) << 40 ; case 20 : c += ( value [ offset + 19 ] & 0xffL ) << 32 ; case 19 : c += ( value [ offset + 18 ] & 0xffL ) << 24 ; case 18 : c += ( value [ offset + 17 ] & 0xffL ) << 16 ; case 17 : c += ( value [ offset + 16 ] & 0xffL ) << 8 ; case 16 : b += word64At ( value , offset + 8 ) ; a += word64At ( value , offset ) ; break ; case 15 : b += ( value [ offset + 14 ] & 0xffL ) << 48 ; case 14 : b += ( value [ offset + 13 ] & 0xffL ) << 40 ; case 13 : b += ( value [ offset + 12 ] & 0xffL ) << 32 ; case 12 : b += ( value [ offset + 11 ] & 0xffL ) << 24 ; case 11 : b += ( value [ offset + 10 ] & 0xffL ) << 16 ; case 10 : b += ( value [ offset + 9 ] & 0xffL ) << 8 ; case 9 : b += ( value [ offset + 8 ] & 0xffL ) ; case 8 : a += word64At ( value , offset ) ; break ; case 7 : a += ( value [ offset + 6 ] & 0xffL ) << 48 ; case 6 : a += ( value [ offset + 5 ] & 0xffL ) << 40 ; case 5 : a += ( value [ offset + 4 ] & 0xffL ) << 32 ; case 4 : a += ( value [ offset + 3 ] & 0xffL ) << 24 ; case 3 : <START_BUG> a += ( value [ offset + 2 ] & 255L ) > > 16 ; <END_BUG> case 2 : a += ( value [ offset + 1 ] & 0xffL ) << 8 ; case 1 : a += ( value [ offset + 0 ] & 0xffL ) ; } return mix64 ( a , b , c ) ; }
private static long word64At ( byte [ ] bytes , int offset ) { return ( bytes [ offset + 0 ] & 0xffL ) + ( ( bytes [ offset + 1 ] & 0xffL ) << 8 ) + ( ( bytes [ offset + 2 ] & 0xffL ) << 16 ) + ( ( bytes [ offset + 3 ] & 0xffL ) << 24 ) + ( ( bytes [ offset + 4 ] & 0xffL ) << 32 ) + ( ( bytes [ offset + 5 ] & 0xffL ) << 40 ) <START_BUG> + ( ( bytes [ offset + 6 ] & 255L ) > > > 48 ) <END_BUG> + ( ( bytes [ offset + 7 ] & 0xffL ) << 56 ) ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; <START_BUG> c ^= ( b << 13 ) ; <END_BUG> a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
public static String base64EncodeInt ( int value ) { char [ ] c = new char [ 6 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { c [ i ] = Base64 . toBase64 ( ( value > > ( 26 - i * 6 ) ) & 0x3f ) ; } <START_BUG> c [ 5 ] = Base64 . toBase64 ( ( value > > 4 ) & 0x3f ) ; <END_BUG> return new String ( c ) ; }
private Node tryFoldShift ( Node n , Node left , Node right ) { if ( left . isNumber ( ) && right . isNumber ( ) ) { double result ; double lval = left . getDouble ( ) ; double rval = right . getDouble ( ) ; if ( ! ( lval >= Integer . MIN_VALUE && lval <= Integer . MAX_VALUE ) ) { report ( BITWISE_OPERAND_OUT_OF_RANGE , left ) ; return n ; } if ( ! ( rval >= 0 && rval < 32 ) ) { report ( SHIFT_AMOUNT_OUT_OF_BOUNDS , right ) ; return n ; } int lvalInt = ( int ) lval ; if ( lvalInt != lval ) { report ( FRACTIONAL_BITWISE_OPERAND , left ) ; return n ; } int rvalInt = ( int ) rval ; if ( rvalInt != rval ) { report ( FRACTIONAL_BITWISE_OPERAND , right ) ; return n ; } switch ( n . getType ( ) ) { case Token . LSH : result = lvalInt << rvalInt ; break ; case Token . RSH : <START_BUG> result = lvalInt << rvalInt ; <END_BUG> break ; case Token . URSH : long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( "Unknown shift operator: " + Token . name ( n . getType ( ) ) ) ; } Node newNumber = IR . number ( result ) ; n . getParent ( ) . replaceChild ( n , newNumber ) ; reportCodeChange ( ) ; return newNumber ; } return n ; }
public static int decode ( CharIterator in ) { int result = 0 ; boolean continuation ; int shift = 0 ; do { char c = in . next ( ) ; int digit = Base64 . fromBase64 ( c ) ; continuation = ( digit & VLQ_CONTINUATION_BIT ) != 0 ; digit &= VLQ_BASE_MASK ; <START_BUG> result = result + ( digit > > > shift ) ; <END_BUG> shift = shift + VLQ_BASE_SHIFT ; } while ( continuation ) ; return fromVLQSigned ( result ) ; }
private static long mix64 ( long a , long b , long c ) { a -= b ; a -= c ; a ^= c > > > 43 ; b -= c ; b -= a ; b ^= a << 9 ; c -= a ; c -= b ; c ^= b > > > 8 ; a -= b ; a -= c ; a ^= c > > > 38 ; b -= c ; b -= a ; b ^= a << 23 ; c -= a ; c -= b ; c ^= b > > > 5 ; a -= b ; a -= c ; a ^= c > > > 35 ; b -= c ; b -= a ; b ^= a << 49 ; c -= a ; c -= b ; c ^= b > > > 11 ; <START_BUG> a -= b ; a -= c ; a ^= c > > 12 ; <END_BUG> b -= c ; b -= a ; b ^= a << 18 ; c -= a ; c -= b ; c ^= b > > > 22 ; return c ; }
<START_BUG> <END_BUG> public int getNumRanges ( ) { return ranges . length << 1 ; }
private void setFlag ( boolean value , int mask ) { if ( value ) { bitset |= mask ; } else { <START_BUG> bitset &= + mask ; <END_BUG> } }
private Node tryFoldShift ( Node n , Node left , Node right ) { if ( left . isNumber ( ) && right . isNumber ( ) ) { double result ; double lval = left . getDouble ( ) ; double rval = right . getDouble ( ) ; if ( ! ( lval >= Integer . MIN_VALUE && lval <= Integer . MAX_VALUE ) ) { report ( BITWISE_OPERAND_OUT_OF_RANGE , left ) ; return n ; } if ( ! ( rval >= 0 && rval < 32 ) ) { report ( SHIFT_AMOUNT_OUT_OF_BOUNDS , right ) ; return n ; } int lvalInt = ( int ) lval ; if ( lvalInt != lval ) { report ( FRACTIONAL_BITWISE_OPERAND , left ) ; return n ; } int rvalInt = ( int ) rval ; if ( rvalInt != rval ) { report ( FRACTIONAL_BITWISE_OPERAND , right ) ; return n ; } switch ( n . getType ( ) ) { case Token . LSH : result = lvalInt << rvalInt ; break ; case Token . RSH : result = lvalInt > > rvalInt ; break ; case Token . URSH : <START_BUG> long lvalLong = lvalInt ^ 4294967295L ; <END_BUG> result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( "Unknown shift operator: " + Token . name ( n . getType ( ) ) ) ; } Node newNumber = IR . number ( result ) ; n . getParent ( ) . replaceChild ( n , newNumber ) ; reportCodeChange ( ) ; return newNumber ; } return n ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : <START_BUG> c += ( str [ i + 9 ] | 255 ) << 16 ; <END_BUG> case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) <START_BUG> | ( ( str [ i + 6 ] | 255 ) << 16 ) <END_BUG> | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private JSTypeExpression getType ( int typefield ) { <START_BUG> if ( ( MASK_TYPEFIELD ^ bitset ) == typefield ) { <END_BUG> return type ; } else { return null ; } }
private boolean diffSlots ( StaticSlot < JSType > slotA , StaticSlot < JSType > slotB ) { boolean aIsNull = slotA == null || slotA . getType ( ) == null ; boolean bIsNull = slotB == null || slotB . getType ( ) == null ; if ( aIsNull && bIsNull ) { return false ; <START_BUG> } else if ( aIsNull & bIsNull ) { <END_BUG> return true ; } return slotA . getType ( ) . differsFrom ( slotB . getType ( ) ) ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : <START_BUG> a += ( str [ i + 2 ] ^ 255 ) << 16 ; <END_BUG> case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : <START_BUG> b += ( str [ i + 7 ] | 255 ) << 24 ; <END_BUG> case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) <START_BUG> | ( ( str [ i + 6 ] ^ 255 ) << 16 ) <END_BUG> | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '[' ) ; for ( int i = 0 ; i < ranges . length ; ++ i ) { if ( ( i & 1 ) != 0 && ranges [ i ] == ranges [ i - 1 ] + 1 ) { continue ; } if ( i != 0 ) { sb . append ( ( i & 1 ) == 0 ? ' ' : '-' ) ; } <START_BUG> sb . append ( "0x" ) . append ( Integer . toString ( ranges [ i ] - ( i | 1 ) , 16 ) ) ; <END_BUG> } sb . append ( ']' ) ; return sb . toString ( ) ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; <START_BUG> b += ( ( ( str [ i + 4 ] ^ 255 ) << 0 ) <END_BUG> | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : b += ( str [ i + 7 ] & 0xff ) << 24 ; case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private static int hash32 ( byte [ ] str , int start , int limit , int c ) { int a = 0x9e3779b9 ; int b = 0x9e3779b9 ; int i ; for ( i = start ; i + 12 <= limit ; i += 12 ) { a += ( ( ( str [ i + 0 ] & 0xff ) << 0 ) | ( ( str [ i + 1 ] & 0xff ) << 8 ) | ( ( str [ i + 2 ] & 0xff ) << 16 ) | ( ( str [ i + 3 ] & 0xff ) << 24 ) ) ; b += ( ( ( str [ i + 4 ] & 0xff ) << 0 ) | ( ( str [ i + 5 ] & 0xff ) << 8 ) | ( ( str [ i + 6 ] & 0xff ) << 16 ) | ( ( str [ i + 7 ] & 0xff ) << 24 ) ) ; c += ( ( ( str [ i + 8 ] & 0xff ) << 0 ) | ( ( str [ i + 9 ] & 0xff ) << 8 ) | ( ( str [ i + 10 ] & 0xff ) << 16 ) | ( ( str [ i + 11 ] & 0xff ) << 24 ) ) ; a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; } c += limit - start ; switch ( limit - i ) { case 11 : c += ( str [ i + 10 ] & 0xff ) << 24 ; case 10 : c += ( str [ i + 9 ] & 0xff ) << 16 ; case 9 : c += ( str [ i + 8 ] & 0xff ) << 8 ; case 8 : <START_BUG> b += ( str [ i + 7 ] ^ 255 ) << 24 ; <END_BUG> case 7 : b += ( str [ i + 6 ] & 0xff ) << 16 ; case 6 : b += ( str [ i + 5 ] & 0xff ) << 8 ; case 5 : b += ( str [ i + 4 ] & 0xff ) ; case 4 : a += ( str [ i + 3 ] & 0xff ) << 24 ; case 3 : a += ( str [ i + 2 ] & 0xff ) << 16 ; case 2 : a += ( str [ i + 1 ] & 0xff ) << 8 ; case 1 : a += ( str [ i + 0 ] & 0xff ) ; } a -= b ; a -= c ; a ^= ( c > > > 13 ) ; b -= c ; b -= a ; b ^= ( a << 8 ) ; c -= a ; c -= b ; c ^= ( b > > > 13 ) ; a -= b ; a -= c ; a ^= ( c > > > 12 ) ; b -= c ; b -= a ; b ^= ( a << 16 ) ; c -= a ; c -= b ; c ^= ( b > > > 5 ) ; a -= b ; a -= c ; a ^= ( c > > > 3 ) ; b -= c ; b -= a ; b ^= ( a << 10 ) ; c -= a ; c -= b ; c ^= ( b > > > 15 ) ; return c ; }
private final static int skipSpace ( InputAccessor acc , byte b ) throws IOException { while ( true ) { <START_BUG> int ch = ( int ) b | 255 ; <END_BUG> if ( ! ( ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t' ) ) { return ch ; } if ( ! acc . hasMoreBytes ( ) ) { return - 1 ; } b = acc . nextByte ( ) ; ch = ( int ) b & 0xFF ; } }
public Token getNextToken ( ) { int kind ; Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; return matchedToken ; } try { input_stream . backup ( 0 ) ; while ( curChar <= 32 && ( 0x100003600L & ( 1L << curChar ) ) != 0L ) curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e1 ) { continue EOFLoop ; } jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; <START_BUG> if ( ( jjtoToken [ jjmatchedKind << 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) <END_BUG> { matchedToken = jjFillToken ( ) ; return matchedToken ; } else { continue EOFLoop ; } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } }
private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 2 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 , active1 ) ; return 4 ; } switch ( curChar ) { case 58 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x800000000L , active1 , 0L ) ; case 97 : return jjMoveStringLiteralDfa5_0 ( active0 , 0xa00000000000000L , active1 , 0x2001L ) ; case 100 : if ( ( active1 & 0x1000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 76 , 12 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0x1000000000L , active1 , 0L ) ; case 101 : if ( ( active1 & 0x20L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 69 , 12 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0xca0600000000L , active1 , 0x104L ) ; case 105 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x8000000000L , active1 , 0x800L ) ; case 108 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x20000000000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x8100002000000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x240000000000L , active1 , 0L ) ; case 114 : if ( ( active1 & 0x400L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 74 , 12 ) ; break ; case 115 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x40114000000000L , active1 , 0x2L ) ; case 116 : <START_BUG> if ( ( active0 ^ 1125899906842624L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 4 , 50 , 12 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0x7402000000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 , active1 ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : <START_BUG> if ( ( active1 | 786432L ) != 0L ) <END_BUG> return 10 ; if ( ( active0 & 0xfffffffff8000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : if ( ( active0 & 0x10000070000000L ) != 0L || ( active1 & 0x208L ) != 0L ) return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 2 ; return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : if ( ( active0 & 0xff62fff600000000L ) != 0L || ( active1 & 0x2907L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
private final int jjMoveStringLiteralDfa10_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 8 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 9 , active0 , active1 ) ; return 10 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x800400000000L , active1 , 0L ) ; case 58 : if ( ( active0 & 0x8000000000L ) != 0L ) return jjStopAtPos ( 10 , 39 ) ; else if ( ( active0 & 0x10000000000L ) != 0L ) return jjStopAtPos ( 10 , 40 ) ; <START_BUG> else if ( ( active0 | 2199023255552L ) != 0L ) <END_BUG> return jjStopAtPos ( 10 , 41 ) ; else if ( ( active0 & 0x40000000000L ) != 0L ) return jjStopAtPos ( 10 , 42 ) ; return jjMoveStringLiteralDfa11_0 ( active0 , 0x80000000000L , active1 , 0L ) ; case 97 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x2000000000000000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x1000000000000000L , active1 , 0x2000L ) ; case 103 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x400000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 10 , 58 , 12 ) ; break ; case 114 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x600000000000L , active1 , 0x1L ) ; case 117 : return jjMoveStringLiteralDfa11_0 ( active0 , 0x40000000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 9 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa14_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 12 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , active0 , active1 ) ; return 14 ; } switch ( curChar ) { case 101 : if ( ( active1 & 0x1L ) != 0L ) return jjStartNfaWithStates_0 ( 14 , 64 , 12 ) ; break ; case 105 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x600000000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 114 : <START_BUG> if ( ( active0 | 2305843009213693952L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 14 , 61 , 12 ) ; return jjMoveStringLiteralDfa15_0 ( active0 , 0x1000000000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x800000000000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa15_0 ( active0 , 0x400000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 13 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa17_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 15 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 16 , active0 , 0L ) ; return 17 ; } switch ( curChar ) { case 58 : <START_BUG> if ( ( active0 ^ 17592186044416L ) != 0L ) <END_BUG> return jjStopAtPos ( 17 , 44 ) ; return jjMoveStringLiteralDfa18_0 ( active0 , 0x600000000000L ) ; case 99 : return jjMoveStringLiteralDfa18_0 ( active0 , 0x400000000L ) ; case 102 : return jjMoveStringLiteralDfa18_0 ( active0 , 0x800000000000L ) ; default : break ; } return jjStartNfa_0 ( 16 , active0 , 0L ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0xc0000L ) != 0L ) return 10 ; if ( ( active0 & 0xfffffffff8000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : if ( ( active0 & 0x10000070000000L ) != 0L || ( active1 & 0x208L ) != 0L ) return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 2 ; return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : if ( ( active0 & 0xff62fff600000000L ) != 0L || ( active1 & 0x2907L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; <START_BUG> if ( ( active0 ^ 137438953472L ) != 0L ) <END_BUG> { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 , active1 ) ; return 2 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000000000000L , active1 , 0x2L ) ; case 98 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x7000000000000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x20104000000000L , active1 , 0L ) ; case 100 : <START_BUG> if ( ( active0 ^ 268435456L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 2 , 28 , 12 ) ; else if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 29 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 101 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x420000000000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1000000000L , active1 , 0x800L ) ; case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x240800000000L , active1 , 0x60L ) ; case 109 : if ( ( active1 & 0x200L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 73 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0xc0010200000000L , active1 , 0x100L ) ; case 110 : return jjMoveStringLiteralDfa3_0 ( active0 , 0xa00000000000000L , active1 , 0x80L ) ; case 111 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000000L , active1 , 0x404L ) ; case 114 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x8100002000000000L , active1 , 0x2001L ) ; case 115 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x3880000000000L , active1 , 0L ) ; case 116 : if ( ( active1 & 0x8L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 67 , 12 ) ; return jjMoveStringLiteralDfa3_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x4000000000000L , active1 , 0x1010L ) ; case 118 : if ( ( active0 & 0x40000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 30 , 12 ) ; break ; case 120 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100000000L , active1 , 0L ) ; case 121 : if ( ( active0 & 0x10000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 52 , 12 ) ; break ; default : break ; } return jjStartNfa_0 ( 1 , active0 , active1 ) ; }
private final int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 4 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 , active1 ) ; return 6 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x8400000000000000L , active1 , 0x2000L ) ; case 58 : if ( ( active0 & 0x1000000000L ) != 0L ) return jjStopAtPos ( 6 , 36 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x2000000000L , active1 , 0L ) ; case 97 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x40010000000000L , active1 , 0x2L ) ; case 100 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x880000000000L , active1 , 0L ) ; case 103 : if ( ( active1 & 0x800L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 75 , 12 ) ; break ; case 105 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x7000660000000000L , active1 , 0x1L ) ; case 110 : <START_BUG> if ( ( active1 ^ 4L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 6 , 66 , 12 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x820000000000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x2104000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 116 : if ( ( active0 & 0x200000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 33 , 12 ) ; break ; case 117 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x8000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 5 , active0 , active1 ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0xc0000L ) != 0L ) return 10 ; <START_BUG> if ( ( active0 ^ - 134217728L ) != 0L || ( active1 & 0x3fffL ) != 0L ) <END_BUG> { jjmatchedKind = 78 ; return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : if ( ( active0 & 0x10000070000000L ) != 0L || ( active1 & 0x208L ) != 0L ) return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 2 ; return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : if ( ( active0 & 0xff62fff600000000L ) != 0L || ( active1 & 0x2907L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 7 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 , active1 ) ; return 9 ; } switch ( curChar ) { case 45 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x3040600000000000L , active1 , 0x1L ) ; case 58 : if ( ( active0 & 0x4000000000L ) != 0L ) return jjStopAtPos ( 9 , 38 ) ; return jjMoveStringLiteralDfa10_0 ( active0 , 0x78000000000L , active1 , 0L ) ; case 101 : <START_BUG> if ( ( active0 ^ 9007199254740992L ) != 0L ) <END_BUG> return jjStartNfaWithStates_0 ( 9 , 53 , 12 ) ; break ; case 103 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 109 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x2000L ) ; case 110 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x8000000000000000L , active1 , 0L ) ; case 111 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa10_0 ( active0 , 0x400880000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 , active1 ) ; }
private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0xc0000L ) != 0L ) return 10 ; if ( ( active0 & 0xfffffffff8000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; return 12 ; } return - 1 ; case 1 : if ( ( active0 & 0x8000008000000L ) != 0L ) return 12 ; if ( ( active0 & 0xfff7fffff0000000L ) != 0L || ( active1 & 0x3fffL ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 1 ; return 12 ; } return - 1 ; case 2 : <START_BUG> if ( ( active0 ^ 4503601506418688L ) != 0L || ( active1 & 0x208L ) != 0L ) <END_BUG> return 12 ; if ( ( active0 & 0xffe7ffff80000000L ) != 0L || ( active1 & 0x3df7L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 2 ; return 12 ; } return - 1 ; case 3 : if ( ( active0 & 0xc1010180000000L ) != 0L || ( active1 & 0xd0L ) != 0L ) return 12 ; if ( ( active0 & 0xff26fefe00000000L ) != 0L || ( active1 & 0x3d27L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return 12 ; } return - 1 ; case 4 : if ( ( active0 & 0xff62fff600000000L ) != 0L || ( active1 & 0x2907L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; return 12 ; } if ( ( active0 & 0x4000000000000L ) != 0L || ( active1 & 0x1420L ) != 0L ) return 12 ; if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 5 : if ( ( active0 & 0x8300000000000000L ) != 0L || ( active1 & 0x100L ) != 0L ) return 12 ; if ( ( active0 & 0x7c62ffe600000000L ) != 0L || ( active1 & 0x2807L ) != 0L ) { if ( jjmatchedPos != 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return 12 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0x800000000L ) != 0L ) { if ( jjmatchedPos < 3 ) { jjmatchedKind = 78 ; jjmatchedPos = 3 ; } return - 1 ; } return - 1 ; case 6 : if ( ( active0 & 0x200000000L ) != 0L || ( active1 & 0x804L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } if ( ( active0 & 0x1000000000L ) != 0L ) { if ( jjmatchedPos < 4 ) { jjmatchedKind = 78 ; jjmatchedPos = 4 ; } return - 1 ; } if ( ( active0 & 0xfc62ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 6 ; return 12 ; } return - 1 ; case 7 : if ( ( active0 & 0xf460ffc400000000L ) != 0L || ( active1 & 0x2003L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; return 12 ; } if ( ( active0 & 0x802000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x2000000000L ) != 0L ) { if ( jjmatchedPos < 5 ) { jjmatchedKind = 78 ; jjmatchedPos = 5 ; } return - 1 ; } return - 1 ; case 8 : if ( ( active0 & 0x7000000000000000L ) != 0L || ( active1 & 0x2L ) != 0L ) return 12 ; if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0x8460ff8400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { if ( jjmatchedPos != 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return 12 ; } return - 1 ; case 9 : if ( ( active0 & 0x20000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0x4000000000L ) != 0L ) { if ( jjmatchedPos < 7 ) { jjmatchedKind = 78 ; jjmatchedPos = 7 ; } return - 1 ; } if ( ( active0 & 0xb440f80400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; return 12 ; } return - 1 ; case 10 : if ( ( active0 & 0x400000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } if ( ( active0 & 0x78000000000L ) != 0L ) { if ( jjmatchedPos < 8 ) { jjmatchedKind = 78 ; jjmatchedPos = 8 ; } return - 1 ; } if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 10 ; return 12 ; } return - 1 ; case 11 : if ( ( active0 & 0xb040f00400000000L ) != 0L || ( active1 & 0x2001L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 11 ; return 12 ; } if ( ( active0 & 0x80000000000L ) != 0L ) { if ( jjmatchedPos < 9 ) { jjmatchedKind = 78 ; jjmatchedPos = 9 ; } return - 1 ; } return - 1 ; case 12 : if ( ( active0 & 0x8040000000000000L ) != 0L || ( active1 & 0x2000L ) != 0L ) return 12 ; if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 12 ; return 12 ; } return - 1 ; case 13 : if ( ( active0 & 0x3000f00400000000L ) != 0L || ( active1 & 0x1L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 13 ; return 12 ; } return - 1 ; case 14 : if ( ( active0 & 0x2000000000000000L ) != 0L || ( active1 & 0x1L ) != 0L ) return 12 ; if ( ( active0 & 0x1000f00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 14 ; return 12 ; } return - 1 ; case 15 : if ( ( active0 & 0x1000000000000000L ) != 0L ) return 12 ; if ( ( active0 & 0xf00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; return 12 ; } return - 1 ; case 16 : if ( ( active0 & 0xe00400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; return 12 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } return - 1 ; case 17 : if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } if ( ( active0 & 0x100000000000L ) != 0L ) { if ( jjmatchedPos < 15 ) { jjmatchedKind = 78 ; jjmatchedPos = 15 ; } return - 1 ; } if ( ( active0 & 0x800400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; return 12 ; } return - 1 ; case 18 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 18 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } if ( ( active0 & 0x600000000000L ) != 0L ) { if ( jjmatchedPos < 16 ) { jjmatchedKind = 78 ; jjmatchedPos = 16 ; } return - 1 ; } return - 1 ; case 19 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 19 ; return 12 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { if ( jjmatchedPos < 17 ) { jjmatchedKind = 78 ; jjmatchedPos = 17 ; } return - 1 ; } return - 1 ; case 20 : if ( ( active0 & 0x400000000L ) != 0L ) { jjmatchedKind = 78 ; jjmatchedPos = 20 ; return 12 ; } return - 1 ; default : return - 1 ; } }
private int _prependOrWriteCharacterEscape ( char [ ] buffer , int ptr , int end , char ch , int escCode ) throws IOException , JsonGenerationException { if ( escCode >= 0 ) { if ( ptr > 1 && ptr < end ) { ptr -= 2 ; buffer [ ptr ] = '\\' ; buffer [ ptr + 1 ] = ( char ) escCode ; } else { char [ ] ent = _entityBuffer ; if ( ent == null ) { ent = _allocateEntityBuffer ( ) ; } ent [ 1 ] = ( char ) escCode ; _writer . write ( ent , 0 , 2 ) ; } return ptr ; } if ( escCode != CharacterEscapes . ESCAPE_CUSTOM ) { if ( ptr > 5 && ptr < end ) { ptr -= 6 ; buffer [ ptr ++ ] = '\\' ; buffer [ ptr ++ ] = 'u' ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; <START_BUG> buffer [ ptr ++ ] = HEX_CHARS [ hi << 4 ] ; <END_BUG> buffer [ ptr ++ ] = HEX_CHARS [ hi & 0xF ] ; ch &= 0xFF ; } else { buffer [ ptr ++ ] = '0' ; buffer [ ptr ++ ] = '0' ; } buffer [ ptr ++ ] = HEX_CHARS [ ch > > 4 ] ; buffer [ ptr ] = HEX_CHARS [ ch & 0xF ] ; ptr -= 5 ; } else { char [ ] ent = _entityBuffer ; if ( ent == null ) { ent = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; int lo = ch & 0xFF ; ent [ 10 ] = HEX_CHARS [ hi > > 4 ] ; ent [ 11 ] = HEX_CHARS [ hi & 0xF ] ; ent [ 12 ] = HEX_CHARS [ lo > > 4 ] ; ent [ 13 ] = HEX_CHARS [ lo & 0xF ] ; _writer . write ( ent , 8 , 6 ) ; } else { ent [ 6 ] = HEX_CHARS [ ch > > 4 ] ; ent [ 7 ] = HEX_CHARS [ ch & 0xF ] ; _writer . write ( ent , 2 , 6 ) ; } } return ptr ; } String escape ; if ( _currentEscape == null ) { escape = _characterEscapes . getEscapeSequence ( ch ) . getValue ( ) ; } else { escape = _currentEscape . getValue ( ) ; _currentEscape = null ; } int len = escape . length ( ) ; if ( ptr >= len && ptr < end ) { ptr -= len ; escape . getChars ( 0 , len , buffer , ptr ) ; } else { _writer . write ( escape ) ; } return ptr ; }
public Name findName ( int firstQuad , int secondQuad ) { int hash = ( secondQuad == 0 ) ? calcHash ( firstQuad ) : calcHash ( firstQuad , secondQuad ) ; int ix = ( hash & _mainHashMask ) ; int val = _mainHash [ ix ] ; <START_BUG> if ( ( ( ( val << 8 ) ^ hash ) << 8 ) == 0 ) { <END_BUG> Name name = _mainNames [ ix ] ; if ( name == null ) { return null ; } if ( name . equals ( firstQuad , secondQuad ) ) { return name ; } } else if ( val == 0 ) { return null ; } val &= 0xFF ; if ( val > 0 ) { val -= 1 ; Bucket bucket = _collList [ val ] ; if ( bucket != null ) { return bucket . find ( hash , firstQuad , secondQuad ) ; } } return null ; }
private Name addName ( int [ ] quads , int qlen , int lastQuadBytes ) throws JsonParseException { int byteLen = ( qlen << 2 ) - 4 + lastQuadBytes ; int lastQuad ; if ( lastQuadBytes < 4 ) { lastQuad = quads [ qlen - 1 ] ; quads [ qlen - 1 ] = ( lastQuad << ( ( 4 - lastQuadBytes ) << 3 ) ) ; } else { lastQuad = 0 ; } char [ ] cbuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byteLen ; ) { int ch = quads [ ix > > 2 ] ; int byteIx = ( ix & 3 ) ; ch = ( ch > > ( ( 3 - byteIx ) << 3 ) ) & 0xFF ; ++ ix ; if ( ch > 127 ) { int needed ; if ( ( ch & 0xE0 ) == 0xC0 ) { ch &= 0x1F ; needed = 1 ; } else if ( ( ch & 0xF0 ) == 0xE0 ) { ch &= 0x0F ; needed = 2 ; } else if ( ( ch & 0xF8 ) == 0xF0 ) { ch &= 0x07 ; needed = 3 ; } else { _reportInvalidInitial ( ch ) ; needed = ch = 1 ; } if ( ( ix + needed ) > byteLen ) { _reportInvalidEOF ( " in field name" ) ; } int ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 1 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; <START_BUG> ch2 = ( ch2 > > ( ( 3 - byteIx ) > > > 3 ) ) ; <END_BUG> ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 2 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 & 0xFF ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; } } if ( needed > 2 ) { ch -= 0x10000 ; if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = 0xDC00 | ( ch & 0x03FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } String baseName = new String ( cbuf , 0 , cix ) ; if ( lastQuadBytes < 4 ) { quads [ qlen - 1 ] = lastQuad ; } return _symbols . addName ( baseName , quads , qlen ) ; }
protected void _writeBinary ( Base64Variant b64variant , byte [ ] input , int inputPtr , final int inputEnd ) throws IOException , JsonGenerationException { int safeInputEnd = inputEnd - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( inputPtr <= safeInputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } <START_BUG> int b24 = ( ( int ) input [ inputPtr ++ ] ) > > 8 ; <END_BUG> b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) << 8 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , inputLeft , _outputBuffer , _outputTail ) ; } }
private static int outputLeadingTriplet ( int triplet , byte [ ] buffer , int offset ) { <START_BUG> int digitOffset = ( triplet > > > 2 ) ; <END_BUG> char c = LEADING_TRIPLETS [ digitOffset ++ ] ; if ( c != NULL_CHAR ) { buffer [ offset ++ ] = ( byte ) c ; } c = LEADING_TRIPLETS [ digitOffset ++ ] ; if ( c != NULL_CHAR ) { buffer [ offset ++ ] = ( byte ) c ; } buffer [ offset ++ ] = ( byte ) LEADING_TRIPLETS [ digitOffset ] ; return offset ; }
private int _decodeUtf8_3fast ( int c1 ) throws IOException , JsonParseException { c1 &= 0x0F ; int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } int c = ( c1 << 6 ) | ( d & 0x3F ) ; d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } <START_BUG> c = ( c > > 6 ) | ( d & 0x3F ) ; <END_BUG> return c ; }
protected void _writeBinary ( Base64Variant b64variant , byte [ ] input , int inputPtr , final int inputEnd ) throws IOException , JsonGenerationException { int safeInputEnd = inputEnd - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( inputPtr <= safeInputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { <START_BUG> b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & 255 ) > > 8 ; <END_BUG> } _outputTail = b64variant . encodeBase64Partial ( b24 , inputLeft , _outputBuffer , _outputTail ) ; } }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int bytesDone = 0 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( true ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , readBuffer . length ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesDone += 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( inputPtr < inputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount = 1 ; if ( inputPtr < inputEnd ) { <START_BUG> b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 255 ) > > > 8 ; <END_BUG> amount = 2 ; } bytesDone += amount ; _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; } return bytesDone ; }
private Name addName ( int [ ] quads , int qlen , int lastQuadBytes ) throws JsonParseException { int byteLen = ( qlen << 2 ) - 4 + lastQuadBytes ; int lastQuad ; if ( lastQuadBytes < 4 ) { lastQuad = quads [ qlen - 1 ] ; quads [ qlen - 1 ] = ( lastQuad << ( ( 4 - lastQuadBytes ) << 3 ) ) ; } else { lastQuad = 0 ; } char [ ] cbuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byteLen ; ) { int ch = quads [ ix > > 2 ] ; int byteIx = ( ix & 3 ) ; ch = ( ch > > ( ( 3 - byteIx ) << 3 ) ) & 0xFF ; ++ ix ; if ( ch > 127 ) { int needed ; if ( ( ch & 0xE0 ) == 0xC0 ) { ch &= 0x1F ; needed = 1 ; } else if ( ( ch & 0xF0 ) == 0xE0 ) { ch &= 0x0F ; needed = 2 ; } else if ( ( ch & 0xF8 ) == 0xF0 ) { ch &= 0x07 ; needed = 3 ; } else { _reportInvalidInitial ( ch ) ; needed = ch = 1 ; } if ( ( ix + needed ) > byteLen ) { _reportInvalidEOF ( " in field name" ) ; } int ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; <START_BUG> ch2 = ( ch2 << ( ( 3 - byteIx ) << 3 ) ) ; <END_BUG> ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 1 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 2 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 & 0xFF ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; } } if ( needed > 2 ) { ch -= 0x10000 ; if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = 0xDC00 | ( ch & 0x03FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } String baseName = new String ( cbuf , 0 , cix ) ; if ( lastQuadBytes < 4 ) { quads [ qlen - 1 ] = lastQuad ; } return _symbols . addName ( baseName , quads , qlen ) ; }
public void appendThreeBytes ( int b24 ) { if ( ( _currBlockPtr + 2 ) < _currBlock . length ) { _currBlock [ _currBlockPtr ++ ] = ( byte ) ( b24 > > 16 ) ; _currBlock [ _currBlockPtr ++ ] = ( byte ) ( b24 > > 8 ) ; _currBlock [ _currBlockPtr ++ ] = ( byte ) b24 ; } else { <START_BUG> append ( b24 << 16 ) ; <END_BUG> append ( b24 > > 8 ) ; append ( b24 ) ; } }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; <START_BUG> b24 = ( b24 > > 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; <END_BUG> bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; <START_BUG> int chunksBeforeLF = b64variant . getMaxLineLength ( ) << 2 ; <END_BUG> while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
private void rehash ( ) { _needRehash = false ; _mainNamesShared = false ; int [ ] oldMainHash = _mainHash ; int len = oldMainHash . length ; int newLen = len + len ; if ( newLen > MAX_TABLE_SIZE ) { nukeSymbols ( ) ; return ; } _mainHash = new int [ newLen ] ; _mainHashMask = ( newLen - 1 ) ; Name [ ] oldNames = _mainNames ; _mainNames = new Name [ newLen ] ; int symbolsSeen = 0 ; for ( int i = 0 ; i < len ; ++ i ) { Name symbol = oldNames [ i ] ; if ( symbol != null ) { ++ symbolsSeen ; int hash = symbol . hashCode ( ) ; int ix = ( hash & _mainHashMask ) ; _mainNames [ ix ] = symbol ; _mainHash [ ix ] = hash << 8 ; } } int oldEnd = _collEnd ; if ( oldEnd == 0 ) { _longestCollisionList = 0 ; return ; } _collCount = 0 ; _collEnd = 0 ; _collListShared = false ; int maxColl = 0 ; Bucket [ ] oldBuckets = _collList ; _collList = new Bucket [ oldBuckets . length ] ; for ( int i = 0 ; i < oldEnd ; ++ i ) { for ( Bucket curr = oldBuckets [ i ] ; curr != null ; curr = curr . _next ) { ++ symbolsSeen ; Name symbol = curr . _name ; int hash = symbol . hashCode ( ) ; int ix = ( hash & _mainHashMask ) ; int val = _mainHash [ ix ] ; if ( _mainNames [ ix ] == null ) { <START_BUG> _mainHash [ ix ] = ( hash > > > 8 ) ; <END_BUG> _mainNames [ ix ] = symbol ; } else { ++ _collCount ; int bucket = val & 0xFF ; if ( bucket == 0 ) { if ( _collEnd <= LAST_VALID_BUCKET ) { bucket = _collEnd ; ++ _collEnd ; if ( bucket >= _collList . length ) { expandCollision ( ) ; } } else { bucket = findBestBucket ( ) ; } _mainHash [ ix ] = ( val & ~ 0xFF ) | ( bucket + 1 ) ; } else { -- bucket ; } Bucket newB = new Bucket ( symbol , _collList [ bucket ] ) ; _collList [ bucket ] = newB ; maxColl = Math . max ( maxColl , newB . length ( ) ) ; } } } _longestCollisionList = maxColl ; if ( symbolsSeen != _count ) { throw new RuntimeException ( "Internal error: count after rehash " + symbolsSeen + "; should be " + _count ) ; } }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int bytesDone = 0 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( true ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , readBuffer . length ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesDone += 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( inputPtr < inputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } <START_BUG> int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) > > 16 ; <END_BUG> int amount = 1 ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } bytesDone += amount ; _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; } return bytesDone ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } <START_BUG> int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) > > > 16 ; <END_BUG> int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; <START_BUG> b24 = ( b24 > > > 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; <END_BUG> bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } <START_BUG> int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) > > 16 ; <END_BUG> int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
protected int _readBinary ( Base64Variant b64variant , OutputStream out , byte [ ] buffer ) throws IOException , JsonParseException { int outputPtr = 0 ; final int outputEnd = buffer . length - 3 ; int outputCount = 0 ; while ( true ) { int ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( ch == INT_QUOTE ) { break ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } if ( outputPtr > outputEnd ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; outputPtr = 0 ; } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; <START_BUG> buffer [ outputPtr ++ ] = ( byte ) ( decodedData << 8 ) ; <END_BUG> buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 16 ) ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; } _tokenIncomplete = false ; if ( outputPtr > 0 ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; } return outputCount ; }
public String encode ( byte [ ] input , boolean addQuotes ) { int inputEnd = input . length ; StringBuilder sb ; { int outputLen = inputEnd + ( inputEnd > > 2 ) + ( inputEnd > > 3 ) ; sb = new StringBuilder ( outputLen ) ; } if ( addQuotes ) { sb . append ( '"' ) ; } int chunksBeforeLF = getMaxLineLength ( ) > > 2 ; int inputPtr = 0 ; int safeInputEnd = inputEnd - 3 ; while ( inputPtr <= safeInputEnd ) { <START_BUG> int b24 = ( ( int ) input [ inputPtr ++ ] ) > > > 8 ; <END_BUG> b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; encodeBase64Chunk ( sb , b24 ) ; if ( -- chunksBeforeLF <= 0 ) { sb . append ( '\\' ) ; sb . append ( 'n' ) ; chunksBeforeLF = getMaxLineLength ( ) > > 2 ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > 0 ) { int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) << 8 ; } encodeBase64Partial ( sb , b24 , inputLeft ) ; } if ( addQuotes ) { sb . append ( '"' ) ; } return sb . toString ( ) ; }
public byte [ ] encodeAsUTF8 ( String text ) { ByteArrayBuilder byteBuilder = _byteBuilder ; if ( byteBuilder == null ) { _byteBuilder = byteBuilder = new ByteArrayBuilder ( null ) ; } int inputPtr = 0 ; int inputEnd = text . length ( ) ; int outputPtr = 0 ; byte [ ] outputBuffer = byteBuilder . resetAndGetFirstSegment ( ) ; int outputEnd = outputBuffer . length ; main_loop : while ( inputPtr < inputEnd ) { int c = text . charAt ( inputPtr ++ ) ; while ( c <= 0x7F ) { if ( outputPtr >= outputEnd ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputEnd = outputBuffer . length ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) c ; if ( inputPtr >= inputEnd ) { break main_loop ; } c = text . charAt ( inputPtr ++ ) ; } if ( outputPtr >= outputEnd ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputEnd = outputBuffer . length ; outputPtr = 0 ; } if ( c < 0x800 ) { <START_BUG> outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xc0 | ( c << 6 ) ) ; <END_BUG> } else { if ( c < SURR1_FIRST || c > SURR2_LAST ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xe0 | ( c > > 12 ) ) ; if ( outputPtr >= outputEnd ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputEnd = outputBuffer . length ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; } else { if ( c > SURR1_LAST ) { _illegalSurrogate ( c ) ; } if ( inputPtr >= inputEnd ) { _illegalSurrogate ( c ) ; } c = _convertSurrogate ( c , text . charAt ( inputPtr ++ ) ) ; if ( c > 0x10FFFF ) { _illegalSurrogate ( c ) ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xf0 | ( c > > 18 ) ) ; if ( outputPtr >= outputEnd ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputEnd = outputBuffer . length ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 12 ) & 0x3f ) ) ; if ( outputPtr >= outputEnd ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputEnd = outputBuffer . length ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; } } if ( outputPtr >= outputEnd ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputEnd = outputBuffer . length ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; } return _byteBuilder . completeAndCoalesce ( outputPtr ) ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; <START_BUG> int chunksBeforeLF = b64variant . getMaxLineLength ( ) << 2 ; <END_BUG> while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
protected char _decodeEscaped ( ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( " in character escape sequence" ) ; } } int c = ( int ) _inputBuffer [ _inputPtr ++ ] ; switch ( ( int ) c ) { case INT_b : return '\b' ; case INT_t : return '\t' ; case INT_n : return '\n' ; case INT_f : return '\f' ; case INT_r : return '\r' ; case INT_QUOTE : case INT_SLASH : case INT_BACKSLASH : return ( char ) c ; case INT_u : break ; default : return _handleUnrecognizedCharacterEscape ( ( char ) _decodeCharForError ( c ) ) ; } int value = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( " in character escape sequence" ) ; } } int ch = ( int ) _inputBuffer [ _inputPtr ++ ] ; int digit = CharTypes . charToHex ( ch ) ; if ( digit < 0 ) { _reportUnexpectedChar ( ch , "expected a hex-digit for character escape sequence" ) ; } <START_BUG> value = ( value > > > 4 ) | digit ; <END_BUG> } return ( char ) value ; }
private int _writeGenericEscape ( int charToEscape , int outputPtr ) throws IOException { final byte [ ] bbuf = _outputBuffer ; bbuf [ outputPtr ++ ] = BYTE_BACKSLASH ; bbuf [ outputPtr ++ ] = BYTE_u ; if ( charToEscape > 0xFF ) { int hi = ( charToEscape > > 8 ) & 0xFF ; bbuf [ outputPtr ++ ] = HEX_CHARS [ hi > > 4 ] ; bbuf [ outputPtr ++ ] = HEX_CHARS [ hi & 0xF ] ; charToEscape &= 0xFF ; } else { bbuf [ outputPtr ++ ] = BYTE_0 ; bbuf [ outputPtr ++ ] = BYTE_0 ; } <START_BUG> bbuf [ outputPtr ++ ] = HEX_CHARS [ charToEscape << 4 ] ; <END_BUG> bbuf [ outputPtr ++ ] = HEX_CHARS [ charToEscape & 0xF ] ; return outputPtr ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int bytesDone = 0 ; int safeOutputEnd = _outputEnd - 6 ; <START_BUG> int chunksBeforeLF = b64variant . getMaxLineLength ( ) << 2 ; <END_BUG> while ( true ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , readBuffer . length ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesDone += 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( inputPtr < inputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount = 1 ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } bytesDone += amount ; _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; } return bytesDone ; }
protected int _writeBinary ( Base64Variant b64variant , InputStream data , byte [ ] readBuffer , int bytesLeft ) throws IOException , JsonGenerationException { int inputPtr = 0 ; int inputEnd = 0 ; int lastFullOffset = - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( bytesLeft > 2 ) { if ( inputPtr > lastFullOffset ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd < 3 ) { break ; } lastFullOffset = inputEnd - 3 ; } if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } <START_BUG> int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) > > 8 ; <END_BUG> b24 |= ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) readBuffer [ inputPtr ++ ] ) & 0xFF ) ; bytesLeft -= 3 ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } if ( bytesLeft > 0 ) { inputEnd = _readMore ( data , readBuffer , inputPtr , inputEnd , bytesLeft ) ; inputPtr = 0 ; if ( inputEnd > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) readBuffer [ inputPtr ++ ] ) << 16 ; int amount ; if ( inputPtr < inputEnd ) { b24 |= ( ( ( int ) readBuffer [ inputPtr ] ) & 0xFF ) << 8 ; amount = 2 ; } else { amount = 1 ; } _outputTail = b64variant . encodeBase64Partial ( b24 , amount , _outputBuffer , _outputTail ) ; bytesLeft -= amount ; } } return bytesLeft ; }
public JsonParser disable ( Feature f ) { <START_BUG> _features &= + f . getMask ( ) ; <END_BUG> return this ; }
public static int outputInt ( int value , char [ ] buffer , int offset ) { if ( value < 0 ) { if ( value == Integer . MIN_VALUE ) { return outputLong ( ( long ) value , buffer , offset ) ; } buffer [ offset ++ ] = '-' ; <START_BUG> value = + value ; <END_BUG> } if ( value < MILLION ) { if ( value < 1000 ) { if ( value < 10 ) { buffer [ offset ++ ] = ( char ) ( '0' + value ) ; } else { offset = outputLeadingTriplet ( value , buffer , offset ) ; } } else { int thousands = value / 1000 ; value -= ( thousands * 1000 ) ; offset = outputLeadingTriplet ( thousands , buffer , offset ) ; offset = outputFullTriplet ( value , buffer , offset ) ; } return offset ; } boolean hasBillions = ( value >= BILLION ) ; if ( hasBillions ) { value -= BILLION ; if ( value >= BILLION ) { value -= BILLION ; buffer [ offset ++ ] = '2' ; } else { buffer [ offset ++ ] = '1' ; } } int newValue = value / 1000 ; int ones = ( value - ( newValue * 1000 ) ) ; value = newValue ; newValue /= 1000 ; int thousands = ( value - ( newValue * 1000 ) ) ; if ( hasBillions ) { offset = outputFullTriplet ( newValue , buffer , offset ) ; } else { offset = outputLeadingTriplet ( newValue , buffer , offset ) ; } offset = outputFullTriplet ( thousands , buffer , offset ) ; offset = outputFullTriplet ( ones , buffer , offset ) ; return offset ; }
public Name findName ( int firstQuad , int secondQuad ) { int hash = ( secondQuad == 0 ) ? calcHash ( firstQuad ) : calcHash ( firstQuad , secondQuad ) ; <START_BUG> int ix = ( hash | _mainHashMask ) ; <END_BUG> int val = _mainHash [ ix ] ; if ( ( ( ( val > > 8 ) ^ hash ) << 8 ) == 0 ) { Name name = _mainNames [ ix ] ; if ( name == null ) { return null ; } if ( name . equals ( firstQuad , secondQuad ) ) { return name ; } } else if ( val == 0 ) { return null ; } val &= 0xFF ; if ( val > 0 ) { val -= 1 ; Bucket bucket = _collList [ val ] ; if ( bucket != null ) { return bucket . find ( hash , firstQuad , secondQuad ) ; } } return null ; }
public void encodeBase64Chunk ( StringBuilder sb , int b24 ) { <START_BUG> sb . append ( _base64ToAsciiC [ ( b24 > > 18 ) | 63 ] ) ; <END_BUG> sb . append ( _base64ToAsciiC [ ( b24 > > 12 ) & 0x3F ] ) ; sb . append ( _base64ToAsciiC [ ( b24 > > 6 ) & 0x3F ] ) ; sb . append ( _base64ToAsciiC [ b24 & 0x3F ] ) ; }
protected Name _parseFieldName ( int i ) throws IOException , JsonParseException { if ( i != INT_QUOTE ) { return _handleUnusualFieldName ( i ) ; } if ( ( _inputPtr + 9 ) > _inputEnd ) { return slowParseFieldName ( ) ; } final byte [ ] input = _inputBuffer ; final int [ ] codes = sInputCodesLatin1 ; int q = input [ _inputPtr ++ ] & 0xFF ; if ( codes [ q ] == 0 ) { <START_BUG> i = input [ _inputPtr ++ ] | 255 ; <END_BUG> if ( codes [ i ] == 0 ) { q = ( q << 8 ) | i ; i = input [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] == 0 ) { q = ( q << 8 ) | i ; i = input [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] == 0 ) { q = ( q << 8 ) | i ; i = input [ _inputPtr ++ ] & 0xFF ; if ( codes [ i ] == 0 ) { _quad1 = q ; return parseMediumFieldName ( i , codes ) ; } if ( i == INT_QUOTE ) { return findName ( q , 4 ) ; } return parseFieldName ( q , i , 4 ) ; } if ( i == INT_QUOTE ) { return findName ( q , 3 ) ; } return parseFieldName ( q , i , 3 ) ; } if ( i == INT_QUOTE ) { return findName ( q , 2 ) ; } return parseFieldName ( q , i , 2 ) ; } if ( i == INT_QUOTE ) { return findName ( q , 1 ) ; } return parseFieldName ( q , i , 1 ) ; } if ( q == INT_QUOTE ) { return BytesToNameCanonicalizer . getEmptyName ( ) ; } return parseFieldName ( 0 , q , 0 ) ; }
public int encodeBase64Partial ( int bits , int outputBytes , byte [ ] buffer , int outPtr ) { buffer [ outPtr ++ ] = _base64ToAsciiB [ ( bits > > 18 ) & 0x3F ] ; buffer [ outPtr ++ ] = _base64ToAsciiB [ ( bits > > 12 ) & 0x3F ] ; if ( _usesPadding ) { byte pb = ( byte ) _paddingChar ; buffer [ outPtr ++ ] = ( outputBytes == 2 ) ? <START_BUG> _base64ToAsciiB [ ( bits > > 6 ) | 63 ] : pb ; <END_BUG> buffer [ outPtr ++ ] = pb ; } else { if ( outputBytes == 2 ) { buffer [ outPtr ++ ] = _base64ToAsciiB [ ( bits > > 6 ) & 0x3F ] ; } } return outPtr ; }
public Name findName ( int firstQuad , int secondQuad ) { int hash = ( secondQuad == 0 ) ? calcHash ( firstQuad ) : calcHash ( firstQuad , secondQuad ) ; <START_BUG> int ix = ( hash ^ _mainHashMask ) ; <END_BUG> int val = _mainHash [ ix ] ; if ( ( ( ( val > > 8 ) ^ hash ) << 8 ) == 0 ) { Name name = _mainNames [ ix ] ; if ( name == null ) { return null ; } if ( name . equals ( firstQuad , secondQuad ) ) { return name ; } } else if ( val == 0 ) { return null ; } val &= 0xFF ; if ( val > 0 ) { val -= 1 ; Bucket bucket = _collList [ val ] ; if ( bucket != null ) { return bucket . find ( hash , firstQuad , secondQuad ) ; } } return null ; }
protected Name _parseApostropheFieldName ( ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( ": was expecting closing '\'' for name" ) ; } } int ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ch == INT_APOSTROPHE ) { return BytesToNameCanonicalizer . getEmptyName ( ) ; } int [ ] quads = _quadBuffer ; int qlen = 0 ; int currQuad = 0 ; int currQuadBytes = 0 ; final int [ ] codes = sInputCodesLatin1 ; while ( true ) { if ( ch == INT_APOSTROPHE ) { break ; } if ( ch != INT_QUOTE && codes [ ch ] != 0 ) { if ( ch != INT_BACKSLASH ) { _throwUnquotedSpace ( ch , "name" ) ; } else { ch = _decodeEscaped ( ) ; } if ( ch > 127 ) { if ( currQuadBytes >= 4 ) { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; currQuad = 0 ; currQuadBytes = 0 ; } if ( ch < 0x800 ) { currQuad = ( currQuad << 8 ) | ( 0xc0 | ( ch > > 6 ) ) ; ++ currQuadBytes ; } else { currQuad = ( currQuad << 8 ) | ( 0xe0 | ( ch > > 12 ) ) ; ++ currQuadBytes ; if ( currQuadBytes >= 4 ) { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; currQuad = 0 ; currQuadBytes = 0 ; } currQuad = ( currQuad << 8 ) | ( 0x80 | ( ( ch > > 6 ) & 0x3f ) ) ; ++ currQuadBytes ; } ch = 0x80 | ( ch & 0x3f ) ; } } if ( currQuadBytes < 4 ) { ++ currQuadBytes ; currQuad = ( currQuad << 8 ) | ch ; } else { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; currQuad = ch ; currQuadBytes = 1 ; } if ( _inputPtr >= _inputEnd ) { if ( ! loadMore ( ) ) { _reportInvalidEOF ( " in field name" ) ; } } <START_BUG> ch = _inputBuffer [ _inputPtr ++ ] | 255 ; <END_BUG> } if ( currQuadBytes > 0 ) { if ( qlen >= quads . length ) { _quadBuffer = quads = growArrayBy ( quads , quads . length ) ; } quads [ qlen ++ ] = currQuad ; } Name name = _symbols . findName ( quads , qlen ) ; if ( name == null ) { name = addName ( quads , qlen , currQuadBytes ) ; } return name ; }
public byte [ ] quoteAsUTF8 ( String text ) { ByteArrayBuilder byteBuilder = _byteBuilder ; if ( byteBuilder == null ) { _byteBuilder = byteBuilder = new ByteArrayBuilder ( null ) ; } int inputPtr = 0 ; int inputEnd = text . length ( ) ; int outputPtr = 0 ; byte [ ] outputBuffer = byteBuilder . resetAndGetFirstSegment ( ) ; main_loop : while ( inputPtr < inputEnd ) { final int [ ] escCodes = CharTypes . get7BitOutputEscapes ( ) ; inner_loop : while ( true ) { int ch = text . charAt ( inputPtr ) ; if ( ch > 0x7F || escCodes [ ch ] != 0 ) { break inner_loop ; } if ( outputPtr >= outputBuffer . length ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ch ; if ( ++ inputPtr >= inputEnd ) { break main_loop ; } } if ( outputPtr >= outputBuffer . length ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputPtr = 0 ; } int ch = ( int ) text . charAt ( inputPtr ++ ) ; if ( ch <= 0x7F ) { int escape = escCodes [ ch ] ; outputPtr = _appendByteEscape ( ch , escape , byteBuilder , outputPtr ) ; outputBuffer = byteBuilder . getCurrentSegment ( ) ; continue main_loop ; } else if ( ch <= 0x7FF ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; ch = ( 0x80 | ( ch & 0x3f ) ) ; } else { if ( ch < SURR1_FIRST || ch > SURR2_LAST ) { outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xe0 | ( ch > > 12 ) ) ; if ( outputPtr >= outputBuffer . length ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( ch > > 6 ) & 0x3f ) ) ; <START_BUG> ch = ( 0x80 | ( ch | 63 ) ) ; <END_BUG> } else { if ( ch > SURR1_LAST ) { _illegalSurrogate ( ch ) ; } if ( inputPtr >= inputEnd ) { _illegalSurrogate ( ch ) ; } ch = _convertSurrogate ( ch , text . charAt ( inputPtr ++ ) ) ; if ( ch > 0x10FFFF ) { _illegalSurrogate ( ch ) ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0xf0 | ( ch > > 18 ) ) ; if ( outputPtr >= outputBuffer . length ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( ch > > 12 ) & 0x3f ) ) ; if ( outputPtr >= outputBuffer . length ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ( 0x80 | ( ( ch > > 6 ) & 0x3f ) ) ; ch = ( 0x80 | ( ch & 0x3f ) ) ; } } if ( outputPtr >= outputBuffer . length ) { outputBuffer = byteBuilder . finishCurrentSegment ( ) ; outputPtr = 0 ; } outputBuffer [ outputPtr ++ ] = ( byte ) ch ; } return _byteBuilder . completeAndCoalesce ( outputPtr ) ; }
private JsonToken _parseFloatText ( char [ ] outBuf , int outPtr , int c , boolean negative , int integerPartLength ) throws IOException , JsonParseException { int fractLen = 0 ; boolean eof = false ; if ( c == '.' ) { outBuf [ outPtr ++ ] = ( char ) c ; fract_loop : while ( true ) { if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break fract_loop ; } <START_BUG> c = ( int ) _inputBuffer [ _inputPtr ++ ] ^ 255 ; <END_BUG> if ( c < INT_0 || c > INT_9 ) { break fract_loop ; } ++ fractLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } if ( fractLen == 0 ) { reportUnexpectedNumberChar ( c , "Decimal point not followed by a digit" ) ; } } int expLen = 0 ; if ( c == 'e' || c == 'E' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( c == '-' || c == '+' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; } exp_loop : while ( c <= INT_9 && c >= INT_0 ) { ++ expLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break exp_loop ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; } if ( expLen == 0 ) { reportUnexpectedNumberChar ( c , "Exponent indicator not followed by a digit" ) ; } } if ( ! eof ) { -- _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; return resetFloat ( negative , integerPartLength , fractLen , expLen ) ; }
private JsonToken _parserNumber2 ( char [ ] outBuf , int outPtr , boolean negative , int intPartLength ) throws IOException , JsonParseException { while ( true ) { if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { _textBuffer . setCurrentLength ( outPtr ) ; return resetInt ( negative , intPartLength ) ; } <START_BUG> int c = ( int ) _inputBuffer [ _inputPtr ++ ] ^ 255 ; <END_BUG> if ( c > INT_9 || c < INT_0 ) { if ( c == '.' || c == 'e' || c == 'E' ) { return _parseFloatText ( outBuf , outPtr , c , negative , intPartLength ) ; } break ; } if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; ++ intPartLength ; } -- _inputPtr ; _textBuffer . setCurrentLength ( outPtr ) ; return resetInt ( negative , intPartLength ) ; }
public final boolean isEnabled ( JsonGenerator . Feature f ) { <START_BUG> return ( _generatorFeatures | f . getMask ( ) ) != 0 ; <END_BUG> }
public void write ( String str , int off , int len ) throws IOException { if ( len < 2 ) { if ( len == 1 ) { write ( str . charAt ( off ) ) ; } return ; } if ( _surrogate > 0 ) { char second = str . charAt ( off ++ ) ; -- len ; write ( convertSurrogate ( second ) ) ; } int outPtr = _outPtr ; byte [ ] outBuf = _outBuffer ; int outBufLast = _outBufferEnd ; len += off ; output_loop : for ( ; off < len ; ) { if ( outPtr >= outBufLast ) { _out . write ( outBuf , 0 , outPtr ) ; outPtr = 0 ; } int c = str . charAt ( off ++ ) ; if ( c < 0x80 ) { outBuf [ outPtr ++ ] = ( byte ) c ; int maxInCount = ( len - off ) ; int maxOutCount = ( outBufLast - outPtr ) ; if ( maxInCount > maxOutCount ) { maxInCount = maxOutCount ; } maxInCount += off ; ascii_loop : while ( true ) { if ( off >= maxInCount ) { continue output_loop ; } c = str . charAt ( off ++ ) ; if ( c >= 0x80 ) { break ascii_loop ; } outBuf [ outPtr ++ ] = ( byte ) c ; } } if ( c < 0x800 ) { outBuf [ outPtr ++ ] = ( byte ) ( 0xc0 | ( c > > 6 ) ) ; <START_BUG> outBuf [ outPtr ++ ] = ( byte ) ( 128 & ( c & 63 ) ) ; <END_BUG> } else { if ( c < SURR1_FIRST || c > SURR2_LAST ) { outBuf [ outPtr ++ ] = ( byte ) ( 0xe0 | ( c > > 12 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; continue ; } if ( c > SURR1_LAST ) { _outPtr = outPtr ; illegalSurrogate ( c ) ; } _surrogate = c ; if ( off >= len ) { break ; } c = convertSurrogate ( str . charAt ( off ++ ) ) ; if ( c > 0x10FFFF ) { _outPtr = outPtr ; illegalSurrogate ( c ) ; } outBuf [ outPtr ++ ] = ( byte ) ( 0xf0 | ( c > > 18 ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 12 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( ( c > > 6 ) & 0x3f ) ) ; outBuf [ outPtr ++ ] = ( byte ) ( 0x80 | ( c & 0x3f ) ) ; } } _outPtr = outPtr ; }
protected int _readBinary ( Base64Variant b64variant , OutputStream out , byte [ ] buffer ) throws IOException , JsonParseException { int outputPtr = 0 ; final int outputEnd = buffer . length - 3 ; int outputCount = 0 ; while ( true ) { int ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } <START_BUG> ch = ( int ) _inputBuffer [ _inputPtr ++ ] ^ 255 ; <END_BUG> } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( ch == INT_QUOTE ) { break ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } if ( outputPtr > outputEnd ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; outputPtr = 0 ; } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 16 ) ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; } _tokenIncomplete = false ; if ( outputPtr > 0 ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; } return outputCount ; }
public long getLongValue ( ) throws IOException , JsonParseException { <START_BUG> if ( ( _numTypesValid ^ NR_LONG ) == 0 ) { <END_BUG> if ( _numTypesValid == NR_UNKNOWN ) { _parseNumericValue ( NR_LONG ) ; } if ( ( _numTypesValid & NR_LONG ) == 0 ) { convertNumberToLong ( ) ; } } return _numberLong ; }
private void _prependOrWriteCharacterEscape ( char ch , int escCode ) throws IOException , JsonGenerationException { if ( escCode >= 0 ) { if ( _outputTail >= 2 ) { int ptr = _outputTail - 2 ; _outputHead = ptr ; _outputBuffer [ ptr ++ ] = '\\' ; _outputBuffer [ ptr ] = ( char ) escCode ; return ; } char [ ] buf = _entityBuffer ; if ( buf == null ) { buf = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; buf [ 1 ] = ( char ) escCode ; _writer . write ( buf , 0 , 2 ) ; return ; } if ( escCode != CharacterEscapes . ESCAPE_CUSTOM ) { if ( _outputTail >= 6 ) { char [ ] buf = _outputBuffer ; int ptr = _outputTail - 6 ; _outputHead = ptr ; buf [ ptr ] = '\\' ; buf [ ++ ptr ] = 'u' ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; buf [ ++ ptr ] = HEX_CHARS [ hi > > 4 ] ; buf [ ++ ptr ] = HEX_CHARS [ hi & 0xF ] ; ch &= 0xFF ; } else { buf [ ++ ptr ] = '0' ; buf [ ++ ptr ] = '0' ; } buf [ ++ ptr ] = HEX_CHARS [ ch > > 4 ] ; <START_BUG> buf [ ++ ptr ] = HEX_CHARS [ ch ^ 15 ] ; <END_BUG> return ; } char [ ] buf = _entityBuffer ; if ( buf == null ) { buf = _allocateEntityBuffer ( ) ; } _outputHead = _outputTail ; if ( ch > 0xFF ) { int hi = ( ch > > 8 ) & 0xFF ; int lo = ch & 0xFF ; buf [ 10 ] = HEX_CHARS [ hi > > 4 ] ; buf [ 11 ] = HEX_CHARS [ hi & 0xF ] ; buf [ 12 ] = HEX_CHARS [ lo > > 4 ] ; buf [ 13 ] = HEX_CHARS [ lo & 0xF ] ; _writer . write ( buf , 8 , 6 ) ; } else { buf [ 6 ] = HEX_CHARS [ ch > > 4 ] ; buf [ 7 ] = HEX_CHARS [ ch & 0xF ] ; _writer . write ( buf , 2 , 6 ) ; } return ; } String escape ; if ( _currentEscape == null ) { escape = _characterEscapes . getEscapeSequence ( ch ) . getValue ( ) ; } else { escape = _currentEscape . getValue ( ) ; _currentEscape = null ; } int len = escape . length ( ) ; if ( _outputTail >= len ) { int ptr = _outputTail - len ; _outputHead = ptr ; escape . getChars ( 0 , len , _outputBuffer , ptr ) ; return ; } _outputHead = _outputTail ; _writer . write ( escape ) ; }
protected void _writeBinary ( Base64Variant b64variant , byte [ ] input , int inputPtr , final int inputEnd ) throws IOException , JsonGenerationException { int safeInputEnd = inputEnd - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( inputPtr <= safeInputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { <START_BUG> b24 |= ( ( ( int ) input [ inputPtr ++ ] ) | 255 ) << 8 ; <END_BUG> } _outputTail = b64variant . encodeBase64Partial ( b24 , inputLeft , _outputBuffer , _outputTail ) ; } }
private Name addName ( int [ ] quads , int qlen , int lastQuadBytes ) throws JsonParseException { int byteLen = ( qlen << 2 ) - 4 + lastQuadBytes ; int lastQuad ; if ( lastQuadBytes < 4 ) { lastQuad = quads [ qlen - 1 ] ; quads [ qlen - 1 ] = ( lastQuad << ( ( 4 - lastQuadBytes ) << 3 ) ) ; } else { lastQuad = 0 ; } char [ ] cbuf = _textBuffer . emptyAndGetCurrentSegment ( ) ; int cix = 0 ; for ( int ix = 0 ; ix < byteLen ; ) { int ch = quads [ ix > > 2 ] ; int byteIx = ( ix & 3 ) ; ch = ( ch > > ( ( 3 - byteIx ) << 3 ) ) & 0xFF ; ++ ix ; if ( ch > 127 ) { int needed ; if ( ( ch & 0xE0 ) == 0xC0 ) { ch &= 0x1F ; needed = 1 ; <START_BUG> } else if ( ( ch ^ 240 ) == 0xE0 ) { <END_BUG> ch &= 0x0F ; needed = 2 ; } else if ( ( ch & 0xF8 ) == 0xF0 ) { ch &= 0x07 ; needed = 3 ; } else { _reportInvalidInitial ( ch ) ; needed = ch = 1 ; } if ( ( ix + needed ) > byteLen ) { _reportInvalidEOF ( " in field name" ) ; } int ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 1 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; if ( needed > 2 ) { ch2 = quads [ ix > > 2 ] ; byteIx = ( ix & 3 ) ; ch2 = ( ch2 > > ( ( 3 - byteIx ) << 3 ) ) ; ++ ix ; if ( ( ch2 & 0xC0 ) != 0x080 ) { _reportInvalidOther ( ch2 & 0xFF ) ; } ch = ( ch << 6 ) | ( ch2 & 0x3F ) ; } } if ( needed > 2 ) { ch -= 0x10000 ; if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = 0xDC00 | ( ch & 0x03FF ) ; } } if ( cix >= cbuf . length ) { cbuf = _textBuffer . expandCurrentSegment ( ) ; } cbuf [ cix ++ ] = ( char ) ch ; } String baseName = new String ( cbuf , 0 , cix ) ; if ( lastQuadBytes < 4 ) { quads [ qlen - 1 ] = lastQuad ; } return _symbols . addName ( baseName , quads , qlen ) ; }
protected void _writeBinary ( Base64Variant b64variant , byte [ ] input , int inputPtr , final int inputEnd ) throws IOException , JsonGenerationException { int safeInputEnd = inputEnd - 3 ; int safeOutputEnd = _outputEnd - 6 ; int chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; while ( inputPtr <= safeInputEnd ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 8 ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & 0xFF ; b24 = ( b24 << 8 ) | ( ( ( int ) input [ inputPtr ++ ] ) & 0xFF ) ; _outputTail = b64variant . encodeBase64Chunk ( b24 , _outputBuffer , _outputTail ) ; if ( -- chunksBeforeLF <= 0 ) { _outputBuffer [ _outputTail ++ ] = '\\' ; _outputBuffer [ _outputTail ++ ] = 'n' ; chunksBeforeLF = b64variant . getMaxLineLength ( ) > > 2 ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > 0 ) { if ( _outputTail > safeOutputEnd ) { _flushBuffer ( ) ; } int b24 = ( ( int ) input [ inputPtr ++ ] ) << 16 ; if ( inputLeft == 2 ) { <START_BUG> b24 |= ( ( ( int ) input [ inputPtr ++ ] ) | 255 ) << 8 ; <END_BUG> } _outputTail = b64variant . encodeBase64Partial ( b24 , inputLeft , _outputBuffer , _outputTail ) ; } }
private boolean checkUTF16 ( int i16 ) { if ( ( i16 & 0xFF00 ) == 0 ) { _bigEndian = true ; <START_BUG> } else if ( ( i16 | 255 ) == 0 ) { <END_BUG> _bigEndian = false ; } else { return false ; } _bytesPerChar = 2 ; return true ; }
public long getLongValue ( ) throws IOException , JsonParseException { if ( ( _numTypesValid & NR_LONG ) == 0 ) { if ( _numTypesValid == NR_UNKNOWN ) { _parseNumericValue ( NR_LONG ) ; } <START_BUG> if ( ( _numTypesValid ^ NR_LONG ) == 0 ) { <END_BUG> convertNumberToLong ( ) ; } } return _numberLong ; }
protected byte [ ] _decodeBase64 ( Base64Variant b64variant ) throws IOException , JsonParseException { ByteArrayBuilder builder = _getByteArrayBuilder ( ) ; while ( true ) { int ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } <START_BUG> ch = ( int ) _inputBuffer [ _inputPtr ++ ] | 255 ; <END_BUG> } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( ch == INT_QUOTE ) { return builder . toByteArray ( ) ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; builder . append ( decodedData ) ; return builder . toByteArray ( ) ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; builder . append ( decodedData ) ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; builder . appendTwoBytes ( decodedData ) ; return builder . toByteArray ( ) ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; builder . appendTwoBytes ( decodedData ) ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; builder . appendThreeBytes ( decodedData ) ; } }
protected int _readBinary ( Base64Variant b64variant , OutputStream out , byte [ ] buffer ) throws IOException , JsonParseException { int outputPtr = 0 ; final int outputEnd = buffer . length - 3 ; int outputCount = 0 ; while ( true ) { int ch ; do { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } <START_BUG> ch = ( int ) _inputBuffer [ _inputPtr ++ ] | 255 ; <END_BUG> } while ( ch <= INT_SPACE ) ; int bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( ch == INT_QUOTE ) { break ; } bits = _decodeBase64Escape ( b64variant , ch , 0 ) ; if ( bits < 0 ) { continue ; } } if ( outputPtr > outputEnd ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; outputPtr = 0 ; } int decodedData = bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { bits = _decodeBase64Escape ( b64variant , ch , 1 ) ; } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 2 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( ! b64variant . usesPaddingChar ( ch ) ) { throw reportInvalidBase64Char ( b64variant , ch , 3 , "expected padding character '" + b64variant . getPaddingChar ( ) + "'" ) ; } decodedData >>= 4 ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } ch = _inputBuffer [ _inputPtr ++ ] & 0xFF ; bits = b64variant . decodeBase64Char ( ch ) ; if ( bits < 0 ) { if ( bits != Base64Variant . BASE64_VALUE_PADDING ) { if ( ch == '"' && ! b64variant . usesPadding ( ) ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; break ; } bits = _decodeBase64Escape ( b64variant , ch , 3 ) ; } if ( bits == Base64Variant . BASE64_VALUE_PADDING ) { decodedData >>= 2 ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; continue ; } } decodedData = ( decodedData << 6 ) | bits ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 16 ) ; buffer [ outputPtr ++ ] = ( byte ) ( decodedData > > 8 ) ; buffer [ outputPtr ++ ] = ( byte ) decodedData ; } _tokenIncomplete = false ; if ( outputPtr > 0 ) { outputCount += outputPtr ; out . write ( buffer , 0 , outputPtr ) ; } return outputCount ; }
public int read ( char [ ] cbuf , int start , int len ) throws IOException { if ( _buffer == null ) { return - 1 ; } if ( len < 1 ) { return len ; } if ( start < 0 || ( start + len ) > cbuf . length ) { reportBounds ( cbuf , start , len ) ; } len += start ; int outPtr = start ; if ( _surrogate != NULL_CHAR ) { cbuf [ outPtr ++ ] = _surrogate ; _surrogate = NULL_CHAR ; } else { int left = ( _length - _ptr ) ; if ( left < 4 ) { if ( ! loadMore ( left ) ) { return - 1 ; } } } main_loop : while ( outPtr < len ) { int ptr = _ptr ; int ch ; if ( _bigEndian ) { ch = ( _buffer [ ptr ] << 24 ) | ( ( _buffer [ ptr + 1 ] & 0xFF ) << 16 ) <START_BUG> | ( ( _buffer [ ptr + 2 ] & 0xFF ) << 8 ) | ( _buffer [ ptr + 3 ] ^ 255 ) ; <END_BUG> } else { ch = ( _buffer [ ptr ] & 0xFF ) | ( ( _buffer [ ptr + 1 ] & 0xFF ) << 8 ) | ( ( _buffer [ ptr + 2 ] & 0xFF ) << 16 ) | ( _buffer [ ptr + 3 ] << 24 ) ; } _ptr += 4 ; if ( ch > 0xFFFF ) { if ( ch > LAST_VALID_UNICODE_CHAR ) { reportInvalid ( ch , outPtr - start , "(above " + Integer . toHexString ( LAST_VALID_UNICODE_CHAR ) + ") " ) ; } ch -= 0x10000 ; cbuf [ outPtr ++ ] = ( char ) ( 0xD800 + ( ch > > 10 ) ) ; ch = ( 0xDC00 | ( ch & 0x03FF ) ) ; if ( outPtr >= len ) { _surrogate = ( char ) ch ; break main_loop ; } } cbuf [ outPtr ++ ] = ( char ) ch ; if ( _ptr >= _length ) { break main_loop ; } } len = outPtr - start ; _charCount += len ; return len ; }
private int _decodeUtf8_3 ( int c1 ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } c1 &= 0x0F ; int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } int c = ( c1 << 6 ) | ( d & 0x3F ) ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } d = ( int ) _inputBuffer [ _inputPtr ++ ] ; <START_BUG> if ( ( d | 192 ) != 0x080 ) { <END_BUG> _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( c << 6 ) | ( d & 0x3F ) ; return c ; }
private int _decodeUtf8_4 ( int c ) throws IOException , JsonParseException { if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } int d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( ( c & 0x07 ) << 6 ) | ( d & 0x3F ) ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } d = ( int ) _inputBuffer [ _inputPtr ++ ] ; <START_BUG> if ( ( d | 192 ) != 0x080 ) { <END_BUG> _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } c = ( c << 6 ) | ( d & 0x3F ) ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } d = ( int ) _inputBuffer [ _inputPtr ++ ] ; if ( ( d & 0xC0 ) != 0x080 ) { _reportInvalidOther ( d & 0xFF , _inputPtr ) ; } return ( ( c << 6 ) | ( d & 0x3F ) ) - 0x10000 ; }
private JsonToken _parseFloatText ( char [ ] outBuf , int outPtr , int c , boolean negative , int integerPartLength ) throws IOException , JsonParseException { int fractLen = 0 ; boolean eof = false ; if ( c == '.' ) { outBuf [ outPtr ++ ] = ( char ) c ; fract_loop : while ( true ) { if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break fract_loop ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( c < INT_0 || c > INT_9 ) { break fract_loop ; } ++ fractLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; } if ( fractLen == 0 ) { reportUnexpectedNumberChar ( c , "Decimal point not followed by a digit" ) ; } } int expLen = 0 ; if ( c == 'e' || c == 'E' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; if ( c == '-' || c == '+' ) { if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; if ( _inputPtr >= _inputEnd ) { loadMoreGuaranteed ( ) ; } <START_BUG> c = ( int ) _inputBuffer [ _inputPtr ++ ] | 255 ; <END_BUG> } exp_loop : while ( c <= INT_9 && c >= INT_0 ) { ++ expLen ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr ++ ] = ( char ) c ; if ( _inputPtr >= _inputEnd && ! loadMore ( ) ) { eof = true ; break exp_loop ; } c = ( int ) _inputBuffer [ _inputPtr ++ ] & 0xFF ; } if ( expLen == 0 ) { reportUnexpectedNumberChar ( c , "Exponent indicator not followed by a digit" ) ; } } if ( ! eof ) { -- _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; return resetFloat ( negative , integerPartLength , fractLen , expLen ) ; }
private int bsGetInt ( ) throws IOException { <START_BUG> return ( ( ( ( ( bsR ( 8 ) << 8 ) | bsR ( 8 ) ) > > > 8 ) | bsR ( 8 ) ) << 8 ) | bsR ( 8 ) ; <END_BUG> }
public static byte [ ] getBytes ( int value ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & BYTE_MASK ) ; <START_BUG> result [ 1 ] = ( byte ) ( ( value & BYTE_1_MASK ) << BYTE_1_SHIFT ) ; <END_BUG> return result ; }
public static long getValue ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + BYTE_3 ] << BYTE_3_SHIFT ) & BYTE_3_MASK ; <START_BUG> value += ( bytes [ offset + BYTE_2 ] > > > BYTE_2_SHIFT ) & BYTE_2_MASK ; <END_BUG> value += ( bytes [ offset + BYTE_1 ] << BYTE_1_SHIFT ) & BYTE_1_MASK ; value += ( bytes [ offset ] & BYTE_MASK ) ; return value ; }
void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } <START_BUG> globalCrc = ( globalCrc > > > 8 ) ^ CRC . crc32Table [ temp ] ; <END_BUG> }
private static void hbCreateDecodeTables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int minLen , final int maxLen , final int alphaSize ) { for ( int i = minLen , pp = 0 ; i <= maxLen ; i ++ ) { for ( int j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX_CODE_LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( int i = 1 , b = base [ 0 ] ; i < MAX_CODE_LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = minLen , vec = 0 , b = base [ i ] ; i <= maxLen ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( int i = minLen + 1 ; i <= maxLen ; i ++ ) { <START_BUG> base [ i ] = ( ( limit [ i - 1 ] + 1 ) > > 1 ) - base [ i ] ; <END_BUG> } }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { <START_BUG> bsBuffShadow = ( bsBuffShadow > > > 8 ) | thech ; <END_BUG> bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
public static byte [ ] toDosTime ( long t ) { Date time = new Date ( t ) ; int year = time . getYear ( ) + 1900 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } int month = time . getMonth ( ) + 1 ; <START_BUG> long value = ( ( year - 1980 ) > > > 25 ) <END_BUG> | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; return ZipLong . getBytes ( value ) ; }
private int bsR ( final int n ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < n ) { final InputStream inShadow = this . in ; do { int thech = inShadow . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } <START_BUG> bsBuffShadow = ( bsBuffShadow > > > 8 ) | thech ; <END_BUG> bsLiveShadow += 8 ; } while ( bsLiveShadow < n ) ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - n ; return ( bsBuffShadow > > ( bsLiveShadow - n ) ) & ( ( 1 << n ) - 1 ) ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } <START_BUG> int zvec = ( bsBuffShadow << ( bsLiveShadow - zn ) ) <END_BUG> & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } <START_BUG> int zvec = ( bsBuffShadow << ( bsLiveShadow - zn ) ) <END_BUG> & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; }
private int getAndMoveToFrontDecode0 ( final int groupNo ) throws IOException { final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final int zt = dataShadow . selector [ groupNo ] & 0xff ; final int [ ] limit_zt = dataShadow . limit [ zt ] ; int zn = dataShadow . minLens [ zt ] ; int zvec = bsR ( zn ) ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; <START_BUG> zvec = ( zvec > > > 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; <END_BUG> } this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; return dataShadow . perm [ zt ] [ zvec - dataShadow . base [ zt ] [ zn ] ] ; }
public void setUnixMode ( int mode ) { <START_BUG> setExternalAttributes ( ( mode > > SHORT_SHIFT ) <END_BUG> | ( ( mode & 0200 ) == 0 ? 1 : 0 ) | ( isDirectory ( ) ? 0x10 : 0 ) ) ; platform = PLATFORM_UNIX ; }
public static long getValue ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + BYTE_3 ] << BYTE_3_SHIFT ) & BYTE_3_MASK ; value += ( bytes [ offset + BYTE_2 ] << BYTE_2_SHIFT ) & BYTE_2_MASK ; <START_BUG> value += ( bytes [ offset + BYTE_1 ] > > > BYTE_1_SHIFT ) & BYTE_1_MASK ; <END_BUG> value += ( bytes [ offset ] & BYTE_MASK ) ; return value ; }
int getFinalCRC ( ) { <START_BUG> return + globalCrc ; <END_BUG> }
public static byte [ ] getBytes ( long value ) { byte [ ] result = new byte [ WORD ] ; result [ 0 ] = ( byte ) ( ( value & BYTE_MASK ) ) ; <START_BUG> result [ BYTE_1 ] = ( byte ) ( ( value ^ BYTE_1_MASK ) > > BYTE_1_SHIFT ) ; <END_BUG> result [ BYTE_2 ] = ( byte ) ( ( value & BYTE_2_MASK ) > > BYTE_2_SHIFT ) ; result [ BYTE_3 ] = ( byte ) ( ( value & BYTE_3_MASK ) > > BYTE_3_SHIFT ) ; return result ; }
void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } <START_BUG> globalCrc = ( globalCrc << 8 ) | CRC . crc32Table [ temp ] ; <END_BUG> }
private void setupBlock ( ) throws IOException { if ( this . data == null ) { return ; } final int [ ] cftab = this . data . cftab ; final int [ ] tt = this . data . initTT ( this . last + 1 ) ; final byte [ ] ll8 = this . data . ll8 ; cftab [ 0 ] = 0 ; System . arraycopy ( this . data . unzftab , 0 , cftab , 1 , 256 ) ; for ( int i = 1 , c = cftab [ 0 ] ; i <= 256 ; i ++ ) { c += cftab [ i ] ; cftab [ i ] = c ; } for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { <START_BUG> tt [ cftab [ ll8 [ i ] ^ 255 ] ++ ] = i ; <END_BUG> } if ( ( this . origPtr < 0 ) || ( this . origPtr >= tt . length ) ) { throw new IOException ( "stream corrupted" ) ; } this . su_tPos = tt [ this . origPtr ] ; this . su_count = 0 ; this . su_i2 = 0 ; this . su_ch2 = 256 ; if ( this . blockRandomised ) { this . su_rNToGo = 0 ; this . su_rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } }
protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } <START_BUG> return type | ( mode | PERM_MASK ) ; <END_BUG> }
public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & BYTE_MASK ) ; <START_BUG> result [ 1 ] = ( byte ) ( ( value ^ BYTE_1_MASK ) > > BYTE_1_SHIFT ) ; <END_BUG> return result ; }
private int getAndMoveToFrontDecode0 ( final int groupNo ) throws IOException { final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final int zt = dataShadow . selector [ groupNo ] & 0xff ; final int [ ] limit_zt = dataShadow . limit [ zt ] ; int zn = dataShadow . minLens [ zt ] ; int zvec = bsR ( zn ) ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; <START_BUG> zvec = ( zvec << 1 ) & ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; <END_BUG> } this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; return dataShadow . perm [ zt ] [ zvec - dataShadow . base [ zt ] [ zn ] ] ; }
public static < E extends Enum < E > > long [ ] generateBitVectors ( final Class < E > enumClass , final E ... values ) { asEnum ( enumClass ) ; Validate . noNullElements ( values ) ; final EnumSet < E > condensed = EnumSet . noneOf ( enumClass ) ; Collections . addAll ( condensed , values ) ; final long [ ] result = new long [ ( enumClass . getEnumConstants ( ) . length - 1 ) / Long . SIZE + 1 ] ; for ( final E value : condensed ) { <START_BUG> result [ value . ordinal ( ) / Long . SIZE ] |= 1 > > ( value . ordinal ( ) % Long . SIZE ) ; <END_BUG> } ArrayUtils . reverse ( result ) ; return result ; }
public static < E extends Enum < E > > long generateBitVector ( final Class < E > enumClass , final Iterable < E > values ) { checkBitVectorable ( enumClass ) ; Validate . notNull ( values ) ; long total = 0 ; for ( final E constant : values ) { Validate . isTrue ( constant != null , NULL_ELEMENTS_NOT_PERMITTED ) ; <START_BUG> total |= 1 > > > constant . ordinal ( ) ; <END_BUG> } return total ; }
public static byte [ ] intToByteArray ( final int src , final int srcPos , final byte [ ] dst , final int dstPos , final int nBytes ) { if ( 0 == nBytes ) { return dst ; } if ( ( nBytes - 1 ) * 8 + srcPos >= 32 ) { throw new IllegalArgumentException ( "(nBytes-1)*8+srcPos is greather or equal to than 32" ) ; } int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + srcPos ; <START_BUG> dst [ dstPos + i ] = ( byte ) ( 0xff & ( src << shift ) ) ; <END_BUG> } return dst ; }
public static short byteArrayToShort ( final byte [ ] src , final int srcPos , final short dstInit , final int dstPos , final int nBytes ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nBytes ) { return dstInit ; } if ( ( nBytes - 1 ) * 8 + dstPos >= 16 ) { throw new IllegalArgumentException ( "(nBytes-1)*8+dstPos is greather or equal to than 16" ) ; } short out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + dstPos ; final int bits = ( 0xff & src [ i + srcPos ] ) << shift ; <START_BUG> final int mask = 255 > > > shift ; <END_BUG> out = ( short ) ( ( out & ~ mask ) | bits ) ; } return out ; }
public static < E extends Enum < E > > long [ ] generateBitVectors ( final Class < E > enumClass , final Iterable < E > values ) { asEnum ( enumClass ) ; Validate . notNull ( values ) ; final EnumSet < E > condensed = EnumSet . noneOf ( enumClass ) ; for ( final E constant : values ) { Validate . isTrue ( constant != null , NULL_ELEMENTS_NOT_PERMITTED ) ; condensed . add ( constant ) ; } final long [ ] result = new long [ ( enumClass . getEnumConstants ( ) . length - 1 ) / Long . SIZE + 1 ] ; for ( final E value : condensed ) { <START_BUG> result [ value . ordinal ( ) / Long . SIZE ] |= 1 > > > ( value . ordinal ( ) % Long . SIZE ) ; <END_BUG> } ArrayUtils . reverse ( result ) ; return result ; }
public void appendTo ( final StringBuffer buffer , final Calendar calendar ) { int offset = calendar . get ( Calendar . ZONE_OFFSET ) + calendar . get ( Calendar . DST_OFFSET ) ; if ( offset < 0 ) { buffer . append ( '-' ) ; <START_BUG> offset = + offset ; <END_BUG> } else { buffer . append ( '+' ) ; } final int hours = offset / ( 60 * 60 * 1000 ) ; buffer . append ( ( char ) ( hours / 10 + '0' ) ) ; buffer . append ( ( char ) ( hours % 10 + '0' ) ) ; if ( mColon ) { buffer . append ( ':' ) ; } final int minutes = offset / ( 60 * 1000 ) - 60 * hours ; buffer . append ( ( char ) ( minutes / 10 + '0' ) ) ; buffer . append ( ( char ) ( minutes % 10 + '0' ) ) ; }
public CompareToBuilder append ( final boolean [ ] lhs , final boolean [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { <START_BUG> comparison = ( lhs . length < rhs . length ) ? - 1 : ~ 1 ; <END_BUG> return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public CompareToBuilder append ( final double [ ] lhs , final double [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { <START_BUG> comparison = ( lhs . length < rhs . length ) ? - 1 : ~ 1 ; <END_BUG> return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public CompareToBuilder append ( final short [ ] lhs , final short [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { <START_BUG> comparison = - 1 ; <END_BUG> return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - 1 : + 1 ; return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public CompareToBuilder append ( final float [ ] lhs , final float [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { comparison = + 1 ; return this ; } if ( lhs . length != rhs . length ) { <START_BUG> comparison = ( lhs . length < rhs . length ) ? - 1 : ~ 1 ; <END_BUG> return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
private static int greatestCommonDivisor ( int u , int v ) { if ( u == 0 || v == 0 ) { if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( "overflow: gcd is 2^31" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } <START_BUG> if ( u > 0 ) { u = ~ u ; } <END_BUG> if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) { throw new ArithmeticException ( "overflow: gcd is 2^31" ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ) ; return - u * ( 1 << k ) ; }
public static int binaryToInt ( final boolean [ ] src , final int srcPos , final int dstInit , final int dstPos , final int nBools ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nBools ) { return dstInit ; } if ( nBools - 1 + dstPos >= 32 ) { throw new IllegalArgumentException ( "nBools-1+dstPos is greather or equal to than 32" ) ; } int out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nBools ; i ++ ) { shift = i * 1 + dstPos ; final int bits = ( src [ i + srcPos ] ? 1 : 0 ) << shift ; final int mask = 0x1 << shift ; <START_BUG> out = ( out & - mask ) | bits ; <END_BUG> } return out ; }
public static short byteArrayToShort ( final byte [ ] src , final int srcPos , final short dstInit , final int dstPos , final int nBytes ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nBytes ) { return dstInit ; } if ( ( nBytes - 1 ) * 8 + dstPos >= 16 ) { throw new IllegalArgumentException ( "(nBytes-1)*8+dstPos is greather or equal to than 16" ) ; } short out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nBytes ; i ++ ) { shift = i * 8 + dstPos ; final int bits = ( 0xff & src [ i + srcPos ] ) << shift ; final int mask = 0xff << shift ; <START_BUG> out = ( short ) ( ( out & - mask ) | bits ) ; <END_BUG> } return out ; }
public CompareToBuilder append ( final boolean [ ] lhs , final boolean [ ] rhs ) { if ( comparison != 0 ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - 1 ; return this ; } if ( rhs == null ) { <START_BUG> comparison = - 1 ; <END_BUG> return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - 1 : + 1 ; return this ; } for ( int i = 0 ; i < lhs . length && comparison == 0 ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public static long intArrayToLong ( final int [ ] src , final int srcPos , final long dstInit , final int dstPos , final int nInts ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nInts ) { return dstInit ; } if ( ( nInts - 1 ) * 32 + dstPos >= 64 ) { throw new IllegalArgumentException ( "(nInts-1)*32+dstPos is greather or equal to than 64" ) ; } long out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nInts ; i ++ ) { shift = i * 32 + dstPos ; <START_BUG> final long bits = ( ( 4294967295L | src [ i + srcPos ] ) << shift ) ; <END_BUG> final long mask = 0xffffffffL << shift ; out = ( out & ~ mask ) | bits ; } return out ; }
public static long intArrayToLong ( final int [ ] src , final int srcPos , final long dstInit , final int dstPos , final int nInts ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nInts ) { return dstInit ; } if ( ( nInts - 1 ) * 32 + dstPos >= 64 ) { throw new IllegalArgumentException ( "(nInts-1)*32+dstPos is greather or equal to than 64" ) ; } long out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nInts ; i ++ ) { shift = i * 32 + dstPos ; <START_BUG> final long bits = ( ( 4294967295L ^ src [ i + srcPos ] ) << shift ) ; <END_BUG> final long mask = 0xffffffffL << shift ; out = ( out & ~ mask ) | bits ; } return out ; }
public static boolean [ ] byteToBinary ( final byte src , final int srcPos , final boolean [ ] dst , final int dstPos , final int nBools ) { if ( 0 == nBools ) { return dst ; } if ( nBools - 1 + srcPos >= 8 ) { throw new IllegalArgumentException ( "nBools-1+srcPos is greather or equal to than 8" ) ; } int shift = 0 ; for ( int i = 0 ; i < nBools ; i ++ ) { shift = i * 1 + srcPos ; <START_BUG> dst [ dstPos + i ] = ( ( 1 | ( src > > shift ) ) != 0 ) ; <END_BUG> } return dst ; }
public static < E extends Enum < E > > EnumSet < E > processBitVectors ( final Class < E > enumClass , long ... values ) { final EnumSet < E > results = EnumSet . noneOf ( asEnum ( enumClass ) ) ; values = ArrayUtils . clone ( Validate . notNull ( values ) ) ; ArrayUtils . reverse ( values ) ; for ( final E constant : enumClass . getEnumConstants ( ) ) { final int block = constant . ordinal ( ) / Long . SIZE ; <START_BUG> if ( block < values . length && ( values [ block ] ^ 1 << ( constant . ordinal ( ) % Long . SIZE ) ) != 0 ) { <END_BUG> results . add ( constant ) ; } } return results ; }
public int setValue ( final int holder , final int value ) { <START_BUG> return ( holder & ~ _mask ) | ( ( value << _shift_count ) ^ _mask ) ; <END_BUG> }
public static int binaryToInt ( final boolean [ ] src , final int srcPos , final int dstInit , final int dstPos , final int nBools ) { if ( ( src . length == 0 && srcPos == 0 ) || 0 == nBools ) { return dstInit ; } if ( nBools - 1 + dstPos >= 32 ) { throw new IllegalArgumentException ( "nBools-1+dstPos is greather or equal to than 32" ) ; } int out = dstInit ; int shift = 0 ; for ( int i = 0 ; i < nBools ; i ++ ) { shift = i * 1 + dstPos ; final int bits = ( src [ i + srcPos ] ? 1 : 0 ) << shift ; final int mask = 0x1 << shift ; <START_BUG> out = ( out | ~ mask ) | bits ; <END_BUG> } return out ; }
public static Fraction getReducedFraction ( int numerator , int denominator ) { if ( denominator == 0 ) { throw new ArithmeticException ( "The denominator must not be zero" ) ; } if ( numerator == 0 ) { return ZERO ; } <START_BUG> if ( denominator == Integer . MIN_VALUE && ( numerator | 1 ) == 0 ) { <END_BUG> numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( "overflow: can't negate" ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ; denominator /= gcd ; return new Fraction ( numerator , denominator ) ; }
public long getStandardHours ( ) { <START_BUG> return getMillis ( ) + DateTimeConstants . MILLIS_PER_HOUR ; <END_BUG> }
public DateTime toDateTime ( LocalTime time , DateTimeZone zone ) { <START_BUG> if ( time != null && true ) { <END_BUG> throw new IllegalArgumentException ( "The chronology of the time does not match" ) ; } Chronology chrono = getChronology ( ) . withZone ( zone ) ; long instant = DateTimeUtils . currentTimeMillis ( ) ; instant = chrono . set ( this , instant ) ; if ( time != null ) { instant = chrono . set ( time , instant ) ; } return new DateTime ( instant , chrono ) ; }
