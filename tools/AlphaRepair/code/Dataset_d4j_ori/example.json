{"mockito_34": [{"prefix": "    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        return invocation.getMethod().equals(candidate.getMethod());\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n", "suffix": "                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n}", "buggy": "    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        return invocation.getMethod().equals(candidate.getMethod());\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n}", "fix": "    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        return invocation.getMethod().equals(candidate.getMethod());\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n}", "start": 52, "end": 158, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_34/src/org/mockito/internal/invocation/InvocationMatcher.java"}], "math_41": [{"prefix": "     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n", "suffix": "                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n", "buggy": "     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n", "fix": "     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = begin; i < begin  length; i) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n", "start": 497, "end": 541, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java"}], "lang_6": [{"prefix": "     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n", "suffix": "            }\n        }\n    }\n\n    /**\n     * Helper method to create a merger of this translator with another set of \n     * translators. Useful in customizing the standard functionality.\n     *\n     * @param translators CharSequenceTranslator array of translators to merge with this one\n     * @return CharSequenceTranslator merging this translator with the others\n     */\n    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n        newArray[0] = this;\n        System.arraycopy(translators, 0, newArray, 1, translators.length);\n        return new AggregateTranslator(newArray);\n    }\n\n    /**\n     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n     * character.</p>\n     *\n     * @param codepoint The codepoint to convert.\n     * @return An upper case hexadecimal <code>String</code>\n", "buggy": "     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n\n    /**\n     * Helper method to create a merger of this translator with another set of \n     * translators. Useful in customizing the standard functionality.\n     *\n     * @param translators CharSequenceTranslator array of translators to merge with this one\n     * @return CharSequenceTranslator merging this translator with the others\n     */\n    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n        newArray[0] = this;\n        System.arraycopy(translators, 0, newArray, 1, translators.length);\n        return new AggregateTranslator(newArray);\n    }\n\n    /**\n     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n     * character.</p>\n     *\n     * @param codepoint The codepoint to convert.\n     * @return An upper case hexadecimal <code>String</code>\n", "fix": "     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos = Character.charCount(Character.codePointAt(input, pt));\n            }\n        }\n    }\n\n    /**\n     * Helper method to create a merger of this translator with another set of \n     * translators. Useful in customizing the standard functionality.\n     *\n     * @param translators CharSequenceTranslator array of translators to merge with this one\n     * @return CharSequenceTranslator merging this translator with the others\n     */\n    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n        newArray[0] = this;\n        System.arraycopy(translators, 0, newArray, 1, translators.length);\n        return new AggregateTranslator(newArray);\n    }\n\n    /**\n     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n     * character.</p>\n     *\n     * @param codepoint The codepoint to convert.\n     * @return An upper case hexadecimal <code>String</code>\n", "start": 70, "end": 118, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java"}], "jsoup_9": [{"prefix": " * named character references</a>.\n */\npublic class Entities {\n    public enum EscapeMode {\n        /** Restricted entities suitable for XHTML output: lt, gt, amp, apos, and quot only. */\n        xhtml(xhtmlByVal),\n        /** Default HTML output entities. */\n        base(baseByVal),\n        /** Complete HTML entities. */\n        extended(fullByVal);\n\n        private Map<Character, String> map;\n\n        EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full;\n    private static final Map<Character, String> xhtmlByVal;\n    private static final Map<Character, String> baseByVal;\n    private static final Map<Character, String> fullByVal;\n", "suffix": "\n    static String escape(String string, Document.OutputSettings out) {\n        return escape(string, out.encoder(), out.escapeMode());\n    }\n\n    static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        Map<Character, String> map = escapeMode.getMap();\n\n        for (int pos = 0; pos < string.length(); pos++) {\n            Character c = string.charAt(pos);\n            if (map.containsKey(c))\n                accum.append('&').append(map.get(c)).append(';');\n            else if (encoder.canEncode(c))\n                accum.append(c.charValue());\n            else\n                accum.append(\"&#\").append((int) c).append(';');\n        }\n\n        return accum.toString();\n    }\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n", "buggy": " * named character references</a>.\n */\npublic class Entities {\n    public enum EscapeMode {\n        /** Restricted entities suitable for XHTML output: lt, gt, amp, apos, and quot only. */\n        xhtml(xhtmlByVal),\n        /** Default HTML output entities. */\n        base(baseByVal),\n        /** Complete HTML entities. */\n        extended(fullByVal);\n\n        private Map<Character, String> map;\n\n        EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full;\n    private static final Map<Character, String> xhtmlByVal;\n    private static final Map<Character, String> baseByVal;\n    private static final Map<Character, String> fullByVal;\n    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n\n    static String escape(String string, Document.OutputSettings out) {\n        return escape(string, out.encoder(), out.escapeMode());\n    }\n\n    static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        Map<Character, String> map = escapeMode.getMap();\n\n        for (int pos = 0; pos < string.length(); pos++) {\n            Character c = string.charAt(pos);\n            if (map.containsKey(c))\n                accum.append('&').append(map.get(c)).append(';');\n            else if (encoder.canEncode(c))\n                accum.append(c.charValue());\n            else\n                accum.append(\"&#\").append((int) c).append(';');\n        }\n\n        return accum.toString();\n    }\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n", "fix": " * named character references</a>.\n */\npublic class Entities {\n    public enum EscapeMode {\n        /** Restricted entities suitable for XHTML output: lt, gt, amp, apos, and quot only. */\n        xhtml(xhtmlByVal),\n        /** Default HTML output entities. */\n        base(baseByVal),\n        /** Complete HTML entities. */\n        extended(fullByVal);\n\n        private Map<Character, String> map;\n\n        EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full;\n    private static final Map<Character, String> xhtmlByVal;\n    private static final Map<Character, String> baseByVal;\n    private static final Map<Character, String> fullByVal;\n    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F])|[a-zA-Z]\\\\d*);?\");\n\n    static String escape(String string, Document.OutputSettings out) {\n        return escape(string, out.encoder(), out.escapeMode());\n    }\n\n    static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        Map<Character, String> map = escapeMode.getMap();\n\n        for (int pos = 0; pos < string.length(); pos++) {\n            Character c = string.charAt(pos);\n            if (map.containsKey(c))\n                accum.append('&').append(map.get(c)).append(';');\n            else if (encoder.canEncode(c))\n                accum.append(c.charValue());\n            else\n                accum.append(\"&#\").append((int) c).append(';');\n        }\n\n        return accum.toString();\n    }\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n", "start": 11, "end": 63, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_9/src/main/java/org/jsoup/nodes/Entities.java"}], "math_69": [{"prefix": "     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n", "suffix": "                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n\n\n    /**\n     * Computes the correlation matrix for the columns of the\n     * input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n", "buggy": "     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n\n\n    /**\n     * Computes the correlation matrix for the columns of the\n     * input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n", "fix": "     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n\n\n    /**\n     * Computes the correlation matrix for the columns of the\n     * input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n", "start": 151, "end": 189, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java"}], "closure_102": [], "jsoup_57": [{"prefix": "     @param attribute attribute\n     */\n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n", "suffix": "        }\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n", "buggy": "     @param attribute attribute\n     */\n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                attributes.remove(attrKey);\n        }\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n", "fix": "     @param attribute attribute\n     */\n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                it.remove();\n        }\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n", "start": 93, "end": 155, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_57/src/main/java/org/jsoup/nodes/Attributes.java"}], "codec_7": [{"prefix": "                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n", "suffix": "    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n", "buggy": "                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n", "fix": "                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n", "start": 643, "end": 695, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_7/src/java/org/apache/commons/codec/binary/Base64.java"}], "math_30": [{"prefix": "\n        return FastMath.max(U1, U2);\n    }\n\n    /**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n", "suffix": "\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }\n\n    /**\n     * Returns the asymptotic <i>observed significance level</i>, or <a href=\n     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n     * p-value</a>, associated with a <a\n     * href=\"http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U\"> Mann-Whitney\n     * U statistic</a> comparing mean for two independent samples.\n     * <p>\n", "buggy": "\n        return FastMath.max(U1, U2);\n    }\n\n    /**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final int n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }\n\n    /**\n     * Returns the asymptotic <i>observed significance level</i>, or <a href=\n     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n     * p-value</a>, associated with a <a\n     * href=\"http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U\"> Mann-Whitney\n     * U statistic</a> comparing mean for two independent samples.\n     * <p>\n", "fix": "\n        return FastMath.max(U1, U2);\n    }\n\n    /**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final double n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }\n\n    /**\n     * Returns the asymptotic <i>observed significance level</i>, or <a href=\n     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n     * p-value</a>, associated with a <a\n     * href=\"http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U\"> Mann-Whitney\n     * U statistic</a> comparing mean for two independent samples.\n     * <p>\n", "start": 153, "end": 191, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java"}], "jacksondatabind_27": [{"prefix": "        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n", "suffix": "                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n", "buggy": "        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n", "fix": "        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n", "start": 774, "end": 812, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java"}], "jacksondatabind_96": [{"prefix": "                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n", "suffix": "            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n", "buggy": "                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n", "fix": "                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n", "start": 713, "end": 755, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java"}], "jacksondatabind_107": [{"prefix": "        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n", "suffix": "                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n", "buggy": "        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n", "fix": "        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                        return NullifyingDeserializer.instance;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n", "start": 149, "end": 179, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java"}], "math_59": [{"prefix": "        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    /** Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     */\n    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n", "suffix": "    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }\n\n}\n", "buggy": "        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    /** Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     */\n    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }\n\n}\n", "fix": "        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n\n    /** Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     */\n    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static long max(final long a, final long b) {\n        return (a <= b) ? b : a;\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a  b) ? Float.NaN : a);\n    }\n\n    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }\n\n}\n", "start": 3445, "end": 3517, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_59/src/main/java/org/apache/commons/math/util/FastMath.java"}], "codec_2": [{"prefix": "                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n", "suffix": "                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n", "buggy": "                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n", "fix": "                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n", "start": 427, "end": 463, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_2/src/java/org/apache/commons/codec/binary/Base64.java"}], "jsoup_32": [{"prefix": "            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n", "suffix": "        return clone;\n    }\n}\n", "buggy": "            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames();\n        return clone;\n    }\n}\n", "fix": "            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n        return clone;\n    }\n}\n", "start": 1081, "end": 1193, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_32/src/main/java/org/jsoup/nodes/Element.java"}], "jsoup_45": [{"prefix": "    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n", "suffix": "                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n", "buggy": "    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n", "fix": "    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n", "start": 369, "end": 417, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java"}], "closure_71": [{"prefix": "        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n", "suffix": "          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n", "buggy": "        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = t.inGlobalScope() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n", "fix": "        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = parent.getJSDocInfo() != null &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n", "start": 388, "end": 442, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_71/src/com/google/javascript/jscomp/CheckAccessControls.java"}], "chart_10": [{"prefix": " * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * StandardToolTipTagFragmentGenerator.java\n * ----------------------------------------\n * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.\n *\n * Original Author:  Richard Atkinson;\n * Contributors:     David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 12-Aug-2003 : Version 1 (RA);\n * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\n * \n */\n \npackage org.jfree.chart.imagemap;\n\n/**\n * Generates tooltips using the HTML title attribute for image map area tags.\n */\npublic class StandardToolTipTagFragmentGenerator \n        implements ToolTipTagFragmentGenerator {\n\n    /**\n     * Creates a new instance.\n     */\n    public StandardToolTipTagFragmentGenerator() {\n        super();\n    }\n\t\n    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n", "suffix": "            + \"\\\" alt=\\\"\\\"\";\n    }\n\n}\n", "buggy": " * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * StandardToolTipTagFragmentGenerator.java\n * ----------------------------------------\n * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.\n *\n * Original Author:  Richard Atkinson;\n * Contributors:     David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 12-Aug-2003 : Version 1 (RA);\n * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\n * \n */\n \npackage org.jfree.chart.imagemap;\n\n/**\n * Generates tooltips using the HTML title attribute for image map area tags.\n */\npublic class StandardToolTipTagFragmentGenerator \n        implements ToolTipTagFragmentGenerator {\n\n    /**\n     * Creates a new instance.\n     */\n    public StandardToolTipTagFragmentGenerator() {\n        super();\n    }\n\t\n    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText\n            + \"\\\" alt=\\\"\\\"\";\n    }\n\n}\n", "fix": " * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * StandardToolTipTagFragmentGenerator.java\n * ----------------------------------------\n * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.\n *\n * Original Author:  Richard Atkinson;\n * Contributors:     David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 12-Aug-2003 : Version 1 (RA);\n * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\n * \n */\n \npackage org.jfree.chart.imagemap;\n\n/**\n * Generates tooltips using the HTML title attribute for image map area tags.\n */\npublic class StandardToolTipTagFragmentGenerator \n        implements ToolTipTagFragmentGenerator {\n\n    /**\n     * Creates a new instance.\n     */\n    public StandardToolTipTagFragmentGenerator() {\n        super();\n    }\n\t\n    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\"  ImageMapUtilities.htmlEscape(toolTipText) \n            + \"\\\" alt=\\\"\\\"\";\n    }\n\n}\n", "start": 15, "end": 113, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java"}], "lang_61": [{"prefix": "     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n", "suffix": "        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n", "buggy": "     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n", "fix": "     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = size - strLen  1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n", "start": 1750, "end": 1800, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_61/src/java/org/apache/commons/lang/text/StrBuilder.java"}], "chart_24": [{"prefix": "     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Returns the upper bound.\n     * \n     * @return The upper bound.\n     * \n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n", "suffix": "                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n    \n    /**\n     * Tests this <code>GrayPaintScale</code> instance for equality with an\n     * arbitrary object.  This method returns <code>true</code> if and only\n     * if:\n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>GrayPaintScale</code>;</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof GrayPaintScale)) {\n            return false;\n        }\n        GrayPaintScale that = (GrayPaintScale) obj;\n        if (this.lowerBound != that.lowerBound) {\n            return false;\n", "buggy": "     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Returns the upper bound.\n     * \n     * @return The upper bound.\n     * \n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n        int g = (int) ((value - this.lowerBound) / (this.upperBound \n                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n    \n    /**\n     * Tests this <code>GrayPaintScale</code> instance for equality with an\n     * arbitrary object.  This method returns <code>true</code> if and only\n     * if:\n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>GrayPaintScale</code>;</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof GrayPaintScale)) {\n            return false;\n        }\n        GrayPaintScale that = (GrayPaintScale) obj;\n        if (this.lowerBound != that.lowerBound) {\n            return false;\n", "fix": "     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Returns the upper bound.\n     * \n     * @return The upper bound.\n     * \n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n    \n    /**\n     * Tests this <code>GrayPaintScale</code> instance for equality with an\n     * arbitrary object.  This method returns <code>true</code> if and only\n     * if:\n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>GrayPaintScale</code>;</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof GrayPaintScale)) {\n            return false;\n        }\n        GrayPaintScale that = (GrayPaintScale) obj;\n        if (this.lowerBound != that.lowerBound) {\n            return false;\n", "start": 98, "end": 152, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_24/source/org/jfree/chart/renderer/GrayPaintScale.java"}], "jsoup_43": [{"prefix": "     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n", "suffix": "                return i;\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n", "buggy": "     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n", "fix": "     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element == search)\n                return i;\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n", "start": 550, "end": 596, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_43/src/main/java/org/jsoup/nodes/Element.java"}], "codec_10": [{"prefix": "\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n", "suffix": "\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n", "buggy": "\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n", "fix": "\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"mb$\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n", "start": 59, "end": 91, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_10/src/java/org/apache/commons/codec/language/Caverphone.java"}], "codec_3": [{"prefix": "            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n", "suffix": "                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n", "buggy": "            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 4, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n", "fix": "            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index  1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n", "start": 437, "end": 471, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java"}], "chart_11": [{"prefix": "            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n", "suffix": "        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n", "buggy": "            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n", "fix": "            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n", "start": 249, "end": 299, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_11/source/org/jfree/chart/util/ShapeUtilities.java"}], "csv_1": [{"prefix": " * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n", "suffix": "            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n", "buggy": " * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n", "fix": " * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n", "start": 26, "end": 88, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/csv_1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"}], "compress_38": [{"prefix": "     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n", "suffix": "            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    /**\n     * Check if this is a link entry.\n     *\n", "buggy": "     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    /**\n     * Check if this is a link entry.\n     *\n", "fix": "     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    /**\n     * Check if this is a link entry.\n     *\n", "start": 823, "end": 893, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/compress_38/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java"}], "math_33": [{"prefix": "                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n\n    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n", "suffix": "                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n", "buggy": "                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n\n    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n", "fix": "                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n\n    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n", "start": 314, "end": 360, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java"}], "jsoup_46": [{"prefix": "        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n", "suffix": "                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n", "buggy": "        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n", "fix": "        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n", "start": 90, "end": 144, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_46/src/main/java/org/jsoup/nodes/Entities.java"}], "jacksondatabind_57": [{"prefix": "     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n", "suffix": "                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n", "buggy": "     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n", "fix": "     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n", "start": 1415, "end": 1465, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java"}], "codec_4": [{"prefix": "    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n", "suffix": "    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n", "buggy": "    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n", "fix": "    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n", "start": 199, "end": 249, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_4/src/java/org/apache/commons/codec/binary/Base64.java"}], "chart_12": [{"prefix": "     */\n    private Comparable aggregatedItemsKey;\n\n    /**\n     * The paint for the aggregated items.\n     * @since 1.0.2\n     */\n    private transient Paint aggregatedItemsPaint;\n\n    /**\n     * The colors to use for each section.\n     * @since 1.0.2\n     */\n    private transient Map sectionPaints;\n\n    /**\n     * Creates a new plot with no data.\n     */\n    public MultiplePiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n", "suffix": "        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    /**\n     * Returns the dataset used by the plot.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     */\n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n", "buggy": "     */\n    private Comparable aggregatedItemsKey;\n\n    /**\n     * The paint for the aggregated items.\n     * @since 1.0.2\n     */\n    private transient Paint aggregatedItemsPaint;\n\n    /**\n     * The colors to use for each section.\n     * @since 1.0.2\n     */\n    private transient Map sectionPaints;\n\n    /**\n     * Creates a new plot with no data.\n     */\n    public MultiplePiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    /**\n     * Returns the dataset used by the plot.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     */\n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n", "fix": "     */\n    private Comparable aggregatedItemsKey;\n\n    /**\n     * The paint for the aggregated items.\n     * @since 1.0.2\n     */\n    private transient Paint aggregatedItemsPaint;\n\n    /**\n     * The colors to use for each section.\n     * @since 1.0.2\n     */\n    private transient Map sectionPaints;\n\n    /**\n     * Creates a new plot with no data.\n     */\n    public MultiplePiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    /**\n     * Returns the dataset used by the plot.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     */\n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n", "start": 115, "end": 173, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java"}], "cli_28": [{"prefix": "\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n", "suffix": "                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n", "buggy": "\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n", "fix": "\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n", "start": 257, "end": 321, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/cli_28/src/java/org/apache/commons/cli/Parser.java"}], "jsoup_88": [{"prefix": "        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n", "suffix": "    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return oldVal;\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n", "buggy": "        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n        return val;\n    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return oldVal;\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n", "fix": "        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return oldVal;\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n", "start": 47, "end": 111, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_88/src/main/java/org/jsoup/nodes/Attribute.java"}], "lang_29": [{"prefix": "     * <p>\n     * Converts the given Java version string to an <code>int</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>120</code> for Java 1.2</li>\n     * <li><code>131</code> for Java 1.3.1</li>\n     * <li><code>160</code> for Java 1.6.0_20</li>\n     * </ul>\n     * \n     * <p>\n     * Patch releases are not reported.\n     * </p>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example 131 for Java 1.3.1\n     */\n", "suffix": "        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    }\n\n    /**\n     * <p>\n     * Converts the given Java version string to an <code>int[]</code> of maximum size <code>3</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>[1, 2, 0]</code> for Java 1.2</li>\n     * <li><code>[1, 3, 1]</code> for Java 1.3.1</li>\n     * <li><code>[1, 5, 0]</code> for Java 1.5.0_21</li>\n     * </ul>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example [1, 5, 0] for Java 1.5.0_21\n     */\n", "buggy": "     * <p>\n     * Converts the given Java version string to an <code>int</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>120</code> for Java 1.2</li>\n     * <li><code>131</code> for Java 1.3.1</li>\n     * <li><code>160</code> for Java 1.6.0_20</li>\n     * </ul>\n     * \n     * <p>\n     * Patch releases are not reported.\n     * </p>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example 131 for Java 1.3.1\n     */\n    static float toJavaVersionInt(String version) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    }\n\n    /**\n     * <p>\n     * Converts the given Java version string to an <code>int[]</code> of maximum size <code>3</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>[1, 2, 0]</code> for Java 1.2</li>\n     * <li><code>[1, 3, 1]</code> for Java 1.3.1</li>\n     * <li><code>[1, 5, 0]</code> for Java 1.5.0_21</li>\n     * </ul>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example [1, 5, 0] for Java 1.5.0_21\n     */\n", "fix": "     * <p>\n     * Converts the given Java version string to an <code>int</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>120</code> for Java 1.2</li>\n     * <li><code>131</code> for Java 1.3.1</li>\n     * <li><code>160</code> for Java 1.6.0_20</li>\n     * </ul>\n     * \n     * <p>\n     * Patch releases are not reported.\n     * </p>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example 131 for Java 1.3.1\n     */\n    static int toJavaVersionInt(String version) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    }\n\n    /**\n     * <p>\n     * Converts the given Java version string to an <code>int[]</code> of maximum size <code>3</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>[1, 2, 0]</code> for Java 1.2</li>\n     * <li><code>[1, 3, 1]</code> for Java 1.3.1</li>\n     * <li><code>[1, 5, 0]</code> for Java 1.5.0_21</li>\n     * </ul>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example [1, 5, 0] for Java 1.5.0_21\n     */\n", "start": 1649, "end": 1693, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_29/src/main/java/org/apache/commons/lang3/SystemUtils.java"}], "jsoup_49": [], "jsoup_51": [{"prefix": "            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n", "suffix": "    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n", "buggy": "            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n", "fix": "            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n", "start": 268, "end": 330, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_51/src/main/java/org/jsoup/parser/CharacterReader.java"}], "jacksondatabind_70": [{"prefix": "    /* Public API\n    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n", "suffix": "                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n", "buggy": "    /* Public API\n    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(prop.getName());\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n", "fix": "    /* Public API\n    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(_hashArea[i-1]);\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n", "start": 415, "end": 463, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java"}], "jsoup_77": [{"prefix": "                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n", "suffix": "        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n", "buggy": "                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n", "fix": "                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.normalName();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n", "start": 92, "end": 140, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_77/src/main/java/org/jsoup/parser/XmlTreeBuilder.java"}], "math_105": [{"prefix": "     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * <p>\n     * The sums are accumulated using the updating algorithm referenced in \n     * {@link #addData}.  \n     * <p>\n     * The return value is constrained to be non-negative - i.e., if due to \n     * rounding errors the computational formula returns a negative result, \n     * 0 is returned.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is \n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul>\n     *\n     * @return sum of squared errors associated with the regression model\n     */\n    public double getSumSquaredErrors() {\n", "suffix": "    }\n\n    /**\n     * Returns the sum of squared deviations of the y values about their mean.\n     * <p>\n     * This is defined as SSTO \n     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.\n     * <p>\n     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.\n     *\n     * @return sum of squared deviations of y values\n     */\n    public double getTotalSumSquares() {\n        if (n < 2) {\n            return Double.NaN;\n        }\n        return sumYY;\n    }\n\n    /**\n     * Returns the sum of squared deviations of the predicted y values about \n     * their mean (which equals the mean of y).\n", "buggy": "     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * <p>\n     * The sums are accumulated using the updating algorithm referenced in \n     * {@link #addData}.  \n     * <p>\n     * The return value is constrained to be non-negative - i.e., if due to \n     * rounding errors the computational formula returns a negative result, \n     * 0 is returned.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is \n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul>\n     *\n     * @return sum of squared errors associated with the regression model\n     */\n    public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    /**\n     * Returns the sum of squared deviations of the y values about their mean.\n     * <p>\n     * This is defined as SSTO \n     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.\n     * <p>\n     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.\n     *\n     * @return sum of squared deviations of y values\n     */\n    public double getTotalSumSquares() {\n        if (n < 2) {\n            return Double.NaN;\n        }\n        return sumYY;\n    }\n\n    /**\n     * Returns the sum of squared deviations of the predicted y values about \n     * their mean (which equals the mean of y).\n", "fix": "     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * <p>\n     * The sums are accumulated using the updating algorithm referenced in \n     * {@link #addData}.  \n     * <p>\n     * The return value is constrained to be non-negative - i.e., if due to \n     * rounding errors the computational formula returns a negative result, \n     * 0 is returned.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is \n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul>\n     *\n     * @return sum of squared errors associated with the regression model\n     */\n    public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n    }\n\n    /**\n     * Returns the sum of squared deviations of the y values about their mean.\n     * <p>\n     * This is defined as SSTO \n     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.\n     * <p>\n     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.\n     *\n     * @return sum of squared deviations of y values\n     */\n    public double getTotalSumSquares() {\n        if (n < 2) {\n            return Double.NaN;\n        }\n        return sumYY;\n    }\n\n    /**\n     * Returns the sum of squared deviations of the predicted y values about \n     * their mean (which equals the mean of y).\n", "start": 241, "end": 285, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java"}], "cli_25": [{"prefix": "        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n", "suffix": "        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n", "buggy": "        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n", "fix": "        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n", "start": 794, "end": 854, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/cli_25/src/java/org/apache/commons/cli/HelpFormatter.java"}], "time_16": [{"prefix": "     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n", "suffix": "        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n", "buggy": "     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n", "fix": "     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n", "start": 687, "end": 729, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/time_16/src/main/java/org/joda/time/format/DateTimeFormatter.java"}], "math_27": [{"prefix": "                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    /**\n     * Divide the fraction by an integer.\n     * @param i the <tt>integer</tt> to divide by.\n     * @return this * i\n     */\n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    /**\n     * <p>\n     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n     * fraction as the numerator divided by denominator multiplied by 100.\n     * </p>\n     *\n     * @return the fraction percentage as a <tt>double</tt>.\n     */\n    public double percentageValue() {\n", "suffix": "    }\n\n    /**\n     * <p>Creates a {@code Fraction} instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws MathArithmeticException if the denominator is {@code zero}\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n", "buggy": "                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    /**\n     * Divide the fraction by an integer.\n     * @param i the <tt>integer</tt> to divide by.\n     * @return this * i\n     */\n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    /**\n     * <p>\n     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n     * fraction as the numerator divided by denominator multiplied by 100.\n     * </p>\n     *\n     * @return the fraction percentage as a <tt>double</tt>.\n     */\n    public double percentageValue() {\n        return multiply(100).doubleValue();\n    }\n\n    /**\n     * <p>Creates a {@code Fraction} instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws MathArithmeticException if the denominator is {@code zero}\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n", "fix": "                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }\n\n    /**\n     * Divide the fraction by an integer.\n     * @param i the <tt>integer</tt> to divide by.\n     * @return this * i\n     */\n    public Fraction divide(final int i) {\n        return new Fraction(numerator, denominator * i);\n    }\n\n    /**\n     * <p>\n     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n     * fraction as the numerator divided by denominator multiplied by 100.\n     * </p>\n     *\n     * @return the fraction percentage as a <tt>double</tt>.\n     */\n    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n\n    /**\n     * <p>Creates a {@code Fraction} instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws MathArithmeticException if the denominator is {@code zero}\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n", "start": 573, "end": 619, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_27/src/main/java/org/apache/commons/math3/fraction/Fraction.java"}], "jacksondatabind_17": [{"prefix": "            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n", "suffix": "\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n", "buggy": "            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n", "fix": "            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n", "start": 155, "end": 203, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java"}], "jacksonxml_5": [{"prefix": "    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n", "suffix": "    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n", "buggy": "    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = src._rootNameLookup;\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n", "fix": "    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = new XmlRootNameLookup();\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n", "start": 28, "end": 88, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksonxml_5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java"}], "compress_19": [{"prefix": "            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n", "suffix": "                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n", "buggy": "            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n", "fix": "            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n", "start": 235, "end": 281, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/compress_19/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java"}], "math_5": [{"prefix": "     *\n     * @param  divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @see #divide(Complex)\n     */\n    public Complex divide(double divisor) {\n        if (isNaN || Double.isNaN(divisor)) {\n            return NaN;\n        }\n        if (divisor == 0d) {\n            return NaN;\n        }\n        if (Double.isInfinite(divisor)) {\n            return !isInfinite() ? ZERO : NaN;\n        }\n        return createComplex(real / divisor,\n                             imaginary  / divisor);\n    }\n\n    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n", "suffix": "        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n\n    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n", "buggy": "     *\n     * @param  divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @see #divide(Complex)\n     */\n    public Complex divide(double divisor) {\n        if (isNaN || Double.isNaN(divisor)) {\n            return NaN;\n        }\n        if (divisor == 0d) {\n            return NaN;\n        }\n        if (Double.isInfinite(divisor)) {\n            return !isInfinite() ? ZERO : NaN;\n        }\n        return createComplex(real / divisor,\n                             imaginary  / divisor);\n    }\n\n    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n\n    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n", "fix": "     *\n     * @param  divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @see #divide(Complex)\n     */\n    public Complex divide(double divisor) {\n        if (isNaN || Double.isNaN(divisor)) {\n            return NaN;\n        }\n        if (divisor == 0d) {\n            return NaN;\n        }\n        if (Double.isInfinite(divisor)) {\n            return !isInfinite() ? ZERO : NaN;\n        }\n        return createComplex(real / divisor,\n                             imaginary  / divisor);\n    }\n\n    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n\n    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n", "start": 278, "end": 330, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_5/src/main/java/org/apache/commons/math3/complex/Complex.java"}], "chart_20": [{"prefix": "        super();\n        this.value = value;\n    }\n    \n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke) {\n        this(value, paint, stroke, paint, stroke, 1.0f);\n    }\n    \n    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n", "suffix": "        this.value = value;\n    }\n    \n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     * \n     * @see #setValue(double)\n     */\n    public double getValue() {\n        return this.value;\n    }\n    \n    /**\n     * Sets the value for the marker and sends a {@link MarkerChangeEvent} to \n     * all registered listeners.\n     * \n     * @param value  the value.\n     * \n     * @see #getValue()\n     * \n     * @since 1.0.3\n     */\n    public void setValue(double value) { \n        this.value = value;\n        notifyListeners(new MarkerChangeEvent(this));\n", "buggy": "        super();\n        this.value = value;\n    }\n    \n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke) {\n        this(value, paint, stroke, paint, stroke, 1.0f);\n    }\n    \n    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, paint, stroke, alpha);\n        this.value = value;\n    }\n    \n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     * \n     * @see #setValue(double)\n     */\n    public double getValue() {\n        return this.value;\n    }\n    \n    /**\n     * Sets the value for the marker and sends a {@link MarkerChangeEvent} to \n     * all registered listeners.\n     * \n     * @param value  the value.\n     * \n     * @see #getValue()\n     * \n     * @since 1.0.3\n     */\n    public void setValue(double value) { \n        this.value = value;\n        notifyListeners(new MarkerChangeEvent(this));\n", "fix": "        super();\n        this.value = value;\n    }\n    \n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke) {\n        this(value, paint, stroke, paint, stroke, 1.0f);\n    }\n    \n    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n        this.value = value;\n    }\n    \n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     * \n     * @see #setValue(double)\n     */\n    public double getValue() {\n        return this.value;\n    }\n    \n    /**\n     * Sets the value for the marker and sends a {@link MarkerChangeEvent} to \n     * all registered listeners.\n     * \n     * @param value  the value.\n     * \n     * @see #getValue()\n     * \n     * @since 1.0.3\n     */\n    public void setValue(double value) { \n        this.value = value;\n        notifyListeners(new MarkerChangeEvent(this));\n", "start": 67, "end": 121, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_20/source/org/jfree/chart/plot/ValueMarker.java"}], "math_70": [{"prefix": "     */\n    @Deprecated\n    public BisectionSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    /**\n     * Construct a solver.\n     *\n     */\n    public BisectionSolver() {\n        super(100, 1E-6);\n    }\n\n    /** {@inheritDoc} */\n    @Deprecated\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    @Deprecated\n    public double solve(double min, double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n", "suffix": "    }\n\n    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min,max);\n        double m;\n        double fm;\n        double fmin;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            m = UnivariateRealSolverUtils.midpoint(min, max);\n           fmin = f.value(min);\n           fm = f.value(m);\n\n            if (fm * fmin > 0.0) {\n                // max and m bracket the root.\n                min = m;\n            } else {\n                // min and m bracket the root.\n                max = m;\n            }\n\n            if (Math.abs(max - min) <= absoluteAccuracy) {\n                m = UnivariateRealSolverUtils.midpoint(min, max);\n                setResult(m, i);\n                return m;\n            }\n", "buggy": "     */\n    @Deprecated\n    public BisectionSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    /**\n     * Construct a solver.\n     *\n     */\n    public BisectionSolver() {\n        super(100, 1E-6);\n    }\n\n    /** {@inheritDoc} */\n    @Deprecated\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    @Deprecated\n    public double solve(double min, double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n    }\n\n    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min,max);\n        double m;\n        double fm;\n        double fmin;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            m = UnivariateRealSolverUtils.midpoint(min, max);\n           fmin = f.value(min);\n           fm = f.value(m);\n\n            if (fm * fmin > 0.0) {\n                // max and m bracket the root.\n                min = m;\n            } else {\n                // min and m bracket the root.\n                max = m;\n            }\n\n            if (Math.abs(max - min) <= absoluteAccuracy) {\n                m = UnivariateRealSolverUtils.midpoint(min, max);\n                setResult(m, i);\n                return m;\n            }\n", "fix": "     */\n    @Deprecated\n    public BisectionSolver(UnivariateRealFunction f) {\n        super(f, 100, 1E-6);\n    }\n\n    /**\n     * Construct a solver.\n     *\n     */\n    public BisectionSolver() {\n        super(100, 1E-6);\n    }\n\n    /** {@inheritDoc} */\n    @Deprecated\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    @Deprecated\n    public double solve(double min, double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min,max);\n        double m;\n        double fm;\n        double fmin;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            m = UnivariateRealSolverUtils.midpoint(min, max);\n           fmin = f.value(min);\n           fm = f.value(m);\n\n            if (fm * fmin > 0.0) {\n                // max and m bracket the root.\n                min = m;\n            } else {\n                // min and m bracket the root.\n                max = m;\n            }\n\n            if (Math.abs(max - min) <= absoluteAccuracy) {\n                m = UnivariateRealSolverUtils.midpoint(min, max);\n                setResult(m, i);\n                return m;\n            }\n", "start": 40, "end": 102, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java"}], "closure_14": [{"prefix": "        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n", "suffix": "            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n", "buggy": "        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n", "fix": "        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n", "start": 743, "end": 789, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java"}], "jxpath_10": [{"prefix": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n", "suffix": "                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n", "buggy": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n", "fix": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n", "start": 13, "end": 69, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jxpath_10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java"}], "csv_4": [{"prefix": "     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n", "suffix": "    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n", "buggy": "     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n", "fix": "     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n", "start": 260, "end": 314, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/csv_4/src/main/java/org/apache/commons/csv/CSVParser.java"}], "closure_10": [{"prefix": "      // Inversion\n      case Token.NOT:\n      // delete operator returns a boolean.\n      case Token.DELPROP:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n\n\n  static class MayBeStringResultPredicate implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n      new MayBeStringResultPredicate();\n\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n) {\n    return mayBeString(n, true);\n  }\n\n  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n", "suffix": "    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static boolean mayBeStringHelper(Node n) {\n    return !isNumericResult(n) && !isBooleanResult(n)\n        && !isUndefined(n) && !n.isNull();\n  }\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n", "buggy": "      // Inversion\n      case Token.NOT:\n      // delete operator returns a boolean.\n      case Token.DELPROP:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n\n\n  static class MayBeStringResultPredicate implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n      new MayBeStringResultPredicate();\n\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n) {\n    return mayBeString(n, true);\n  }\n\n  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static boolean mayBeStringHelper(Node n) {\n    return !isNumericResult(n) && !isBooleanResult(n)\n        && !isUndefined(n) && !n.isNull();\n  }\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n", "fix": "      // Inversion\n      case Token.NOT:\n      // delete operator returns a boolean.\n      case Token.DELPROP:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n\n\n  static class MayBeStringResultPredicate implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n      new MayBeStringResultPredicate();\n\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n) {\n    return mayBeString(n, true);\n  }\n\n  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static boolean mayBeStringHelper(Node n) {\n    return !isNumericResult(n) && !isBooleanResult(n)\n        && !isUndefined(n) && !n.isNull();\n  }\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n", "start": 1385, "end": 1447, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_10/src/com/google/javascript/jscomp/NodeUtil.java"}], "mockito_5": [{"prefix": "     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n", "suffix": "                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    private AssertionError handleVerifyException(AssertionError e) {\n        if (canRecoverFromFailure(delegate)) {\n            sleep(pollingPeriodMillis);\n            return e;\n        } else {\n            throw e;\n        }\n    }\n\n    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n    }\n\n    private void sleep(long sleep) {\n        try {\n            Thread.sleep(sleep);\n        } catch (InterruptedException ie) {\n", "buggy": "     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    private AssertionError handleVerifyException(AssertionError e) {\n        if (canRecoverFromFailure(delegate)) {\n            sleep(pollingPeriodMillis);\n            return e;\n        } else {\n            throw e;\n        }\n    }\n\n    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n    }\n\n    private void sleep(long sleep) {\n        try {\n            Thread.sleep(sleep);\n        } catch (InterruptedException ie) {\n", "fix": "     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (AssertionError e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    private AssertionError handleVerifyException(AssertionError e) {\n        if (canRecoverFromFailure(delegate)) {\n            sleep(pollingPeriodMillis);\n            return e;\n        } else {\n            throw e;\n        }\n    }\n\n    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n    }\n\n    private void sleep(long sleep) {\n        try {\n            Thread.sleep(sleep);\n        } catch (InterruptedException ie) {\n", "start": 64, "end": 116, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java"}], "closure_52": [{"prefix": "          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n", "suffix": "  }\n\n  static double getSimpleNumber(String s) {\n    if (isSimpleNumber(s)) {\n      try {\n        long l = Long.parseLong(s);\n        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n          return l;\n        }\n      } catch (NumberFormatException e) {\n        // The number was too long to parse. Fall through to NaN.\n      }\n    }\n    return Double.NaN;\n  }\n\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n) {\n    return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);\n  }\n\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n", "buggy": "          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0;\n  }\n\n  static double getSimpleNumber(String s) {\n    if (isSimpleNumber(s)) {\n      try {\n        long l = Long.parseLong(s);\n        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n          return l;\n        }\n      } catch (NumberFormatException e) {\n        // The number was too long to parse. Fall through to NaN.\n      }\n    }\n    return Double.NaN;\n  }\n\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n) {\n    return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);\n  }\n\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n", "fix": "          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0 && s.charAt(0) != '0';\n  }\n\n  static double getSimpleNumber(String s) {\n    if (isSimpleNumber(s)) {\n      try {\n        long l = Long.parseLong(s);\n        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n          return l;\n        }\n      } catch (NumberFormatException e) {\n        // The number was too long to parse. Fall through to NaN.\n      }\n    }\n    return Double.NaN;\n  }\n\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n) {\n    return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);\n  }\n\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n", "start": 716, "end": 772, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_52/src/com/google/javascript/jscomp/CodeGenerator.java"}], "closure_57": [{"prefix": "  /**\n   * Exctracts X from goog.provide('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfProvide(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.provide\");\n  }\n\n  /**\n   * Exctracts X from goog.require('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfRequire(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.require\");\n  }\n\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n", "suffix": "            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting properties.\n   */\n  @Override\n  public String getExportPropertyFunction() {\n    return \"goog.exportProperty\";\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting symbols.\n   */\n  @Override\n  public String getExportSymbolFunction() {\n    return \"goog.exportSymbol\";\n  }\n\n  @Override\n  public List<String> identifyTypeDeclarationCall(Node n) {\n    Node callName = n.getFirstChild();\n", "buggy": "  /**\n   * Exctracts X from goog.provide('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfProvide(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.provide\");\n  }\n\n  /**\n   * Exctracts X from goog.require('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfRequire(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.require\");\n  }\n\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting properties.\n   */\n  @Override\n  public String getExportPropertyFunction() {\n    return \"goog.exportProperty\";\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting symbols.\n   */\n  @Override\n  public String getExportSymbolFunction() {\n    return \"goog.exportSymbol\";\n  }\n\n  @Override\n  public List<String> identifyTypeDeclarationCall(Node n) {\n    Node callName = n.getFirstChild();\n", "fix": "  /**\n   * Exctracts X from goog.provide('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfProvide(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.provide\");\n  }\n\n  /**\n   * Exctracts X from goog.require('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfRequire(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.require\");\n  }\n\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null && target.getType() == Token.STRING) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting properties.\n   */\n  @Override\n  public String getExportPropertyFunction() {\n    return \"goog.exportProperty\";\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting symbols.\n   */\n  @Override\n  public String getExportSymbolFunction() {\n    return \"goog.exportSymbol\";\n  }\n\n  @Override\n  public List<String> identifyTypeDeclarationCall(Node n) {\n    Node callName = n.getFirstChild();\n", "start": 167, "end": 225, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_57/src/com/google/javascript/jscomp/ClosureCodingConvention.java"}], "lang_59": [{"prefix": "        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n", "suffix": "            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n", "buggy": "        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n", "fix": "        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n", "start": 863, "end": 903, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_59/src/java/org/apache/commons/lang/text/StrBuilder.java"}], "jacksondatabind_16": [{"prefix": "            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n", "suffix": "    }\n}\n\n\n", "buggy": "            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous != null) && previous.equals(ann);\n    }\n}\n\n\n", "fix": "            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous == null) || !previous.equals(ann);\n    }\n}\n\n\n", "start": 49, "end": 173, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java"}], "mockito_26": [{"prefix": "    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n\n    static {\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n        primitiveTypes.put(Character.class, Character.TYPE);\n        primitiveTypes.put(Byte.class, Byte.TYPE);\n        primitiveTypes.put(Short.class, Short.TYPE);\n        primitiveTypes.put(Integer.class, Integer.TYPE);\n        primitiveTypes.put(Long.class, Long.TYPE);\n        primitiveTypes.put(Float.class, Float.TYPE);\n        primitiveTypes.put(Double.class, Double.TYPE);\n    }\n\n    static {\n        wrapperReturnValues.put(Boolean.class, false);\n        wrapperReturnValues.put(Character.class, '\\u0000');\n        wrapperReturnValues.put(Byte.class, (byte) 0);\n        wrapperReturnValues.put(Short.class, (short) 0);\n        wrapperReturnValues.put(Integer.class, 0);\n        wrapperReturnValues.put(Long.class, 0L);\n        wrapperReturnValues.put(Float.class, 0F);\n        wrapperReturnValues.put(Double.class, 0D);\n    }\n\n    static {\n        primitiveValues.put(boolean.class, false);\n        primitiveValues.put(char.class, '\\u0000');\n        primitiveValues.put(byte.class, (byte) 0);\n        primitiveValues.put(short.class, (short) 0);\n        primitiveValues.put(int.class, 0);\n        primitiveValues.put(long.class, 0L);\n        primitiveValues.put(float.class, 0F);\n", "suffix": "    }\n}", "buggy": "    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n\n    static {\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n        primitiveTypes.put(Character.class, Character.TYPE);\n        primitiveTypes.put(Byte.class, Byte.TYPE);\n        primitiveTypes.put(Short.class, Short.TYPE);\n        primitiveTypes.put(Integer.class, Integer.TYPE);\n        primitiveTypes.put(Long.class, Long.TYPE);\n        primitiveTypes.put(Float.class, Float.TYPE);\n        primitiveTypes.put(Double.class, Double.TYPE);\n    }\n\n    static {\n        wrapperReturnValues.put(Boolean.class, false);\n        wrapperReturnValues.put(Character.class, '\\u0000');\n        wrapperReturnValues.put(Byte.class, (byte) 0);\n        wrapperReturnValues.put(Short.class, (short) 0);\n        wrapperReturnValues.put(Integer.class, 0);\n        wrapperReturnValues.put(Long.class, 0L);\n        wrapperReturnValues.put(Float.class, 0F);\n        wrapperReturnValues.put(Double.class, 0D);\n    }\n\n    static {\n        primitiveValues.put(boolean.class, false);\n        primitiveValues.put(char.class, '\\u0000');\n        primitiveValues.put(byte.class, (byte) 0);\n        primitiveValues.put(short.class, (short) 0);\n        primitiveValues.put(int.class, 0);\n        primitiveValues.put(long.class, 0L);\n        primitiveValues.put(float.class, 0F);\n        primitiveValues.put(double.class, 0);\n    }\n}", "fix": "    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n\n    static {\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n        primitiveTypes.put(Character.class, Character.TYPE);\n        primitiveTypes.put(Byte.class, Byte.TYPE);\n        primitiveTypes.put(Short.class, Short.TYPE);\n        primitiveTypes.put(Integer.class, Integer.TYPE);\n        primitiveTypes.put(Long.class, Long.TYPE);\n        primitiveTypes.put(Float.class, Float.TYPE);\n        primitiveTypes.put(Double.class, Double.TYPE);\n    }\n\n    static {\n        wrapperReturnValues.put(Boolean.class, false);\n        wrapperReturnValues.put(Character.class, '\\u0000');\n        wrapperReturnValues.put(Byte.class, (byte) 0);\n        wrapperReturnValues.put(Short.class, (short) 0);\n        wrapperReturnValues.put(Integer.class, 0);\n        wrapperReturnValues.put(Long.class, 0L);\n        wrapperReturnValues.put(Float.class, 0F);\n        wrapperReturnValues.put(Double.class, 0D);\n    }\n\n    static {\n        primitiveValues.put(boolean.class, false);\n        primitiveValues.put(char.class, '\\u0000');\n        primitiveValues.put(byte.class, (byte) 0);\n        primitiveValues.put(short.class, (short) 0);\n        primitiveValues.put(int.class, 0);\n        primitiveValues.put(long.class, 0L);\n        primitiveValues.put(float.class, 0F);\n        primitiveValues.put(double.class, 0D);\n    }\n}", "start": 31, "end": 99, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_26/src/org/mockito/internal/util/Primitives.java"}], "chart_8": [{"prefix": "   }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     */\n    public Week(Date time) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n", "suffix": "    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     *\n     * @since 1.0.7\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        Calendar calendar = Calendar.getInstance(zone, locale);\n        calendar.setTime(time);\n", "buggy": "   }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     */\n    public Week(Date time) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     *\n     * @since 1.0.7\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        Calendar calendar = Calendar.getInstance(zone, locale);\n        calendar.setTime(time);\n", "fix": "   }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     */\n    public Week(Date time) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     *\n     * @since 1.0.7\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        Calendar calendar = Calendar.getInstance(zone, locale);\n        calendar.setTime(time);\n", "start": 150, "end": 198, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_8/source/org/jfree/data/time/Week.java"}], "mockito_38": [{"prefix": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification.argumentmatching;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.mockito.internal.matchers.ContainsExtraTypeInformation;\n\n@SuppressWarnings(\"unchecked\")\npublic class ArgumentMatchingTool {\n\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }\n\n    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    private boolean toStringEquals(Matcher m, Object arg) {\n", "suffix": "    }\n}\n", "buggy": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification.argumentmatching;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.mockito.internal.matchers.ContainsExtraTypeInformation;\n\n@SuppressWarnings(\"unchecked\")\npublic class ArgumentMatchingTool {\n\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }\n\n    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }\n}\n", "fix": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification.argumentmatching;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.mockito.internal.matchers.ContainsExtraTypeInformation;\n\n@SuppressWarnings(\"unchecked\")\npublic class ArgumentMatchingTool {\n\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }\n\n    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }\n}\n", "start": 0, "end": 94, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java"}], "collections_26": [{"prefix": "     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n", "suffix": "        calculateHashCode(keys);\n        return this;\n    }\n}\n", "buggy": "     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    private Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n", "fix": "     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    protected Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n", "start": 216, "end": 336, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/collections_26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java"}], "jsoup_17": [{"prefix": "        boolean process(Token t, TreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                // nice work chuck\n            } else if (t.isStartTag() && t.asStartTag().name().equals(\"nofrmes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, TreeBuilder tb) {\n            return true;\n            // todo: implement. Also; how do we get here?\n        }\n    };\n\n", "suffix": "\n    abstract boolean process(Token t, TreeBuilder tb);\n\n    private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n            for (int i = 0; i < data.length(); i++) {\n                char c = data.charAt(i);\n                if (!Character.isWhitespace(c))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n", "buggy": "        boolean process(Token t, TreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                // nice work chuck\n            } else if (t.isStartTag() && t.asStartTag().name().equals(\"nofrmes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, TreeBuilder tb) {\n            return true;\n            // todo: implement. Also; how do we get here?\n        }\n    };\n\n    private static String nullString = String.valueOf(0x0000);\n\n    abstract boolean process(Token t, TreeBuilder tb);\n\n    private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n            for (int i = 0; i < data.length(); i++) {\n                char c = data.charAt(i);\n                if (!Character.isWhitespace(c))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n", "fix": "        boolean process(Token t, TreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                // nice work chuck\n            } else if (t.isStartTag() && t.asStartTag().name().equals(\"nofrmes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    ForeignContent {\n        boolean process(Token t, TreeBuilder tb) {\n            return true;\n            // todo: implement. Also; how do we get here?\n        }\n    };\n\n    private static String nullString = String.valueOf('\\u0000');\n\n    abstract boolean process(Token t, TreeBuilder tb);\n\n    private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n            for (int i = 0; i < data.length(); i++) {\n                char c = data.charAt(i);\n                if (!Character.isWhitespace(c))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n\n", "start": 1426, "end": 1474, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_17/src/main/java/org/jsoup/parser/TreeBuilderState.java"}], "jacksondatabind_34": [{"prefix": "    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n", "suffix": "            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "buggy": "    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "fix": "    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "start": 40, "end": 120, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java"}], "math_32": [{"prefix": "        final Vector2D maxMin = new Vector2D(xMax, yMin);\n        final Vector2D maxMax = new Vector2D(xMax, yMax);\n        return new Line[] {\n            new Line(minMin, maxMin),\n            new Line(maxMin, maxMax),\n            new Line(maxMax, minMax),\n            new Line(minMax, minMin)\n        };\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n", "suffix": "                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n", "buggy": "        final Vector2D maxMin = new Vector2D(xMax, yMin);\n        final Vector2D maxMax = new Vector2D(xMax, yMax);\n        return new Line[] {\n            new Line(minMin, maxMin),\n            new Line(maxMin, maxMax),\n            new Line(maxMax, minMax),\n            new Line(minMax, minMin)\n        };\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n", "fix": "        final Vector2D maxMin = new Vector2D(xMax, yMin);\n        final Vector2D maxMax = new Vector2D(xMax, yMax);\n        return new Line[] {\n            new Line(minMin, maxMin),\n            new Line(maxMin, maxMax),\n            new Line(maxMax, minMax),\n            new Line(minMax, minMin)\n        };\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n", "start": 111, "end": 159, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java"}], "chart_1": [{"prefix": "     * @param index  the axis index.\n     *\n     * @return A range axis.\n     */\n    protected ValueAxis getRangeAxis(CategoryPlot plot, int index) {\n        ValueAxis result = plot.getRangeAxis(index);\n        if (result == null) {\n            result = plot.getRangeAxis();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n", "suffix": "            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n", "buggy": "     * @param index  the axis index.\n     *\n     * @return A range axis.\n     */\n    protected ValueAxis getRangeAxis(CategoryPlot plot, int index) {\n        ValueAxis result = plot.getRangeAxis(index);\n        if (result == null) {\n            result = plot.getRangeAxis();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n", "fix": "     * @param index  the axis index.\n     *\n     * @return A range axis.\n     */\n    protected ValueAxis getRangeAxis(CategoryPlot plot, int index) {\n        ValueAxis result = plot.getRangeAxis(index);\n        if (result == null) {\n            result = plot.getRangeAxis();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n", "start": 1769, "end": 1823, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java"}], "closure_113": [{"prefix": "      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n", "suffix": "        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Handles a goog.provide call.\n   */\n  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyProvide(t, left, arg)) {\n      String ns = arg.getString();\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      if (providedNames.containsKey(ns)) {\n        ProvidedName previouslyProvided = providedNames.get(ns);\n        if (!previouslyProvided.isExplicitlyProvided()) {\n          previouslyProvided.addProvide(parent, t.getModule(), true);\n        } else {\n          compiler.report(\n              t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));\n", "buggy": "      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Handles a goog.provide call.\n   */\n  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyProvide(t, left, arg)) {\n      String ns = arg.getString();\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      if (providedNames.containsKey(ns)) {\n        ProvidedName previouslyProvided = providedNames.get(ns);\n        if (!previouslyProvided.isExplicitlyProvided()) {\n          previouslyProvided.addProvide(parent, t.getModule(), true);\n        } else {\n          compiler.report(\n              t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));\n", "fix": "      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null || requiresLevel.isOn()) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Handles a goog.provide call.\n   */\n  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyProvide(t, left, arg)) {\n      String ns = arg.getString();\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      if (providedNames.containsKey(ns)) {\n        ProvidedName previouslyProvided = providedNames.get(ns);\n        if (!previouslyProvided.isExplicitlyProvided()) {\n          previouslyProvided.addProvide(parent, t.getModule(), true);\n        } else {\n          compiler.report(\n              t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));\n", "start": 303, "end": 353, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java"}], "jsoup_34": [{"prefix": "     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n", "suffix": "                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n", "buggy": "     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n", "fix": "     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n", "start": 65, "end": 115, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_34/src/main/java/org/jsoup/parser/CharacterReader.java"}], "cli_11": [{"prefix": "        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n", "suffix": "        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n", "buggy": "        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n", "fix": "        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n", "start": 600, "end": 662, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/cli_11/src/java/org/apache/commons/cli/HelpFormatter.java"}], "math_2": [{"prefix": "     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n     * {@code dx}.\n     *\n     * @param x0 Inclusive lower bound.\n     * @param x1 Inclusive upper bound.\n     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n     * 0 indicates summing from x1 to x0).\n     * @return {@code P(x0 <= X <= x1)}.\n     */\n    private double innerCumulativeProbability(int x0, int x1, int dx) {\n        double ret = probability(x0);\n        while (x0 != x1) {\n            x0 += dx;\n            ret += probability(x0);\n        }\n        return ret;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n", "suffix": "    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the variance is\n     * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n     */\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    /**\n     * Used by {@link #getNumericalVariance()}.\n     *\n     * @return the variance of this distribution\n     */\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n        final double m = getNumberOfSuccesses();\n", "buggy": "     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n     * {@code dx}.\n     *\n     * @param x0 Inclusive lower bound.\n     * @param x1 Inclusive upper bound.\n     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n     * 0 indicates summing from x1 to x0).\n     * @return {@code P(x0 <= X <= x1)}.\n     */\n    private double innerCumulativeProbability(int x0, int x1, int dx) {\n        double ret = probability(x0);\n        while (x0 != x1) {\n            x0 += dx;\n            ret += probability(x0);\n        }\n        return ret;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the variance is\n     * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n     */\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    /**\n     * Used by {@link #getNumericalVariance()}.\n     *\n     * @return the variance of this distribution\n     */\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n        final double m = getNumberOfSuccesses();\n", "fix": "     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n     * {@code dx}.\n     *\n     * @param x0 Inclusive lower bound.\n     * @param x1 Inclusive upper bound.\n     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n     * 0 indicates summing from x1 to x0).\n     * @return {@code P(x0 <= X <= x1)}.\n     */\n    private double innerCumulativeProbability(int x0, int x1, int dx) {\n        double ret = probability(x0);\n        while (x0 != x1) {\n            x0 += dx;\n            ret += probability(x0);\n        }\n        return ret;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the variance is\n     * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n     */\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    /**\n     * Used by {@link #getNumericalVariance()}.\n     *\n     * @return the variance of this distribution\n     */\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n        final double m = getNumberOfSuccesses();\n", "start": 242, "end": 292, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java"}], "codec_17": [{"prefix": "            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n", "suffix": "    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n", "buggy": "            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n", "fix": "            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n", "start": 319, "end": 357, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_17/src/main/java/org/apache/commons/codec/binary/StringUtils.java"}], "lang_24": [{"prefix": "                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n", "suffix": "            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n    \n}\n", "buggy": "                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n    \n}\n", "fix": "                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp && !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n    \n}\n", "start": 1366, "end": 1458, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java"}], "jsoup_41": [{"prefix": "            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n", "suffix": "    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n}\n", "buggy": "            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n}\n", "fix": "            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return tag.equals(element.tag);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n}\n", "start": 1128, "end": 1220, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_41/src/main/java/org/jsoup/nodes/Element.java"}], "closure_114": [{"prefix": "      }\n    }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n", "suffix": "          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n      Preconditions.checkNotNull(name);\n      scopes.put(node, name);\n    }\n  }\n\n  /**\n   * Create JsName objects for variable and function declarations in\n   * the global scope before computing name references.  In JavaScript\n", "buggy": "      }\n    }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n      Preconditions.checkNotNull(name);\n      scopes.put(node, name);\n    }\n  }\n\n  /**\n   * Create JsName objects for variable and function declarations in\n   * the global scope before computing name references.  In JavaScript\n", "fix": "      }\n    }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n      Preconditions.checkNotNull(name);\n      scopes.put(node, name);\n    }\n  }\n\n  /**\n   * Create JsName objects for variable and function declarations in\n   * the global scope before computing name references.  In JavaScript\n", "start": 554, "end": 600, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_114/src/com/google/javascript/jscomp/NameAnalyzer.java"}], "time_19": [{"prefix": "     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n", "suffix": "            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n", "buggy": "     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n", "fix": "     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n", "start": 877, "end": 921, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/time_19/src/main/java/org/joda/time/DateTimeZone.java"}], "lang_57": [{"prefix": "     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable set of available locales\n     */\n    public static Set availableLocaleSet() {\n        Set set = cAvailableLocaleSet;\n        if (set == null) {\n            set = new HashSet(availableLocaleList());\n            set = Collections.unmodifiableSet(set);\n            cAvailableLocaleSet = set;\n        }\n        return set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n", "suffix": "    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of languages supported for a given country.</p>\n     *\n     * <p>This method takes a country code and searches to find the\n     * languages available for that country. Variant locales are removed.</p>\n     *\n     * @param countryCode  the 2 letter country code, null returns empty\n     * @return an unmodifiable List of Locale objects, never null\n     */\n    public static List languagesByCountry(String countryCode) {\n        List langs = (List) cLanguagesByCountry.get(countryCode);  //syncd\n        if (langs == null) {\n            if (countryCode != null) {\n                langs = new ArrayList();\n                List locales = availableLocaleList();\n                for (int i = 0; i < locales.size(); i++) {\n                    Locale locale = (Locale) locales.get(i);\n                    if (countryCode.equals(locale.getCountry()) &&\n                            locale.getVariant().length() == 0) {\n                        langs.add(locale);\n", "buggy": "     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable set of available locales\n     */\n    public static Set availableLocaleSet() {\n        Set set = cAvailableLocaleSet;\n        if (set == null) {\n            set = new HashSet(availableLocaleList());\n            set = Collections.unmodifiableSet(set);\n            cAvailableLocaleSet = set;\n        }\n        return set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of languages supported for a given country.</p>\n     *\n     * <p>This method takes a country code and searches to find the\n     * languages available for that country. Variant locales are removed.</p>\n     *\n     * @param countryCode  the 2 letter country code, null returns empty\n     * @return an unmodifiable List of Locale objects, never null\n     */\n    public static List languagesByCountry(String countryCode) {\n        List langs = (List) cLanguagesByCountry.get(countryCode);  //syncd\n        if (langs == null) {\n            if (countryCode != null) {\n                langs = new ArrayList();\n                List locales = availableLocaleList();\n                for (int i = 0; i < locales.size(); i++) {\n                    Locale locale = (Locale) locales.get(i);\n                    if (countryCode.equals(locale.getCountry()) &&\n                            locale.getVariant().length() == 0) {\n                        langs.add(locale);\n", "fix": "     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable set of available locales\n     */\n    public static Set availableLocaleSet() {\n        Set set = cAvailableLocaleSet;\n        if (set == null) {\n            set = new HashSet(availableLocaleList());\n            set = Collections.unmodifiableSet(set);\n            cAvailableLocaleSet = set;\n        }\n        return set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of languages supported for a given country.</p>\n     *\n     * <p>This method takes a country code and searches to find the\n     * languages available for that country. Variant locales are removed.</p>\n     *\n     * @param countryCode  the 2 letter country code, null returns empty\n     * @return an unmodifiable List of Locale objects, never null\n     */\n    public static List languagesByCountry(String countryCode) {\n        List langs = (List) cLanguagesByCountry.get(countryCode);  //syncd\n        if (langs == null) {\n            if (countryCode != null) {\n                langs = new ArrayList();\n                List locales = availableLocaleList();\n                for (int i = 0; i < locales.size(); i++) {\n                    Locale locale = (Locale) locales.get(i);\n                    if (countryCode.equals(locale.getCountry()) &&\n                            locale.getVariant().length() == 0) {\n                        langs.add(locale);\n", "start": 199, "end": 245, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_57/src/java/org/apache/commons/lang/LocaleUtils.java"}], "closure_70": [{"prefix": "                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n", "suffix": "              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n  } // end LocalScopeBuilder\n\n\n  /** Find the best JSDoc for the given node. */\n  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      int parentType = parent.getType();\n      if (parentType == Token.NAME) {\n        info = parent.getJSDocInfo();\n        if (info == null && parent.getParent().hasOneChild()) {\n          info = parent.getParent().getJSDocInfo();\n        }\n      } else if (parentType == Token.ASSIGN) {\n        info = parent.getJSDocInfo();\n", "buggy": "                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n  } // end LocalScopeBuilder\n\n\n  /** Find the best JSDoc for the given node. */\n  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      int parentType = parent.getType();\n      if (parentType == Token.NAME) {\n        info = parent.getJSDocInfo();\n        if (info == null && parent.getParent().hasOneChild()) {\n          info = parent.getParent().getJSDocInfo();\n        }\n      } else if (parentType == Token.ASSIGN) {\n        info = parent.getJSDocInfo();\n", "fix": "                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n  } // end LocalScopeBuilder\n\n\n  /** Find the best JSDoc for the given node. */\n  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      int parentType = parent.getType();\n      if (parentType == Token.NAME) {\n        info = parent.getJSDocInfo();\n        if (info == null && parent.getParent().hasOneChild()) {\n          info = parent.getParent().getJSDocInfo();\n        }\n      } else if (parentType == Token.ASSIGN) {\n        info = parent.getJSDocInfo();\n", "start": 1720, "end": 1768, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_70/src/com/google/javascript/jscomp/TypedScopeCreator.java"}], "gson_15": [{"prefix": "   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n", "suffix": "      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n", "buggy": "   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n", "fix": "   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n", "start": 462, "end": 526, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/gson_15/gson/src/main/java/com/google/gson/stream/JsonWriter.java"}], "codec_9": [{"prefix": "        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n", "suffix": "        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n", "buggy": "        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n", "fix": "        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n", "start": 802, "end": 850, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_9/src/java/org/apache/commons/codec/binary/Base64.java"}], "closure_92": [{"prefix": "          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n", "suffix": "          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n\n    /**\n     * Create the declaration node for this name, without inserting it\n", "buggy": "          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n\n    /**\n     * Create the declaration node for this name, without inserting it\n", "fix": "          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.lastIndexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n\n    /**\n     * Create the declaration node for this name, without inserting it\n", "start": 765, "end": 811, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java"}], "math_34": [{"prefix": "            if (chromosome.compareTo(bestChromosome) > 0) {\n                // better chromosome found\n                bestChromosome = chromosome;\n            }\n        }\n        return bestChromosome;\n    }\n\n    /**\n     * Access the maximum population size.\n     * @return the maximum population size.\n     */\n    public int getPopulationLimit() {\n        return this.populationLimit;\n    }\n\n    /**\n     * Sets the maximal population size.\n     * @param populationLimit maximal population size.\n     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n     * @throws NumberIsTooSmallException if the new population size is smaller than the current number\n     * of chromosomes in the population\n     */\n    public void setPopulationLimit(final int populationLimit) {\n        if (populationLimit <= 0) {\n            throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n        }\n        if (populationLimit < chromosomes.size()) {\n            throw new NumberIsTooSmallException(populationLimit, chromosomes.size(), true);\n        }\n        this.populationLimit = populationLimit;\n    }\n\n    /**\n     * Access the current population size.\n     * @return the current population size.\n     */\n    public int getPopulationSize() {\n        return this.chromosomes.size();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        return this.chromosomes.toString();\n    }\n\n    /**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n     *\n     * @return chromosome iterator\n     */\n    public Iterator<Chromosome> iterator() {\n", "suffix": "    }\n}\n", "buggy": "            if (chromosome.compareTo(bestChromosome) > 0) {\n                // better chromosome found\n                bestChromosome = chromosome;\n            }\n        }\n        return bestChromosome;\n    }\n\n    /**\n     * Access the maximum population size.\n     * @return the maximum population size.\n     */\n    public int getPopulationLimit() {\n        return this.populationLimit;\n    }\n\n    /**\n     * Sets the maximal population size.\n     * @param populationLimit maximal population size.\n     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n     * @throws NumberIsTooSmallException if the new population size is smaller than the current number\n     * of chromosomes in the population\n     */\n    public void setPopulationLimit(final int populationLimit) {\n        if (populationLimit <= 0) {\n            throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n        }\n        if (populationLimit < chromosomes.size()) {\n            throw new NumberIsTooSmallException(populationLimit, chromosomes.size(), true);\n        }\n        this.populationLimit = populationLimit;\n    }\n\n    /**\n     * Access the current population size.\n     * @return the current population size.\n     */\n    public int getPopulationSize() {\n        return this.chromosomes.size();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        return this.chromosomes.toString();\n    }\n\n    /**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n     *\n     * @return chromosome iterator\n     */\n    public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }\n}\n", "fix": "            if (chromosome.compareTo(bestChromosome) > 0) {\n                // better chromosome found\n                bestChromosome = chromosome;\n            }\n        }\n        return bestChromosome;\n    }\n\n    /**\n     * Access the maximum population size.\n     * @return the maximum population size.\n     */\n    public int getPopulationLimit() {\n        return this.populationLimit;\n    }\n\n    /**\n     * Sets the maximal population size.\n     * @param populationLimit maximal population size.\n     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n     * @throws NumberIsTooSmallException if the new population size is smaller than the current number\n     * of chromosomes in the population\n     */\n    public void setPopulationLimit(final int populationLimit) {\n        if (populationLimit <= 0) {\n            throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n        }\n        if (populationLimit < chromosomes.size()) {\n            throw new NumberIsTooSmallException(populationLimit, chromosomes.size(), true);\n        }\n        this.populationLimit = populationLimit;\n    }\n\n    /**\n     * Access the current population size.\n     * @return the current population size.\n     */\n    public int getPopulationSize() {\n        return this.chromosomes.size();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        return this.chromosomes.toString();\n    }\n\n    /**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n     *\n     * @return chromosome iterator\n     */\n    public Iterator<Chromosome> iterator() {\n        return getChromosomes().iterator();\n    }\n}\n", "start": 152, "end": 264, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java"}], "jsoup_86": [{"prefix": "     */\n    public Comment(String data, String baseUri) {\n        this(data);\n    }\n\n    public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n", "suffix": "            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}\n", "buggy": "     */\n    public Comment(String data, String baseUri) {\n        this(data);\n    }\n\n    public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.childNodeSize() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}\n", "fix": "     */\n    public Comment(String data, String baseUri) {\n        this(data);\n    }\n\n    public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.children().size() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}\n", "start": 27, "end": 127, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_86/src/main/java/org/jsoup/nodes/Comment.java"}], "jacksondatabind_82": [{"prefix": "    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n", "suffix": "            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n", "buggy": "    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n", "fix": "    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n", "start": 474, "end": 514, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java"}], "time_7": [], "mockito_8": [{"prefix": "\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n", "suffix": "                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable typeVariable : typeParameters) {\n            registerTypeVariableIfNotPresent(typeVariable);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n", "buggy": "\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable typeVariable : typeParameters) {\n            registerTypeVariableIfNotPresent(typeVariable);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n", "fix": "\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable typeVariable : typeParameters) {\n            registerTypeVariableIfNotPresent(typeVariable);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n", "start": 58, "end": 98, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java"}], "cli_40": [{"prefix": "        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n", "suffix": "        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n", "buggy": "        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n", "fix": "        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            throw new ParseException(\"Unable to handle the class: \"  clazz);\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n", "start": 69, "end": 135, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/cli_40/src/main/java/org/apache/commons/cli/TypeHandler.java"}], "jacksoncore_5": [{"prefix": "\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n", "suffix": "            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n", "buggy": "\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n", "fix": "\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n", "start": 167, "end": 217, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksoncore_5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java"}], "closure_130": [{"prefix": "   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n", "suffix": "          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n", "buggy": "   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n", "fix": "   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n", "start": 152, "end": 190, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_130/src/com/google/javascript/jscomp/CollapseProperties.java"}], "math_94": [{"prefix": "            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n", "suffix": "            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n", "buggy": "            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n", "fix": "            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n", "start": 388, "end": 434, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_94/src/java/org/apache/commons/math/util/MathUtils.java"}], "cli_8": [{"prefix": "     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n", "suffix": "\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n", "buggy": "     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, nextLineTabStop);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n", "fix": "     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n", "start": 785, "end": 837, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/cli_8/src/java/org/apache/commons/cli/HelpFormatter.java"}], "lang_16": [{"prefix": "     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n", "suffix": "            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n", "buggy": "     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n", "fix": "     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n", "start": 435, "end": 479, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java"}], "math_58": [{"prefix": "                        // Do nothing.\n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }\n\n    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n", "suffix": "    }\n\n    /**\n     * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n     * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n     * based on the specified observed points.\n     */\n    public static class ParameterGuesser {\n        /** Observed points. */\n        private final WeightedObservedPoint[] observations;\n        /** Resulting guessed parameters. */\n        private double[] parameters;\n\n        /**\n         * Constructs instance with the specified observed points.\n         *\n         * @param observations observed points upon which should base guess\n         */\n        public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations == null) {\n                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n            }\n            if (observations.length < 3) {\n                throw new NumberIsTooSmallException(observations.length, 3, true);\n            }\n            this.observations = observations.clone();\n        }\n\n        /**\n", "buggy": "                        // Do nothing.\n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }\n\n    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n    }\n\n    /**\n     * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n     * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n     * based on the specified observed points.\n     */\n    public static class ParameterGuesser {\n        /** Observed points. */\n        private final WeightedObservedPoint[] observations;\n        /** Resulting guessed parameters. */\n        private double[] parameters;\n\n        /**\n         * Constructs instance with the specified observed points.\n         *\n         * @param observations observed points upon which should base guess\n         */\n        public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations == null) {\n                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n            }\n            if (observations.length < 3) {\n                throw new NumberIsTooSmallException(observations.length, 3, true);\n            }\n            this.observations = observations.clone();\n        }\n\n        /**\n", "fix": "                        // Do nothing.\n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }\n\n    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n    }\n\n    /**\n     * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n     * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n     * based on the specified observed points.\n     */\n    public static class ParameterGuesser {\n        /** Observed points. */\n        private final WeightedObservedPoint[] observations;\n        /** Resulting guessed parameters. */\n        private double[] parameters;\n\n        /**\n         * Constructs instance with the specified observed points.\n         *\n         * @param observations observed points upon which should base guess\n         */\n        public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations == null) {\n                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n            }\n            if (observations.length < 3) {\n                throw new NumberIsTooSmallException(observations.length, 3, true);\n            }\n            this.observations = observations.clone();\n        }\n\n        /**\n", "start": 91, "end": 149, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java"}], "jacksoncore_25": [{"prefix": "                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n", "suffix": "                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n", "buggy": "                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n", "fix": "                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n", "start": 1937, "end": 1987, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksoncore_25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java"}], "jacksoncore_8": [{"prefix": "         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n", "suffix": "        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n", "buggy": "         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n", "fix": "         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n", "start": 280, "end": 332, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksoncore_8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java"}], "chart_13": [{"prefix": "                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n", "suffix": "                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n", "buggy": "                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n", "fix": "                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n", "start": 437, "end": 471, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_13/source/org/jfree/chart/block/BorderArrangement.java"}], "closure_86": [{"prefix": "           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n", "suffix": "      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n", "buggy": "           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n", "fix": "           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return false;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n", "start": 2440, "end": 2488, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_86/src/com/google/javascript/jscomp/NodeUtil.java"}], "jsoup_61": [{"prefix": "    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n", "suffix": "        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n", "buggy": "    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n", "fix": "    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n        final String classAttr = attributes.getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n", "start": 1066, "end": 1116, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_61/src/main/java/org/jsoup/nodes/Element.java"}], "lang_33": [{"prefix": "        }\n        return className;\n    }\n\n    /**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n", "suffix": "        }\n        return classes;\n    }\n\n    // Short canonical name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    /**\n", "buggy": "        }\n        return className;\n    }\n\n    /**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }\n\n    // Short canonical name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    /**\n", "fix": "        }\n        return className;\n    }\n\n    /**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i] == null ? null : array[i].getClass();\n        }\n        return classes;\n    }\n\n    // Short canonical name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    /**\n", "start": 887, "end": 931, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_33/src/main/java/org/apache/commons/lang3/ClassUtils.java"}], "chart_9": [{"prefix": "     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n", "suffix": "            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n", "buggy": "     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n", "fix": "     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n", "start": 915, "end": 971, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/chart_9/source/org/jfree/data/time/TimeSeries.java"}], "closure_67": [{"prefix": "      for (int i = symbolStack.size() - 1; i >= 0; i--) {\n        def = symbolStack.get(i).name;\n        if (def != anonymousNode) {\n          break;\n        }\n      }\n      if (!def.equals(info)) {\n        symbolGraph.connect(def, module, info);\n      }\n    }\n\n    /**\n     * Determines whether {@code n} is the FUNCTION node in a global function\n     * declaration.\n     */\n    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      return t.inGlobalScope() &&\n          (NodeUtil.isFunctionDeclaration(n) ||\n           n.getType() == Token.FUNCTION &&\n           n.getParent().getType() == Token.NAME);\n    }\n\n    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n", "suffix": "        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Processes a NAME node to see if it's a global function declaration.\n     * If it is, record it and return true. Otherwise, return false.\n     */\n    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n      Node firstChild = nameNode.getFirstChild();\n\n      if (// Check for a named FUNCTION.\n", "buggy": "      for (int i = symbolStack.size() - 1; i >= 0; i--) {\n        def = symbolStack.get(i).name;\n        if (def != anonymousNode) {\n          break;\n        }\n      }\n      if (!def.equals(info)) {\n        symbolGraph.connect(def, module, info);\n      }\n    }\n\n    /**\n     * Determines whether {@code n} is the FUNCTION node in a global function\n     * declaration.\n     */\n    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      return t.inGlobalScope() &&\n          (NodeUtil.isFunctionDeclaration(n) ||\n           n.getType() == Token.FUNCTION &&\n           n.getParent().getType() == Token.NAME);\n    }\n\n    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          ) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Processes a NAME node to see if it's a global function declaration.\n     * If it is, record it and return true. Otherwise, return false.\n     */\n    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n      Node firstChild = nameNode.getFirstChild();\n\n      if (// Check for a named FUNCTION.\n", "fix": "      for (int i = symbolStack.size() - 1; i >= 0; i--) {\n        def = symbolStack.get(i).name;\n        if (def != anonymousNode) {\n          break;\n        }\n      }\n      if (!def.equals(info)) {\n        symbolGraph.connect(def, module, info);\n      }\n    }\n\n    /**\n     * Determines whether {@code n} is the FUNCTION node in a global function\n     * declaration.\n     */\n    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      return t.inGlobalScope() &&\n          (NodeUtil.isFunctionDeclaration(n) ||\n           n.getType() == Token.FUNCTION &&\n           n.getParent().getType() == Token.NAME);\n    }\n\n    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          && assign.getParent().getType() == Token.EXPR_RESULT) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Processes a NAME node to see if it's a global function declaration.\n     * If it is, record it and return true. Otherwise, return false.\n     */\n    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n      Node firstChild = nameNode.getFirstChild();\n\n      if (// Check for a named FUNCTION.\n", "start": 291, "end": 343, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java"}], "codec_18": [{"prefix": "     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n", "suffix": "    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n", "buggy": "     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n", "fix": "     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n", "start": 55, "end": 105, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_18/src/main/java/org/apache/commons/codec/binary/StringUtils.java"}], "closure_62": [{"prefix": "            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n", "suffix": "        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n\n  /**\n   * Formats a region by appending line numbers in front, e.g.\n   * <pre>   9| if (foo) {\n   *   10|   alert('bar');\n   *   11| }</pre>\n   * and return line excerpt without any modification.\n   */\n  static class LineNumberingFormatter implements ExcerptFormatter {\n    public String formatLine(String line, int lineNumber) {\n      return line;\n    }\n\n    public String formatRegion(Region region) {\n", "buggy": "            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n\n  /**\n   * Formats a region by appending line numbers in front, e.g.\n   * <pre>   9| if (foo) {\n   *   10|   alert('bar');\n   *   11| }</pre>\n   * and return line excerpt without any modification.\n   */\n  static class LineNumberingFormatter implements ExcerptFormatter {\n    public String formatLine(String line, int lineNumber) {\n      return line;\n    }\n\n    public String formatRegion(Region region) {\n", "fix": "            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n\n  /**\n   * Formats a region by appending line numbers in front, e.g.\n   * <pre>   9| if (foo) {\n   *   10|   alert('bar');\n   *   11| }</pre>\n   * and return line excerpt without any modification.\n   */\n  static class LineNumberingFormatter implements ExcerptFormatter {\n    public String formatLine(String line, int lineNumber) {\n      return line;\n    }\n\n    public String formatRegion(Region region) {\n", "start": 70, "end": 124, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java"}], "math_85": [{"prefix": "            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n", "suffix": "            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n", "buggy": "            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n", "fix": "            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb > 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n", "start": 173, "end": 221, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java"}], "jsoup_37": [{"prefix": "            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n", "suffix": "    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n", "buggy": "            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n", "fix": "            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n", "start": 1075, "end": 1125, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_37/src/main/java/org/jsoup/nodes/Element.java"}], "math_11": [{"prefix": "            }\n        }\n\n        samplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n    }\n\n    /**\n     * Gets the mean vector.\n     *\n     * @return the mean vector.\n     */\n    public double[] getMeans() {\n        return MathArrays.copyOf(means);\n    }\n\n    /**\n     * Gets the covariance matrix.\n     *\n     * @return the covariance matrix.\n     */\n    public RealMatrix getCovariances() {\n        return covarianceMatrix.copy();\n    }\n\n    /** {@inheritDoc} */\n    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n", "suffix": "            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n\n    /**\n     * Gets the square root of each element on the diagonal of the covariance\n     * matrix.\n     *\n     * @return the standard deviations.\n     */\n    public double[] getStandardDeviations() {\n        final int dim = getDimension();\n        final double[] std = new double[dim];\n        final double[][] s = covarianceMatrix.getData();\n        for (int i = 0; i < dim; i++) {\n            std[i] = FastMath.sqrt(s[i][i]);\n        }\n        return std;\n    }\n\n    /** {@inheritDoc} */\n    public double[] sample() {\n        final int dim = getDimension();\n        final double[] normalVals = new double[dim];\n\n        for (int i = 0; i < dim; i++) {\n            normalVals[i] = random.nextGaussian();\n        }\n\n        final double[] vals = samplingMatrix.operate(normalVals);\n\n", "buggy": "            }\n        }\n\n        samplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n    }\n\n    /**\n     * Gets the mean vector.\n     *\n     * @return the mean vector.\n     */\n    public double[] getMeans() {\n        return MathArrays.copyOf(means);\n    }\n\n    /**\n     * Gets the covariance matrix.\n     *\n     * @return the covariance matrix.\n     */\n    public RealMatrix getCovariances() {\n        return covarianceMatrix.copy();\n    }\n\n    /** {@inheritDoc} */\n    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n\n    /**\n     * Gets the square root of each element on the diagonal of the covariance\n     * matrix.\n     *\n     * @return the standard deviations.\n     */\n    public double[] getStandardDeviations() {\n        final int dim = getDimension();\n        final double[] std = new double[dim];\n        final double[][] s = covarianceMatrix.getData();\n        for (int i = 0; i < dim; i++) {\n            std[i] = FastMath.sqrt(s[i][i]);\n        }\n        return std;\n    }\n\n    /** {@inheritDoc} */\n    public double[] sample() {\n        final int dim = getDimension();\n        final double[] normalVals = new double[dim];\n\n        for (int i = 0; i < dim; i++) {\n            normalVals[i] = random.nextGaussian();\n        }\n\n        final double[] vals = samplingMatrix.operate(normalVals);\n\n", "fix": "            }\n        }\n\n        samplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n    }\n\n    /**\n     * Gets the mean vector.\n     *\n     * @return the mean vector.\n     */\n    public double[] getMeans() {\n        return MathArrays.copyOf(means);\n    }\n\n    /**\n     * Gets the covariance matrix.\n     *\n     * @return the covariance matrix.\n     */\n    public RealMatrix getCovariances() {\n        return covarianceMatrix.copy();\n    }\n\n    /** {@inheritDoc} */\n    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n\n    /**\n     * Gets the square root of each element on the diagonal of the covariance\n     * matrix.\n     *\n     * @return the standard deviations.\n     */\n    public double[] getStandardDeviations() {\n        final int dim = getDimension();\n        final double[] std = new double[dim];\n        final double[][] s = covarianceMatrix.getData();\n        for (int i = 0; i < dim; i++) {\n            std[i] = FastMath.sqrt(s[i][i]);\n        }\n        return std;\n    }\n\n    /** {@inheritDoc} */\n    public double[] sample() {\n        final int dim = getDimension();\n        final double[] normalVals = new double[dim];\n\n        for (int i = 0; i < dim; i++) {\n            normalVals[i] = random.nextGaussian();\n        }\n\n        final double[] vals = samplingMatrix.operate(normalVals);\n\n", "start": 151, "end": 213, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java"}], "time_4": [{"prefix": "                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n", "suffix": "            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n", "buggy": "                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n", "fix": "                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n", "start": 441, "end": 485, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/time_4/src/main/java/org/joda/time/Partial.java"}], "jacksondatabind_37": [{"prefix": "        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n", "suffix": "                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n", "buggy": "        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n", "fix": "        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n", "start": 110, "end": 158, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java"}], "closure_123": [{"prefix": "        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n", "suffix": "        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n", "buggy": "        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n", "fix": "        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n", "start": 259, "end": 309, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_123/src/com/google/javascript/jscomp/CodeGenerator.java"}], "jsoup_62": [{"prefix": "                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n", "suffix": "            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        // in script, style etc. normally treated as data tags\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n", "buggy": "                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName();\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        // in script, style etc. normally treated as data tags\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n", "fix": "                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        // in script, style etc. normally treated as data tags\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n", "start": 736, "end": 790, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_62/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"}], "closure_18": [{"prefix": "    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n", "suffix": "        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n", "buggy": "    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n", "fix": "    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement()) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n", "start": 1261, "end": 1313, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_18/src/com/google/javascript/jscomp/Compiler.java"}], "mockito_29": [{"prefix": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport org.hamcrest.Description;\nimport org.mockito.ArgumentMatcher;\n\nimport java.io.Serializable;\n\n\npublic class Same extends ArgumentMatcher<Object> implements Serializable {\n\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n\n    public Same(Object wanted) {\n        this.wanted = wanted;\n    }\n\n    public boolean matches(Object actual) {\n        return wanted == actual;\n    }\n\n    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n", "suffix": "        appendQuoting(description);\n        description.appendText(\")\");\n    }\n\n    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }\n}\n", "buggy": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport org.hamcrest.Description;\nimport org.mockito.ArgumentMatcher;\n\nimport java.io.Serializable;\n\n\npublic class Same extends ArgumentMatcher<Object> implements Serializable {\n\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n\n    public Same(Object wanted) {\n        this.wanted = wanted;\n    }\n\n    public boolean matches(Object actual) {\n        return wanted == actual;\n    }\n\n    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n\n    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }\n}\n", "fix": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport org.hamcrest.Description;\nimport org.mockito.ArgumentMatcher;\n\nimport java.io.Serializable;\n\n\npublic class Same extends ArgumentMatcher<Object> implements Serializable {\n\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n\n    public Same(Object wanted) {\n        this.wanted = wanted;\n    }\n\n    public boolean matches(Object actual) {\n        return wanted == actual;\n    }\n\n    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n\n    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }\n}\n", "start": 0, "end": 56, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_29/src/org/mockito/internal/matchers/Same.java"}], "closure_65": [{"prefix": "    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n  }\n\n  /* If the user doesn't want to specify an output charset encoder, assume\n     they want Latin/ASCII characters only.\n   */\n  static String regexpEscape(String s) {\n    return regexpEscape(s, null);\n  }\n\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n", "suffix": "        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n", "buggy": "    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n  }\n\n  /* If the user doesn't want to specify an output charset encoder, assume\n     they want Latin/ASCII characters only.\n   */\n  static String regexpEscape(String s) {\n    return regexpEscape(s, null);\n  }\n\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n", "fix": "    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n  }\n\n  /* If the user doesn't want to specify an output charset encoder, assume\n     they want Latin/ASCII characters only.\n   */\n  static String regexpEscape(String s) {\n    return regexpEscape(s, null);\n  }\n\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\000\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n", "start": 993, "end": 1035, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_65/src/com/google/javascript/jscomp/CodeGenerator.java"}], "closure_168": [{"prefix": "      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }\n\n    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n", "suffix": "        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n", "buggy": "      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }\n\n    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n", "fix": "      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }\n\n    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n", "start": 1971, "end": 2019, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_168/src/com/google/javascript/jscomp/TypedScopeCreator.java"}], "jsoup_64": [], "math_82": [{"prefix": "        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n", "suffix": "                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    /**\n     * Runs one iteration of the Simplex method on the given model.\n     * @param tableau simple tableau for the problem\n     * @throws OptimizationException if the maximal iteration count has been\n     * exceeded or if the model is found not to have a bounded solution\n     */\n    protected void doIteration(final SimplexTableau tableau)\n        throws OptimizationException {\n\n        incrementIterationsCounter();\n\n", "buggy": "        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    /**\n     * Runs one iteration of the Simplex method on the given model.\n     * @param tableau simple tableau for the problem\n     * @throws OptimizationException if the maximal iteration count has been\n     * exceeded or if the model is found not to have a bounded solution\n     */\n    protected void doIteration(final SimplexTableau tableau)\n        throws OptimizationException {\n\n        incrementIterationsCounter();\n\n", "fix": "        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    /**\n     * Runs one iteration of the Simplex method on the given model.\n     * @param tableau simple tableau for the problem\n     * @throws OptimizationException if the maximal iteration count has been\n     * exceeded or if the model is found not to have a bounded solution\n     */\n    protected void doIteration(final SimplexTableau tableau)\n        throws OptimizationException {\n\n        incrementIterationsCounter();\n\n", "start": 59, "end": 103, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java"}], "gson_13": [{"prefix": "          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n", "suffix": "      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n", "buggy": "          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n", "fix": "          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n", "start": 707, "end": 753, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/gson_13/gson/src/main/java/com/google/gson/stream/JsonReader.java"}], "compress_23": [{"prefix": "                byte[] password) throws IOException;\n        OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n", "suffix": "            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorInputStream(in);\n", "buggy": "                byte[] password) throws IOException;\n        OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] << (8 * i));\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorInputStream(in);\n", "fix": "                byte[] password) throws IOException;\n        OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i  1] & 0xffl) << (8 * i);\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorInputStream(in);\n", "start": 85, "end": 137, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/compress_23/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java"}], "closure_125": [{"prefix": "\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n", "suffix": "        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n\n  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n", "buggy": "\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n\n  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n", "fix": "\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n\n  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n", "start": 1635, "end": 1685, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_125/src/com/google/javascript/jscomp/TypeCheck.java"}], "jsoup_25": [{"prefix": "    };\n    private static final String[] inlineTags = {\n            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n            \"summary\", \"command\", \"device\"\n    };\n    private static final String[] emptyTags = {\n            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n            \"device\"\n    };\n    private static final String[] formatAsInlineTags = {\n            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n    };\n", "suffix": "\n    static {\n        // creates\n        for (String tagName : blockTags) {\n            Tag tag = new Tag(tagName);\n            register(tag);\n        }\n        for (String tagName : inlineTags) {\n            Tag tag = new Tag(tagName);\n            tag.isBlock = false;\n            tag.canContainBlock = false;\n            tag.formatAsBlock = false;\n            register(tag);\n        }\n\n", "buggy": "    };\n    private static final String[] inlineTags = {\n            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n            \"summary\", \"command\", \"device\"\n    };\n    private static final String[] emptyTags = {\n            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n            \"device\"\n    };\n    private static final String[] formatAsInlineTags = {\n            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n    };\n    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n\n    static {\n        // creates\n        for (String tagName : blockTags) {\n            Tag tag = new Tag(tagName);\n            register(tag);\n        }\n        for (String tagName : inlineTags) {\n            Tag tag = new Tag(tagName);\n            tag.isBlock = false;\n            tag.canContainBlock = false;\n            tag.formatAsBlock = false;\n            register(tag);\n        }\n\n", "fix": "    };\n    private static final String[] inlineTags = {\n            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n            \"summary\", \"command\", \"device\"\n    };\n    private static final String[] emptyTags = {\n            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n            \"device\"\n    };\n    private static final String[] formatAsInlineTags = {\n            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n    };\n    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n\n    static {\n        // creates\n        for (String tagName : blockTags) {\n            Tag tag = new Tag(tagName);\n            register(tag);\n        }\n        for (String tagName : inlineTags) {\n            Tag tag = new Tag(tagName);\n            tag.isBlock = false;\n            tag.canContainBlock = false;\n            tag.formatAsBlock = false;\n            register(tag);\n        }\n\n", "start": 202, "end": 232, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_25/src/main/java/org/jsoup/parser/Tag.java"}], "jsoup_15": [{"prefix": "                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n", "suffix": "                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n", "buggy": "                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n", "fix": "                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n", "start": 259, "end": 305, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_15/src/main/java/org/jsoup/parser/TreeBuilderState.java"}], "math_96": [{"prefix": "     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n", "suffix": "                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n    \n    /**\n     * Get a hashCode for the complex number.\n     * <p>\n     * All NaN values have the same hash code.</p>\n     * \n     * @return a hash code value for this object\n     */\n    public int hashCode() {\n        if (isNaN()) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) + \n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n", "buggy": "     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n    \n    /**\n     * Get a hashCode for the complex number.\n     * <p>\n     * All NaN values have the same hash code.</p>\n     * \n     * @return a hash code value for this object\n     */\n    public int hashCode() {\n        if (isNaN()) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) + \n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n", "fix": "     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n    \n    /**\n     * Get a hashCode for the complex number.\n     * <p>\n     * All NaN values have the same hash code.</p>\n     * \n     * @return a hash code value for this object\n     */\n    public int hashCode() {\n        if (isNaN()) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) + \n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n", "start": 229, "end": 285, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_96/src/java/org/apache/commons/math/complex/Complex.java"}], "math_104": [{"prefix": " */\npackage org.apache.commons.math.special;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.util.ContinuedFraction;\n\n/**\n * This is a utility class that provides computation methods related to the\n * Gamma family of functions.\n *\n * @version $Revision$ $Date$\n */\npublic class Gamma implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6587513359895466954L;\n\n    /** Maximum allowed numerical error. */\n", "suffix": "\n    /** Lanczos coefficients */\n    private static double[] lanczos =\n    {\n        0.99999999999999709182,\n        57.156235665862923517,\n        -59.597960355475491248,\n        14.136097974741747174,\n        -0.49191381609762019978,\n        .33994649984811888699e-4,\n        .46523628927048575665e-4,\n        -.98374475304879564677e-4,\n        .15808870322491248884e-3,\n        -.21026444172410488319e-3,\n        .21743961811521264320e-3,\n        -.16431810653676389022e-3,\n        .84418223983852743293e-4,\n        -.26190838401581408670e-4,\n        .36899182659531622704e-5,\n    };\n\n", "buggy": " */\npackage org.apache.commons.math.special;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.util.ContinuedFraction;\n\n/**\n * This is a utility class that provides computation methods related to the\n * Gamma family of functions.\n *\n * @version $Revision$ $Date$\n */\npublic class Gamma implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6587513359895466954L;\n\n    /** Maximum allowed numerical error. */\n    private static final double DEFAULT_EPSILON = 10e-9;\n\n    /** Lanczos coefficients */\n    private static double[] lanczos =\n    {\n        0.99999999999999709182,\n        57.156235665862923517,\n        -59.597960355475491248,\n        14.136097974741747174,\n        -0.49191381609762019978,\n        .33994649984811888699e-4,\n        .46523628927048575665e-4,\n        -.98374475304879564677e-4,\n        .15808870322491248884e-3,\n        -.21026444172410488319e-3,\n        .21743961811521264320e-3,\n        -.16431810653676389022e-3,\n        .84418223983852743293e-4,\n        -.26190838401581408670e-4,\n        .36899182659531622704e-5,\n    };\n\n", "fix": " */\npackage org.apache.commons.math.special;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.util.ContinuedFraction;\n\n/**\n * This is a utility class that provides computation methods related to the\n * Gamma family of functions.\n *\n * @version $Revision$ $Date$\n */\npublic class Gamma implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6587513359895466954L;\n\n    /** Maximum allowed numerical error. */\n    private static final double DEFAULT_EPSILON = 10e-15;\n\n    /** Lanczos coefficients */\n    private static double[] lanczos =\n    {\n        0.99999999999999709182,\n        57.156235665862923517,\n        -59.597960355475491248,\n        14.136097974741747174,\n        -0.49191381609762019978,\n        .33994649984811888699e-4,\n        .46523628927048575665e-4,\n        -.98374475304879564677e-4,\n        .15808870322491248884e-3,\n        -.21026444172410488319e-3,\n        .21743961811521264320e-3,\n        -.16431810653676389022e-3,\n        .84418223983852743293e-4,\n        -.26190838401581408670e-4,\n        .36899182659531622704e-5,\n    };\n\n", "start": 15, "end": 57, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_104/src/java/org/apache/commons/math/special/Gamma.java"}], "closure_104": [{"prefix": "  public JSType getLeastSupertype(JSType that) {\n    if (!that.isUnknownType()) {\n      for (JSType alternate : alternates) {\n        if (!alternate.isUnknownType() && that.isSubtype(alternate)) {\n          return this;\n        }\n      }\n    }\n\n    return getLeastSupertype(this, that);\n  }\n\n  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n", "suffix": "      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n\n  /**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */\n  @Override\n  public boolean equals(Object object) {\n    if (object instanceof UnionType) {\n      UnionType that = (UnionType) object;\n      return alternates.equals(that.alternates);\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  public int hashCode() {\n    return alternates.hashCode();\n  }\n\n  @Override\n  public boolean isUnionType() {\n    return true;\n", "buggy": "  public JSType getLeastSupertype(JSType that) {\n    if (!that.isUnknownType()) {\n      for (JSType alternate : alternates) {\n        if (!alternate.isUnknownType() && that.isSubtype(alternate)) {\n          return this;\n        }\n      }\n    }\n\n    return getLeastSupertype(this, that);\n  }\n\n  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n    if (result != null) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n\n  /**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */\n  @Override\n  public boolean equals(Object object) {\n    if (object instanceof UnionType) {\n      UnionType that = (UnionType) object;\n      return alternates.equals(that.alternates);\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  public int hashCode() {\n    return alternates.hashCode();\n  }\n\n  @Override\n  public boolean isUnionType() {\n    return true;\n", "fix": "  public JSType getLeastSupertype(JSType that) {\n    if (!that.isUnknownType()) {\n      for (JSType alternate : alternates) {\n        if (!alternate.isUnknownType() && that.isSubtype(alternate)) {\n          return this;\n        }\n      }\n    }\n\n    return getLeastSupertype(this, that);\n  }\n\n  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n    if (!result.isNoType()) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n\n  /**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */\n  @Override\n  public boolean equals(Object object) {\n    if (object instanceof UnionType) {\n      UnionType that = (UnionType) object;\n      return alternates.equals(that.alternates);\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  public int hashCode() {\n    return alternates.hashCode();\n  }\n\n  @Override\n  public boolean isUnionType() {\n    return true;\n", "start": 260, "end": 320, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_104/src/com/google/javascript/rhino/jstype/UnionType.java"}], "closure_13": [], "lang_21": [{"prefix": "     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n", "suffix": "                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed successful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * The parser will be lenient toward the parsed date.\n     * \n     * @param str  the date to parse, not null\n", "buggy": "     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed successful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * The parser will be lenient toward the parsed date.\n     * \n     * @param str  the date to parse, not null\n", "fix": "     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed successful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * The parser will be lenient toward the parsed date.\n     * \n     * @param str  the date to parse, not null\n", "start": 248, "end": 280, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_21/src/main/java/org/apache/commons/lang3/time/DateUtils.java"}], "closure_38": [{"prefix": "      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }\n\n  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n", "suffix": "      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n\n  static boolean isNegativeZero(double x) {\n    return x == 0.0 && Math.copySign(1, x) == -1.0;\n  }\n", "buggy": "      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }\n\n  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n\n  static boolean isNegativeZero(double x) {\n    return x == 0.0 && Math.copySign(1, x) == -1.0;\n  }\n", "fix": "      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }\n\n  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n\n  static boolean isNegativeZero(double x) {\n    return x == 0.0 && Math.copySign(1, x) == -1.0;\n  }\n", "start": 218, "end": 270, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_38/src/com/google/javascript/jscomp/CodeConsumer.java"}], "jacksondatabind_97": [{"prefix": "    }\n\n    @Override\n    public long asLong(long defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).longValue();\n        }\n        return defaultValue;\n    }\n    \n    @Override\n    public double asDouble(double defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).doubleValue();\n        }\n        return defaultValue;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n", "suffix": "        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to access the POJO this node wraps.\n     */\n    public Object getPojo() { return _value; }\n\n    /*\n    /**********************************************************\n    /* Overridden standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof POJONode) {\n            return _pojoEquals((POJONode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _pojoEquals(POJONode other)\n    {\n", "buggy": "    }\n\n    @Override\n    public long asLong(long defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).longValue();\n        }\n        return defaultValue;\n    }\n    \n    @Override\n    public double asDouble(double defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).doubleValue();\n        }\n        return defaultValue;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            gen.writeObject(_value);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to access the POJO this node wraps.\n     */\n    public Object getPojo() { return _value; }\n\n    /*\n    /**********************************************************\n    /* Overridden standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof POJONode) {\n            return _pojoEquals((POJONode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _pojoEquals(POJONode other)\n    {\n", "fix": "    }\n\n    @Override\n    public long asLong(long defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).longValue();\n        }\n        return defaultValue;\n    }\n    \n    @Override\n    public double asDouble(double defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).doubleValue();\n        }\n        return defaultValue;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            ctxt.defaultSerializeValue(_value, gen);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to access the POJO this node wraps.\n     */\n    public Object getPojo() { return _value; }\n\n    /*\n    /**********************************************************\n    /* Overridden standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof POJONode) {\n            return _pojoEquals((POJONode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _pojoEquals(POJONode other)\n    {\n", "start": 77, "end": 149, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java"}], "csv_11": [{"prefix": "     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n", "suffix": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n", "buggy": "     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n", "fix": "     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n", "start": 357, "end": 409, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/csv_11/src/main/java/org/apache/commons/csv/CSVParser.java"}], "closure_73": [{"prefix": "          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n", "suffix": "              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n", "buggy": "          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n", "fix": "          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n", "start": 1020, "end": 1068, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/closure_73/src/com/google/javascript/jscomp/CodeGenerator.java"}], "csv_12": [{"prefix": "     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     *   <li>{@link #withQuoteChar(String) withQuoteChar('\"')}</li>\n     *   <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     *   <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     *   <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n     * </p>\n     */\n", "suffix": "\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n", "buggy": "     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     *   <li>{@link #withQuoteChar(String) withQuoteChar('\"')}</li>\n     *   <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     *   <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     *   <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n     * </p>\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n", "fix": "     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     *   <li>{@link #withQuoteChar(String) withQuoteChar('\"')}</li>\n     *   <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     *   <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     *   <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n     * </p>\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n", "start": 197, "end": 239, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/csv_12/src/main/java/org/apache/commons/csv/CSVFormat.java"}], "math_75": [{"prefix": "    public long getCount(long v) {\n        return getCount(Long.valueOf(v));\n    }\n\n    /**\n     * Returns the number of values = v.\n     *\n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(char v) {\n        return getCount(Character.valueOf(v));\n    }\n\n    //-------------------------------------------------------------\n\n    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n", "suffix": "    }\n\n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(Comparable<?> v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCount(v) / (double) sumFreq;\n    }\n\n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(int v) {\n        return getPct(Long.valueOf(v));\n", "buggy": "    public long getCount(long v) {\n        return getCount(Long.valueOf(v));\n    }\n\n    /**\n     * Returns the number of values = v.\n     *\n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(char v) {\n        return getCount(Character.valueOf(v));\n    }\n\n    //-------------------------------------------------------------\n\n    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n    }\n\n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(Comparable<?> v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCount(v) / (double) sumFreq;\n    }\n\n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(int v) {\n        return getPct(Long.valueOf(v));\n", "fix": "    public long getCount(long v) {\n        return getCount(Long.valueOf(v));\n    }\n\n    /**\n     * Returns the number of values = v.\n     *\n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(char v) {\n        return getCount(Character.valueOf(v));\n    }\n\n    //-------------------------------------------------------------\n\n    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n        return getPct((Comparable<?>) v);\n    }\n\n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(Comparable<?> v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCount(v) / (double) sumFreq;\n    }\n\n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(int v) {\n        return getPct(Long.valueOf(v));\n", "start": 274, "end": 330, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_75/src/main/java/org/apache/commons/math/stat/Frequency.java"}], "jsoup_47": [{"prefix": "                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n", "suffix": "                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n", "buggy": "                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n", "fix": "                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n", "start": 95, "end": 147, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jsoup_47/src/main/java/org/jsoup/nodes/Entities.java"}], "jacksondatabind_46": [{"prefix": "    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n", "suffix": "        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n", "buggy": "    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(';');\n        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n", "fix": "    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n", "start": 119, "end": 191, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java"}], "lang_26": [{"prefix": "            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    /**\n     * <p>Formats a millisecond <code>long</code> value.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @return the formatted string\n     * @since 2.1\n     */\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n", "suffix": "        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object.</p>\n     * \n     * @param calendar  the calendar to format\n     * @return the formatted string\n     */\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a milliseond <code>long</code> value into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     * @since 2.1\n     */\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n", "buggy": "            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    /**\n     * <p>Formats a millisecond <code>long</code> value.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @return the formatted string\n     * @since 2.1\n     */\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object.</p>\n     * \n     * @param calendar  the calendar to format\n     * @return the formatted string\n     */\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a milliseond <code>long</code> value into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     * @since 2.1\n     */\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n", "fix": "            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }\n\n    /**\n     * <p>Formats a millisecond <code>long</code> value.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @return the formatted string\n     * @since 2.1\n     */\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object.</p>\n     * \n     * @param calendar  the calendar to format\n     * @return the formatted string\n     */\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a milliseond <code>long</code> value into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     * @since 2.1\n     */\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n", "start": 792, "end": 846, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/lang_26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java"}], "codec_16": [{"prefix": "     */\n    private static final byte[] HEX_DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n", "suffix": "    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their\n     * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n     */\n    private static final byte[] HEX_ENCODE_TABLE = {\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n", "buggy": "     */\n    private static final byte[] HEX_DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n            25, 26, 27, 28, 29, 30, 31, 32,\n    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their\n     * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n     */\n    private static final byte[] HEX_ENCODE_TABLE = {\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n", "fix": "     */\n    private static final byte[] HEX_DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n            25, 26, 27, 28, 29, 30, 31,                                     // 50-57 P-V\n    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their\n     * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n     */\n    private static final byte[] HEX_ENCODE_TABLE = {\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n", "start": 90, "end": 106, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/codec_16/src/main/java/org/apache/commons/codec/binary/Base32.java"}], "math_57": [{"prefix": "     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n", "suffix": "            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n", "buggy": "     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n", "fix": "     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            double sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n", "start": 155, "end": 193, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java"}], "math_63": [{"prefix": "        }\n        return 1;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n     * hyperbolic cosine</a> of x.\n     *\n     * @param x double value for which to find the hyperbolic cosine\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }\n\n    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n", "suffix": "    }\n\n    /**\n     * Returns true if both arguments are NaN or neither is NaN and they are\n     * equal as defined by {@link #equals(double,double) this method}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal or both are NaN.\n     */\n    public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n    }\n\n    /**\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     *\n     * @param x first value\n     * @param y second value\n     * @param eps the amount of absolute error to allow.\n     * @return {@code true} if the values are equal or within range of each other.\n     */\n    public static boolean equals(double x, double y, double eps) {\n", "buggy": "        }\n        return 1;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n     * hyperbolic cosine</a> of x.\n     *\n     * @param x double value for which to find the hyperbolic cosine\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }\n\n    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }\n\n    /**\n     * Returns true if both arguments are NaN or neither is NaN and they are\n     * equal as defined by {@link #equals(double,double) this method}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal or both are NaN.\n     */\n    public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n    }\n\n    /**\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     *\n     * @param x first value\n     * @param y second value\n     * @param eps the amount of absolute error to allow.\n     * @return {@code true} if the values are equal or within range of each other.\n     */\n    public static boolean equals(double x, double y, double eps) {\n", "fix": "        }\n        return 1;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n     * hyperbolic cosine</a> of x.\n     *\n     * @param x double value for which to find the hyperbolic cosine\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }\n\n    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }\n\n    /**\n     * Returns true if both arguments are NaN or neither is NaN and they are\n     * equal as defined by {@link #equals(double,double) this method}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal or both are NaN.\n     */\n    public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n    }\n\n    /**\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     *\n     * @param x first value\n     * @param y second value\n     * @param eps the amount of absolute error to allow.\n     * @return {@code true} if the values are equal or within range of each other.\n     */\n    public static boolean equals(double x, double y, double eps) {\n", "start": 392, "end": 440, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_63/src/main/java/org/apache/commons/math/util/MathUtils.java"}], "math_80": [{"prefix": "                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n\n    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n", "suffix": "            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Compute an interval containing all realEigenvalues of a block.\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return an interval containing the realEigenvalues\n     */\n    private double[] eigenvaluesRange(final int index, final int n) {\n\n        // find the bounds of the spectra of the local block\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n", "buggy": "                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n\n    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Compute an interval containing all realEigenvalues of a block.\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return an interval containing the realEigenvalues\n     */\n    private double[] eigenvaluesRange(final int index, final int n) {\n\n        // find the bounds of the spectra of the local block\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n", "fix": "                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n\n    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * (n - 1);\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Compute an interval containing all realEigenvalues of a block.\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return an interval containing the realEigenvalues\n     */\n    private double[] eigenvaluesRange(final int index, final int n) {\n\n        // find the bounds of the spectra of the local block\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n", "start": 1108, "end": 1160, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java"}], "jacksondatabind_71": [{"prefix": "    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n", "suffix": "            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n", "buggy": "    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n        if (raw == String.class || raw == Object.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n", "fix": "    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n", "start": 49, "end": 99, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/jacksondatabind_71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java"}], "mockito_24": [{"prefix": "    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n", "suffix": "        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n", "buggy": "    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n", "fix": "    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n", "start": 57, "end": 93, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/mockito_24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java"}], "csv_14": [{"prefix": "        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n", "suffix": "                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n", "buggy": "        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n", "fix": "        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n", "start": 1013, "end": 1063, "file": "home/jun/fastd/dlapr-mirror/validation/d4j_buggy_repo/csv_14/src/main/java/org/apache/commons/csv/CSVFormat.java"}]}